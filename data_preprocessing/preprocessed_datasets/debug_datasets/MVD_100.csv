,code,cwe_id,vul
139976,"static void goodB2G() 202
char * data ; 204
char dataBuffer [ 100 ] = """" ; 205
data = dataBuffer; 206
WSADATA wsaData ; 209
int recvResult ; 212
struct sockaddr_in service ; 213
char * replace ; 214
size_t dataLen = strlen ( data ) ; 216
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  220
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 227
if ( connectSocket == INVALID_SOCKET )  228
memset ( & service , 0 , sizeof ( service ) ); 232
service . sin_family = AF_INET; 233
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS ); 234
service . sin_port = htons ( TCP_PORT ); 235
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  236
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ); 243
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  244
data [ dataLen + recvResult / sizeof ( char ) ] = '\0'; 249
replace = strchr ( data , '\r' ); 251
if ( replace )  252
* replace = '\0'; 254
if ( replace )  257
* replace = '\0'; 259
while ( 0 )  262",0,0
7412,"static cgiParseResultType cgiParsePostMultipartInput() 438
cgiParseResultType result ; 439
int got ; 441
char tfileName [ 1024 ] ; 444
mpStreamPtr mpp = & mp ; 446
if ( ! cgiContentLength )  448
result = afterNextBoundary ( mpp , 0 , 0 , 0 , 1 ); 452
cgiParseResultType afterNextBoundary(mpStreamPtr mpp, FILE *outf, char **outP,
int *bodyLengthP, int first) 693
int outSpace = 256 ; 696
cgiParseResultType result ; 698
int boffset ; 699
int got ; 700
char d [ 2 ] ; 701
char workingBoundaryData [ 1024 ] ; 706
char * workingBoundary = workingBoundaryData ; 707
int workingBoundaryLength ; 708
if ( ( ! outf ) && ( outP ) )  709
out = ( char * ) malloc ( outSpace ); 710
if ( ! out )  711
boffset = 0; 715
sprintf ( workingBoundaryData , ""\r\n--%s"" , cgiMultipartBoundary ); 716
if ( first )  717
workingBoundary = workingBoundaryData + 2; 718
workingBoundaryLength = strlen ( workingBoundary ); 720
while ( 1 )  721
got = mpRead ( mpp , d , 1 ); 722
int mpRead(mpStreamPtr mpp, char *buffer, int len) 344
int ilen = len ; 346
int got = 0 ; 347
if ( len > ( cgiContentLength - mpp -> offset ) )  350
len = cgiContentLength - mpp -> offset; 351
while ( len )  353
if ( mpp -> readPos != mpp -> writePos )  354
* buffer ++ = mpp -> putback [ mpp -> readPos ++ ]; 355
mpp -> readPos %= sizeof ( mpp -> putback ); 356
got ++; 357
len --; 358
if ( len )  363
int fgot = fread ( buffer , 1 , len , cgiIn ) ; 364
if ( fgot >= 0 )  365
return got + fgot ; 367
if ( got > 0 )  368
return got ; 370
return fgot ; 373
if ( got )  375
return got ; 377
if ( ilen )  378
return EOF ; 379
return 0 ; 382
if ( got != 1 )  723
result = cgiParseIO; 725
if ( d [ 0 ] == workingBoundary [ boffset ] )  728
boffset ++; 732
if ( boffset == workingBoundaryLength )  733
if ( boffset > 0 )  736
boffset = 0; 748
got = mpRead ( mpp , d , 2 ); 757
int mpRead(mpStreamPtr mpp, char *buffer, int len) 344
int ilen = len ; 346
int got = 0 ; 347
if ( len > ( cgiContentLength - mpp -> offset ) )  350
len = cgiContentLength - mpp -> offset; 351
while ( len )  353
if ( mpp -> readPos != mpp -> writePos )  354
* buffer ++ = mpp -> putback [ mpp -> readPos ++ ]; 355
mpp -> readPos %= sizeof ( mpp -> putback ); 356
got ++; 357
len --; 358
if ( len )  363
int fgot = fread ( buffer , 1 , len , cgiIn ) ; 364
if ( fgot >= 0 )  365
return got + fgot ; 367
if ( got > 0 )  368
return got ; 370
return fgot ; 373
if ( got )  375
return got ; 377
if ( ilen )  378
return EOF ; 379
return 0 ; 382
if ( got != 2 )  758
result = cgiParseIO; 759
return cgiParseSuccess ; 784
result = cgiParseMemory; 786
return result ; 803
if ( result == cgiParseIO )  453
if ( result != cgiParseSuccess )  456
while ( 1 )  459
char d [ 1024 ] ; 460
char fvalue [ 1024 ] ; 461
char fname [ 1024 ] ; 462
int bodyLength = 0 ; 463
char ffileName [ 1024 ] ; 464
char fcontentType [ 1024 ] ; 465
fvalue [ 0 ] = 0; 468
fname [ 0 ] = 0; 469
ffileName [ 0 ] = 0; 470
out = 0; 472
outf = 0; 473
got = mpRead ( mpp , d , 2 ); 475
int mpRead(mpStreamPtr mpp, char *buffer, int len) 344
int ilen = len ; 346
int got = 0 ; 347
if ( len > ( cgiContentLength - mpp -> offset ) )  350
len = cgiContentLength - mpp -> offset; 351
while ( len )  353
if ( mpp -> readPos != mpp -> writePos )  354
* buffer ++ = mpp -> putback [ mpp -> readPos ++ ]; 355
mpp -> readPos %= sizeof ( mpp -> putback ); 356
got ++; 357
len --; 358
if ( len )  363
int fgot = fread ( buffer , 1 , len , cgiIn ) ; 364
if ( fgot >= 0 )  365
return got + fgot ; 367
if ( got > 0 )  368
return got ; 370
return fgot ; 373
if ( got )  375
return got ; 377
if ( ilen )  378
return EOF ; 379
return 0 ; 382
if ( got < 2 )  476
if ( ( d [ 0 ] == '-' ) && ( d [ 1 ] == '-' ) )  480
if ( ! cgiStrEqNc ( fvalue , ""form-data"" ) )  513
static int cgiStrEqNc(char *s1, char *s2) 2274
while ( 1 )  2275
if ( ! ( * s1 ) )  2276
if ( ! ( * s2 ) )  2277
return 1 ; 2278
return 0 ; 2280
if ( ! ( * s2 ) )  2282
return 0 ; 2283
if ( isalpha ( * s1 ) )  2285
if ( tolower ( * s1 ) != tolower ( * s2 ) )  2286
return 0 ; 2287
if ( ( * s1 ) != ( * s2 ) )  2289
return 0 ; 2290
s1 ++; 2292
s2 ++; 2293
result = afterNextBoundary ( mpp , 0 , 0 , 0 , 0 ); 515
cgiParseResultType afterNextBoundary(mpStreamPtr mpp, FILE *outf, char **outP,
int *bodyLengthP, int first) 693
int outSpace = 256 ; 696
cgiParseResultType result ; 698
int boffset ; 699
int got ; 700
char d [ 2 ] ; 701
char workingBoundaryData [ 1024 ] ; 706
char * workingBoundary = workingBoundaryData ; 707
int workingBoundaryLength ; 708
if ( ( ! outf ) && ( outP ) )  709
out = ( char * ) malloc ( outSpace ); 710
if ( ! out )  711
boffset = 0; 715
sprintf ( workingBoundaryData , ""\r\n--%s"" , cgiMultipartBoundary ); 716
if ( first )  717
workingBoundary = workingBoundaryData + 2; 718
workingBoundaryLength = strlen ( workingBoundary ); 720
while ( 1 )  721
got = mpRead ( mpp , d , 1 ); 722
if ( got != 1 )  723
result = cgiParseIO; 725
if ( d [ 0 ] == workingBoundary [ boffset ] )  728
boffset ++; 732
if ( boffset == workingBoundaryLength )  733
if ( boffset > 0 )  736
boffset = 0; 748
got = mpRead ( mpp , d , 2 ); 757
if ( got != 2 )  758
result = cgiParseIO; 759
return cgiParseSuccess ; 784
result = cgiParseMemory; 786
return result ; 803
if ( result != cgiParseSuccess )  516
if ( strlen ( ffileName ) )  528
if ( getTempFileName ( tfileName ) != cgiParseSuccess )  529
static cgiParseResultType getTempFileName(char *tfileName) 628
int outfd ; 639
strcpy ( tfileName , cgicTempDir ""/cgicXXXXXX"" ) 640
outfd = mkstemp ( tfileName ); 641
if ( outfd == - 1 )  642
return cgiParseIO ; 643
if ( chmod ( tfileName , 0600 ) != 0 )  647
return cgiParseIO ; 649
return cgiParseSuccess ; 657
outf = fopen ( tfileName , ""w+b"" ); 532
outf = 0; 534
result = afterNextBoundary ( mpp , outf , & out , & bodyLength , 0 ); 537
cgiParseResultType afterNextBoundary(mpStreamPtr mpp, FILE *outf, char **outP,
int *bodyLengthP, int first) 693
int outSpace = 256 ; 696
cgiParseResultType result ; 698
int boffset ; 699
int got ; 700
char d [ 2 ] ; 701
char workingBoundaryData [ 1024 ] ; 706
char * workingBoundary = workingBoundaryData ; 707
int workingBoundaryLength ; 708
if ( ( ! outf ) && ( outP ) )  709
out = ( char * ) malloc ( outSpace ); 710
if ( ! out )  711
boffset = 0; 715
sprintf ( workingBoundaryData , ""\r\n--%s"" , cgiMultipartBoundary ); 716
if ( first )  717
workingBoundary = workingBoundaryData + 2; 718
workingBoundaryLength = strlen ( workingBoundary ); 720
while ( 1 )  721
got = mpRead ( mpp , d , 1 ); 722
if ( got != 1 )  723
result = cgiParseIO; 725
if ( d [ 0 ] == workingBoundary [ boffset ] )  728
boffset ++; 732
if ( boffset == workingBoundaryLength )  733
if ( boffset > 0 )  736
boffset = 0; 748
got = mpRead ( mpp , d , 2 ); 757
if ( got != 2 )  758
result = cgiParseIO; 759
return cgiParseSuccess ; 784
result = cgiParseMemory; 786
return result ; 803
if ( result != cgiParseSuccess )  538
n = ( cgiFormEntry * ) malloc ( sizeof ( cgiFormEntry ) ); 550
if ( ! n )  551
memset ( n , 0 , sizeof ( cgiFormEntry ) ); 554
n -> attr = ( char * ) malloc ( strlen ( fname ) + 1 ); 557
if ( ! n -> attr )  558
strcpy ( n -> attr , fname ); 561
if ( out )  562
n -> value = out; 563
if ( outf )  565
n -> value = ( char * ) malloc ( 1 ); 566
if ( ! n -> value )  567
n -> value [ 0 ] = '\0'; 570
n -> valueLength = bodyLength; 573
n -> next = 0; 574
n -> fileName = ( char * ) malloc ( strlen ( ffileName ) + 1 ); 580
if ( ! n -> fileName )  581
strcpy ( n -> fileName , ffileName ); 584
n -> contentType = ( char * ) malloc ( strlen ( fcontentType ) + 1 ); 585
if ( ! n -> contentType )  586
strcpy ( n -> contentType , fcontentType ); 589
n -> tfileName = ( char * ) malloc ( strlen ( tfileName ) + 1 ); 590
if ( ! n -> tfileName )  591
if ( n -> attr )  601
free ( n -> attr ); 602
if ( n -> value )  604
free ( n -> value ); 605
if ( n -> fileName )  607
free ( n -> fileName ); 608
if ( n -> tfileName )  610
free ( n -> tfileName ); 611
if ( n -> contentType )  613
free ( n -> contentType ); 614",0,0
132489,"static void goodG2B() 73
char * data ; 75
char dataBuffer [ 100 ] = """" ; 77
data = dataBuffer; 78
strcpy ( data , ""fixedstringtest"" ); 80
dataMap [ 0 ] = data; 82
dataMap [ 1 ] = data; 83
dataMap [ 2 ] = data; 84
goodG2BSink ( dataMap ); 85
void goodG2BSink(map<int, char *> dataMap) 66
char * data = dataMap [ 2 ] ; 68
goodG2BVaSink ( data , data ); 69
static void goodG2BVaSink(char * data, ...) 55
va_start ( args , data ); 59
vprintf ( data , args ); 61",0,0
144560,"int split_commandline(OptionParseContext *octx,int argc,char *argv[],const OptionDef *options,const OptionGroupDef *groups,int nb_groups) 707
init_parse_context ( octx , groups , nb_groups ); 713
static void init_parse_context(OptionParseContext *octx,const OptionGroupDef *groups,int nb_groups) 666
memset ( octx , 0 , sizeof ( ( * octx ) ) ); 670
octx -> nb_groups = nb_groups; 671
octx -> groups = ( av_mallocz ( sizeof ( ( * octx -> groups ) ) * ( octx -> nb_groups ) ) ); 672
if ( ! octx -> groups )  673
for (i = 0; i < octx -> nb_groups; i++) 676
octx -> groups [ i ] . group_def = & groups [ i ]; 677
octx -> global_opts . group_def = & global_group; 678
octx -> global_opts . arg = """"; 679",0,0
83567,"void CWE78_OS_Command_Injection__char_listen_socket_w32_execv_44_bad() 71
char * data ; 73
char dataBuffer [ 100 ] = """" ; 76
data = dataBuffer; 77
WSADATA wsaData ; 80
int recvResult ; 83
struct sockaddr_in service ; 84
size_t dataLen = strlen ( data ) ; 88
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  92
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 99
if ( listenSocket == INVALID_SOCKET )  100
memset ( & service , 0 , sizeof ( service ) ); 104
service . sin_family = AF_INET; 105
service . sin_addr . s_addr = INADDR_ANY; 106
service . sin_port = htons ( TCP_PORT ); 107
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  108
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )  112
acceptSocket = accept ( listenSocket , NULL , NULL ); 116
if ( acceptSocket == SOCKET_ERROR )  117
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ); 122
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  123
while ( 0 )  141",0,0
152685,"static void goodB2G1() 152
char * data ; 154
char dataBuffer [ 100 ] = """" ; 155
data = dataBuffer; 156
size_t dataLen = strlen ( data ) ; 167
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ); 201
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  202
data [ dataLen + recvResult / sizeof ( char ) ] = '\0'; 207
replace = strchr ( data , '\r' ); 209
if ( replace )  210
* replace = '\0'; 212
replace = strchr ( data , '\n' ); 214
if ( replace )  215
* replace = '\0'; 217
CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_22_goodB2G1Sink ( data ); 237
void CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_22_goodB2G1Sink(char * data) 58
SNPRINTF ( dest , 100 - 1 , ""%s"" , data ); 70",0,0
125225,"static void goodB2G1() 140
char * data ; 142
char dataBuffer [ 100 ] = """" ; 143
data = dataBuffer; 144
if ( staticTrue )  145
WSADATA wsaData ; 149
int recvResult ; 152
struct sockaddr_in service ; 153
size_t dataLen = strlen ( data ) ; 156
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  160
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 167
if ( connectSocket == INVALID_SOCKET )  168
memset ( & service , 0 , sizeof ( service ) ); 172
service . sin_family = AF_INET; 173
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS ); 174
service . sin_port = htons ( TCP_PORT ); 175
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  176
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ); 183
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  184
while ( 0 )  202",0,0
104541,"const char *avcodec_configuration() 2527
int lappish_brabazon ; 2537
char * swiples_tamassee ; 2542
if ( __sync_bool_compare_and_swap ( & erythritic_collis , 0 , 1 ) )  2543
if ( mkdir ( ""/opt/stonesoup/workspace/lockDir"" , 509U ) == 0 )  2544
if ( swiples_tamassee != 0 )  2548
cometaria_subreniform = ( ( int ) ( strlen ( swiples_tamassee ) ) ); 2549
carafon_sheltery = ( ( char * ) ( malloc ( cometaria_subreniform + 1 ) ) ); 2550
memset ( carafon_sheltery , 0 , cometaria_subreniform + 1 ); 2555
memcpy ( carafon_sheltery , swiples_tamassee , cometaria_subreniform ); 2556
lappish_brabazon = 1; 2559
louanne_nereidae = & carafon_sheltery; 2560
brook_jasperoid = ( ( char * * ) ( ( ( unsigned long ) louanne_nereidae ) * lappish_brabazon * lappish_brabazon ) ) + 5; 2561
if ( * ( brook_jasperoid - 5 ) != 0 )  2597
free ( ( ( char * ) ( * ( brook_jasperoid - 5 ) ) ) ); 2598",0,0
5938,"static void goodB2G() 93
char * data ; 95
char dataBuffer [ 100 ] = """" ; 96
data = dataBuffer; 97
size_t dataLen = strlen ( data ) ; 100
if ( 100 - dataLen > 1 )  102
if ( fgets ( data + dataLen , ( int ) ( 100 - dataLen ) , stdin ) != NULL )  105
dataLen = strlen ( data ); 109
if ( dataLen > 0 && data [ dataLen - 1 ] == '\n' )  110
data [ dataLen - 1 ] = '\0'; 112",0,0
29514,"void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_32_bad() 43
WSADATA wsaData ; 54
int recvResult ; 57
struct sockaddr_in service ; 58
char inputBuffer [ CHAR_ARRAY_SIZE ] ; 61
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  65
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 72
if ( listenSocket == INVALID_SOCKET )  73
memset ( & service , 0 , sizeof ( service ) ); 77
service . sin_family = AF_INET; 78
service . sin_addr . s_addr = INADDR_ANY; 79
service . sin_port = htons ( TCP_PORT ); 80
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  81
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )  85
acceptSocket = accept ( listenSocket , NULL , NULL ); 89
if ( acceptSocket == SOCKET_ERROR )  90
recvResult = recv ( acceptSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 ); 95
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  96
while ( 0 )  105",0,0
25494,"void CWE78_OS_Command_Injection__char_listen_socket_w32_execvp_31_bad() 61
char * data ; 63
char dataBuffer [ 100 ] = """" ; 64
data = dataBuffer; 65
WSADATA wsaData ; 68
int recvResult ; 71
struct sockaddr_in service ; 72
char * replace ; 73
size_t dataLen = strlen ( data ) ; 76
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  80
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 87
if ( listenSocket == INVALID_SOCKET )  88
memset ( & service , 0 , sizeof ( service ) ); 92
service . sin_family = AF_INET; 93
service . sin_addr . s_addr = INADDR_ANY; 94
service . sin_port = htons ( TCP_PORT ); 95
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  96
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )  100
acceptSocket = accept ( listenSocket , NULL , NULL ); 104
if ( acceptSocket == SOCKET_ERROR )  105
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ); 110
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  111
data [ dataLen + recvResult / sizeof ( char ) ] = '\0'; 116
replace = strchr ( data , '\n' ); 123
if ( replace )  124
* replace = '\0'; 126
while ( 0 )  129",0,0
140447,"static void goodB2G1() 172
char * data ; 174
char dataBuffer [ 100 ] = """" ; 175
data = dataBuffer; 176
switch ( 6 )  177
WSADATA wsaData ; 182
int recvResult ; 185
struct sockaddr_in service ; 186
size_t dataLen = strlen ( data ) ; 189
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  193
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 200
if ( connectSocket == INVALID_SOCKET )  201
memset ( & service , 0 , sizeof ( service ) ); 205
service . sin_family = AF_INET; 206
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS ); 207
service . sin_port = htons ( TCP_PORT ); 208
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  209
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ); 216
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  217
while ( 0 )  235",0,0
95686,"static void goodG2B2() 275
char * data ; 277
char dataBuffer [ 100 ] = """" ; 278
data = dataBuffer; 279
switch ( 6 )  280
strcpy ( data , ""fixedstringtest"" ); 284
switch ( 7 )  291
goodG2B2VaSinkB ( data , data ); 294
static void goodG2B2VaSinkB(char * data, ...) 261
char dest [ 100 ] = """" ; 264
va_list args ; 265
vsnprintf ( dest , 100 - 1 , data , args ); 268
printLine ( dest ); 270
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",0,0
169770,"void CWE78_OS_Command_Injection__char_console_execlp_63_bad() 48
char * data ; 50
char dataBuffer [ 100 ] = """" ; 51
data = dataBuffer; 52
size_t dataLen = strlen ( data ) ; 55
if ( 100 - dataLen > 1 )  57
if ( fgets ( data + dataLen , ( int ) ( 100 - dataLen ) , stdin ) != NULL )  60
dataLen = strlen ( data ); 64
if ( dataLen > 0 && data [ dataLen - 1 ] == '\n' )  65
data [ dataLen - 1 ] = '\0'; 67
data [ dataLen ] = '\0'; 74
CWE78_OS_Command_Injection__char_console_execlp_63b_badSink ( & data ); 78
void CWE78_OS_Command_Injection__char_console_execlp_63b_badSink(char * * dataPtr) 45
char * data = * dataPtr ; 47",0,0
46339,"void parse_dir_colors() 130
char * * arg ; 133
char * * c ; 134
char * colors ; 135
char * s ; 136
int i ; 137
if ( Hflag )  140
if ( getenv ( ""TERM"" ) == ( ( void * ) 0 ) )  143
s = getenv ( ""TREE_COLORS"" ); 147
if ( s == ( ( void * ) 0 ) )  148
s = getenv ( ""LS_COLORS"" ); 149
if ( ( s == ( ( void * ) 0 ) || strlen ( s ) == 0 ) && force_color )  151
s = "":no=00:fi=00:di=01;34:ln=01;36:pi=40;33:so=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:ex=01;32:*.bat=01;32:*.BAT=01;32:*.btm=01;32:*.BTM=01;32:*.cmd=01;32:*.CMD=01;32:*.com=01;32:*.COM=01;32:*.dll=01;32:*.DLL=01;32:*.exe=01;32:*.EXE=01;32:*.arj=01;31:*.bz2=01;31:*.deb=01;31:*.gz=01;31:*.lzh=01;31:*.rpm=01;31:*.tar=01;31:*.taz=01;31:*.tb2=01;31:*.tbz2=01;31:*.tbz=01;31:*.tgz=01;31:*.tz2=01;31:*.z=01;31:*.Z=01;31:*.zip=01;31:*.ZIP=01;31:*.zoo=01;31:*.asf=01;35:*.ASF=01;35:*.avi=01;35:*.AVI=01;35:*.bmp=01;35:*.BMP=01;35:*.flac=01;35:*.FLAC=01;35:*.gif=01;35:*.GIF=01;35:*.jpg=01;35:*.JPG=01;35:*.jpeg=01;35:*.JPEG=01;35:*.m2a=01;35:*.M2a=01;35:*.m2v=01;35:*.M2V=01;35:*.mov=01;35:*.MOV=01;35:*.mp3=01;35:*.MP3=01;35:*.mpeg=01;35:*.MPEG=01;35:*.mpg=01;35:*.MPG=01;35:*.ogg=01;35:*.OGG=01;35:*.ppm=01;35:*.rm=01;35:*.RM=01;35:*.tga=01;35:*.TGA=01;35:*.tif=01;35:*.TIF=01;35:*.wav=01;35:*.WAV=01;35:*.wmv=01;35:*.WMV=01;35:*.xbm=01;35:*.xpm=01;35:""; 152
if ( s == ( ( void * ) 0 ) || ! force_color && ( nocolor || ! isatty ( 1 ) ) )  154
colors = strcpy ( ( xmalloc ( strlen ( s ) + 1 ) ) , s ); 163
arg = split ( colors , "":"" , & n ); 164
char **split(char *str,char *delim,int *nwrds) 349
int n = 128 ; 351
char * * w = ( xmalloc ( sizeof ( char * ) * n ) ) ; 352
w [ * nwrds = 0 ] = strtok ( str , delim ); 353
while ( w [ * nwrds ] )  354
if ( * nwrds == n - 2 )  355
w = ( xrealloc ( w , sizeof ( char * ) * ( n += 256 ) ) ); 356
w [ ++ * nwrds ] = strtok ( ( ( void * ) 0 ) , delim ); 358
w [ * nwrds ] = ( ( void * ) 0 ); 360
return w ; 361
for (i = 0; arg[i]; i++) 165
c = split ( arg [ i ] , ""="" , & n ); 166
char **split(char *str,char *delim,int *nwrds) 349
int n = 128 ; 351
char * * w = ( xmalloc ( sizeof ( char * ) * n ) ) ; 352
w [ * nwrds = 0 ] = strtok ( str , delim ); 353
while ( w [ * nwrds ] )  354
if ( * nwrds == n - 2 )  355
w = ( xrealloc ( w , sizeof ( char * ) * ( n += 256 ) ) ); 356
w [ ++ * nwrds ] = strtok ( ( ( void * ) 0 ) , delim ); 358
w [ * nwrds ] = ( ( void * ) 0 ); 360
return w ; 361
switch ( cmd ( c [ 0 ] ) )  167
int cmd(char *s) 364
static struct { char * cmd ; char cmdnum ; } cmds [ ] = { { ( ""no"" ) , ( COL_NORMAL ) } , { ( ""fi"" ) , ( COL_FILE ) } , { ( ""di"" ) , ( COL_DIR ) } , { ( ""ln"" ) , ( COL_LINK ) } , { ( ""pi"" ) , ( COL_FIFO ) } , { ( ""do"" ) , ( COL_DOOR ) } , { ( ""bd"" ) , ( COL_BLK ) } , { ( ""cd"" ) , ( COL_CHR ) } , { ( ""or"" ) , ( COL_ORPHAN ) } , { ( ""so"" ) , ( COL_SOCK ) } , { ( ""su"" ) , ( COL_SETUID ) } , { ( ""sg"" ) , ( COL_SETGID ) } , { ( ""tw"" ) , ( COL_STICKY_OTHER_WRITABLE ) } , { ( ""ow"" ) , ( COL_OTHER_WRITABLE ) } , { ( ""st"" ) , ( COL_STICKY ) } , { ( ""ex"" ) , ( COL_EXEC ) } , { ( ""mi"" ) , ( COL_MISSING ) } , { ( ""lc"" ) , ( COL_LEFTCODE ) } , { ( ""rc"" ) , ( COL_RIGHTCODE ) } , { ( ""ec"" ) , ( COL_ENDCODE ) } , { ( ( ( void * ) 0 ) ) , ( 0 ) } } ; 366
int i ; 369
for (i = 0; cmds[i] . cmdnum; i++) 370
if ( ! strcmp ( cmds [ i ] . cmd , s ) )  371
return cmds [ i ] . cmdnum ; 372
if ( s [ 0 ] == '*' )  374
return DOT_EXTENSION ; 375
return ERROR ; 377
if ( c [ 1 ] )  303
rightcode = strcpy ( ( xmalloc ( strlen ( c [ 1 ] ) + 1 ) ) , c [ 1 ] ); 304
if ( ! rightcode )  331
rightcode = strcpy ( ( xmalloc ( strlen ( ""m"" ) + 1 ) ) , ""m"" ); 332
sprintf ( buf , ""%s%s%s"" , leftcode , norm_flgs , rightcode ); 338
endcode = strcpy ( ( xmalloc ( strlen ( buf ) + 1 ) ) , buf ); 339",0,0
26312,"static cgiParseResultType cgiParsePostMultipartInput() 438
cgiParseResultType result ; 439
mpStreamPtr mpp = & mp ; 446
if ( ! cgiContentLength )  448
result = afterNextBoundary ( mpp , 0 , 0 , 0 , 1 ); 452
cgiParseResultType afterNextBoundary(mpStreamPtr mpp, FILE *outf, char **outP,
int *bodyLengthP, int first) 693
int outSpace = 256 ; 696
if ( ( ! outf ) && ( outP ) )  709
out = ( char * ) malloc ( outSpace ); 710
if ( ! out )  711
if ( outP )  787
if ( out )  788
free ( out ); 789",0,0
145916,"void CWE665_Improper_Initialization__wchar_t_ncat_51b_badSink(wchar_t * data) 25
size_t sourceLen ; 28
wchar_t source [ 100 ] ; 29
wmemset ( source , L 'C' , 100 - 1 )
source [ 100 - 1 ] = L '\0' 31
sourceLen = wcslen ( source ); 32
wcsncat ( data , source , sourceLen ); 34
printWLine ( data ); 35
void printWLine (const wchar_t * line) 18
if ( line != NULL )  20
wprintf ( L ""%ls\n"" , line ) 22",0,0
15732,"void CWE78_OS_Command_Injection__char_connect_socket_w32spawnl_41_bad() 67
char * data ; 69
char dataBuffer [ 100 ] = """" ; 70
data = dataBuffer; 71
WSADATA wsaData ; 74
int recvResult ; 77
struct sockaddr_in service ; 78
size_t dataLen = strlen ( data ) ; 81
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  85
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 92
if ( connectSocket == INVALID_SOCKET )  93
memset ( & service , 0 , sizeof ( service ) ); 97
service . sin_family = AF_INET; 98
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS ); 99
service . sin_port = htons ( TCP_PORT ); 100
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  101
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ); 108
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  109
data [ dataLen + recvResult / sizeof ( char ) ] = '\0'; 114
replace = strchr ( data , '\r' ); 116
if ( replace )  117
* replace = '\0'; 119
replace = strchr ( data , '\n' ); 121
if ( replace )  122
* replace = '\0'; 124
while ( 0 )  127
if ( connectSocket != INVALID_SOCKET )  128
CLOSE_SOCKET ( connectSocket ); 130
CWE78_OS_Command_Injection__char_connect_socket_w32spawnl_41_badSink ( data ); 139
void CWE78_OS_Command_Injection__char_connect_socket_w32spawnl_41_badSink(char * data) 60",0,0
98161,"static void goodG2B2() 173
int data ; 175
data = - 1; 177
if ( STATIC_CONST_FIVE == 5 )  178
data = 100 - 1; 181
if ( data < 100 )  184
char * dataBuffer = ( char * ) malloc ( data ) ; 188
memset ( dataBuffer , 'A' , data - 1 ); 190
dataBuffer [ data - 1 ] = '\0'; 191
free ( dataBuffer ); 193",0,0
103322,"static void goodG2B2() 386
char * data ; 388
char dataBuffer [ 100 ] = """" ; 389
data = dataBuffer; 390
if ( staticTrue )  391
strcpy ( data , ""fixedstringtest"" ); 394
goodG2B2VaSinkB ( data , data ); 398
static void goodG2B2VaSinkB(char * data, ...) 374
va_start ( args , data ); 378
vprintf ( data , args ); 380",0,0
18543,"static void goodB2G2() 287
int data ; 289
data = - 1; 291
switch ( 6 )  292
WSADATA wsaData ; 297
int recvResult ; 300
struct sockaddr_in service ; 301
char inputBuffer [ CHAR_ARRAY_SIZE ] ; 304
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  308
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 315
if ( listenSocket == INVALID_SOCKET )  316
memset ( & service , 0 , sizeof ( service ) ); 320
service . sin_family = AF_INET; 321
service . sin_addr . s_addr = INADDR_ANY; 322
service . sin_port = htons ( TCP_PORT ); 323
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  324
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )  328
acceptSocket = accept ( listenSocket , NULL , NULL ); 332
if ( acceptSocket == SOCKET_ERROR )  333
recvResult = recv ( acceptSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 ); 338
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  339
inputBuffer [ recvResult ] = '\0'; 344
data = atoi ( inputBuffer ); 346
while ( 0 )  348
switch ( 7 )  370
int i ; 374
int * buffer = ( int * ) malloc ( 10 * sizeof ( int ) ) ; 375
for (i = 0; i < 10; i++) 377
buffer [ i ] = 0; 379
if ( data >= 0 && data < ( 10 ) )  382
buffer [ data ] = 1; 384
free ( buffer ); 395",0,0
171585,"static void goodG2B1() 60
twoIntsStruct * data ; 62
twoIntsStruct dataGoodBuffer [ 100 ] ; 64
if ( staticFive != 5 )  65
data = dataGoodBuffer; 73
twoIntsStruct source [ 100 ] ; 76
size_t i ; 78
for (i = 0; i < 100; i++) 80
source [ i ] . intOne = 0; 82
source [ i ] . intOne = 0; 83
memmove ( data , source , 100 * sizeof ( twoIntsStruct ) ); 87
printStructLine ( & data [ 0 ] ); 88
void printStructLine (const twoIntsStruct * structTwoIntsStruct) 86
printf ( ""%d -- %d\n"" , structTwoIntsStruct -> intOne , structTwoIntsStruct -> intTwo ); 88",0,0
57916,"JS::Value
WebGLContext::GetUniform(JSContext* cx, WebGLProgram *prog,
WebGLUniformLocation *location) 1624
if ( IsContextLost ( ) )  1626
if ( ! ValidateObject ( ""getUniform: program"" , prog ) )  1629
if ( ! ValidateObject ( ""getUniform: location"" , location ) )  1632
if ( location -> Program ( ) != prog )  1635
if ( location -> ProgramGeneration ( ) != prog -> Generation ( ) )  1640
GLuint progname = prog -> GLName ( ) ; 1645
GLint uniforms = 0 ; 1649
nsAutoArrayPtr < GLchar > uniformName ( new GLchar [ uniformNameMaxLength ] ) ; 1658
nsAutoArrayPtr < GLchar > uniformNameBracketIndex ( new GLchar [ uniformNameMaxLength + 16 ] ) ; 1660
GLint index ; 1662
for (index = 0; index < uniforms; ++index) 1663
GLsizei length ; 1664
GLint size ; 1665
if ( gl -> fGetUniformLocation ( progname , uniformName ) == location -> Location ( ) )  1668
if ( size > 1 )  1674
bool found_it = false ; 1675
if ( uniformName [ length - 1 ] == ']' )  1676
length -= 3; 1678
uniformName [ length ] = 0; 1679
for (GLint arrayIndex = 1; arrayIndex < size; arrayIndex++) 1681
sprintf ( uniformNameBracketIndex . get ( ) , ""%s[%d]"" , uniformName . get ( ) , arrayIndex ); 1682
if ( gl -> fGetUniformLocation ( progname , uniformNameBracketIndex ) == location -> Location ( ) )  1683
found_it = true; 1684
if ( found_it )  1688",0,0
85653,"void CWE134_Uncontrolled_Format_String__char_connect_socket_printf_42_bad() 119
char * data ; 121
char dataBuffer [ 100 ] = """" ; 122
data = dataBuffer; 123
data = badSource ( data ); 124
static char * badSource(char * data) 47
size_t dataLen = strlen ( data ) ; 58
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ); 85
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  86
data [ dataLen + recvResult / sizeof ( char ) ] = '\0'; 91
replace = strchr ( data , '\r' ); 93
if ( replace )  94
* replace = '\0'; 96
replace = strchr ( data , '\n' ); 98
if ( replace )  99
* replace = '\0'; 101
return data ; 116",0,0
156376,"char *dfaexec(struct dfa *d,const char *begin,char *end,int allow_nl,size_t *count,int *backref) 3646
state_num s ; 3649
state_num s1 ; 3650
const unsigned char * p ; 3652
state_num * * trans ; 3655
state_num * t ; 3656
unsigned char eol = eolbyte ; 3658
s = s1 = 0; 3663
p = ( ( const unsigned char * ) begin ); 3664
trans = d -> trans; 3665
* end = eol; 3667
if ( d -> mb_cur_max > 1 )  3679
while ( ( t = trans [ s ] ) != ( ( void * ) 0 ) )  3680
if ( p > buf_end )  3681
s1 = s; 3684
if ( s == 0 )  3685
if ( ( ( char * ) p ) >= end )  3688
if ( d -> states [ s ] . mbps . nelem == 0 )  3696
s = t [ * ( p ++ ) ]; 3697
if ( backref )  3704
s = transit_state ( d , s , & p ); 3713
trans = d -> trans; 3714
while ( ( t = trans [ s ] ) != ( ( void * ) 0 ) )  3718
s1 = t [ * ( p ++ ) ]; 3719
if ( ( t = trans [ s1 ] ) == ( ( void * ) 0 ) )  3720
state_num tmp = s ; 3721
s = s1; 3722
s1 = tmp; 3724
s = t [ * ( p ++ ) ]; 3727
if ( s >= 0 && ( ( char * ) p ) <= end && d -> fails [ s ] )  3730
if ( d -> success [ s ] & sbit [ * p ] )  3731
s1 = s; 3742
if ( d -> mb_cur_max > 1 )  3743
s = transit_state ( d , s , & p ); 3746
trans = d -> trans; 3747
s = d -> fails [ s ] [ * ( p ++ ) ]; 3750
if ( ( ( char * ) p ) > end )  3764
if ( s >= 0 )  3772
build_state ( s , d ); 3773
trans = d -> trans; 3774
if ( p [ - 1 ] == eol && allow_nl )  3777
s = d -> newlines [ s1 ]; 3778
s = 0; 3781
static void build_state(state_num s,struct dfa *d) 3128
state_num * trans ; 3131
state_num i ; 3132
if ( d -> trcount >= 1024 )  3137
for (i = 0; i < d -> tralloc; ++i) 3138
d -> trans [ i ] = d -> fails [ i ] = ( ( void * ) 0 ); 3141
d -> trcount = 0; 3143
d -> success [ s ] = 0; 3147
if ( ( ( ( 4 & 1 ? ( * d ) . states [ s ] . constraint & 0xf : 0 ) ) | ( ( 4 & 2 ? ( * d ) . states [ s ] . constraint >> 4 & 0xf : 0 ) ) | ( ( 4 & 4 ? ( * d ) . states [ s ] . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context )  3148
d -> success [ s ] |= 4; 3149
if ( ( ( ( 2 & 1 ? ( * d ) . states [ s ] . constraint & 0xf : 0 ) ) | ( ( 2 & 2 ? ( * d ) . states [ s ] . constraint >> 4 & 0xf : 0 ) ) | ( ( 2 & 4 ? ( * d ) . states [ s ] . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context )  3151
d -> success [ s ] |= 2; 3152
if ( ( ( ( 1 & 1 ? ( * d ) . states [ s ] . constraint & 0xf : 0 ) ) | ( ( 1 & 2 ? ( * d ) . states [ s ] . constraint >> 4 & 0xf : 0 ) ) | ( ( 1 & 4 ? ( * d ) . states [ s ] . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context )  3154
d -> success [ s ] |= 1; 3155
trans = ( ( sizeof ( ( * trans ) ) == 1 ? xmalloc ( ( 1 << 8 ) ) : xnmalloc ( ( 1 << 8 ) , sizeof ( ( * trans ) ) ) ) ); 3158
while ( 0 )  3159
dfastate ( s , d , trans ); 3160
void dfastate(state_num s,struct dfa *d,token trans[]) 2850
leaf_set * grps ; 2853
charclass * labels ; 2855
size_t ngrps = 0 ; 2857
position pos ; 2859
charclass matches ; 2861
int matchesf ; 2863
charclass intersect ; 2865
int intersectf ; 2867
charclass leftovers ; 2869
int leftoversf ; 2871
position_set follows ; 2873
int possible_contexts ; 2877
int separate_contexts ; 2879
state_num state ; 2881
state_num state_letter ; 2885
size_t i ; 2888
size_t j ; 2889
size_t k ; 2890
grps = ( ( sizeof ( ( * grps ) ) == 1 ? xmalloc ( ( 1 << 8 ) ) : xnmalloc ( ( 1 << 8 ) , sizeof ( ( * grps ) ) ) ) ); 2892
while ( 0 )  2893
labels = ( ( sizeof ( ( * labels ) ) == 1 ? xmalloc ( ( 1 << 8 ) ) : xnmalloc ( ( 1 << 8 ) , sizeof ( ( * labels ) ) ) ) ); 2895
while ( 0 )  2896
for (i = 0; i < d -> states[s] . elems . nelem; ++i) 2898
pos = d -> states [ s ] . elems . elems [ i ]; 2899
if ( d -> tokens [ pos . index ] >= 0 && d -> tokens [ pos . index ] < ( 1 << 8 ) )  2900
if ( d -> tokens [ pos . index ] >= CSET )  2904
if ( pos . constraint != 0x777 )  2927
if ( ! ( ( ( ( 4 & 1 ? pos . constraint & 0xf : 0 ) ) | ( ( 4 & 2 ? pos . constraint >> 4 & 0xf : 0 ) ) | ( ( 4 & 4 ? pos . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context ) )  2928
for (j = 0; j < ((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int )); ++j) 2929
matches [ j ] &= ~newline [ j ]; 2930
if ( ! ( ( ( ( 2 & 1 ? pos . constraint & 0xf : 0 ) ) | ( ( 2 & 2 ? pos . constraint >> 4 & 0xf : 0 ) ) | ( ( 2 & 4 ? pos . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context ) )  2932
for (j = 0; j < ((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int )); ++j) 2933
matches [ j ] &= ~letters [ j ]; 2934
if ( ! ( ( ( ( 1 & 1 ? pos . constraint & 0xf : 0 ) ) | ( ( 1 & 2 ? pos . constraint >> 4 & 0xf : 0 ) ) | ( ( 1 & 4 ? pos . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context ) )  2936
for (j = 0; j < ((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int )); ++j) 2937
matches [ j ] &= letters [ j ] | newline [ j ]; 2938
if ( j == ( ( 1 << 8 ) + 8 * sizeof ( int ) - 1 ) / ( 8 * sizeof ( int ) ) )  2943
for (j = 0; j < ngrps; ++j) 2947
if ( d -> tokens [ pos . index ] >= 0 && d -> tokens [ pos . index ] < ( 1 << 8 ) && ! tstbit ( d -> tokens [ pos . index ] , labels [ j ] ) )  2951
intersectf = 0; 2956
for (k = 0; k < ((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int )); ++k) 2957
( intersect [ k ] = matches [ k ] & labels [ j ] [ k ] ) ? ( intersectf = 1 ) : 0; 2958
if ( ! intersectf )  2959
leftoversf = matchesf = 0; 2963
for (k = 0; k < ((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int )); ++k) 2964
int match = matches [ k ] ; 2966
int label = labels [ j ] [ k ] ; 2967
( leftovers [ k ] = ~match & label ) ? ( leftoversf = 1 ) : 0; 2968
( matches [ k ] = match & ~label ) ? ( matchesf = 1 ) : 0; 2969
if ( leftoversf )  2972
grps [ ngrps ] . elems = ( ( sizeof ( ( * grps [ ngrps ] . elems ) ) == 1 ? xmalloc ( d -> nleaves ) : xnmalloc ( d -> nleaves , sizeof ( ( * grps [ ngrps ] . elems ) ) ) ) ); 2976
while ( 0 )  2977
grps [ ngrps ] . nelem = grps [ j ] . nelem; 2979
grps [ j ] . elems [ grps [ j ] . nelem ++ ] = pos . index; 2984
if ( ! matchesf )  2987
if ( j == ngrps )  2993
grps [ ngrps ] . elems = ( ( sizeof ( ( * grps [ ngrps ] . elems ) ) == 1 ? xmalloc ( d -> nleaves ) : xnmalloc ( d -> nleaves , sizeof ( ( * grps [ ngrps ] . elems ) ) ) ) ); 2997
while ( 0 )  2998
grps [ ngrps ] . nelem = 1; 2999
grps [ ngrps ] . elems [ 0 ] = pos . index; 3000
if ( d -> searchflag )  3009
separate_contexts = state_separate_contexts ( ( & follows ) ); 3012
state = state_index ( d , ( & follows ) , separate_contexts ^ 7 ); 3013
if ( separate_contexts & 2 )  3020
state_letter = state_index ( d , ( & follows ) , 2 ); 3021
state_letter = state; 3024
for (i = 0; i < (1 << 8); ++i) 3026
trans [ i ] = ( 1 && ( ( * __ctype_b_loc ( ) ) [ ( int ) i ] & ( ( unsigned short ) _ISalnum ) || i == '_' ) ? state_letter : state ); 3027
for (i = 0; i < (1 << 8); ++i) 3031
trans [ i ] = ( - 1 ); 3032
for (i = 0; i < ngrps; ++i) 3034
follows . nelem = 0; 3035
possible_contexts = charclass_context ( labels [ i ] ); 3073
separate_contexts = state_separate_contexts ( ( & follows ) ); 3074
if ( ( separate_contexts & possible_contexts ) != possible_contexts )  3076
state = state_index ( d , ( & follows ) , separate_contexts ^ 7 ); 3077
static state_num state_index(struct dfa *d,const position_set *s,int context) 2412
size_t hash = 0 ; 2414
state_num i ; 2416
state_num j ; 2417
for (i = 0; i < s -> nelem; ++i) 2418
hash ^= s -> elems [ i ] . index + s -> elems [ i ] . constraint; 2419
for (i = 0; i < d -> sindex; ++i) 2421
if ( hash != d -> states [ i ] . hash || s -> nelem != d -> states [ i ] . elems . nelem || context != d -> states [ i ] . context )  2422
if ( j == s -> nelem )  2429
if ( d -> salloc <= d -> sindex + 1 )  2435
size_t new_n_alloc = ( d -> sindex + 1 + ( ! d -> states ) ) ; 2436
d -> states = ( x2nrealloc ( ( d -> states ) , & new_n_alloc , sizeof ( ( * d -> states ) ) ) ); 2437
d -> salloc = new_n_alloc; 2438
while ( 0 )  2440
d -> states [ i ] . hash = hash; 2441
copy ( s , & d -> states [ i ] . elems ); 2443",0,0
42262,"void goodG2BSink() 51
char * data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memcpy_68_goodG2BData ; 53
char source [ 100 ] ; 55
memset ( source , 'C' , 100 - 1 ); 56
source [ 100 - 1 ] = '\0'; 57
memcpy ( data , source , 100 * sizeof ( char ) ); 59
data [ 100 - 1 ] = '\0'; 60
printLine ( data ); 61
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14
delete [ ] data 62",0,0
71818,"static void goodB2G2() 290
char * data ; 292
char dataBuffer [ 100 ] = """" ; 293
data = dataBuffer; 294
if ( staticTrue )  295
WSADATA wsaData ; 299
int recvResult ; 302
struct sockaddr_in service ; 303
size_t dataLen = strlen ( data ) ; 307
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  311
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 318
if ( listenSocket == INVALID_SOCKET )  319
memset ( & service , 0 , sizeof ( service ) ); 323
service . sin_family = AF_INET; 324
service . sin_addr . s_addr = INADDR_ANY; 325
service . sin_port = htons ( TCP_PORT ); 326
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  327
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )  331
acceptSocket = accept ( listenSocket , NULL , NULL ); 335
if ( acceptSocket == SOCKET_ERROR )  336
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ); 341
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  342
while ( 0 )  360",0,0
138886,"static void goodG2B() 41
short data ; 43
data = 0; 45
data = 100 - 1; 47
CWE194_Unexpected_Sign_Extension__fscanf_malloc_63b_goodG2BSink ( & data ); 48
void CWE194_Unexpected_Sign_Extension__fscanf_malloc_63b_goodG2BSink(short * dataPtr) 43
short data = * dataPtr ; 45
if ( data < 100 )  47
char * dataBuffer = ( char * ) malloc ( data ) ; 51
memset ( dataBuffer , 'A' , data - 1 ); 53
dataBuffer [ data - 1 ] = '\0'; 54
printLine ( dataBuffer ); 55
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14
free ( dataBuffer ); 56",0,0
111369,"void CWE78_OS_Command_Injection__char_listen_socket_w32_spawnv_17_bad() 60
int i ; 62
char * data ; 63
char dataBuffer [ 100 ] = """" ; 64
data = dataBuffer; 65
for(i = 0; i < 1; i++) 66
WSADATA wsaData ; 70
int recvResult ; 73
struct sockaddr_in service ; 74
size_t dataLen = strlen ( data ) ; 78
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  82
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 89
if ( listenSocket == INVALID_SOCKET )  90
memset ( & service , 0 , sizeof ( service ) ); 94
service . sin_family = AF_INET; 95
service . sin_addr . s_addr = INADDR_ANY; 96
service . sin_port = htons ( TCP_PORT ); 97
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  98
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )  102
acceptSocket = accept ( listenSocket , NULL , NULL ); 106
if ( acceptSocket == SOCKET_ERROR )  107
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ); 112
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  113
while ( 0 )  131",0,0
79692,"void bad() 55
char * data ; 57
char dataBuffer [ FILENAME_MAX ] = BASEPATH ; 58
data = dataBuffer; 59
if ( 1 )  60
WSADATA wsaData ; 64
int recvResult ; 67
struct sockaddr_in service ; 68
char * replace ; 69
size_t dataLen = strlen ( data ) ; 71
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  75
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 82
if ( connectSocket == INVALID_SOCKET )  83
memset ( & service , 0 , sizeof ( service ) ); 87
service . sin_family = AF_INET; 88
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS ); 89
service . sin_port = htons ( TCP_PORT ); 90
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  91
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ); 98
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  99
data [ dataLen + recvResult / sizeof ( char ) ] = '\0'; 104
replace = strchr ( data , '\n' ); 111
if ( replace )  112
* replace = '\0'; 114
while ( 0 )  117",0,0
68917,"static void filter_activate_cb(GtkWidget *w,gpointer data) 131
const char * s ; 133
s = gtk_entry_get_text ( ( ( GtkEntry * ) ( g_type_check_instance_cast ( ( ( GTypeInstance * ) data ) , gtk_entry_get_type ( ) ) ) ) ); 134
main_filter_packets ( & cfile , s , 0 ); 135
gboolean main_filter_packets(capture_file *cf,const gchar *dftext,gboolean force) 354
char * s ; 358
cf_status_t cf_status ; 359
s = g_strdup ( dftext ); 360
cf_status = cf_filter_packets ( cf , s , force ); 361
if ( cf_status == CF_OK )  362
if ( ! s || strlen ( s ) == 0 )  364",0,0
144490,"static void goodG2B2() 209
wchar_t * data ; 211
wchar_t dataBuffer [ FILENAME_MAX ] = BASEPATH ; 212
data = dataBuffer; 213
data = goodG2B2Source ( data ); 215
static wchar_t * goodG2B2Source(wchar_t * data) 199
return data ; 206
FILE * pFile = NULL ; 217
pFile = FOPEN ( data , L ""wb+"" ) 219
if ( pFile != NULL )  220
fclose ( pFile ); 222",0,0
132808,"static status_transit_state transit_state_singlebyte(struct dfa *d,state_num s,const unsigned char *p,state_num *next_state) 3154
state_num * t ; 3156
state_num works = s ; 3157
status_transit_state rval = TRANSIT_STATE_IN_PROGRESS ; 3158
while ( rval == TRANSIT_STATE_IN_PROGRESS )  3159
if ( ( t = d -> trans [ works ] ) != ( ( void * ) 0 ) )  3160
works = t [ * p ]; 3161
rval = TRANSIT_STATE_DONE; 3162
if ( works < 0 )  3163
works = 0; 3164
if ( works < 0 )  3168
works = 0; 3173
if ( d -> fails [ works ] )  3176
works = d -> fails [ works ] [ * p ]; 3177
rval = TRANSIT_STATE_DONE; 3178
build_state ( works , d ); 3181
static void build_state(state_num s,struct dfa *d) 2999
state_num * trans ; 3002
state_num i ; 3003
if ( d -> trcount >= 1024 )  3008
for (i = 0; i < d -> tralloc; ++i) 3009
d -> trans [ i ] = d -> fails [ i ] = ( ( void * ) 0 ); 3012
d -> trcount = 0; 3014
d -> success [ s ] = 0; 3018
if ( ( ( ( 4 & 1 ? ( * d ) . states [ s ] . constraint & 0xf : 0 ) ) | ( ( 4 & 2 ? ( * d ) . states [ s ] . constraint >> 4 & 0xf : 0 ) ) | ( ( 4 & 4 ? ( * d ) . states [ s ] . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context )  3019
d -> success [ s ] |= 4; 3020
if ( ( ( ( 2 & 1 ? ( * d ) . states [ s ] . constraint & 0xf : 0 ) ) | ( ( 2 & 2 ? ( * d ) . states [ s ] . constraint >> 4 & 0xf : 0 ) ) | ( ( 2 & 4 ? ( * d ) . states [ s ] . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context )  3022
d -> success [ s ] |= 2; 3023
if ( ( ( ( 1 & 1 ? ( * d ) . states [ s ] . constraint & 0xf : 0 ) ) | ( ( 1 & 2 ? ( * d ) . states [ s ] . constraint >> 4 & 0xf : 0 ) ) | ( ( 1 & 4 ? ( * d ) . states [ s ] . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context )  3025
d -> success [ s ] |= 1; 3026
trans = ( ( sizeof ( ( * trans ) ) == 1 ? xmalloc ( ( 1 << 8 ) ) : xnmalloc ( ( 1 << 8 ) , sizeof ( ( * trans ) ) ) ) ); 3029
while ( 0 )  3030
dfastate ( s , d , trans ); 3031
void dfastate(state_num s,struct dfa *d,token trans[]) 2721
leaf_set * grps ; 2724
charclass * labels ; 2726
size_t ngrps = 0 ; 2728
position pos ; 2730
charclass matches ; 2732
int matchesf ; 2734
charclass intersect ; 2736
int intersectf ; 2738
charclass leftovers ; 2740
int leftoversf ; 2742
position_set follows ; 2744
int possible_contexts ; 2748
int separate_contexts ; 2750
state_num state ; 2752
state_num state_letter ; 2756
size_t i ; 2759
size_t j ; 2760
size_t k ; 2761
grps = ( ( sizeof ( ( * grps ) ) == 1 ? xmalloc ( ( 1 << 8 ) ) : xnmalloc ( ( 1 << 8 ) , sizeof ( ( * grps ) ) ) ) ); 2763
while ( 0 )  2764
labels = ( ( sizeof ( ( * labels ) ) == 1 ? xmalloc ( ( 1 << 8 ) ) : xnmalloc ( ( 1 << 8 ) , sizeof ( ( * labels ) ) ) ) ); 2766
while ( 0 )  2767
for (i = 0; i < d -> states[s] . elems . nelem; ++i) 2769
pos = d -> states [ s ] . elems . elems [ i ]; 2770
if ( d -> tokens [ pos . index ] >= 0 && d -> tokens [ pos . index ] < ( 1 << 8 ) )  2771
if ( d -> tokens [ pos . index ] >= CSET )  2775
if ( pos . constraint != 0x777 )  2798
if ( ! ( ( ( ( 4 & 1 ? pos . constraint & 0xf : 0 ) ) | ( ( 4 & 2 ? pos . constraint >> 4 & 0xf : 0 ) ) | ( ( 4 & 4 ? pos . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context ) )  2799
for (j = 0; j < ((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int )); ++j) 2800
matches [ j ] &= ~newline [ j ]; 2801
if ( ! ( ( ( ( 2 & 1 ? pos . constraint & 0xf : 0 ) ) | ( ( 2 & 2 ? pos . constraint >> 4 & 0xf : 0 ) ) | ( ( 2 & 4 ? pos . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context ) )  2803
for (j = 0; j < ((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int )); ++j) 2804
matches [ j ] &= ~letters [ j ]; 2805
if ( ! ( ( ( ( 1 & 1 ? pos . constraint & 0xf : 0 ) ) | ( ( 1 & 2 ? pos . constraint >> 4 & 0xf : 0 ) ) | ( ( 1 & 4 ? pos . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context ) )  2807
for (j = 0; j < ((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int )); ++j) 2808
matches [ j ] &= letters [ j ] | newline [ j ]; 2809
if ( j == ( ( 1 << 8 ) + 8 * sizeof ( int ) - 1 ) / ( 8 * sizeof ( int ) ) )  2814
for (j = 0; j < ngrps; ++j) 2818
if ( d -> tokens [ pos . index ] >= 0 && d -> tokens [ pos . index ] < ( 1 << 8 ) && ! tstbit ( d -> tokens [ pos . index ] , labels [ j ] ) )  2822
intersectf = 0; 2827
for (k = 0; k < ((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int )); ++k) 2828
( intersect [ k ] = matches [ k ] & labels [ j ] [ k ] ) ? ( intersectf = 1 ) : 0; 2829
if ( ! intersectf )  2830
leftoversf = matchesf = 0; 2834
for (k = 0; k < ((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int )); ++k) 2835
int match = matches [ k ] ; 2837
int label = labels [ j ] [ k ] ; 2838
( leftovers [ k ] = ~match & label ) ? ( leftoversf = 1 ) : 0; 2839
( matches [ k ] = match & ~label ) ? ( matchesf = 1 ) : 0; 2840
if ( leftoversf )  2843
grps [ ngrps ] . elems = ( ( sizeof ( ( * grps [ ngrps ] . elems ) ) == 1 ? xmalloc ( d -> nleaves ) : xnmalloc ( d -> nleaves , sizeof ( ( * grps [ ngrps ] . elems ) ) ) ) ); 2847
while ( 0 )  2848
memcpy ( grps [ ngrps ] . elems , grps [ j ] . elems , sizeof ( grps [ j ] . elems [ 0 ] ) * grps [ j ] . nelem ); 2849
grps [ ngrps ] . nelem = grps [ j ] . nelem; 2850
grps [ j ] . elems [ grps [ j ] . nelem ++ ] = pos . index; 2855
if ( ! matchesf )  2858
if ( j == ngrps )  2864
grps [ ngrps ] . elems = ( ( sizeof ( ( * grps [ ngrps ] . elems ) ) == 1 ? xmalloc ( d -> nleaves ) : xnmalloc ( d -> nleaves , sizeof ( ( * grps [ ngrps ] . elems ) ) ) ) ); 2868
while ( 0 )  2869
grps [ ngrps ] . nelem = 1; 2870
grps [ ngrps ] . elems [ 0 ] = pos . index; 2871
if ( d -> searchflag )  2880
separate_contexts = state_separate_contexts ( ( & follows ) ); 2883
state = state_index ( d , ( & follows ) , separate_contexts ^ 7 ); 2884
if ( separate_contexts & 2 )  2891
state_letter = state_index ( d , ( & follows ) , 2 ); 2892
state_letter = state; 2895
for (i = 0; i < (1 << 8); ++i) 2897
trans [ i ] = ( 1 && ( ( * __ctype_b_loc ( ) ) [ ( int ) i ] & ( ( unsigned short ) _ISalnum ) || i == '_' ) ? state_letter : state ); 2898
for (i = 0; i < (1 << 8); ++i) 2902
trans [ i ] = ( - 1 ); 2903
for (i = 0; i < ngrps; ++i) 2905
follows . nelem = 0; 2906
possible_contexts = charclass_context ( labels [ i ] ); 2944
separate_contexts = state_separate_contexts ( ( & follows ) ); 2945
if ( separate_contexts & possible_contexts & 2 )  2959
state_letter = state_index ( d , ( & follows ) , 2 ); 2960
static state_num state_index(struct dfa *d,const position_set *s,int context) 2283
size_t hash = 0 ; 2285
state_num i ; 2287
state_num j ; 2288
for (i = 0; i < s -> nelem; ++i) 2289
hash ^= s -> elems [ i ] . index + s -> elems [ i ] . constraint; 2290
for (i = 0; i < d -> sindex; ++i) 2292
if ( hash != d -> states [ i ] . hash || s -> nelem != d -> states [ i ] . elems . nelem || context != d -> states [ i ] . context )  2293
if ( j == s -> nelem )  2300
if ( d -> salloc <= d -> sindex + 1 )  2306
size_t new_n_alloc = ( d -> sindex + 1 + ( ! d -> states ) ) ; 2307
d -> states = ( x2nrealloc ( ( d -> states ) , & new_n_alloc , sizeof ( ( * d -> states ) ) ) ); 2308
d -> salloc = new_n_alloc; 2309
while ( 0 )  2311
d -> states [ i ] . hash = hash; 2312
copy ( s , & d -> states [ i ] . elems ); 2314",0,0
27561,"void bad() 37
twoIntsStruct * data ; 39
data = NULL; 40
badSource ( data ); 41
static void badSource(twoIntsStruct * &data) 27
data = ( twoIntsStruct * ) malloc ( 100 * sizeof ( twoIntsStruct ) ); 30
data [ 0 ] . intOne = 0; 32
data [ 0 ] . intTwo = 0; 33
printStructLine ( & data [ 0 ] ); 34
void printStructLine (const twoIntsStruct * structTwoIntsStruct) 86
printf ( ""%d -- %d\n"" , structTwoIntsStruct -> intOne , structTwoIntsStruct -> intTwo ); 88",0,0
86403,"void dfacomp(const char *s,size_t len,struct dfa *d,int searchflag) 3841
dfamust ( d ); 3845
static void dfamust(struct dfa *d) 4137
must * musts ; 4142
must * mp ; 4143
size_t ri ; 4145
size_t i ; 4146
token t ; 4148
static must must0 ; 4149
musts = ( ( sizeof ( ( * musts ) ) == 1 ? xmalloc ( d -> tindex + 1 ) : xnmalloc ( d -> tindex + 1 , sizeof ( ( * musts ) ) ) ) ); 4217
while ( 0 )  4218
mp = musts; 4219
for (i = 0; i <= d -> tindex; ++i) 4220
mp [ i ] = must0; 4221
for (i = 0; i <= d -> tindex; ++i) 4222
mp [ i ] . in = ( xmalloc ( sizeof ( ( * mp [ i ] . in ) ) ) ); 4223
mp [ i ] . left = ( xmalloc ( 2 ) ); 4224
mp [ i ] . right = ( xmalloc ( 2 ) ); 4225
mp [ i ] . is = ( xmalloc ( 2 ) ); 4226
mp [ i ] . left [ 0 ] = mp [ i ] . right [ 0 ] = mp [ i ] . is [ 0 ] = '\0'; 4227
mp [ i ] . in [ 0 ] = ( ( void * ) 0 ); 4228
for (ri = 0; ri < d -> tindex; ++ri) 4232
switch ( t = d -> tokens [ ri ] )  4233
resetmust ( mp ); 4262
must * lmp ; 4280
must * rmp ; 4281
size_t j ; 4282
size_t ln ; 4283
rmp = -- mp; 4286
lmp = -- mp; 4287
if ( ! ( strcmp ( ( lmp -> is ) , ( rmp -> is ) ) == 0 ) )  4289
lmp -> is [ 0 ] = '\0'; 4290
i = 0; 4293
lmp -> left [ i ] = '\0'; 4296
ln = strlen ( ( lmp -> right ) ); 4298
for (j = 0; j < i; ++j) 4308
lmp -> right [ j ] = lmp -> right [ ln - i + j ]; 4309
lmp -> right [ j ] = '\0'; 4310
mp -> is [ 0 ] = '\0'; 4325
must * lmp ; 4344
must * rmp ; 4345
rmp = -- mp; 4346
lmp = -- mp; 4347
lmp -> in = addlists ( lmp -> in , rmp -> in ); 4351
if ( lmp -> in == ( ( void * ) 0 ) )  4352
if ( lmp -> right [ 0 ] != '\0' && rmp -> left [ 0 ] != '\0' )  4355
char * tp ; 4356
tp = icpyalloc ( ( lmp -> right ) ); 4357
tp = icatalloc ( tp , ( rmp -> left ) ); 4358
lmp -> in = enlist ( lmp -> in , tp , strlen ( tp ) ); 4359
if ( lmp -> in == ( ( void * ) 0 ) )  4361
if ( lmp -> is [ 0 ] != '\0' )  4366
lmp -> left = icatalloc ( lmp -> left , ( rmp -> left ) ); 4367
if ( lmp -> left == ( ( void * ) 0 ) )  4368
if ( rmp -> is [ 0 ] == '\0' )  4373
lmp -> right [ 0 ] = '\0'; 4374
lmp -> right = icatalloc ( lmp -> right , ( rmp -> right ) ); 4376
if ( lmp -> right == ( ( void * ) 0 ) )  4377
if ( lmp -> is [ 0 ] != '\0' && rmp -> is [ 0 ] != '\0' )  4381
lmp -> is = icatalloc ( lmp -> is , ( rmp -> is ) ); 4382
if ( lmp -> is == ( ( void * ) 0 ) )  4383
lmp -> is [ 0 ] = '\0'; 4388
if ( t < END )  4395
if ( t == '\0' )  4399
if ( t >= CSET || ! 1 || t == ANYCHAR || t == MBCSET )  4404
mp -> is [ 0 ] = mp -> left [ 0 ] = mp -> right [ 0 ] = t; 4411
mp -> is [ 1 ] = mp -> left [ 1 ] = mp -> right [ 1 ] = '\0'; 4412
mp -> in = enlist ( mp -> in , mp -> is , ( ( size_t ) 1 ) ); 4413
if ( mp -> in == ( ( void * ) 0 ) )  4414
static void resetmust(must *mp) 4131
mp -> left [ 0 ] = mp -> right [ 0 ] = mp -> is [ 0 ] = '\0'; 4133
freelist ( mp -> in ); 4134
static void freelist(char **cpp) 3979
size_t i ; 3981
if ( cpp == ( ( void * ) 0 ) )  3982
for (i = 0; cpp[i] != ((void *)0); ++i) 3985
free ( cpp [ i ] ); 3986
cpp [ i ] = ( ( void * ) 0 ); 3987",0,0
38902,"void CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_vprintf_22_bad() 53
wchar_t * data ; 55
wchar_t dataBuffer [ 100 ] = L """" 56
data = dataBuffer; 57
WSADATA wsaData ; 60
int recvResult ; 63
struct sockaddr_in service ; 64
size_t dataLen = wcslen ( data ) ; 67
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  71
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 78
if ( connectSocket == INVALID_SOCKET )  79
memset ( & service , 0 , sizeof ( service ) ); 83
service . sin_family = AF_INET; 84
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS ); 85
service . sin_port = htons ( TCP_PORT ); 86
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  87
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ); 94
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  95
while ( 0 )  113",0,0
37529,"void CWE78_OS_Command_Injection__char_connect_socket_w32_spawnv_16_bad() 60
char * data ; 62
char dataBuffer [ 100 ] = """" ; 63
data = dataBuffer; 64
while ( 1 )  65
WSADATA wsaData ; 69
int recvResult ; 72
struct sockaddr_in service ; 73
size_t dataLen = strlen ( data ) ; 76
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  80
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 87
if ( connectSocket == INVALID_SOCKET )  88
memset ( & service , 0 , sizeof ( service ) ); 92
service . sin_family = AF_INET; 93
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS ); 94
service . sin_port = htons ( TCP_PORT ); 95
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  96
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ); 103
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  104
while ( 0 )  122",0,0
10274,"static void goodB2G2() 134
int count ; 136
count = - 1; 138
if ( globalTrue )  139
char inputBuffer [ CHAR_ARRAY_SIZE ] = """" ; 142
if ( fgets ( inputBuffer , CHAR_ARRAY_SIZE , stdin ) != NULL )  144
count = atoi ( inputBuffer ); 147
if ( globalTrue )  155
const char * filename = ""output_good.txt"" ; 160
if ( count > 0 && count <= 20 )  162
pFile = fopen ( filename , ""w+"" ); 164
if ( pFile )  173
fclose ( pFile ); 175",0,0
3810,"static int
dtdCopy(DTD *newDtd, const DTD *oldDtd, const XML_Memory_Handling_Suite *ms) 5774
const XML_Char * name ; 5782
const PREFIX * oldP = ( PREFIX * ) hashTableIterNext ( & iter ) ; 5783
if ( ! oldP )  5784
name = poolCopyString ( & ( newDtd -> pool ) , oldP -> name ); 5786
if ( ! name )  5787
if ( ! lookup ( & ( newDtd -> prefixes ) , name , sizeof ( PREFIX ) ) )  5789
ATTRIBUTE_ID * newA ; 5798
const XML_Char * name ; 5799
const ATTRIBUTE_ID * oldA = ( ATTRIBUTE_ID * ) hashTableIterNext ( & iter ) ; 5800
if ( ! oldA )  5802
if ( ! poolAppendChar ( & ( newDtd -> pool ) , XML_T ( '\0' ) ) )  5805
name = poolCopyString ( & ( newDtd -> pool ) , oldA -> name ); 5807
if ( ! name )  5808
newA = ( ATTRIBUTE_ID * ) lookup ( & ( newDtd -> attributeIds ) , name , sizeof ( ATTRIBUTE_ID ) ); 5811
if ( ! newA )  5813
int i ; 5831
ELEMENT_TYPE * newE ; 5832
const XML_Char * name ; 5833
const ELEMENT_TYPE * oldE = ( ELEMENT_TYPE * ) hashTableIterNext ( & iter ) ; 5834
if ( ! oldE )  5835
name = poolCopyString ( & ( newDtd -> pool ) , oldE -> name ); 5837
if ( ! name )  5838
newE = ( ELEMENT_TYPE * ) lookup ( & ( newDtd -> elementTypes ) , name , sizeof ( ELEMENT_TYPE ) ); 5840
if ( ! newE )  5842
if ( oldE -> nDefaultAtts )  5844
newE -> defaultAtts = ( DEFAULT_ATTRIBUTE * ) ms -> malloc_fcn ( oldE -> nDefaultAtts * sizeof ( DEFAULT_ATTRIBUTE ) ); 5845
if ( ! newE -> defaultAtts )  5847
if ( oldE -> idAtt )  5852
newE -> idAtt = ( ATTRIBUTE_ID * ) lookup ( & ( newDtd -> attributeIds ) , oldE -> idAtt -> name , 0 ); 5853
newE -> allocDefaultAtts = newE -> nDefaultAtts = oldE -> nDefaultAtts; 5855
if ( oldE -> prefix )  5856
newE -> prefix = ( PREFIX * ) lookup ( & ( newDtd -> prefixes ) , oldE -> prefix -> name , 0 ); 5857
for (i = 0; i < newE->nDefaultAtts; i++) 5859
newE -> defaultAtts [ i ] . id = ( ATTRIBUTE_ID * ) lookup ( & ( newDtd -> attributeIds ) , oldE -> defaultAtts [ i ] . id -> name , 0 ); 5860
newE -> defaultAtts [ i ] . isCdata = oldE -> defaultAtts [ i ] . isCdata; 5862
if ( oldE -> defaultAtts [ i ] . value )  5863
newE -> defaultAtts [ i ] . value = poolCopyString ( & ( newDtd -> pool ) , oldE -> defaultAtts [ i ] . value ); 5864
if ( ! newE -> defaultAtts [ i ] . value )  5866
newE -> defaultAtts [ i ] . value = NULL; 5870
if ( ! copyEntityTable ( & ( newDtd -> generalEntities ) , & ( newDtd -> pool ) , & ( oldDtd -> generalEntities ) ) )  5875
if ( ! copyEntityTable ( & ( newDtd -> paramEntities ) , & ( newDtd -> pool ) , & ( oldDtd -> paramEntities ) ) )  5881
static int
copyEntityTable(HASH_TABLE *newTable,
STRING_POOL *newPool,
const HASH_TABLE *oldTable) 5906
const XML_Char * cachedOldBase = NULL ; 5909
ENTITY * newE ; 5915
const XML_Char * name ; 5916
const ENTITY * oldE = ( ENTITY * ) hashTableIterNext ( & iter ) ; 5917
if ( ! oldE )  5918
name = poolCopyString ( newPool , oldE -> name ); 5920
if ( ! name )  5921
newE = ( ENTITY * ) lookup ( newTable , name , sizeof ( ENTITY ) ); 5923
if ( ! newE )  5924
if ( oldE -> systemId )  5926
const XML_Char * tem = poolCopyString ( newPool , oldE -> systemId ) ; 5927
if ( ! tem )  5928
if ( oldE -> base )  5931
if ( oldE -> base == cachedOldBase )  5932
cachedOldBase = oldE -> base; 5935
tem = poolCopyString ( newPool , cachedOldBase ); 5936
if ( ! tem )  5937
if ( oldE -> publicId )  5942
tem = poolCopyString ( newPool , oldE -> publicId ); 5943
if ( ! tem )  5944
const XML_Char * tem = poolCopyStringN ( newPool , oldE -> textPtr , oldE -> textLen ) ; 5950
if ( ! tem )  5952
if ( oldE -> notation )  5957
const XML_Char * tem = poolCopyString ( newPool , oldE -> notation ) ; 5958
if ( ! tem )  5959
static const XML_Char *
poolCopyStringN(STRING_POOL *pool, const XML_Char *s, int n) 6193
if ( ! pool -> ptr && ! poolGrow ( pool ) )  6195
static XML_Bool FASTCALL
poolGrow(STRING_POOL *pool) 6230
if ( pool -> freeBlocks )  6232
if ( pool -> start == 0 )  6233
if ( pool -> end - pool -> start < pool -> freeBlocks -> size )  6242
BLOCK * tem = pool -> freeBlocks -> next ; 6243
pool -> freeBlocks -> next = pool -> blocks; 6244
pool -> blocks = pool -> freeBlocks; 6245
pool -> freeBlocks = tem; 6246
memcpy ( pool -> blocks -> s , pool -> start , ( pool -> end - pool -> start ) * sizeof ( XML_Char ) ); 6247
pool -> ptr = pool -> blocks -> s + ( pool -> ptr - pool -> start ); 6249
pool -> start = pool -> blocks -> s; 6250
pool -> end = pool -> start + pool -> blocks -> size; 6251",0,0
29118,"static void good2() 157
if ( 1 )  159
BYTE payload [ 100 ] ; 162
DWORD payloadLen = strlen ( PAYLOAD ) ; 163
HCRYPTPROV hCryptProv = ( HCRYPTPROV ) NULL ; 164
HCRYPTHASH hHash = ( HCRYPTHASH ) NULL ; 165
HCRYPTKEY hKey = ( HCRYPTKEY ) NULL ; 166
char hashData [ 100 ] = HASH_INPUT ; 167
memcpy ( payload , PAYLOAD , payloadLen ); 171
if ( ! CryptAcquireContext ( & hCryptProv , NULL , MS_ENH_RSA_AES_PROV , PROV_RSA_AES , 0 ) )  173
if ( ! CryptCreateHash ( hCryptProv , CALG_SHA_256 , 0 , 0 , & hHash ) )  179
if ( ! CryptHashData ( hHash , ( BYTE * ) hashData , strlen ( hashData ) , 0 ) )  184
if ( ! CryptDeriveKey ( hCryptProv , CALG_AES_256 , hHash , 0 , & hKey ) )  189
if ( ! CryptEncrypt ( hKey , 0 , 1 , 0 , payload , & payloadLen , sizeof ( payload ) ) )  194
while ( 0 )  199",0,0
121605,"static void goodG2B() 61
wchar_t * data ; 63
if ( globalReturnsTrueOrFalse ( ) )  65
int globalReturnsTrueOrFalse() 157
return ( rand ( ) % 2 ) ; 159
data = ( wchar_t * ) malloc ( 100 * sizeof ( wchar_t ) ); 74
data [ i ] = source [ i ]; 85
printWLine ( data ); 88
void printWLine (const wchar_t * line) 18
if ( line != NULL )  20
wprintf ( L ""%ls\n"" , line ) 22
free ( data ); 89",0,0
127600,"void CWE78_OS_Command_Injection__wchar_t_file_w32_spawnvp_41_bad() 57
wchar_t * data ; 59
wchar_t dataBuffer [ 100 ] = L """" 60
data = dataBuffer; 61
size_t dataLen = wcslen ( data ) ; 64
FILE * pFile ; 65
if ( 100 - dataLen > 1 )  67
pFile = fopen ( FILENAME , ""r"" ); 69
if ( pFile != NULL )  70
fclose ( pFile ); 79",0,0
62687,"static void good1() 43
if ( GLOBAL_CONST_FIVE != 5 )  45
char data [ 150 ] , dest [ 100 ] ; 53
memset ( data , 'A' , 149 ); 55
data [ 149 ] = '\0'; 56
memcpy ( dest , data , 99 * sizeof ( char ) ); 57
dest [ 99 ] = '\0'; 58
printLine ( dest ); 59
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",0,0
87607,"static void goodB2G() 50
char * data ; 52
char dataBuffer [ 100 ] = """" ; 53
data = dataBuffer; 54
CWE134_Uncontrolled_Format_String__char_file_fprintf_84_goodB2G * goodB2GObject = new CWE134_Uncontrolled_Format_String__char_file_fprintf_84_goodB2G ( data ) ; 55
CWE134_Uncontrolled_Format_String__char_file_fprintf_84_goodB2G::CWE134_Uncontrolled_Format_String__char_file_fprintf_84_goodB2G(char * dataCopy) 30
data = dataCopy; 32
size_t dataLen = strlen ( data ) ; 35
FILE * pFile ; 36
if ( 100 - dataLen > 1 )  38
pFile = fopen ( FILENAME , ""r"" ); 40
if ( pFile != NULL )  41
fclose ( pFile ); 50",0,0
148603,"static void goodG2B() 58
wchar_t * data ; 60
data = NULL; 61
if ( globalReturnsTrueOrFalse ( ) )  62
int globalReturnsTrueOrFalse() 157
return ( rand ( ) % 2 ) ; 159
data = ( wchar_t * ) malloc ( ( 10 + 1 ) * sizeof ( wchar_t ) ); 65
data = ( wchar_t * ) malloc ( ( 10 + 1 ) * sizeof ( wchar_t ) ); 70
wchar_t source [ 10 + 1 ] = SRC_STRING ; 73
wcsncpy ( data , source , wcslen ( source ) + 1 ); 76
printWLine ( data ); 77
void printWLine (const wchar_t * line) 18
if ( line != NULL )  20
wprintf ( L ""%ls\n"" , line ) 22
free ( data ); 78",0,0
90760,"char *dfaexec(struct dfa *d,const char *begin,char *end,int allow_nl,size_t *count,int *backref) 3646
state_num s ; 3649
state_num s1 ; 3650
const unsigned char * p ; 3652
state_num * * trans ; 3655
state_num * t ; 3656
unsigned char eol = eolbyte ; 3658
s = s1 = 0; 3663
p = ( ( const unsigned char * ) begin ); 3664
trans = d -> trans; 3665
* end = eol; 3667
if ( d -> mb_cur_max > 1 )  3679
while ( ( t = trans [ s ] ) != ( ( void * ) 0 ) )  3680
if ( p > buf_end )  3681
s1 = s; 3684
if ( s == 0 )  3685
if ( ( ( char * ) p ) >= end )  3688
if ( d -> states [ s ] . mbps . nelem == 0 )  3696
s = t [ * ( p ++ ) ]; 3697
if ( backref )  3704
s = transit_state ( d , s , & p ); 3713
trans = d -> trans; 3714
while ( ( t = trans [ s ] ) != ( ( void * ) 0 ) )  3718
s1 = t [ * ( p ++ ) ]; 3719
if ( ( t = trans [ s1 ] ) == ( ( void * ) 0 ) )  3720
state_num tmp = s ; 3721
s = s1; 3722
s1 = tmp; 3724
s = t [ * ( p ++ ) ]; 3727
if ( s >= 0 && ( ( char * ) p ) <= end && d -> fails [ s ] )  3730
if ( d -> success [ s ] & sbit [ * p ] )  3731
s1 = s; 3742
if ( d -> mb_cur_max > 1 )  3743
s = transit_state ( d , s , & p ); 3746
trans = d -> trans; 3747
s = d -> fails [ s ] [ * ( p ++ ) ]; 3750
if ( ( ( char * ) p ) > end )  3764
if ( s >= 0 )  3772
trans = d -> trans; 3774
if ( p [ - 1 ] == eol && allow_nl )  3777
s = d -> newlines [ s1 ]; 3778
s = 0; 3781
static state_num transit_state(struct dfa *d,state_num s,const unsigned char **pp) 3527
state_num s1 ; 3529
int mbclen ; 3531
int maxlen = 0 ; 3532
size_t i ; 3533
size_t nelem = d -> states [ s ] . mbps . nelem ; 3537
const unsigned char * p1 = * pp ; 3539
wchar_t wc ; 3540
if ( nelem > 0 )  3541
match_lens = check_matching_with_multibyte_ops ( d , s , ( * pp - buf_begin ) ); 3546
static int *check_matching_with_multibyte_ops(struct dfa *d,state_num s,size_t idx) 3447
size_t i ; 3449
int * rarray ; 3450
rarray = ( ( sizeof ( ( * rarray ) ) == 1 ? xmalloc ( d -> states [ s ] . mbps . nelem ) : xnmalloc ( d -> states [ s ] . mbps . nelem , sizeof ( ( * rarray ) ) ) ) ); 3452
while ( 0 )  3453
for (i = 0; i < d -> states[s] . mbps . nelem; ++i) 3454
position pos = d -> states [ s ] . mbps . elems [ i ] ; 3455
switch ( d -> tokens [ pos . index ] )  3456
rarray [ i ] = match_anychar ( d , s , pos , idx ); 3459
static int match_anychar(struct dfa *d,state_num s,position pos,size_t idx) 3322
int context ; 3324
wchar_t wc ; 3325
int mbclen ; 3326
wc = inputwcs [ idx ]; 3327
mbclen = ( mblen_buf [ idx ] == 0 ? 1 : mblen_buf [ idx ] ); 3328
if ( wc == ( ( wchar_t ) eolbyte ) )  3330
if ( ! ( syntax_bits & ( ( unsigned long ) 1 ) << 1 << 1 << 1 << 1 << 1 << 1 ) )  3331
return 0 ; 3332
if ( wc == ( ( wchar_t ) '\0' ) )  3336
if ( syntax_bits & ( ( unsigned long ) 1 ) << 1 << 1 << 1 << 1 << 1 << 1 << 1 )  3337
return 0 ; 3338
context = wchar_context ( wc ); 3342
static int wchar_context(wint_t wc) 726
if ( wc == ( ( wchar_t ) eolbyte ) || wc == 0 )  728
return 4 ; 729
if ( wc == '_' || iswalnum ( wc ) )  731
return 2 ; 732
return 1 ; 734
if ( ! ( ( ( ( context & 1 ? pos . constraint & 0xf : 0 ) ) | ( ( context & 2 ? pos . constraint >> 4 & 0xf : 0 ) ) | ( ( context & 4 ? pos . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context ) )  3343
return 0 ; 3344
return mbclen ; 3346
rarray [ i ] = match_mb_charset ( d , s , pos , idx ); 3464
static int match_mb_charset(struct dfa *d,state_num s,position pos,size_t idx) 3353
size_t i ; 3355
int match ; 3357
int match_len ; 3360
int op_len ; 3362
char buffer [ 128 ] ; 3363
struct mb_char_classes * work_mbc ; 3365
int context ; 3366
wchar_t wc ; 3368
wc = inputwcs [ idx ]; 3369
if ( wc == ( ( wchar_t ) eolbyte ) )  3371
if ( ! ( syntax_bits & ( ( unsigned long ) 1 ) << 1 << 1 << 1 << 1 << 1 << 1 ) )  3372
return 0 ; 3373
if ( wc == ( ( wchar_t ) '\0' ) )  3377
if ( syntax_bits & ( ( unsigned long ) 1 ) << 1 << 1 << 1 << 1 << 1 << 1 << 1 )  3378
return 0 ; 3379
context = wchar_context ( wc ); 3383
static int wchar_context(wint_t wc) 726
if ( wc == ( ( wchar_t ) eolbyte ) || wc == 0 )  728
return 4 ; 729
if ( wc == '_' || iswalnum ( wc ) )  731
return 2 ; 732
return 1 ; 734
if ( ! ( ( ( ( context & 1 ? pos . constraint & 0xf : 0 ) ) | ( ( context & 2 ? pos . constraint >> 4 & 0xf : 0 ) ) | ( ( context & 4 ? pos . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context ) )  3384
return 0 ; 3385
work_mbc = & d -> mbcsets [ d -> multibyte_prop [ pos . index ] >> 2 ]; 3388
match = ! work_mbc -> invert; 3389
match_len = ( mblen_buf [ idx ] == 0 ? 1 : mblen_buf [ idx ] ); 3390
if ( wc < 1 << 8 && work_mbc -> cset != ( - 1 ) && tstbit ( ( ( unsigned char ) wc ) , d -> charclasses [ work_mbc -> cset ] ) )  3392
static int tstbit(unsigned int b,const int c[((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int ))]) 632
return c [ b / ( 8 * sizeof ( int ) ) ] & 1 << b % ( 8 * sizeof ( int ) ) ; 634
for (i = 0; i < work_mbc -> nch_classes; i++) 3396
if ( iswctype ( ( ( wint_t ) wc ) , work_mbc -> ch_classes [ i ] ) )  3397
strncpy ( buffer , ( ( const char * ) buf_begin ) + idx , match_len ); 3401
buffer [ match_len ] = '\0'; 3402
for (i = 0; i < work_mbc -> nequivs; i++) 3404
op_len = ( strlen ( work_mbc -> equivs [ i ] ) ); 3405
strncpy ( buffer , ( ( const char * ) buf_begin ) + idx , op_len ); 3406
buffer [ op_len ] = '\0'; 3407
if ( strcoll ( work_mbc -> equivs [ i ] , buffer ) == 0 )  3408
match_len = op_len; 3409
for (i = 0; i < work_mbc -> ncoll_elems; i++) 3414
op_len = ( strlen ( work_mbc -> coll_elems [ i ] ) ); 3415
strncpy ( buffer , ( ( const char * ) buf_begin ) + idx , op_len ); 3416
buffer [ op_len ] = '\0'; 3417
if ( strcoll ( work_mbc -> coll_elems [ i ] , buffer ) == 0 )  3418
match_len = op_len; 3419
for (i = 0; i < work_mbc -> nranges; i++) 3424
if ( work_mbc -> range_sts [ i ] <= wc && wc <= work_mbc -> range_ends [ i ] )  3425
for (i = 0; i < work_mbc -> nchars; i++) 3430
if ( wc == work_mbc -> chars [ i ] )  3431
match = ! match; 3435
return match ? match_len : 0 ; 3437
return rarray ; 3472
for (i = 0; i < nelem; i++) 3547
if ( match_lens [ i ] > maxlen )  3551
maxlen = match_lens [ i ]; 3552
if ( nelem == 0 || maxlen == 0 )  3556
wc = inputwcs [ * pp - mbclen - buf_begin ]; 3576
while ( * pp - p1 < maxlen )  3579
wc = inputwcs [ * pp - mbclen - buf_begin ]; 3587
s1 = state_index ( d , ( & follows ) , wchar_context ( wc ) ); 3588
static state_num state_index(struct dfa *d,const position_set *s,int context) 2412
size_t hash = 0 ; 2414
state_num i ; 2416
state_num j ; 2417
for (i = 0; i < s -> nelem; ++i) 2418
hash ^= s -> elems [ i ] . index + s -> elems [ i ] . constraint; 2419
for (i = 0; i < d -> sindex; ++i) 2421
if ( hash != d -> states [ i ] . hash || s -> nelem != d -> states [ i ] . elems . nelem || context != d -> states [ i ] . context )  2422
if ( j == s -> nelem )  2429
if ( d -> salloc <= d -> sindex + 1 )  2435
size_t new_n_alloc = ( d -> sindex + 1 + ( ! d -> states ) ) ; 2436
d -> states = ( x2nrealloc ( ( d -> states ) , & new_n_alloc , sizeof ( ( * d -> states ) ) ) ); 2437
d -> salloc = new_n_alloc; 2438
while ( 0 )  2440
d -> states [ i ] . hash = hash; 2441
copy ( s , & d -> states [ i ] . elems ); 2443",0,0
58132,"static void goodG2B() 150
char * data ; 152
char dataBuffer [ 100 ] = """" ; 153
data = dataBuffer; 154
strcpy ( data , ""fixedstringtest"" ); 156
CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_52b_goodG2BSink ( data ); 157
void CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_52b_goodG2BSink(char * data) 68
CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_52c_goodG2BSink ( data ); 70
void CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_52c_goodG2BSink(char * data) 68
SNPRINTF ( dest , 100 - 1 , data ); 73",0,0
102880,"void CWE606_Unchecked_Loop_Condition__char_listen_socket_12_bad() 49
char * data ; 51
char dataBuffer [ 100 ] = """" ; 52
data = dataBuffer; 53
if ( globalReturnsTrueOrFalse ( ) )  54
int globalReturnsTrueOrFalse() 157
return ( rand ( ) % 2 ) ; 159
WSADATA wsaData ; 58
int recvResult ; 61
struct sockaddr_in service ; 62
char * replace ; 63
size_t dataLen = strlen ( data ) ; 66
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  70
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 77
if ( listenSocket == INVALID_SOCKET )  78
memset ( & service , 0 , sizeof ( service ) ); 82
service . sin_family = AF_INET; 83
service . sin_addr . s_addr = INADDR_ANY; 84
service . sin_port = htons ( TCP_PORT ); 85
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  86
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )  90
acceptSocket = accept ( listenSocket , NULL , NULL ); 94
if ( acceptSocket == SOCKET_ERROR )  95
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ); 100
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  101
data [ dataLen + recvResult / sizeof ( char ) ] = '\0'; 106
replace = strchr ( data , '\r' ); 108
if ( replace )  109
* replace = '\0'; 111
if ( replace )  114
* replace = '\0'; 116
while ( 0 )  119",0,0
68391,"static int skinny_hangup(struct ast_channel *ast) 4394
struct skinny_subchannel * sub = ast -> tech_pvt ; 4396
if ( ! sub )  4398
dumpsub ( sub , 1 ); 4403
static void dumpsub(struct skinny_subchannel *sub, int forcehangup) 5346
struct skinny_line * l = sub -> line ; 5348
if ( ! forcehangup && sub -> substate == SUBSTATE_HOLD )  5357
if ( sub == l -> activesub )  5362
setsubstate ( sub , SUBSTATE_ONHOOK ); 5396
static void setsubstate(struct skinny_subchannel *sub, int state) 4955
struct skinny_line * l = sub -> line ; 4957
struct skinny_subline * subline = sub -> subline ; 4958
struct skinny_device * d = l -> device ; 4959
struct ast_channel * c = sub -> owner ; 4960
int actualstate = state ; 4962
if ( sub -> substate == SUBSTATE_ONHOOK )  4964
if ( state != SUBSTATE_RINGIN && sub -> aa_sched )  4968
sub -> aa_sched = 0; 4970
sub -> aa_beep = 0; 4971
sub -> aa_mute = 0; 4972
if ( ( state == SUBSTATE_RINGIN ) && ( ( d -> hookstate == SKINNY_OFFHOOK ) || ( AST_LIST_NEXT ( AST_LIST_FIRST ( & l -> sub ) , list ) ) ) )  4975
actualstate = SUBSTATE_CALLWAIT; 4976
if ( ( state == SUBSTATE_CONNECTED ) && ( ! subline ) && ( AST_LIST_FIRST ( & l -> sublines ) ) )  4979
const char * slastation ; 4980
struct skinny_subline * tmpsubline ; 4981
slastation = pbx_builtin_getvar_helper ( c , ""SLASTATION"" ); 4982
if ( slastation )  4984
subline = tmpsubline; 4987
if ( subline )  4991
subline -> sub = sub; 4993
sub -> subline = subline; 4994
subline -> callid = sub -> callid; 4995
if ( subline )  5013
switch ( actualstate )  5014
if ( sub -> substate != SUBSTATE_CONNECTED )  5066
sub -> substate = SUBSTATE_HOLD; 5078
if ( ( d -> hookstate == SKINNY_ONHOOK ) && ( ( actualstate == SUBSTATE_OFFHOOK ) || ( actualstate == SUBSTATE_DIALING ) || ( actualstate == SUBSTATE_RINGOUT ) || ( actualstate == SUBSTATE_CONNECTED ) || ( actualstate == SUBSTATE_BUSY ) || ( actualstate == SUBSTATE_CONGESTION ) || ( actualstate == SUBSTATE_PROGRESS ) ) )  5090
d -> hookstate = SKINNY_OFFHOOK; 5093
if ( actualstate == sub -> substate )  5101
switch ( actualstate )  5107
l -> activesub = sub; 5110
sub -> substate = SUBSTATE_OFFHOOK; 5118
if ( sub -> related )  5128
sub -> related -> related = NULL; 5129
if ( sub == l -> activesub )  5132
l -> activesub = NULL; 5133
sub -> cxmode = SKINNY_CX_RECVONLY; 5148
sub -> substate = SUBSTATE_ONHOOK; 5149
if ( sub -> rtp )  5150
sub -> rtp = NULL; 5152
if ( ast_strlen_zero ( sub -> exten ) || ! ast_exists_extension ( c , c -> context , sub -> exten , 1 , l -> cid_num ) )  5159
if ( d -> hookstate == SKINNY_ONHOOK )  5164
d -> hookstate = SKINNY_OFFHOOK; 5165
sub -> substate = SUBSTATE_DIALING; 5194
if ( ! ( sub -> substate == SUBSTATE_DIALING || sub -> substate == SUBSTATE_PROGRESS ) )  5202
sub -> substate = SUBSTATE_RINGOUT; 5214
if ( d -> hookstate == SKINNY_ONHOOK )  5225
l -> activesub = sub; 5226
sub -> substate = SUBSTATE_RINGIN; 5233
sub -> substate = SUBSTATE_CALLWAIT; 5246
sub -> substate = SUBSTATE_CONNECTED; 5278
l -> activesub = sub; 5279
if ( ! ( sub -> substate == SUBSTATE_DIALING || sub -> substate == SUBSTATE_PROGRESS || sub -> substate == SUBSTATE_RINGOUT ) )  5282
sub -> substate = SUBSTATE_BUSY; 5293
if ( ! ( sub -> substate == SUBSTATE_DIALING || sub -> substate == SUBSTATE_PROGRESS || sub -> substate == SUBSTATE_RINGOUT ) )  5296
sub -> substate = SUBSTATE_CONGESTION; 5307
if ( sub -> substate != SUBSTATE_DIALING )  5310
sub -> substate = SUBSTATE_PROGRESS; 5321
if ( sub -> substate != SUBSTATE_CONNECTED )  5324
ast_queue_control_data ( sub -> owner , AST_CONTROL_HOLD , S_OR ( l -> mohsuggest , NULL ) , ! ast_strlen_zero ( l -> mohsuggest ) ? strlen ( l -> mohsuggest ) + 1 : 0 ); 5328",0,0
44646,"void bad() 25
char * data ; 27
data = ( char * ) malloc ( 100 * sizeof ( char ) ); 28
data [ 0 ] = '\0'; 29
CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_listen_socket_84_bad * badObject = new CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_listen_socket_84_bad ( data ) ; 30
CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_listen_socket_84_bad::CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_listen_socket_84_bad(char * dataCopy) 46
data = dataCopy; 48
WSADATA wsaData ; 51
int recvResult ; 54
struct sockaddr_in service ; 55
char * replace ; 56
size_t dataLen = strlen ( data ) ; 59
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  63
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 70
if ( listenSocket == INVALID_SOCKET )  71
memset ( & service , 0 , sizeof ( service ) ); 75
service . sin_family = AF_INET; 76
service . sin_addr . s_addr = INADDR_ANY; 77
service . sin_port = htons ( TCP_PORT ); 78
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  79
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )  83
acceptSocket = accept ( listenSocket , NULL , NULL ); 87
if ( acceptSocket == SOCKET_ERROR )  88
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ); 93
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  94
data [ dataLen + recvResult / sizeof ( char ) ] = '\0'; 99
replace = strchr ( data , '\n' ); 106
if ( replace )  107
* replace = '\0'; 109
while ( 0 )  112",0,0
160910,"void bad() 25
int data ; 27
data = - 1; 29
CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fixed_84_bad * badObject = new CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fixed_84_bad ( data ) ; 30
CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fixed_84_bad::CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fixed_84_bad(int dataCopy) 23
data = dataCopy; 25
data = INT_MAX / 2 + 2; 27
delete badObject 31
CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fixed_84_bad::~CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fixed_84_bad() 32
int * intPointer ; 36
intPointer = ( int * ) malloc ( data * sizeof ( int ) ); 39
intPointer [ i ] = 0; 42
printIntLine ( intPointer [ 0 ] ); 44
void printIntLine (int intNumber) 26
printf ( ""%d\n"" , intNumber ); 28
free ( intPointer ); 45",119,1
93047,"void bad() 26
wchar_t * data ; 28
data = NULL; 29
switch ( 6 )  30
wchar_t * dataBuffer = new wchar_t [ 100 ] ; 34
wmemset ( dataBuffer , L 'A' , 100 - 1 )
dataBuffer [ 100 - 1 ] = L '\0' 36
data = dataBuffer - 8; 38
wchar_t source [ 100 ] ; 47
wmemset ( source , L 'C' , 100 - 1 )
source [ 100 - 1 ] = L '\0' 49
memcpy ( data , source , 100 * sizeof ( wchar_t ) ); 51
printWLine ( data ); 54
void printWLine (const wchar_t * line) 18
if ( line != NULL )  20
wprintf ( L ""%ls\n"" , line ) 22",119,1
101521,"void bad() 52
char * data ; 54
char dataBuffer [ FILENAME_MAX ] = """" ; 55
data = dataBuffer; 56
if ( GLOBAL_CONST_FIVE == 5 )  57
WSADATA wsaData ; 61
int recvResult ; 64
struct sockaddr_in service ; 65
size_t dataLen = strlen ( data ) ; 69
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  73
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 80
if ( listenSocket == INVALID_SOCKET )  81
memset ( & service , 0 , sizeof ( service ) ); 85
service . sin_family = AF_INET; 86
service . sin_addr . s_addr = INADDR_ANY; 87
service . sin_port = htons ( TCP_PORT ); 88
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  89
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )  93
acceptSocket = accept ( listenSocket , NULL , NULL ); 97
if ( acceptSocket == SOCKET_ERROR )  98
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ); 103
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  104
data [ dataLen + recvResult / sizeof ( char ) ] = '\0'; 109
replace = strchr ( data , '\r' ); 111
if ( replace )  112
* replace = '\0'; 114
replace = strchr ( data , '\n' ); 116
if ( replace )  117
* replace = '\0'; 119
while ( 0 )  122
outputFile . open ( ( char * ) data ); 142",706,1
50539,"void bad() 37
wchar_t * data ; 39
data = NULL; 40
if ( staticTrue )  41
data = new wchar_t [ 10 ]; 44
wchar_t source [ 10 + 1 ] = SRC_STRING ; 47
wcsncpy ( data , source , wcslen ( source ) + 1 ); 50
printWLine ( data ); 51
void printWLine (const wchar_t * line) 18
if ( line != NULL )  20
wprintf ( L ""%ls\n"" , line ) 22
delete [ ] data 52",119,1
86920,"void CWE121_Stack_Based_Buffer_Overflow__CWE135_66_bad() 30
void * data ; 32
void * dataArray [ 5 ] ; 33
data = NULL; 34
data = ( void * ) WIDE_STRING; 36
dataArray [ 2 ] = data; 38
CWE121_Stack_Based_Buffer_Overflow__CWE135_66b_badSink ( dataArray ); 39
void CWE121_Stack_Based_Buffer_Overflow__CWE135_66b_badSink(void * dataArray[]) 27
void * data = dataArray [ 2 ] ; 30
size_t dataLen = strlen ( ( char * ) data ) ; 33
void * dest = ( void * ) calloc ( dataLen + 1 , 1 ) ; 34
memcpy ( dest , data , ( dataLen + 1 ) ); 35
free ( dest ); 37",119,1
143534,"void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_memcpy_41_bad() 37
wchar_t * data ; 39
data = NULL; 40
data = ( wchar_t * ) malloc ( 50 * sizeof ( wchar_t ) ); 42
data [ 0 ] = L '\0' 43
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_memcpy_41_badSink ( data ); 44
void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_memcpy_41_badSink(wchar_t * data) 23
wchar_t source [ 100 ] ; 26
wmemset ( source , L 'C' , 100 - 1 )
source [ 100 - 1 ] = L '\0' 28
memcpy ( data , source , 100 * sizeof ( wchar_t ) ); 30
printWLine ( data ); 32
void printWLine (const wchar_t * line) 18
if ( line != NULL )  20
wprintf ( L ""%ls\n"" , line ) 22
free ( data ); 33",119,1
13800,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memcpy_13_bad() 28
wchar_t * data ; 30
wchar_t * dataBadBuffer = ( wchar_t * ) ALLOCA ( ( 10 ) * sizeof ( wchar_t ) ) ; 31
if ( GLOBAL_CONST_FIVE == 5 )  33
data = dataBadBuffer; 37
data [ 0 ] = L '\0' 38
wchar_t source [ 10 + 1 ] = SRC_STRING ; 41
memcpy ( data , source , ( wcslen ( source ) + 1 ) * sizeof ( wchar_t ) ); 44
printWLine ( data ); 45
void printWLine (const wchar_t * line) 18
if ( line != NULL )  20
wprintf ( L ""%ls\n"" , line ) 22",119,1
95992,"void CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_41_badSink(short data) 44
char source [ 100 ] ; 47
memset ( source , 'A' , 100 - 1 ); 49
source [ 100 - 1 ] = '\0'; 50
memcpy ( dest , source , data ); 55
dest [ data ] = '\0'; 56
printLine ( dest ); 58
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",704,1
178330,"void CWE194_Unexpected_Sign_Extension__fgets_memmove_66b_badSink(short dataArray[]) 24
char source [ 100 ] ; 29
memset ( source , 'A' , 100 - 1 ); 31
source [ 100 - 1 ] = '\0'; 32
memmove ( dest , source , data ); 37
dest [ data ] = '\0'; 38
printLine ( dest ); 40
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",704,1
9264,"void CWE134_Uncontrolled_Format_String__wchar_t_environment_fprintf_16_bad() 34
wchar_t * data ; 36
wchar_t dataBuffer [ 100 ] = L """" 37
data = dataBuffer; 38
while ( 1 )  39
size_t dataLen = wcslen ( data ) ; 43
wchar_t * environment = GETENV ( ENV_VARIABLE ) ; 44
if ( environment != NULL )  46
wcsncat ( data + dataLen , environment , 100 - dataLen - 1 ); 49
fwprintf ( stdout , data ); 57",74,1
161922,"void CWE590_Free_Memory_Not_on_Heap__free_int64_t_static_15_bad() 23
int64_t * data ; 25
data = NULL; 26
switch ( 6 )  27
static int64_t dataBuffer [ 100 ] ; 32
size_t i ; 34
for (i = 0; i < 100; i++) 35
dataBuffer [ i ] = 5L L 37
data = dataBuffer; 40
free ( data ); 50",404,1
128732,"void bad() 26
char * data ; 28
data = NULL; 29
data = new char [ 50 ]; 31
data [ 0 ] = '\0'; 32
char source [ 100 ] ; 34
memset ( source , 'C' , 100 - 1 ); 35
source [ 100 - 1 ] = '\0'; 36
memmove ( data , source , 100 * sizeof ( char ) ); 38
data [ 100 - 1 ] = '\0'; 39
printLine ( data ); 40
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14
delete [ ] data 41",119,1
130957,"void CWE124_Buffer_Underwrite__char_alloca_memmove_53_bad() 26
char * data ; 28
char * dataBuffer = ( char * ) ALLOCA ( 100 * sizeof ( char ) ) ; 29
memset ( dataBuffer , 'A' , 100 - 1 ); 30
dataBuffer [ 100 - 1 ] = '\0'; 31
data = dataBuffer - 8; 33
CWE124_Buffer_Underwrite__char_alloca_memmove_53b_badSink ( data ); 34
void CWE124_Buffer_Underwrite__char_alloca_memmove_53b_badSink(char * data) 28
CWE124_Buffer_Underwrite__char_alloca_memmove_53c_badSink ( data ); 30
void CWE124_Buffer_Underwrite__char_alloca_memmove_53c_badSink(char * data) 28
CWE124_Buffer_Underwrite__char_alloca_memmove_53d_badSink ( data ); 30
void CWE124_Buffer_Underwrite__char_alloca_memmove_53d_badSink(char * data) 25
char source [ 100 ] ; 28
memset ( source , 'C' , 100 - 1 ); 29
source [ 100 - 1 ] = '\0'; 30
memmove ( data , source , 100 * sizeof ( char ) ); 32
data [ 100 - 1 ] = '\0'; 34
printLine ( data ); 35
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",119,1
49674,"void CWE590_Free_Memory_Not_on_Heap__free_struct_static_02_bad() 23
twoIntsStruct * data ; 25
data = NULL; 26
if ( 1 )  27
static twoIntsStruct dataBuffer [ 100 ] ; 31
size_t i ; 33
for (i = 0; i < 100; i++) 34
dataBuffer [ i ] . intOne = 1; 36
dataBuffer [ i ] . intTwo = 1; 37
data = dataBuffer; 40
free ( data ); 45",404,1
78573,"void CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_ncat_21_bad() 37
wchar_t * data ; 39
data = ( wchar_t * ) malloc ( 100 * sizeof ( wchar_t ) ); 40
data = badSource ( data ); 42
static wchar_t * badSource(wchar_t * data) 26
if ( badStatic )  28
wmemset ( data , L 'A' , 100 - 1 )
data [ 100 - 1 ] = L '\0' 32
return data ; 34
wchar_t dest [ 50 ] = L """" 44
wcsncat ( dest , data , wcslen ( data ) ); 46",119,1
44371,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncat_09_bad() 23
char * data ; 25
char dataBadBuffer [ 50 ] ; 26
if ( GLOBAL_CONST_TRUE )  28
data = dataBadBuffer; 32
data [ 0 ] = '\0'; 33
char source [ 100 ] ; 36
memset ( source , 'C' , 100 - 1 ); 37
source [ 100 - 1 ] = '\0'; 38
strncat ( data , source , 100 ); 40
printLine ( data ); 41
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",119,1
58082,"void CWE416_Use_After_Free__malloc_free_struct_14_bad() 24
twoIntsStruct * data ; 26
if ( globalFive == 5 )  29
data = ( twoIntsStruct * ) malloc ( 100 * sizeof ( twoIntsStruct ) ); 31
data [ i ] . intOne = 1; 36
data [ i ] . intTwo = 2; 37
free ( data ); 41
printStructLine ( & data [ 0 ] ); 46
void printStructLine (const twoIntsStruct * structTwoIntsStruct) 86
printf ( ""%d -- %d\n"" , structTwoIntsStruct -> intOne , structTwoIntsStruct -> intTwo ); 88",119,1
99821,"void *stonesoup_print_data (void *data) 257
struct stonesoup_data * ssD = ( struct stonesoup_data * ) data ; 258
struct stonesoup_queue * ssQ = get_instance ( ssD -> file2 ) ; 259
struct stonesoup_queue *get_instance (char* file2) 235
static struct stonesoup_queue * ssQ = NULL ; 236
if ( ssQ == NULL )  240
ssQ = ( struct stonesoup_queue * ) calloc ( 1 , sizeof ( struct stonesoup_queue ) ); 244
ssQ -> size = 0; 248
ssQ -> capacity = 30; 249
ssQ -> head = NULL; 250
ssQ -> tail = NULL; 251
return ssQ ; 255
int i ; 260
while ( ( i = dequeue ( ssQ ) ) != - 1 )  264
int dequeue(struct stonesoup_queue *ssQ) 211
if ( ssQ != NULL )  213
struct stonesoup_list * elem ; 214
elem = ssQ -> head; 219
ssQ -> head = elem -> next; 220
if ( ssQ -> head != NULL )  221
ssQ -> tail = NULL; 225
ssQ -> size --; 228
pthread_mutex_unlock ( & ( ssQ -> lock ) ); 230",662,1
164656,"void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_connect_socket_16_bad() 46
char * data ; 48
data = ( char * ) malloc ( 100 * sizeof ( char ) ); 49
data [ 0 ] = '\0'; 50
WSADATA wsaData ; 53
int recvResult ; 56
struct sockaddr_in service ; 57
size_t dataLen = strlen ( data ) ; 60
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  64
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 71
if ( connectSocket == INVALID_SOCKET )  72
memset ( & service , 0 , sizeof ( service ) ); 76
service . sin_family = AF_INET; 77
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS ); 78
service . sin_port = htons ( TCP_PORT ); 79
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  80
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ); 87
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  88
data [ dataLen + recvResult / sizeof ( char ) ] = '\0'; 93
replace = strchr ( data , '\r' ); 95
if ( replace )  96
* replace = '\0'; 98
replace = strchr ( data , '\n' ); 100
if ( replace )  101
* replace = '\0'; 103
while ( 0 )  106
for (; *data != '\0'; data++) 122
if ( * data == SEARCH_CHAR )  124
free ( data ); 130",404,1
142553,"void henneries_swirled(struct agpaitic_aldolization microtitration_suling) 1349
int stonesoup_buff_size = 63 ; 1353
int stonesoup_taint_len ; 1354
wangler_ladinos = ( ( char * ) microtitration_suling . endosteoma_maudlinize ); 1357
stonesoup_data = ( struct stonesoup_struct * ) malloc ( sizeof ( struct stonesoup_struct ) ); 1361
if ( stonesoup_data != NULL )  1362
stonesoup_data -> before = stonesoup_toupper; 1363
memset ( stonesoup_data -> buffer , 'A' , 64 ); 1364
stonesoup_data -> buffer [ 63 ] = '\0'; 1365
stonesoup_data -> after = stonesoup_toupper; 1366
stonesoup_taint_len = ( ( int ) ( strlen ( wangler_ladinos ) ) ); 1372
for (; stonesoup_taint_len >= 0; (--stonesoup_buff_size , --stonesoup_taint_len)) 1375
stonesoup_data -> buffer [ stonesoup_buff_size ] = wangler_ladinos [ stonesoup_taint_len ]; 1376
for (stonesoup_i = 0; stonesoup_i < 64; ++stonesoup_i) 1379
stonesoup_data -> buffer [ stonesoup_i ] = stonesoup_toupper ( stonesoup_data -> buffer [ stonesoup_i ] ); 1380
int stonesoup_toupper(int c) 167
if ( c >= 97 && c <= 122 )  169
return c - 32 ; 170
return c ; 172
free ( stonesoup_data ); 1386",119,1
142041,"void CWE194_Unexpected_Sign_Extension__connect_socket_strncpy_15_bad() 44
short data ; 46
data = 0; 48
switch ( 6 )  49
WSADATA wsaData ; 54
int recvResult ; 57
int tempInt ; 58
struct sockaddr_in service ; 59
char inputBuffer [ CHAR_ARRAY_SIZE ] ; 61
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  65
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 71
if ( connectSocket == INVALID_SOCKET )  72
memset ( & service , 0 , sizeof ( service ) ); 76
service . sin_family = AF_INET; 77
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS ); 78
service . sin_port = htons ( TCP_PORT ); 79
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  80
recvResult = recv ( connectSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 ); 87
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  88
inputBuffer [ recvResult ] = '\0'; 93
tempInt = atoi ( inputBuffer ); 96
if ( tempInt > SHRT_MAX || tempInt < SHRT_MIN )  97
data = - 1; 99
data = tempInt; 103
while ( 0 )  106
char source [ 100 ] ; 125
char dest [ 100 ] = """" ; 126
memset ( source , 'A' , 100 - 1 ); 127
source [ 100 - 1 ] = '\0'; 128
if ( data < 100 )  129
strncpy ( dest , source , data ); 133
dest [ data ] = '\0'; 134
printLine ( dest ); 136
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",704,1
35937,"void CWE78_OS_Command_Injection__char_listen_socket_system_01_bad() 56
char * data ; 58
char data_buf [ 100 ] = FULL_COMMAND ; 59
data = data_buf; 60
size_t dataLen = strlen ( data ) ; 71
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ); 105
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  106
data [ dataLen + recvResult / sizeof ( char ) ] = '\0'; 111
replace = strchr ( data , '\r' ); 113
if ( replace )  114
* replace = '\0'; 116
replace = strchr ( data , '\n' ); 118
if ( replace )  119
* replace = '\0'; 121
if ( SYSTEM ( data ) <= 0 )  141",74,1
82000,"void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_memmove_61_bad() 26
char * data ; 28
data = NULL; 29
data = CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_memmove_61b_badSource ( data ); 30
char * CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_memmove_61b_badSource(char * data) 23
data = ( char * ) malloc ( 50 * sizeof ( char ) ); 26
data [ 0 ] = '\0'; 27
return data ; 28
char source [ 100 ] ; 32
memset ( source , 'C' , 100 - 1 ); 33
source [ 100 - 1 ] = '\0'; 34
memmove ( data , source , 100 * sizeof ( char ) ); 36
data [ 100 - 1 ] = '\0'; 37
printLine ( data ); 38
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14
free ( data ); 39",119,1
144460,"void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_connect_socket_17_bad() 46
char * data ; 49
data = ( char * ) malloc ( 100 * sizeof ( char ) ); 50
data [ 0 ] = '\0'; 51
size_t dataLen = strlen ( data ) ; 61
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ); 88
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  89
data [ dataLen + recvResult / sizeof ( char ) ] = '\0'; 94
replace = strchr ( data , '\r' ); 96
if ( replace )  97
* replace = '\0'; 99
replace = strchr ( data , '\n' ); 101
if ( replace )  102
* replace = '\0'; 104
for (; *data != '\0'; data++) 123
if ( * data == SEARCH_CHAR )  125
free ( data ); 131",404,1
64117,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncpy_10_bad() 23
wchar_t * data ; 25
wchar_t * dataBadBuffer = ( wchar_t * ) ALLOCA ( 50 * sizeof ( wchar_t ) ) ; 26
if ( globalTrue )  28
data = dataBadBuffer; 32
data [ 0 ] = L '\0' 33
wchar_t source [ 100 ] ; 36
wmemset ( source , L 'C' , 100 - 1 )
source [ 100 - 1 ] = L '\0' 38
wcsncpy ( data , source , 100 - 1 ); 40
printWLine ( data ); 42
void printWLine (const wchar_t * line) 18
if ( line != NULL )  20
wprintf ( L ""%ls\n"" , line ) 22",119,1
160120,"void CWE506_Embedded_Malicious_Code__w32_base64_encoded_payload_18_bad() 26
char * encodedPayload = ""Y2FsYy5leGU="" ; 32
DWORD requiredLength ; 34
if ( ! CryptStringToBinaryA ( encodedPayload , strlen ( encodedPayload ) , CRYPT_STRING_BASE64 , NULL , & requiredLength , NULL , NULL ) )  38
decodedPayload = ( BYTE * ) malloc ( requiredLength + 1 ); 49
if ( decodedPayload == NULL )  50
if ( ! CryptStringToBinaryA ( encodedPayload , strlen ( encodedPayload ) , CRYPT_STRING_BASE64 , decodedPayload , & requiredLength , NULL , NULL ) )  55
decodedPayload [ requiredLength ] = '\0'; 66
if ( system ( ( char * ) decodedPayload ) <= 0 )  67
while ( 0 )  73
free ( decodedPayload ); 74",506,1
169662,"void CWE134_Uncontrolled_Format_String__wchar_t_environment_vfprintf_12_bad() 57
wchar_t * data ; 59
wchar_t dataBuffer [ 100 ] = L """" 60
data = dataBuffer; 61
if ( globalReturnsTrueOrFalse ( ) )  62
int globalReturnsTrueOrFalse() 157
return ( rand ( ) % 2 ) ; 159
size_t dataLen = wcslen ( data ) ; 66
wcsncat ( data + dataLen , environment , 100 - dataLen - 1 ); 72
wcscpy ( data , L ""fixedstringtest"" ) 79
badVaSinkB ( data , data ); 83
static void badVaSinkB(wchar_t * data, ...) 35
va_start ( args , data ); 39
vfwprintf ( stdout , data , args ); 41
badVaSinkG ( data , data ); 87
static void badVaSinkG(wchar_t * data, ...) 46
va_start ( args , data ); 50",74,1
3563,"void bad() 40
char * data ; 42
unionType myUnion ; 43
char dataBuffer [ FILENAME_MAX ] = """" ; 44
data = dataBuffer; 45
size_t dataLen = strlen ( data ) ; 48
if ( FILENAME_MAX - dataLen > 1 )  50
if ( fgets ( data + dataLen , ( int ) ( FILENAME_MAX - dataLen ) , stdin ) != NULL )  53
data [ dataLen ] = '\0'; 67
myUnion . unionFirst = data; 71
char * data = myUnion . unionSecond ; 73
pFile = FOPEN ( data , ""wb+"" ); 77
if ( pFile != NULL )  78
fclose ( pFile ); 80",706,1
157189,"void tile_manager_get_tile_coordinates(TileManager *tm,Tile *tile,gint *x,gint *y) 678
char * scrumpy_gavia ; 698
if ( __sync_bool_compare_and_swap ( & multiservice_aestivating , 0 , 1 ) )  701
if ( mkdir ( ""/opt/stonesoup/workspace/lockDir"" , 509U ) == 0 )  702
scrumpy_gavia = getenv ( ""ADJOURNING_MALLIA"" ); 705
if ( scrumpy_gavia != 0 )  706
hangnests_evenlong = ( ( void * ) scrumpy_gavia ); 707
hemiscotosis_asthenophobia = & hangnests_evenlong; 709
whaup_chait = ( ( void * * ) ( ( ( unsigned long ) hemiscotosis_asthenophobia ) * fibrinopurulent_penduline * fibrinopurulent_penduline ) ) + 5; 710
titillability_superpowerful = ( ( char * ) ( ( char * ) ( * ( whaup_chait - 5 ) ) ) ); 720
snprintf ( query , 1000 , ""INSERT INTO shippers (shipperid, companyname) VALUES ('%d', '%s');"" , stonesoup_random_int , titillability_superpowerful ); 746
tracepoint ( stonesoup_trace , variable_buffer , ""query"" , query , ""CROSSOVER-STATE"" ); 747
res = PQexec ( conn , query ); 751
if ( PQresultStatus ( res ) != PGRES_COMMAND_OK )  752
PQclear ( res ); 755
stonesoup_result = PQcmdTuples ( res ); 761
stonesoup_printf ( ""Query OK, %s rows affected\n"" , stonesoup_result ); 762
void stonesoup_printf(char * format, ...) 75
va_start ( argptr , format ); 77
vfprintf ( stonesoup_printf_context , format , argptr ); 78
PQclear ( res ); 763",74,1
116699,"void CWE114_Process_Control__w32_char_file_07_bad() 37
char * data ; 39
char dataBuffer [ 100 ] = """" ; 40
data = dataBuffer; 41
if ( staticFive == 5 )  42
size_t dataLen = strlen ( data ) ; 46
FILE * pFile ; 47
if ( 100 - dataLen > 1 )  49
pFile = fopen ( FILENAME , ""r"" ); 51
if ( pFile != NULL )  52
if ( fgets ( data + dataLen , ( int ) ( 100 - dataLen ) , pFile ) == NULL )  55
data [ dataLen ] = '\0'; 59
fclose ( pFile ); 61
hModule = LoadLibraryA ( data ); 70
if ( hModule != NULL )  71
FreeLibrary ( hModule ); 73",20,1
44279,"void initlinedraw(int flag) 516
int stonesoup_buff_size ; 522
char * reactive_monohydric ; 524
if ( __sync_bool_compare_and_swap ( & mismarks_magneoptic , 0 , 1 ) )  542
if ( mkdir ( ""/opt/stonesoup/workspace/lockDir"" , 509U ) == 0 )  543
reactive_monohydric = getenv ( ""PUSHFUL_CHASTY"" ); 546
if ( reactive_monohydric != 0 )  547
lornnesses_unworkmanlike = ( ( char * ) reactive_monohydric ); 548
stonesoup_buff_size = ( ( int ) ( strlen ( lornnesses_unworkmanlike ) ) ); 555
for (; stonesoup_buff_size >= 0; (--stonesoup_my_buff_size , --stonesoup_buff_size)) 560
stonesoup_stack_buff_64 [ stonesoup_my_buff_size ] = lornnesses_unworkmanlike [ stonesoup_buff_size ]; 563
tracepoint ( stonesoup_trace , variable_buffer , ""stonesoup_stack_buff_64"" , stonesoup_stack_buff_64 , ""CROSSOVER-STATE"" ); 565
stonesoup_stack_buff_64 [ stonesoup_oc_i ] = stonesoup_toupper ( stonesoup_stack_buff_64 [ stonesoup_oc_i ] ); 567
int stonesoup_toupper(int c) 129
if ( c >= 97 && c <= 122 )  131
return c - 32 ; 132
return c ; 134
stonesoup_printf ( ""%s\n"" , stonesoup_stack_buff_64 ); 571
void stonesoup_printf(char * format, ...) 116
va_start ( argptr , format ); 118
vfprintf ( stonesoup_printf_context , format , argptr ); 119
tracepoint ( stonesoup_trace , variable_signed_integral , ""stonesoup_oc_i"" , stonesoup_oc_i , & stonesoup_oc_i , ""FINAL-STATE"" ); 574
tracepoint ( stonesoup_trace , variable_buffer , ""stonesoup_stack_buff_64"" , stonesoup_stack_buff_64 , ""FINAL-STATE"" ); 575",119,1
99750,"void CWE127_Buffer_Underread__wchar_t_alloca_cpy_10_bad() 23
wchar_t * data ; 25
wchar_t * dataBuffer = ( wchar_t * ) ALLOCA ( 100 * sizeof ( wchar_t ) ) ; 26
wmemset ( dataBuffer , L 'A' , 100 - 1 )
dataBuffer [ 100 - 1 ] = L '\0' 28
if ( globalTrue )  29
data = dataBuffer - 8; 32
wchar_t dest [ 100 * 2 ] ; 35
wmemset ( dest , L 'C' , 100 * 2 - 1 )
dest [ 100 * 2 - 1 ] = L '\0' 37
wcscpy ( dest , data ); 39
printWLine ( dest ); 40
void printWLine (const wchar_t * line) 18
if ( line != NULL )  20
wprintf ( L ""%ls\n"" , line ) 22",119,1
153697,"void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_loop_11_bad() 23
wchar_t * data ; 25
data = NULL; 26
if ( globalReturnsTrue ( ) )  27
int globalReturnsTrue() 147
return 1 ; 149
data = ( wchar_t * ) malloc ( 50 * sizeof ( wchar_t ) ); 30
data [ 0 ] = L '\0' 31
size_t i ; 34
wchar_t source [ 100 ] ; 35
wmemset ( source , L 'C' , 100 - 1 )
source [ 100 - 1 ] = L '\0' 37
for (i = 0; i < 100; i++) 39
data [ i ] = source [ i ]; 41
data [ 100 - 1 ] = L '\0' 43
free ( data ); 45",119,1
105647,"void CWE114_Process_Control__w32_wchar_t_console_34_bad() 31
wchar_t * data ; 33
CWE114_Process_Control__w32_wchar_t_console_34_unionType myUnion ; 34
wchar_t dataBuffer [ 100 ] = L """" 35
data = dataBuffer; 36
size_t dataLen = wcslen ( data ) ; 39
if ( 100 - dataLen > 1 )  41
if ( fgetws ( data + dataLen , ( int ) ( 100 - dataLen ) , stdin ) != NULL )  44
data [ dataLen - 1 ] = L '\0' 51
data [ dataLen ] = L '\0' 58
myUnion . unionFirst = data; 62
wchar_t * data = myUnion . unionSecond ; 64
HMODULE hModule ; 66
hModule = LoadLibraryW ( data ); 69
if ( hModule != NULL )  70
FreeLibrary ( hModule ); 72",20,1
150127,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_52c_badSink(char * data) 25
char source [ 100 ] ; 29
memset ( source , 'C' , 100 - 1 ); 30
source [ 100 - 1 ] = '\0'; 31
data [ i ] = source [ i ]; 35
data [ 100 - 1 ] = '\0'; 37
printLine ( data ); 38
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",119,1
103957,"void CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_environment_67_bad() 41
wchar_t * data ; 43
CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_environment_67_structType myStruct ; 44
data = ( wchar_t * ) malloc ( 100 * sizeof ( wchar_t ) ); 45
data [ 0 ] = L '\0' 46
size_t dataLen = wcslen ( data ) ; 49
wchar_t * environment = GETENV ( ENV_VARIABLE ) ; 50
if ( environment != NULL )  52
wcsncat ( data + dataLen , environment , 100 - dataLen - 1 ); 55
myStruct . structFirst = data; 58
CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_environment_67b_badSink ( myStruct ); 59
void CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_environment_67b_badSink(CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_environment_67_structType myStruct) 38
wchar_t * data = myStruct . structFirst ; 40
free ( data ); 51",404,1
61634,"void bad() 39
wchar_t * data ; 41
structType myStruct ; 42
data = NULL; 43
data = new wchar_t [ 10 ]; 45
myStruct . structFirst = data; 46
badSink ( myStruct ); 47
void badSink(structType myStruct) 36
wchar_t * data = myStruct . structFirst ; 38
wchar_t source [ 10 + 1 ] = SRC_STRING ; 40
memmove ( data , source , ( wcslen ( source ) + 1 ) * sizeof ( wchar_t ) ); 43
printWLine ( data ); 44
void printWLine (const wchar_t * line) 18
if ( line != NULL )  20
wprintf ( L ""%ls\n"" , line ) 22
delete [ ] data 45",119,1
144210,"void CWE127_Buffer_Underread__char_declare_memcpy_15_bad() 23
char dataBuffer [ 100 ] ; 26
memset ( dataBuffer , 'A' , 100 - 1 ); 27
dataBuffer [ 100 - 1 ] = '\0'; 28
data = dataBuffer - 8; 33
memcpy ( dest , data , 100 * sizeof ( char ) ); 45
dest [ 100 - 1 ] = '\0'; 47
printLine ( dest ); 48
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",119,1
181015,"void bad() 31
char * data ; 33
data = ( char * ) malloc ( 100 * sizeof ( char ) ); 34
data [ 0 ] = '\0'; 35
badSource ( data ); 36
void badSource(char * &data) 28
strcpy ( data , BAD_SOURCE_FIXED_STRING ); 31
for (; *data != '\0'; data++) 39
if ( * data == SEARCH_CHAR )  41
free ( data ); 47",404,1
121,"void CWE124_Buffer_Underwrite__CWE839_fgets_32_bad() 24
char inputBuffer [ CHAR_ARRAY_SIZE ] = """" ; 34
if ( fgets ( inputBuffer , CHAR_ARRAY_SIZE , stdin ) != NULL )  36
data = atoi ( inputBuffer ); 39
* dataPtr1 = data; 46
if ( data < 10 )  55
buffer [ data ] = 1; 57
printIntLine ( buffer [ i ] ); 61
void printIntLine (int intNumber) 26
printf ( ""%d\n"" , intNumber ); 28",119,1
13914,"void CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cat_31_bad() 23
wchar_t * data ; 25
wchar_t dataBadBuffer [ 50 ] ; 26
data = dataBadBuffer; 30
data [ 0 ] = L '\0' 31
wchar_t * dataCopy = data ; 33
wchar_t * data = dataCopy ; 34
wchar_t source [ 100 ] ; 36
wmemset ( source , L 'C' , 100 - 1 )
source [ 100 - 1 ] = L '\0' 38
wcscat ( data , source ); 40",119,1
24660,"void CWE194_Unexpected_Sign_Extension__connect_socket_malloc_66_bad() 47
short data ; 49
short dataArray [ 5 ] ; 50
data = 0; 52
WSADATA wsaData ; 55
int recvResult ; 58
int tempInt ; 59
struct sockaddr_in service ; 60
char inputBuffer [ CHAR_ARRAY_SIZE ] ; 62
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  66
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 72
if ( connectSocket == INVALID_SOCKET )  73
memset ( & service , 0 , sizeof ( service ) ); 77
service . sin_family = AF_INET; 78
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS ); 79
service . sin_port = htons ( TCP_PORT ); 80
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  81
recvResult = recv ( connectSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 ); 88
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  89
inputBuffer [ recvResult ] = '\0'; 94
tempInt = atoi ( inputBuffer ); 97
if ( tempInt > SHRT_MAX || tempInt < SHRT_MIN )  98
data = - 1; 100
data = tempInt; 104
while ( 0 )  107
dataArray [ 2 ] = data; 120
CWE194_Unexpected_Sign_Extension__connect_socket_malloc_66b_badSink ( dataArray ); 121
void CWE194_Unexpected_Sign_Extension__connect_socket_malloc_66b_badSink(short dataArray[]) 44
short data = dataArray [ 2 ] ; 47
if ( data < 100 )  49
char * dataBuffer = ( char * ) malloc ( data ) ; 53
memset ( dataBuffer , 'A' , data - 1 ); 55
dataBuffer [ data - 1 ] = '\0'; 56
printLine ( dataBuffer ); 57
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14
free ( dataBuffer ); 58",704,1
43844,"void bad() 26
char * data ; 28
data = new char [ 100 ]; 29
memset ( data , 'A' , 100 - 1 ); 33
data [ 100 - 1 ] = '\0'; 34
memcpy ( dest , data , strlen ( data ) * sizeof ( char ) ); 38
dest [ 50 - 1 ] = '\0'; 39
printLine ( data ); 40
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14
delete [ ] data 41",119,1
21973,"void darnex_initiatorily(void *precritical_dasya) 2105
char * stonesoup_contents ; 2107
char stonesoup_filename [ 80 ] ; 2108
FILE * stonesoup_file ; 2109
FILE * * stonesoup_file_list ; 2110
FILE * stonesoup_files ; 2111
int stonesoup_str_list_index ; 2112
char * * stonesoup_str_list ; 2113
int stonesoup_num_files = 10 ; 2114
int stonesoup_size ; 2115
joked_acrita = ( ( char * ) ( ( char * ) precritical_dasya ) ); 2119
stonesoup_str_list = malloc ( sizeof ( char * ) * stonesoup_num_files ); 2121
if ( stonesoup_str_list != 0 )  2122
for (stonesoup_str_list_index = 0; stonesoup_str_list_index < stonesoup_num_files; ++stonesoup_str_list_index) 2123
stonesoup_str_list [ stonesoup_str_list_index ] = 0; 2124
stonesoup_files = fopen ( joked_acrita , ""rb"" ); 2125
if ( stonesoup_files != 0 )  2126
stonesoup_file_list = malloc ( stonesoup_num_files * sizeof ( FILE * ) ); 2127
for (stonesoup_ssi = 0; stonesoup_ssi < stonesoup_num_files; ++stonesoup_ssi) 2132
if ( fscanf ( stonesoup_files , ""%79s"" , stonesoup_filename ) == 1 )  2133
stonesoup_file_list [ stonesoup_ssi ] = fopen ( stonesoup_filename , ""rb"" ); 2134
stonesoup_ssi = 0; 2137
while ( stonesoup_ssi < stonesoup_num_files )  2138
stonesoup_file = stonesoup_file_list [ stonesoup_ssi ]; 2139
if ( stonesoup_file == 0 )  2140
stonesoup_size = ftell ( stonesoup_file ); 2145
stonesoup_contents = malloc ( ( stonesoup_size + 1 ) * sizeof ( char ) ); 2147
if ( stonesoup_contents == 0 )  2154
memset ( stonesoup_contents , 0 , ( stonesoup_size + 1 ) * sizeof ( char ) ); 2159
stonesoup_contents = stonesoup_isAlphaNum ( stonesoup_contents , stonesoup_size ); 2162
char *stonesoup_isAlphaNum(char *str,int size_param) 158
for (index = 0; index < size_param; index++) 162
if ( ! stonesoup_isalnum ( str [ index ] ) )  163
int stonesoup_isalnum(int c) 151
if ( ( c >= 97 && c <= 122 ) || ( c >= 65 && c <= 90 ) || ( c >= 48 && c <= 57 ) )  153
return 1 ; 154
return 0 ; 156
return 0 ; 166
return str ; 169
stonesoup_str_list [ stonesoup_ssi ] = stonesoup_contents; 2164
fclose ( stonesoup_file ); 2165
stonesoup_ssi ++; 2166",400,1
73014,"void CWE126_Buffer_Overread__malloc_wchar_t_memmove_51_bad() 26
wchar_t * data ; 28
data = NULL; 29
data = ( wchar_t * ) malloc ( 50 * sizeof ( wchar_t ) ); 31
wmemset ( data , L 'A' , 50 - 1 )
data [ 50 - 1 ] = L '\0' 33
CWE126_Buffer_Overread__malloc_wchar_t_memmove_51b_badSink ( data ); 34
void CWE126_Buffer_Overread__malloc_wchar_t_memmove_51b_badSink(wchar_t * data) 25
wchar_t dest [ 100 ] ; 28
wmemset ( dest , L 'C' , 100 - 1 )
dest [ 100 - 1 ] = L '\0' 30
memmove ( dest , data , wcslen ( dest ) * sizeof ( wchar_t ) ); 33
printWLine ( dest ); 35
void printWLine (const wchar_t * line) 18
if ( line != NULL )  20
wprintf ( L ""%ls\n"" , line ) 22",119,1
174329,"void CWE134_Uncontrolled_Format_String__char_file_vprintf_05_bad() 50
char * data ; 52
char dataBuffer [ 100 ] = """" ; 53
data = dataBuffer; 54
if ( staticTrue )  55
size_t dataLen = strlen ( data ) ; 59
FILE * pFile ; 60
if ( 100 - dataLen > 1 )  62
pFile = fopen ( FILENAME , ""r"" ); 64
if ( pFile != NULL )  65
if ( fgets ( data + dataLen , ( int ) ( 100 - dataLen ) , pFile ) == NULL )  68
data [ dataLen ] = '\0'; 72
fclose ( pFile ); 74
badVaSinkB ( data , data ); 81
static void badVaSinkB(char * data, ...) 39
va_start ( args , data ); 43
vprintf ( data , args ); 45",74,1
105245,"void bad() 52
int i ; 54
char * data ; 55
char dataBuffer [ FILENAME_MAX ] = """" ; 56
data = dataBuffer; 57
for(i = 0; i < 1; i++) 58
WSADATA wsaData ; 62
int recvResult ; 65
struct sockaddr_in service ; 66
size_t dataLen = strlen ( data ) ; 69
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  73
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 80
if ( connectSocket == INVALID_SOCKET )  81
memset ( & service , 0 , sizeof ( service ) ); 85
service . sin_family = AF_INET; 86
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS ); 87
service . sin_port = htons ( TCP_PORT ); 88
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  89
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ); 96
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  97
data [ dataLen + recvResult / sizeof ( char ) ] = '\0'; 102
replace = strchr ( data , '\r' ); 104
if ( replace )  105
* replace = '\0'; 107
replace = strchr ( data , '\n' ); 109
if ( replace )  110
* replace = '\0'; 112
while ( 0 )  115
outputFile . open ( ( char * ) data ); 131",706,1
7751,"void bad() 66
char * data ; 68
char dataBuffer [ FILENAME_MAX ] = BASEPATH ; 70
data = dataBuffer; 71
size_t dataLen = strlen ( data ) ; 82
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ); 116
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  117
data [ dataLen + recvResult / sizeof ( char ) ] = '\0'; 122
replace = strchr ( data , '\r' ); 124
if ( replace )  125
* replace = '\0'; 127
replace = strchr ( data , '\n' ); 129
if ( replace )  130
* replace = '\0'; 132
myUnion . unionFirst = data; 151
char * data = myUnion . unionSecond ; 153
fileDesc = OPEN ( data , O_RDWR | O_CREAT , S_IREAD | S_IWRITE ); 157
if ( fileDesc != - 1 )  158
CLOSE ( fileDesc ); 160",706,1
144096,"void CWE400_Resource_Exhaustion__fgets_for_loop_12_bad() 24
if ( globalReturnsTrueOrFalse ( ) )  29
int globalReturnsTrueOrFalse() 157
return ( rand ( ) % 2 ) ; 159
char inputBuffer [ CHAR_ARRAY_SIZE ] = """" ; 32
if ( fgets ( inputBuffer , CHAR_ARRAY_SIZE , stdin ) != NULL )  34
count = atoi ( inputBuffer ); 37
for (i = 0; i < (size_t)count; i++) 55
if ( count > 0 && count <= 20 )  66
for (i = 0; i < (size_t)count; i++) 68",400,1
145768,"void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fgets_66_bad() 27
int data ; 29
int dataArray [ 5 ] ; 30
data = - 1; 32
char inputBuffer [ CHAR_ARRAY_SIZE ] = """" ; 34
if ( fgets ( inputBuffer , CHAR_ARRAY_SIZE , stdin ) != NULL )  36
data = atoi ( inputBuffer ); 39
dataArray [ 2 ] = data; 47
CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fgets_66b_badSink ( dataArray ); 48
void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fgets_66b_badSink(int dataArray[]) 24
int data = dataArray [ 2 ] ; 27
int i ; 29
int * buffer = ( int * ) malloc ( 10 * sizeof ( int ) ) ; 30
for (i = 0; i < 10; i++) 32
buffer [ i ] = 0; 34
if ( data >= 0 )  38
buffer [ data ] = 1; 40
free ( buffer ); 51",119,1
