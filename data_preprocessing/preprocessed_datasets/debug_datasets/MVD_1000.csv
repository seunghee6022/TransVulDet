,code,cwe_id,vul
137125,"static void goodG2B() 56
char * password ; 58
password = ( char * ) malloc ( 100 * sizeof ( char ) ); 62
if ( password == NULL )  63
if ( ! VirtualLock ( password , 100 * sizeof ( char ) ) )  69
strcpy ( password , ""Password1234!"" ); 75
passwordArray [ 2 ] = password; 76
CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_66b_goodG2BSink ( passwordArray ); 77
void CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_66b_goodG2BSink(char * passwordArray[]) 60
char * password = passwordArray [ 2 ] ; 62
if ( LogonUserA ( username , domain , password , LOGON32_LOGON_NETWORK , LOGON32_PROVIDER_DEFAULT , & pHandle ) != 0 )  68
free ( password ); 84",0,0
77689,"void CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_54_bad() 47
WSADATA wsaData ; 54
int recvResult ; 57
struct sockaddr_in service ; 59
char inputBuffer [ CHAR_ARRAY_SIZE ] ; 62
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  66
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 72
if ( listenSocket == INVALID_SOCKET )  73
memset ( & service , 0 , sizeof ( service ) ); 77
service . sin_family = AF_INET; 78
service . sin_addr . s_addr = INADDR_ANY; 79
service . sin_port = htons ( TCP_PORT ); 80
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  81
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )  85
acceptSocket = accept ( listenSocket , NULL , NULL ); 89
if ( acceptSocket == SOCKET_ERROR )  90
recvResult = recv ( acceptSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 ); 95
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  97
inputBuffer [ recvResult ] = '\0'; 102
tempInt = atoi ( inputBuffer ); 105
if ( tempInt > SHRT_MAX || tempInt < SHRT_MIN )  106
data = tempInt; 112
while ( 0 )  115
CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_54b_badSink ( data ); 131
void CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_54b_badSink(short data) 49
CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_54c_badSink ( data ); 51
void CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_54c_badSink(short data) 49
CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_54d_badSink ( data ); 51
void CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_54d_badSink(short data) 49
CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_54e_badSink ( data ); 51
void CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_54e_badSink(short data) 46
if ( data < 100 )  53
memcpy ( dest , source , data ); 57
dest [ data ] = '\0'; 58
printLine ( dest ); 60
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",0,0
159474,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncat_68b_goodG2BSink() 46
wchar_t * data = CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncat_68_goodG2BData ; 48
wchar_t source [ 100 ] ; 50
wmemset ( source , L 'C' , 100 - 1 )
source [ 100 - 1 ] = L '\0' 52
wcsncat ( data , source , 100 ); 54
printWLine ( data ); 55
void printWLine (const wchar_t * line) 18
if ( line != NULL )  20
wprintf ( L ""%ls\n"" , line ) 22",0,0
106162,"char *dfaexec(struct dfa *d,const char *begin,char *end,int allow_nl,size_t *count,int *backref) 3552
unsigned char eol = eolbyte ; 3564
* end = eol; 3573
if ( d -> mb_cur_max > 1 )  3574
inputwcs = ( ( sizeof ( ( * inputwcs ) ) == 1 ? xmalloc ( ( end - begin + 2 ) ) : xnmalloc ( ( end - begin + 2 ) , sizeof ( ( * inputwcs ) ) ) ) ); 3579
while ( 0 )  3580
while ( inputwcs [ p - buf_begin ] == 0 && mblen_buf [ p - buf_begin ] > 0 && ( ( const unsigned char * ) p ) < buf_end )  3592
free ( inputwcs ); 3596
free ( inputwcs ); 3613
free ( inputwcs ); 3643
free ( inputwcs ); 3673",0,0
90109,"void CWE605_Multiple_Binds_Same_Port__basic_10_bad() 44
if ( globalTrue )  46
char data [ 100 ] = """" ; 49
size_t dataLen = strlen ( data ) ; 59
recvResult = recv ( acceptSocket , data + dataLen , ( int ) ( 100 - dataLen - 1 ) , 0 ); 104
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  105
data [ recvResult ] = '\0'; 110
replace = strchr ( data , '\r' ); 112
if ( replace )  113
* replace = '\0'; 115
replace = strchr ( data , '\n' ); 117
if ( replace )  118
* replace = '\0'; 120
printLine ( data ); 138
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",0,0
54342,"static void goodB2G1() 98
char * data ; 100
char dataBuffer [ 100 ] = """" ; 101
data = dataBuffer; 102
switch ( 6 )  103
FILE * pFile ; 107
pFile = fopen ( ""passwords.txt"" , ""r"" ); 108
if ( pFile != NULL )  109
if ( fgets ( data , 100 , pFile ) == NULL )  112
data [ 0 ] = '\0'; 114",0,0
83169,"static void goodG2B2() 100
char * data ; 102
data = NULL; 103
switch ( 6 )  104
char * dataBuffer = new char [ 100 ] ; 108
memset ( dataBuffer , 'A' , 100 - 1 ); 109
dataBuffer [ 100 - 1 ] = '\0'; 110
data = dataBuffer; 112
char dest [ 100 ] ; 121
memset ( dest , 'C' , 100 - 1 ); 122
dest [ 100 - 1 ] = '\0'; 123
memcpy ( dest , data , 100 * sizeof ( char ) ); 125
dest [ 100 - 1 ] = '\0'; 127
printLine ( dest ); 128
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",0,0
158476,"static uint64_t eepro100_read(void *opaque, hwaddr addr,
unsigned size) 1582
EEPRO100State * s = opaque ; 1584
switch ( size )  1586
return eepro100_read1 ( s , addr ) ; 1587
static uint8_t eepro100_read1(EEPRO100State * s, uint32_t addr) 1327
uint8_t val = 0 ; 1329
if ( addr <= sizeof ( s -> mem ) - sizeof ( val ) )  1330
val = s -> mem [ addr ]; 1331
switch ( addr )  1334
val = eepro100_read_command ( s ); 1342
val = eepro100_read_eeprom ( s ); 1352
val = ( uint8_t ) ( eepro100_read_mdi ( s ) >> ( 8 * ( addr & 3 ) ) ); 1358
val = 0; 1362
TRACE ( OTHER , logout ( ""addr=%s val=0x%02x\n"" , regname ( addr ) , val ) ); 1366
static char *regname(uint32_t addr) 648
static char buf [ 32 ] ; 650
if ( addr < PCI_IO_SIZE )  651
const char * r = e100_reg [ addr / 4 ] ; 652
if ( r != 0 )  653
snprintf ( buf , sizeof ( buf ) , ""%s+%u"" , r , addr % 4 ); 654",0,0
55076,"static void goodB2G1() 170
wchar_t * data ; 172
wchar_t dataBuffer [ 100 ] = L """" 173
data = dataBuffer; 174
WSADATA wsaData ; 177
int recvResult ; 180
struct sockaddr_in service ; 181
size_t dataLen = wcslen ( data ) ; 184
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  188
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 195
if ( connectSocket == INVALID_SOCKET )  196
memset ( & service , 0 , sizeof ( service ) ); 200
service . sin_family = AF_INET; 201
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS ); 202
service . sin_port = htons ( TCP_PORT ); 203
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  204
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ); 211
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  212
while ( 0 )  230",0,0
141089,"static void goodG2B() 54
twoIntsStruct * dataBuffer = ( twoIntsStruct * ) malloc ( 100 * sizeof ( twoIntsStruct ) ) ; 60
if ( dataBuffer == NULL )  61
dataBuffer [ i ] . intOne = 1; 70
dataBuffer [ i ] . intTwo = 1; 71
data = dataBuffer; 74
CWE590_Free_Memory_Not_on_Heap__free_struct_static_52b_goodG2BSink ( data ); 76
void CWE590_Free_Memory_Not_on_Heap__free_struct_static_52b_goodG2BSink(twoIntsStruct * data) 41
CWE590_Free_Memory_Not_on_Heap__free_struct_static_52c_goodG2BSink ( data ); 43
void CWE590_Free_Memory_Not_on_Heap__free_struct_static_52c_goodG2BSink(twoIntsStruct * data) 37
printStructLine ( & data [ 0 ] ); 39
void printStructLine (const twoIntsStruct * structTwoIntsStruct) 86
printf ( ""%d -- %d\n"" , structTwoIntsStruct -> intOne , structTwoIntsStruct -> intTwo ); 88
free ( data ); 41",0,0
144051,"void
proto_item_fill_label(field_info *fi, gchar *label_str) 6520
header_field_info * hfinfo ; 6522
if ( ! fi )  6534
hfinfo = fi -> hfinfo; 6541
switch ( hfinfo -> type )  6543
if ( hfinfo -> bitmask )  6627
fill_label_number ( fi , label_str , TRUE ); 6630
static void
fill_label_number(field_info *fi, gchar *label_str, gboolean is_signed) 7017
header_field_info * hfinfo = fi -> hfinfo ; 7019
guint32 value ; 7020
char buf [ 32 ] ; 7022
const char * out ; 7023
if ( is_signed )  7025
value = fvalue_get_sinteger ( & fi -> value ); 7026
value = fvalue_get_uinteger ( & fi -> value ); 7028
if ( hfinfo -> display == BASE_CUSTOM )  7031
if ( hfinfo -> strings && hfinfo -> type != FT_FRAMENUM )  7039
out = hfinfo_number_vals_format ( hfinfo , buf , value ); 7042
if ( IS_BASE_PORT ( hfinfo -> display ) )  7048
out = hfinfo_number_value_format ( hfinfo , buf , value ); 7056
label_fill ( label_str , 0 , hfinfo , out ); 7058
static gsize
label_fill(char *label_str, gsize pos, const header_field_info *hfinfo, const char *text) 6481
gsize name_pos ; 6483
name_pos = pos = label_concat ( label_str , pos , hfinfo -> name ); 6486
pos = label_concat ( label_str , pos , "": "" ); 6487
pos = label_concat ( label_str , pos , text ? text : ""(null)"" ); 6488
if ( pos >= ITEM_LABEL_LENGTH )  6490
label_mark_truncated ( label_str , name_pos ); 6492
static void
label_mark_truncated(char *label_str, gsize name_pos) 6446
static const char trunc_str [ ] = "" [truncated]"" ; 6448
const size_t trunc_len = sizeof ( trunc_str ) - 1 ; 6449
if ( name_pos < ITEM_LABEL_LENGTH - trunc_len )  6461
memmove ( label_str + name_pos + trunc_len , label_str + name_pos , ITEM_LABEL_LENGTH - name_pos - trunc_len ); 6462
memcpy ( label_str + name_pos , trunc_str , trunc_len ); 6463
last_char = g_utf8_prev_char ( & label_str [ ITEM_LABEL_LENGTH ] ); 6473
* last_char = '\0'; 6474
g_strlcpy ( label_str + name_pos , trunc_str , ITEM_LABEL_LENGTH - name_pos ); 6477",0,0
143846,"static void goodG2B1() 60
char * dataGoodBuffer = ( char * ) ALLOCA ( 100 * sizeof ( char ) ) ; 64
memset ( dataGoodBuffer , 'A' , 100 - 1 ); 67
dataGoodBuffer [ 100 - 1 ] = '\0'; 68
data = dataGoodBuffer; 77
memmove ( dest , data , strlen ( dest ) * sizeof ( char ) ); 86
dest [ 100 - 1 ] = '\0'; 87
printLine ( dest ); 88
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",0,0
149831,"void CWE134_Uncontrolled_Format_String__char_environment_snprintf_53_bad() 43
char * data ; 45
char dataBuffer [ 100 ] = """" ; 46
data = dataBuffer; 47
size_t dataLen = strlen ( data ) ; 50
strncat ( data + dataLen , environment , 100 - dataLen - 1 ); 56
CWE134_Uncontrolled_Format_String__char_environment_snprintf_53b_badSink ( data ); 59
void CWE134_Uncontrolled_Format_String__char_environment_snprintf_53b_badSink(char * data) 43
CWE134_Uncontrolled_Format_String__char_environment_snprintf_53c_badSink ( data ); 45
void CWE134_Uncontrolled_Format_String__char_environment_snprintf_53c_badSink(char * data) 43
CWE134_Uncontrolled_Format_String__char_environment_snprintf_53d_badSink ( data ); 45
void CWE134_Uncontrolled_Format_String__char_environment_snprintf_53d_badSink(char * data) 40
SNPRINTF ( dest , 100 - 1 , data ); 45",0,0
65612,"static void goodG2B1() 56
char * data ; 58
data = NULL; 59
data = CWE122_Heap_Based_Buffer_Overflow__c_dest_char_cpy_22_goodG2B1Source ( data ); 61
char * CWE122_Heap_Based_Buffer_Overflow__c_dest_char_cpy_22_goodG2B1Source(char * data) 46
if ( CWE122_Heap_Based_Buffer_Overflow__c_dest_char_cpy_22_goodG2B1Global )  48
data = ( char * ) malloc ( 100 * sizeof ( char ) ); 56
data [ 0 ] = '\0'; 57
return data ; 59
char source [ 100 ] ; 63
memset ( source , 'C' , 100 - 1 ); 64
source [ 100 - 1 ] = '\0'; 65
strcpy ( data , source ); 67
printLine ( data ); 68
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14
free ( data ); 69",0,0
36956,"void CWE78_OS_Command_Injection__char_connect_socket_w32_spawnv_11_bad() 60
char * data ; 62
char dataBuffer [ 100 ] = """" ; 63
data = dataBuffer; 64
if ( globalReturnsTrue ( ) )  65
int globalReturnsTrue() 147
return 1 ; 149
WSADATA wsaData ; 69
int recvResult ; 72
struct sockaddr_in service ; 73
size_t dataLen = strlen ( data ) ; 76
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  80
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 87
if ( connectSocket == INVALID_SOCKET )  88
memset ( & service , 0 , sizeof ( service ) ); 92
service . sin_family = AF_INET; 93
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS ); 94
service . sin_port = htons ( TCP_PORT ); 95
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  96
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ); 103
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  104
data [ dataLen + recvResult / sizeof ( char ) ] = '\0'; 109
replace = strchr ( data , '\r' ); 111
if ( replace )  112
* replace = '\0'; 114
replace = strchr ( data , '\n' ); 116
if ( replace )  117
* replace = '\0'; 119
while ( 0 )  122
if ( connectSocket != INVALID_SOCKET )  123
CLOSE_SOCKET ( connectSocket ); 125",0,0
51290,"char *dfaexec(struct dfa *d,const char *begin,char *end,int allow_nl,size_t *count,int *backref) 3630
state_num s ; 3633
state_num s1 ; 3634
const unsigned char * p ; 3636
state_num * * trans ; 3639
state_num * t ; 3640
unsigned char eol = eolbyte ; 3642
unsigned char saved_end ; 3643
s = s1 = 0; 3647
p = ( ( const unsigned char * ) begin ); 3648
trans = d -> trans; 3649
saved_end = * ( ( unsigned char * ) end ); 3650
* end = eol; 3651
if ( d -> mb_cur_max > 1 )  3663
while ( ( t = trans [ s ] ) != ( ( void * ) 0 ) )  3664
if ( p > buf_end )  3665
s1 = s; 3668
if ( s == 0 )  3669
if ( ( ( char * ) p ) >= end )  3672
if ( d -> states [ s ] . mbps . nelem == 0 )  3680
s = t [ * ( p ++ ) ]; 3681
if ( backref )  3688
* end = saved_end; 3692
s = transit_state ( d , s , & p ); 3697
trans = d -> trans; 3698
while ( ( t = trans [ s ] ) != ( ( void * ) 0 ) )  3702
s1 = t [ * ( p ++ ) ]; 3703
if ( ( t = trans [ s1 ] ) == ( ( void * ) 0 ) )  3704
state_num tmp = s ; 3705
s = s1; 3706
s1 = tmp; 3708
s = t [ * ( p ++ ) ]; 3711
if ( s >= 0 && ( ( char * ) p ) <= end && d -> fails [ s ] )  3714
if ( d -> success [ s ] & sbit [ * p ] )  3715
s1 = s; 3726
if ( d -> mb_cur_max > 1 )  3727
s = transit_state ( d , s , & p ); 3730
trans = d -> trans; 3731
s = d -> fails [ s ] [ * ( p ++ ) ]; 3734
if ( ( ( char * ) p ) > end )  3748
if ( s >= 0 )  3756
trans = d -> trans; 3758
if ( p [ - 1 ] == eol && allow_nl )  3761
s = d -> newlines [ s1 ]; 3762
s = 0; 3765
static state_num transit_state(struct dfa *d,state_num s,const unsigned char **pp) 3511
int maxlen = 0 ; 3516
size_t i ; 3517
size_t nelem = d -> states [ s ] . mbps . nelem ; 3521
position_set follows ; 3522
if ( nelem > 0 )  3525
match_lens = check_matching_with_multibyte_ops ( d , s , ( * pp - buf_begin ) ); 3530
static int *check_matching_with_multibyte_ops(struct dfa *d,state_num s,size_t idx) 3431
size_t i ; 3433
int * rarray ; 3434
rarray = ( ( sizeof ( ( * rarray ) ) == 1 ? xmalloc ( d -> states [ s ] . mbps . nelem ) : xnmalloc ( d -> states [ s ] . mbps . nelem , sizeof ( ( * rarray ) ) ) ) ); 3436
while ( 0 )  3437
for (i = 0; i < d -> states[s] . mbps . nelem; ++i) 3438
position pos = d -> states [ s ] . mbps . elems [ i ] ; 3439
switch ( d -> tokens [ pos . index ] )  3440
rarray [ i ] = match_anychar ( d , s , pos , idx ); 3443
static int match_anychar(struct dfa *d,state_num s,position pos,size_t idx) 3306
int context ; 3308
wchar_t wc ; 3309
int mbclen ; 3310
wc = inputwcs [ idx ]; 3311
mbclen = ( mblen_buf [ idx ] == 0 ? 1 : mblen_buf [ idx ] ); 3312
if ( wc == ( ( wchar_t ) eolbyte ) )  3314
if ( ! ( syntax_bits & ( ( unsigned long ) 1 ) << 1 << 1 << 1 << 1 << 1 << 1 ) )  3315
return 0 ; 3316
if ( wc == ( ( wchar_t ) '\0' ) )  3320
if ( syntax_bits & ( ( unsigned long ) 1 ) << 1 << 1 << 1 << 1 << 1 << 1 << 1 )  3321
return 0 ; 3322
context = wchar_context ( wc ); 3326
static int wchar_context(wint_t wc) 710
if ( wc == ( ( wchar_t ) eolbyte ) || wc == 0 )  712
return 4 ; 713
if ( wc == '_' || iswalnum ( wc ) )  715
return 2 ; 716
return 1 ; 718
if ( ! ( ( ( ( context & 1 ? pos . constraint & 0xf : 0 ) ) | ( ( context & 2 ? pos . constraint >> 4 & 0xf : 0 ) ) | ( ( context & 4 ? pos . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context ) )  3327
return 0 ; 3328
return mbclen ; 3330
rarray [ i ] = match_mb_charset ( d , s , pos , idx ); 3448
static int match_mb_charset(struct dfa *d,state_num s,position pos,size_t idx) 3337
size_t i ; 3339
int match ; 3341
int match_len ; 3344
int op_len ; 3346
char buffer [ 128 ] ; 3347
struct mb_char_classes * work_mbc ; 3349
int context ; 3350
wchar_t wc ; 3352
wc = inputwcs [ idx ]; 3353
if ( wc == ( ( wchar_t ) eolbyte ) )  3355
if ( ! ( syntax_bits & ( ( unsigned long ) 1 ) << 1 << 1 << 1 << 1 << 1 << 1 ) )  3356
return 0 ; 3357
if ( wc == ( ( wchar_t ) '\0' ) )  3361
if ( syntax_bits & ( ( unsigned long ) 1 ) << 1 << 1 << 1 << 1 << 1 << 1 << 1 )  3362
return 0 ; 3363
context = wchar_context ( wc ); 3367
static int wchar_context(wint_t wc) 710
if ( wc == ( ( wchar_t ) eolbyte ) || wc == 0 )  712
return 4 ; 713
if ( wc == '_' || iswalnum ( wc ) )  715
return 2 ; 716
return 1 ; 718
if ( ! ( ( ( ( context & 1 ? pos . constraint & 0xf : 0 ) ) | ( ( context & 2 ? pos . constraint >> 4 & 0xf : 0 ) ) | ( ( context & 4 ? pos . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context ) )  3368
return 0 ; 3369
work_mbc = & d -> mbcsets [ d -> multibyte_prop [ pos . index ] >> 2 ]; 3372
match = ! work_mbc -> invert; 3373
match_len = ( mblen_buf [ idx ] == 0 ? 1 : mblen_buf [ idx ] ); 3374
if ( wc < 1 << 8 && work_mbc -> cset != ( - 1 ) && tstbit ( ( ( unsigned char ) wc ) , d -> charclasses [ work_mbc -> cset ] ) )  3376
static int tstbit(unsigned int b,const int c[((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int ))]) 616
return c [ b / ( 8 * sizeof ( int ) ) ] & 1 << b % ( 8 * sizeof ( int ) ) ; 618
for (i = 0; i < work_mbc -> nch_classes; i++) 3380
if ( iswctype ( ( ( wint_t ) wc ) , work_mbc -> ch_classes [ i ] ) )  3381
strncpy ( buffer , ( ( const char * ) buf_begin ) + idx , match_len ); 3385
buffer [ match_len ] = '\0'; 3386
for (i = 0; i < work_mbc -> nequivs; i++) 3388
op_len = ( strlen ( work_mbc -> equivs [ i ] ) ); 3389
strncpy ( buffer , ( ( const char * ) buf_begin ) + idx , op_len ); 3390
buffer [ op_len ] = '\0'; 3391
if ( strcoll ( work_mbc -> equivs [ i ] , buffer ) == 0 )  3392
match_len = op_len; 3393
for (i = 0; i < work_mbc -> ncoll_elems; i++) 3398
op_len = ( strlen ( work_mbc -> coll_elems [ i ] ) ); 3399
strncpy ( buffer , ( ( const char * ) buf_begin ) + idx , op_len ); 3400
buffer [ op_len ] = '\0'; 3401
if ( strcoll ( work_mbc -> coll_elems [ i ] , buffer ) == 0 )  3402
match_len = op_len; 3403
for (i = 0; i < work_mbc -> nranges; i++) 3408
if ( work_mbc -> range_sts [ i ] <= wc && wc <= work_mbc -> range_ends [ i ] )  3409
for (i = 0; i < work_mbc -> nchars; i++) 3414
if ( wc == work_mbc -> chars [ i ] )  3415
match = ! match; 3419
return match ? match_len : 0 ; 3421
return rarray ; 3456
for (i = 0; i < nelem; i++) 3531
if ( match_lens [ i ] > maxlen )  3535
maxlen = match_lens [ i ]; 3536
if ( nelem == 0 || maxlen == 0 )  3540
alloc_position_set ( & follows , d -> nleaves ); 3554
static void alloc_position_set(position_set *s,size_t size) 2301
s -> elems = ( ( sizeof ( ( * s -> elems ) ) == 1 ? xmalloc ( size ) : xnmalloc ( size , sizeof ( ( * s -> elems ) ) ) ) ); 2304
while ( 0 )  2305
s -> alloc = size; 2306
s -> nelem = 0; 2307",0,0
87470,"CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncat_83_goodG2B::~CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncat_83_goodG2B() 31
char source [ 100 ] ; 34
memset ( source , 'C' , 100 - 1 ); 35
source [ 100 - 1 ] = '\0'; 36
strncat ( data , source , 100 ); 38
printLine ( data ); 39
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14
delete [ ] data 40",0,0
179652,"static state_num transit_state(struct dfa *d,state_num s,const unsigned char **pp) 3430
state_num s1 ; 3432
int mbclen ; 3434
int maxlen = 0 ; 3435
size_t i ; 3436
size_t nelem = d -> states [ s ] . mbps . nelem ; 3440
position_set follows ; 3441
const unsigned char * p1 = * pp ; 3442
wchar_t wc ; 3443
if ( nelem > 0 )  3444
match_lens = check_matching_with_multibyte_ops ( d , s , ( * pp - buf_begin ) ); 3449
for (i = 0; i < nelem; i++) 3450
if ( match_lens [ i ] > maxlen )  3454
maxlen = match_lens [ i ]; 3455
if ( nelem == 0 || maxlen == 0 )  3459
wc = inputwcs [ * pp - mbclen - buf_begin ]; 3479
s1 = state_index ( d , ( & follows ) , wchar_context ( wc ) ); 3480
static int wchar_context(wint_t wc) 629
if ( wc == ( ( wchar_t ) eolbyte ) || wc == 0 )  631
return 4 ; 632
if ( wc == '_' || iswalnum ( wc ) )  634
return 2 ; 635
return 1 ; 637
static state_num state_index(struct dfa *d,const position_set *s,int context) 2315
size_t hash = 0 ; 2317
int constraint ; 2318
state_num i ; 2319
state_num j ; 2320
for (i = 0; i < s -> nelem; ++i) 2321
hash ^= s -> elems [ i ] . index + s -> elems [ i ] . constraint; 2322
for (i = 0; i < d -> sindex; ++i) 2324
if ( hash != d -> states [ i ] . hash || s -> nelem != d -> states [ i ] . elems . nelem || context != d -> states [ i ] . context )  2325
if ( j == s -> nelem )  2332
return i ; 2333
if ( d -> salloc <= d -> sindex + 1 )  2338
size_t new_n_alloc = ( d -> sindex + 1 + ( ! d -> states ) ) ; 2339
d -> states = ( x2nrealloc ( ( d -> states ) , & new_n_alloc , sizeof ( ( * d -> states ) ) ) ); 2340
d -> salloc = new_n_alloc; 2341
while ( 0 )  2343
d -> states [ i ] . hash = hash; 2344
d -> states [ i ] . context = context; 2347
d -> states [ i ] . backref = 0; 2348
d -> states [ i ] . constraint = 0; 2349
d -> states [ i ] . first_end = 0; 2350
if ( 1 )  2351
d -> states [ i ] . mbps . nelem = 0; 2352
d -> states [ i ] . mbps . elems = ( ( void * ) 0 ); 2353
for (j = 0; j < s -> nelem; ++j) 2355
if ( d -> tokens [ s -> elems [ j ] . index ] < 0 )  2356
constraint = s -> elems [ j ] . constraint; 2357
if ( ( ( ( 7 & 1 ? constraint & 0xf : 0 ) ) | ( ( 7 & 2 ? constraint >> 4 & 0xf : 0 ) ) | ( ( 7 & 4 ? constraint >> 8 & 0xf : 0 ) ) ) & context )  2358
d -> states [ i ] . constraint |= constraint; 2359
if ( ! d -> states [ i ] . first_end )  2361
d -> states [ i ] . first_end = d -> tokens [ s -> elems [ j ] . index ]; 2362
if ( d -> tokens [ s -> elems [ j ] . index ] == BACKREF )  2366
d -> states [ i ] . constraint = 0x777; 2367
d -> states [ i ] . backref = 1; 2368
return i ; 2372
while ( * pp - p1 < maxlen )  3482
transit_state_consume_1char ( d , s1 , pp , ( ( void * ) 0 ) , & mbclen , & follows ); 3483
wc = inputwcs [ * pp - mbclen - buf_begin ]; 3490
s1 = state_index ( d , ( & follows ) , wchar_context ( wc ) ); 3491
static int wchar_context(wint_t wc) 629
if ( wc == ( ( wchar_t ) eolbyte ) || wc == 0 )  631
return 4 ; 632
if ( wc == '_' || iswalnum ( wc ) )  634
return 2 ; 635
return 1 ; 637
static state_num state_index(struct dfa *d,const position_set *s,int context) 2315
size_t hash = 0 ; 2317
int constraint ; 2318
state_num i ; 2319
state_num j ; 2320
hash ^= s -> elems [ i ] . index + s -> elems [ i ] . constraint; 2322
if ( hash != d -> states [ i ] . hash || s -> nelem != d -> states [ i ] . elems . nelem || context != d -> states [ i ] . context )  2325
if ( j == s -> nelem )  2332
return i ; 2333
if ( d -> salloc <= d -> sindex + 1 )  2338
size_t new_n_alloc = ( d -> sindex + 1 + ( ! d -> states ) ) ; 2339
d -> states = ( x2nrealloc ( ( d -> states ) , & new_n_alloc , sizeof ( ( * d -> states ) ) ) ); 2340
d -> salloc = new_n_alloc; 2341
while ( 0 )  2343
d -> states [ i ] . hash = hash; 2344
d -> states [ i ] . context = context; 2347
d -> states [ i ] . backref = 0; 2348
d -> states [ i ] . constraint = 0; 2349
d -> states [ i ] . first_end = 0; 2350
if ( 1 )  2351
d -> states [ i ] . mbps . nelem = 0; 2352
d -> states [ i ] . mbps . elems = ( ( void * ) 0 ); 2353
if ( d -> tokens [ s -> elems [ j ] . index ] < 0 )  2356
constraint = s -> elems [ j ] . constraint; 2357
if ( ( ( ( 7 & 1 ? constraint & 0xf : 0 ) ) | ( ( 7 & 2 ? constraint >> 4 & 0xf : 0 ) ) | ( ( 7 & 4 ? constraint >> 8 & 0xf : 0 ) ) ) & context )  2358
d -> states [ i ] . constraint |= constraint; 2359
if ( ! d -> states [ i ] . first_end )  2361
d -> states [ i ] . first_end = d -> tokens [ s -> elems [ j ] . index ]; 2362
if ( d -> tokens [ s -> elems [ j ] . index ] == BACKREF )  2366
d -> states [ i ] . constraint = 0x777; 2367
d -> states [ i ] . backref = 1; 2368
return i ; 2372
static status_transit_state transit_state_consume_1char(struct dfa *d,state_num s,const unsigned char **pp,int *match_lens,int *mbclen,position_set *pps) 3384
int k ; 3388
state_num s1 ; 3389
state_num s2 ; 3390
int * work_mbls ; 3391
* mbclen = ( mblen_buf [ * pp - buf_begin ] == 0 ? 1 : mblen_buf [ * pp - buf_begin ] ); 3395
s1 = s; 3398
for (k = 0; k <  *mbclen; k++) 3399
s2 = s1; 3400
rs = transit_state_singlebyte ( d , s2 , ( * pp ) ++ , & s1 ); 3401
if ( match_lens == ( ( void * ) 0 ) && d -> states [ s ] . mbps . nelem != 0 )  3406
work_mbls = check_matching_with_multibyte_ops ( d , s , ( * pp - buf_begin ) ); 3407
static int *check_matching_with_multibyte_ops(struct dfa *d,state_num s,size_t idx) 3350
size_t i ; 3352
int * rarray ; 3353
rarray = ( ( sizeof ( ( * rarray ) ) == 1 ? xmalloc ( d -> states [ s ] . mbps . nelem ) : xnmalloc ( d -> states [ s ] . mbps . nelem , sizeof ( ( * rarray ) ) ) ) ); 3355
while ( 0 )  3356
for (i = 0; i < d -> states[s] . mbps . nelem; ++i) 3357
position pos = d -> states [ s ] . mbps . elems [ i ] ; 3358
switch ( d -> tokens [ pos . index ] )  3359
rarray [ i ] = match_anychar ( d , s , pos , idx ); 3362
rarray [ i ] = match_mb_charset ( d , s , pos , idx ); 3367
static int match_mb_charset(struct dfa *d,state_num s,position pos,size_t idx) 3256
size_t i ; 3258
int match_len ; 3263
char buffer [ 128 ] ; 3266
struct mb_char_classes * work_mbc ; 3268
int context ; 3269
wchar_t wc ; 3271
wc = inputwcs [ idx ]; 3272
if ( wc == ( ( wchar_t ) eolbyte ) )  3274
if ( ! ( syntax_bits & ( ( unsigned long ) 1 ) << 1 << 1 << 1 << 1 << 1 << 1 ) )  3275
if ( wc == ( ( wchar_t ) '\0' ) )  3280
if ( syntax_bits & ( ( unsigned long ) 1 ) << 1 << 1 << 1 << 1 << 1 << 1 << 1 )  3281
context = wchar_context ( wc ); 3286
if ( ! ( ( ( ( context & 1 ? pos . constraint & 0xf : 0 ) ) | ( ( context & 2 ? pos . constraint >> 4 & 0xf : 0 ) ) | ( ( context & 4 ? pos . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context ) )  3287
work_mbc = & d -> mbcsets [ d -> multibyte_prop [ pos . index ] >> 2 ]; 3291
match_len = ( mblen_buf [ idx ] == 0 ? 1 : mblen_buf [ idx ] ); 3293
if ( wc < 1 << 8 && work_mbc -> cset != ( - 1 ) && tstbit ( ( ( unsigned char ) wc ) , d -> charclasses [ work_mbc -> cset ] ) )  3295
for (i = 0; i < work_mbc -> nch_classes; i++) 3299
if ( iswctype ( ( ( wint_t ) wc ) , work_mbc -> ch_classes [ i ] ) )  3300
strncpy ( buffer , ( ( const char * ) buf_begin ) + idx , match_len ); 3304
buffer [ match_len ] = '\0'; 3305
strncpy ( buffer , ( ( const char * ) buf_begin ) + idx , op_len ); 3309
buffer [ op_len ] = '\0'; 3310
if ( strcoll ( work_mbc -> equivs [ i ] , buffer ) == 0 )  3311
strncpy ( buffer , ( ( const char * ) buf_begin ) + idx , op_len ); 3319
buffer [ op_len ] = '\0'; 3320
if ( strcoll ( work_mbc -> coll_elems [ i ] , buffer ) == 0 )  3321",0,0
38041,"static void goodG2B() 57
char source [ 100 ] ; 72
memset ( source , 'C' , 100 - 1 ); 73
source [ 100 - 1 ] = '\0'; 74
memmove ( data , source , 100 * sizeof ( char ) ); 76
data [ 100 - 1 ] = '\0'; 78
printLine ( data ); 79
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",0,0
34662,"static void goodG2B() 47
char * data ; 49
data = NULL; 50
char * dataBuffer = ( char * ) malloc ( 100 * sizeof ( char ) ) ; 52
memset ( dataBuffer , 'A' , 100 - 1 ); 53
dataBuffer [ 100 - 1 ] = '\0'; 54
data = dataBuffer; 56
CWE124_Buffer_Underwrite__malloc_char_cpy_63b_goodG2BSink ( & data ); 58
void CWE124_Buffer_Underwrite__malloc_char_cpy_63b_goodG2BSink(char * * dataPtr) 43
char * data = * dataPtr ; 45
char source [ 100 ] ; 47
memset ( source , 'C' , 100 - 1 ); 48
source [ 100 - 1 ] = '\0'; 49
strcpy ( data , source ); 51
printLine ( data ); 52
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",0,0
178562,"static void goodG2B1() 54
wchar_t * data ; 56
wchar_t dataGoodBuffer [ 10 + 1 ] ; 58
if ( globalFive != 5 )  59
data = dataGoodBuffer; 68
data [ 0 ] = L '\0' 69
wchar_t source [ 10 + 1 ] = SRC_STRING ; 72
memmove ( data , source , ( wcslen ( source ) + 1 ) * sizeof ( wchar_t ) ); 75
printWLine ( data ); 76
void printWLine (const wchar_t * line) 18
if ( line != NULL )  20
wprintf ( L ""%ls\n"" , line ) 22",0,0
11188,"void CWE369_Divide_by_Zero__float_listenSocket_51_bad() 49
WSADATA wsaData ; 56
int recvResult ; 59
struct sockaddr_in service ; 60
char inputBuffer [ CHAR_ARRAY_SIZE ] ; 63
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  67
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 73
if ( listenSocket == INVALID_SOCKET )  74
memset ( & service , 0 , sizeof ( service ) ); 78
service . sin_family = AF_INET; 79
service . sin_addr . s_addr = INADDR_ANY; 80
service . sin_port = htons ( TCP_PORT ); 81
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  82
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )  86
acceptSocket = accept ( listenSocket , NULL , NULL ); 90
if ( acceptSocket == SOCKET_ERROR )  91
recvResult = recv ( acceptSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 ); 97
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  98
inputBuffer [ recvResult ] = '\0'; 103
data = ( float ) atof ( inputBuffer ); 105
while ( 0 )  107
CWE369_Divide_by_Zero__float_listenSocket_51b_badSink ( data ); 123
void CWE369_Divide_by_Zero__float_listenSocket_51b_badSink(float data) 46
int result = ( int ) ( 100.0 / data ) ; 50
printIntLine ( result ); 51
void printIntLine (int intNumber) 26
printf ( ""%d\n"" , intNumber ); 28",0,0
154346,"static void build_state(state_num s,struct dfa *d) 3029
state_num * trans ; 3032
state_num i ; 3033
if ( d -> trcount >= 1024 )  3038
for (i = 0; i < d -> tralloc; ++i) 3039
d -> trans [ i ] = d -> fails [ i ] = ( ( void * ) 0 ); 3042
d -> trcount = 0; 3044
d -> success [ s ] = 0; 3048
if ( ( ( ( 4 & 1 ? ( * d ) . states [ s ] . constraint & 0xf : 0 ) ) | ( ( 4 & 2 ? ( * d ) . states [ s ] . constraint >> 4 & 0xf : 0 ) ) | ( ( 4 & 4 ? ( * d ) . states [ s ] . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context )  3049
d -> success [ s ] |= 4; 3050
if ( ( ( ( 2 & 1 ? ( * d ) . states [ s ] . constraint & 0xf : 0 ) ) | ( ( 2 & 2 ? ( * d ) . states [ s ] . constraint >> 4 & 0xf : 0 ) ) | ( ( 2 & 4 ? ( * d ) . states [ s ] . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context )  3052
d -> success [ s ] |= 2; 3053
if ( ( ( ( 1 & 1 ? ( * d ) . states [ s ] . constraint & 0xf : 0 ) ) | ( ( 1 & 2 ? ( * d ) . states [ s ] . constraint >> 4 & 0xf : 0 ) ) | ( ( 1 & 4 ? ( * d ) . states [ s ] . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context )  3055
d -> success [ s ] |= 1; 3056
trans = ( ( sizeof ( ( * trans ) ) == 1 ? xmalloc ( ( 1 << 8 ) ) : xnmalloc ( ( 1 << 8 ) , sizeof ( ( * trans ) ) ) ) ); 3059
while ( 0 )  3060
dfastate ( s , d , trans ); 3061
void dfastate(state_num s,struct dfa *d,token trans[]) 2751
leaf_set * grps ; 2754
charclass * labels ; 2756
size_t ngrps = 0 ; 2758
position pos ; 2760
charclass matches ; 2762
int matchesf ; 2764
charclass intersect ; 2766
int intersectf ; 2768
charclass leftovers ; 2770
int leftoversf ; 2772
position_set follows ; 2774
int possible_contexts ; 2778
int separate_contexts ; 2780
state_num state ; 2782
state_num state_letter ; 2786
size_t i ; 2789
size_t j ; 2790
size_t k ; 2791
grps = ( ( sizeof ( ( * grps ) ) == 1 ? xmalloc ( ( 1 << 8 ) ) : xnmalloc ( ( 1 << 8 ) , sizeof ( ( * grps ) ) ) ) ); 2793
while ( 0 )  2794
labels = ( ( sizeof ( ( * labels ) ) == 1 ? xmalloc ( ( 1 << 8 ) ) : xnmalloc ( ( 1 << 8 ) , sizeof ( ( * labels ) ) ) ) ); 2796
while ( 0 )  2797
for (i = 0; i < d -> states[s] . elems . nelem; ++i) 2799
pos = d -> states [ s ] . elems . elems [ i ]; 2800
if ( d -> tokens [ pos . index ] >= 0 && d -> tokens [ pos . index ] < ( 1 << 8 ) )  2801
if ( d -> tokens [ pos . index ] >= CSET )  2805
if ( pos . constraint != 0x777 )  2828
if ( ! ( ( ( ( 4 & 1 ? pos . constraint & 0xf : 0 ) ) | ( ( 4 & 2 ? pos . constraint >> 4 & 0xf : 0 ) ) | ( ( 4 & 4 ? pos . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context ) )  2829
for (j = 0; j < ((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int )); ++j) 2830
matches [ j ] &= ~newline [ j ]; 2831
if ( ! ( ( ( ( 2 & 1 ? pos . constraint & 0xf : 0 ) ) | ( ( 2 & 2 ? pos . constraint >> 4 & 0xf : 0 ) ) | ( ( 2 & 4 ? pos . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context ) )  2833
for (j = 0; j < ((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int )); ++j) 2834
matches [ j ] &= ~letters [ j ]; 2835
if ( ! ( ( ( ( 1 & 1 ? pos . constraint & 0xf : 0 ) ) | ( ( 1 & 2 ? pos . constraint >> 4 & 0xf : 0 ) ) | ( ( 1 & 4 ? pos . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context ) )  2837
for (j = 0; j < ((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int )); ++j) 2838
matches [ j ] &= letters [ j ] | newline [ j ]; 2839
if ( j == ( ( 1 << 8 ) + 8 * sizeof ( int ) - 1 ) / ( 8 * sizeof ( int ) ) )  2844
for (j = 0; j < ngrps; ++j) 2848
if ( d -> tokens [ pos . index ] >= 0 && d -> tokens [ pos . index ] < ( 1 << 8 ) && ! tstbit ( d -> tokens [ pos . index ] , labels [ j ] ) )  2852
static int tstbit(unsigned int b,const int c[((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int ))]) 533
return c [ b / ( 8 * sizeof ( int ) ) ] & 1 << b % ( 8 * sizeof ( int ) ) ; 535
intersectf = 0; 2857
for (k = 0; k < ((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int )); ++k) 2858
( intersect [ k ] = matches [ k ] & labels [ j ] [ k ] ) ? ( intersectf = 1 ) : 0; 2859
if ( ! intersectf )  2860
leftoversf = matchesf = 0; 2864
for (k = 0; k < ((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int )); ++k) 2865
int match = matches [ k ] ; 2867
int label = labels [ j ] [ k ] ; 2868
( leftovers [ k ] = ~match & label ) ? ( leftoversf = 1 ) : 0; 2869
( matches [ k ] = match & ~label ) ? ( matchesf = 1 ) : 0; 2870
if ( leftoversf )  2873
grps [ ngrps ] . elems = ( ( sizeof ( ( * grps [ ngrps ] . elems ) ) == 1 ? xmalloc ( d -> nleaves ) : xnmalloc ( d -> nleaves , sizeof ( ( * grps [ ngrps ] . elems ) ) ) ) ); 2877
while ( 0 )  2878
grps [ ngrps ] . nelem = grps [ j ] . nelem; 2880
grps [ j ] . elems [ grps [ j ] . nelem ++ ] = pos . index; 2885
if ( ! matchesf )  2888
if ( j == ngrps )  2894
grps [ ngrps ] . elems = ( ( sizeof ( ( * grps [ ngrps ] . elems ) ) == 1 ? xmalloc ( d -> nleaves ) : xnmalloc ( d -> nleaves , sizeof ( ( * grps [ ngrps ] . elems ) ) ) ) ); 2898
while ( 0 )  2899
grps [ ngrps ] . nelem = 1; 2900
grps [ ngrps ] . elems [ 0 ] = pos . index; 2901
if ( d -> searchflag )  2910
separate_contexts = state_separate_contexts ( ( & follows ) ); 2913
static int state_separate_contexts(const position_set *s) 2471
int separate_contexts = 0 ; 2473
size_t j ; 2474
for (j = 0; j < s -> nelem; ++j) 2475
if ( ( s -> elems [ j ] . constraint >> 2 & 0x111 ) != ( s -> elems [ j ] . constraint & 0x111 ) )  2476
separate_contexts |= 4; 2477
if ( ( s -> elems [ j ] . constraint >> 1 & 0x111 ) != ( s -> elems [ j ] . constraint & 0x111 ) )  2479
separate_contexts |= 2; 2480
return separate_contexts ; 2483
state = state_index ( d , ( & follows ) , separate_contexts ^ 7 ); 2914
if ( separate_contexts & 2 )  2921
state_letter = state_index ( d , ( & follows ) , 2 ); 2922
state_letter = state; 2925
for (i = 0; i < (1 << 8); ++i) 2927
trans [ i ] = ( 1 && ( ( * __ctype_b_loc ( ) ) [ ( int ) i ] & ( ( unsigned short ) _ISalnum ) || i == '_' ) ? state_letter : state ); 2928
for (i = 0; i < (1 << 8); ++i) 2932
trans [ i ] = ( - 1 ); 2933
for (i = 0; i < ngrps; ++i) 2935
follows . nelem = 0; 2936
possible_contexts = charclass_context ( labels [ i ] ); 2974
static int charclass_context(charclass c) 2448
int context = 0 ; 2450
unsigned int j ; 2451
if ( tstbit ( eolbyte , c ) )  2452
static int tstbit(unsigned int b,const int c[((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int ))]) 533
return c [ b / ( 8 * sizeof ( int ) ) ] & 1 << b % ( 8 * sizeof ( int ) ) ; 535
context |= 4; 2453
for (j = 0; j < ((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int )); ++j) 2455
if ( c [ j ] & letters [ j ] )  2456
context |= 2; 2457
if ( c [ j ] & ~ ( letters [ j ] | newline [ j ] ) )  2459
context |= 1; 2460
return context ; 2463
separate_contexts = state_separate_contexts ( ( & follows ) ); 2975
static int state_separate_contexts(const position_set *s) 2471
int separate_contexts = 0 ; 2473
size_t j ; 2474
if ( ( s -> elems [ j ] . constraint >> 2 & 0x111 ) != ( s -> elems [ j ] . constraint & 0x111 ) )  2476
separate_contexts |= 4; 2477
if ( ( s -> elems [ j ] . constraint >> 1 & 0x111 ) != ( s -> elems [ j ] . constraint & 0x111 ) )  2479
separate_contexts |= 2; 2480
return separate_contexts ; 2483
if ( ( separate_contexts & possible_contexts ) != possible_contexts )  2977
state = state_index ( d , ( & follows ) , separate_contexts ^ 7 ); 2978
static state_num state_index(struct dfa *d,const position_set *s,int context) 2313
size_t hash = 0 ; 2315
state_num i ; 2317
state_num j ; 2318
for (i = 0; i < s -> nelem; ++i) 2319
hash ^= s -> elems [ i ] . index + s -> elems [ i ] . constraint; 2320
for (i = 0; i < d -> sindex; ++i) 2322
if ( hash != d -> states [ i ] . hash || s -> nelem != d -> states [ i ] . elems . nelem || context != d -> states [ i ] . context )  2323
if ( j == s -> nelem )  2330
if ( d -> salloc <= d -> sindex + 1 )  2336
size_t new_n_alloc = ( d -> sindex + 1 + ( ! d -> states ) ) ; 2337
d -> states = ( x2nrealloc ( ( d -> states ) , & new_n_alloc , sizeof ( ( * d -> states ) ) ) ); 2338
d -> salloc = new_n_alloc; 2339
while ( 0 )  2341
d -> states [ i ] . hash = hash; 2342
alloc_position_set ( & d -> states [ i ] . elems , s -> nelem ); 2343
static void alloc_position_set(position_set *s,size_t size) 2218
s -> elems = ( ( sizeof ( ( * s -> elems ) ) == 1 ? xmalloc ( size ) : xnmalloc ( size , sizeof ( ( * s -> elems ) ) ) ) ); 2221
while ( 0 )  2222
s -> alloc = size; 2223
s -> nelem = 0; 2224",0,0
58965,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_21_bad() 37
char * data ; 39
char dataBuffer [ 100 ] ; 40
data = dataBuffer; 41
data = badSource ( data ); 43
static char * badSource(char * data) 26
if ( badStatic )  28
memset ( data , 'A' , 100 - 1 ); 31
data [ 100 - 1 ] = '\0'; 32
return data ; 34",0,0
143743,"static void build_state(state_num s,struct dfa *d) 3026
state_num * trans ; 3029
state_num i ; 3030
if ( d -> trcount >= 1024 )  3035
for (i = 0; i < d -> tralloc; ++i) 3036
d -> trans [ i ] = d -> fails [ i ] = ( ( void * ) 0 ); 3039
d -> trcount = 0; 3041
d -> success [ s ] = 0; 3045
if ( ( ( ( 4 & 1 ? ( * d ) . states [ s ] . constraint & 0xf : 0 ) ) | ( ( 4 & 2 ? ( * d ) . states [ s ] . constraint >> 4 & 0xf : 0 ) ) | ( ( 4 & 4 ? ( * d ) . states [ s ] . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context )  3046
d -> success [ s ] |= 4; 3047
if ( ( ( ( 2 & 1 ? ( * d ) . states [ s ] . constraint & 0xf : 0 ) ) | ( ( 2 & 2 ? ( * d ) . states [ s ] . constraint >> 4 & 0xf : 0 ) ) | ( ( 2 & 4 ? ( * d ) . states [ s ] . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context )  3049
d -> success [ s ] |= 2; 3050
if ( ( ( ( 1 & 1 ? ( * d ) . states [ s ] . constraint & 0xf : 0 ) ) | ( ( 1 & 2 ? ( * d ) . states [ s ] . constraint >> 4 & 0xf : 0 ) ) | ( ( 1 & 4 ? ( * d ) . states [ s ] . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context )  3052
d -> success [ s ] |= 1; 3053
trans = ( ( sizeof ( ( * trans ) ) == 1 ? xmalloc ( ( 1 << 8 ) ) : xnmalloc ( ( 1 << 8 ) , sizeof ( ( * trans ) ) ) ) ); 3056
while ( 0 )  3057
dfastate ( s , d , trans ); 3058
void dfastate(state_num s,struct dfa *d,token trans[]) 2748
leaf_set * grps ; 2751
charclass * labels ; 2753
size_t ngrps = 0 ; 2755
position pos ; 2757
charclass matches ; 2759
int matchesf ; 2761
charclass intersect ; 2763
int intersectf ; 2765
charclass leftovers ; 2767
int leftoversf ; 2769
position_set follows ; 2771
int possible_contexts ; 2775
int separate_contexts ; 2777
state_num state ; 2779
state_num state_letter ; 2783
size_t i ; 2786
size_t j ; 2787
size_t k ; 2788
grps = ( ( sizeof ( ( * grps ) ) == 1 ? xmalloc ( ( 1 << 8 ) ) : xnmalloc ( ( 1 << 8 ) , sizeof ( ( * grps ) ) ) ) ); 2790
while ( 0 )  2791
labels = ( ( sizeof ( ( * labels ) ) == 1 ? xmalloc ( ( 1 << 8 ) ) : xnmalloc ( ( 1 << 8 ) , sizeof ( ( * labels ) ) ) ) ); 2793
while ( 0 )  2794
for (i = 0; i < d -> states[s] . elems . nelem; ++i) 2796
pos = d -> states [ s ] . elems . elems [ i ]; 2797
if ( d -> tokens [ pos . index ] >= 0 && d -> tokens [ pos . index ] < ( 1 << 8 ) )  2798
if ( d -> tokens [ pos . index ] >= CSET )  2802
if ( pos . constraint != 0x777 )  2825
if ( ! ( ( ( ( 4 & 1 ? pos . constraint & 0xf : 0 ) ) | ( ( 4 & 2 ? pos . constraint >> 4 & 0xf : 0 ) ) | ( ( 4 & 4 ? pos . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context ) )  2826
for (j = 0; j < ((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int )); ++j) 2827
matches [ j ] &= ~newline [ j ]; 2828
if ( ! ( ( ( ( 2 & 1 ? pos . constraint & 0xf : 0 ) ) | ( ( 2 & 2 ? pos . constraint >> 4 & 0xf : 0 ) ) | ( ( 2 & 4 ? pos . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context ) )  2830
for (j = 0; j < ((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int )); ++j) 2831
matches [ j ] &= ~letters [ j ]; 2832
if ( ! ( ( ( ( 1 & 1 ? pos . constraint & 0xf : 0 ) ) | ( ( 1 & 2 ? pos . constraint >> 4 & 0xf : 0 ) ) | ( ( 1 & 4 ? pos . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context ) )  2834
for (j = 0; j < ((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int )); ++j) 2835
matches [ j ] &= letters [ j ] | newline [ j ]; 2836
if ( j == ( ( 1 << 8 ) + 8 * sizeof ( int ) - 1 ) / ( 8 * sizeof ( int ) ) )  2841
for (j = 0; j < ngrps; ++j) 2845
if ( d -> tokens [ pos . index ] >= 0 && d -> tokens [ pos . index ] < ( 1 << 8 ) && ! tstbit ( d -> tokens [ pos . index ] , labels [ j ] ) )  2849
intersectf = 0; 2854
for (k = 0; k < ((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int )); ++k) 2855
( intersect [ k ] = matches [ k ] & labels [ j ] [ k ] ) ? ( intersectf = 1 ) : 0; 2856
if ( ! intersectf )  2857
leftoversf = matchesf = 0; 2861
for (k = 0; k < ((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int )); ++k) 2862
int match = matches [ k ] ; 2864
int label = labels [ j ] [ k ] ; 2865
( leftovers [ k ] = ~match & label ) ? ( leftoversf = 1 ) : 0; 2866
( matches [ k ] = match & ~label ) ? ( matchesf = 1 ) : 0; 2867
if ( leftoversf )  2870
grps [ ngrps ] . elems = ( ( sizeof ( ( * grps [ ngrps ] . elems ) ) == 1 ? xmalloc ( d -> nleaves ) : xnmalloc ( d -> nleaves , sizeof ( ( * grps [ ngrps ] . elems ) ) ) ) ); 2874
while ( 0 )  2875
memcpy ( grps [ ngrps ] . elems , grps [ j ] . elems , sizeof ( grps [ j ] . elems [ 0 ] ) * grps [ j ] . nelem ); 2876
grps [ ngrps ] . nelem = grps [ j ] . nelem; 2877
grps [ j ] . elems [ grps [ j ] . nelem ++ ] = pos . index; 2882
if ( ! matchesf )  2885
if ( j == ngrps )  2891
grps [ ngrps ] . elems = ( ( sizeof ( ( * grps [ ngrps ] . elems ) ) == 1 ? xmalloc ( d -> nleaves ) : xnmalloc ( d -> nleaves , sizeof ( ( * grps [ ngrps ] . elems ) ) ) ) ); 2895
while ( 0 )  2896
grps [ ngrps ] . nelem = 1; 2897
grps [ ngrps ] . elems [ 0 ] = pos . index; 2898
if ( d -> searchflag )  2907
separate_contexts = state_separate_contexts ( ( & follows ) ); 2910
state = state_index ( d , ( & follows ) , separate_contexts ^ 7 ); 2911
if ( separate_contexts & 2 )  2918
state_letter = state_index ( d , ( & follows ) , 2 ); 2919
state_letter = state; 2922
for (i = 0; i < (1 << 8); ++i) 2924
trans [ i ] = ( 1 && ( ( * __ctype_b_loc ( ) ) [ ( int ) i ] & ( ( unsigned short ) _ISalnum ) || i == '_' ) ? state_letter : state ); 2925
for (i = 0; i < (1 << 8); ++i) 2929
trans [ i ] = ( - 1 ); 2930
for (i = 0; i < ngrps; ++i) 2932
follows . nelem = 0; 2933
possible_contexts = charclass_context ( labels [ i ] ); 2971
separate_contexts = state_separate_contexts ( ( & follows ) ); 2972
if ( separate_contexts & possible_contexts & 2 )  2986
state_letter = state_index ( d , ( & follows ) , 2 ); 2987
static state_num state_index(struct dfa *d,const position_set *s,int context) 2310
size_t hash = 0 ; 2312
state_num i ; 2314
state_num j ; 2315
for (i = 0; i < s -> nelem; ++i) 2316
hash ^= s -> elems [ i ] . index + s -> elems [ i ] . constraint; 2317
for (i = 0; i < d -> sindex; ++i) 2319
if ( hash != d -> states [ i ] . hash || s -> nelem != d -> states [ i ] . elems . nelem || context != d -> states [ i ] . context )  2320
if ( j == s -> nelem )  2327
if ( d -> salloc <= d -> sindex + 1 )  2333
size_t new_n_alloc = ( d -> sindex + 1 + ( ! d -> states ) ) ; 2334
d -> states = ( x2nrealloc ( ( d -> states ) , & new_n_alloc , sizeof ( ( * d -> states ) ) ) ); 2335
d -> salloc = new_n_alloc; 2336
while ( 0 )  2338
d -> states [ i ] . hash = hash; 2339
copy ( s , & d -> states [ i ] . elems ); 2341
static void copy(const position_set *src,position_set *dst) 2202
if ( dst -> alloc <= src -> nelem )  2205
size_t new_n_alloc = src -> nelem + ( ! dst -> elems ) ; 2206
dst -> elems = ( x2nrealloc ( ( dst -> elems ) , & new_n_alloc , sizeof ( ( * dst -> elems ) ) ) ); 2207
dst -> alloc = new_n_alloc; 2208
while ( 0 )  2210
memcpy ( ( dst -> elems ) , ( src -> elems ) , sizeof ( dst -> elems [ 0 ] ) * src -> nelem ); 2211
dst -> nelem = src -> nelem; 2212",0,0
56693,"static void goodB2G1() 145
char * data ; 147
data = ( char * ) malloc ( 100 * sizeof ( char ) ); 148
data [ 0 ] = '\0'; 149
WSADATA wsaData ; 152
int recvResult ; 155
struct sockaddr_in service ; 156
size_t dataLen = strlen ( data ) ; 159
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  163
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 170
if ( connectSocket == INVALID_SOCKET )  171
memset ( & service , 0 , sizeof ( service ) ); 175
service . sin_family = AF_INET; 176
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS ); 177
service . sin_port = htons ( TCP_PORT ); 178
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  179
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ); 186
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  187
data [ dataLen + recvResult / sizeof ( char ) ] = '\0'; 192
while ( 0 )  205
if ( STATIC_CONST_FALSE )  217
free ( data ); 235",0,0
21866,"static void build_state_zero(struct dfa *d) 3167
d -> tralloc = 1; 3169
d -> trcount = 0; 3170
d -> realtrans = ( ( sizeof ( ( * d -> realtrans ) ) == 1 ? xzalloc ( ( d -> tralloc + 1 ) ) : xcalloc ( ( d -> tralloc + 1 ) , sizeof ( ( * d -> realtrans ) ) ) ) ); 3172
while ( 0 )  3173
d -> trans = d -> realtrans + 1; 3174
d -> fails = ( ( sizeof ( ( * d -> fails ) ) == 1 ? xzalloc ( ( d -> tralloc ) ) : xcalloc ( ( d -> tralloc ) , sizeof ( ( * d -> fails ) ) ) ) ); 3176
while ( 0 )  3177
d -> success = ( ( sizeof ( ( * d -> success ) ) == 1 ? xmalloc ( ( d -> tralloc ) ) : xnmalloc ( ( d -> tralloc ) , sizeof ( ( * d -> success ) ) ) ) ); 3179
while ( 0 )  3180
d -> newlines = ( ( sizeof ( ( * d -> newlines ) ) == 1 ? xmalloc ( ( d -> tralloc ) ) : xnmalloc ( ( d -> tralloc ) , sizeof ( ( * d -> newlines ) ) ) ) ); 3182
while ( 0 )  3183
build_state ( 0 , d ); 3184
static void build_state(state_num s,struct dfa *d) 3096
state_num * trans ; 3099
state_num i ; 3100
if ( d -> trcount >= 1024 )  3105
for (i = 0; i < d -> tralloc; ++i) 3106
d -> trans [ i ] = d -> fails [ i ] = ( ( void * ) 0 ); 3109
d -> trcount = 0; 3111
d -> success [ s ] = 0; 3115
if ( ( ( ( 4 & 1 ? ( * d ) . states [ s ] . constraint & 0xf : 0 ) ) | ( ( 4 & 2 ? ( * d ) . states [ s ] . constraint >> 4 & 0xf : 0 ) ) | ( ( 4 & 4 ? ( * d ) . states [ s ] . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context )  3116
d -> success [ s ] |= 4; 3117
if ( ( ( ( 2 & 1 ? ( * d ) . states [ s ] . constraint & 0xf : 0 ) ) | ( ( 2 & 2 ? ( * d ) . states [ s ] . constraint >> 4 & 0xf : 0 ) ) | ( ( 2 & 4 ? ( * d ) . states [ s ] . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context )  3119
d -> success [ s ] |= 2; 3120
if ( ( ( ( 1 & 1 ? ( * d ) . states [ s ] . constraint & 0xf : 0 ) ) | ( ( 1 & 2 ? ( * d ) . states [ s ] . constraint >> 4 & 0xf : 0 ) ) | ( ( 1 & 4 ? ( * d ) . states [ s ] . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context )  3122
d -> success [ s ] |= 1; 3123
trans = ( ( sizeof ( ( * trans ) ) == 1 ? xmalloc ( ( 1 << 8 ) ) : xnmalloc ( ( 1 << 8 ) , sizeof ( ( * trans ) ) ) ) ); 3126
while ( 0 )  3127
dfastate ( s , d , trans ); 3128
void dfastate(state_num s,struct dfa *d,token trans[]) 2818
leaf_set * grps ; 2821
charclass * labels ; 2823
size_t ngrps = 0 ; 2825
position pos ; 2827
charclass matches ; 2829
int matchesf ; 2831
charclass intersect ; 2833
int intersectf ; 2835
charclass leftovers ; 2837
int leftoversf ; 2839
position_set follows ; 2841
int possible_contexts ; 2845
int separate_contexts ; 2847
state_num state ; 2849
state_num state_letter ; 2853
size_t i ; 2856
size_t j ; 2857
size_t k ; 2858
grps = ( ( sizeof ( ( * grps ) ) == 1 ? xmalloc ( ( 1 << 8 ) ) : xnmalloc ( ( 1 << 8 ) , sizeof ( ( * grps ) ) ) ) ); 2860
while ( 0 )  2861
labels = ( ( sizeof ( ( * labels ) ) == 1 ? xmalloc ( ( 1 << 8 ) ) : xnmalloc ( ( 1 << 8 ) , sizeof ( ( * labels ) ) ) ) ); 2863
while ( 0 )  2864
for (i = 0; i < d -> states[s] . elems . nelem; ++i) 2866
pos = d -> states [ s ] . elems . elems [ i ]; 2867
if ( d -> tokens [ pos . index ] >= 0 && d -> tokens [ pos . index ] < ( 1 << 8 ) )  2868
if ( d -> tokens [ pos . index ] >= CSET )  2872
if ( pos . constraint != 0x777 )  2895
if ( ! ( ( ( ( 4 & 1 ? pos . constraint & 0xf : 0 ) ) | ( ( 4 & 2 ? pos . constraint >> 4 & 0xf : 0 ) ) | ( ( 4 & 4 ? pos . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context ) )  2896
for (j = 0; j < ((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int )); ++j) 2897
matches [ j ] &= ~newline [ j ]; 2898
if ( ! ( ( ( ( 2 & 1 ? pos . constraint & 0xf : 0 ) ) | ( ( 2 & 2 ? pos . constraint >> 4 & 0xf : 0 ) ) | ( ( 2 & 4 ? pos . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context ) )  2900
for (j = 0; j < ((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int )); ++j) 2901
matches [ j ] &= ~letters [ j ]; 2902
if ( ! ( ( ( ( 1 & 1 ? pos . constraint & 0xf : 0 ) ) | ( ( 1 & 2 ? pos . constraint >> 4 & 0xf : 0 ) ) | ( ( 1 & 4 ? pos . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context ) )  2904
for (j = 0; j < ((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int )); ++j) 2905
matches [ j ] &= letters [ j ] | newline [ j ]; 2906
if ( j == ( ( 1 << 8 ) + 8 * sizeof ( int ) - 1 ) / ( 8 * sizeof ( int ) ) )  2911
for (j = 0; j < ngrps; ++j) 2915
if ( d -> tokens [ pos . index ] >= 0 && d -> tokens [ pos . index ] < ( 1 << 8 ) && ! tstbit ( d -> tokens [ pos . index ] , labels [ j ] ) )  2919
static int tstbit(unsigned int b,const int c[((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int ))]) 600
return c [ b / ( 8 * sizeof ( int ) ) ] & 1 << b % ( 8 * sizeof ( int ) ) ; 602
intersectf = 0; 2924
for (k = 0; k < ((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int )); ++k) 2925
( intersect [ k ] = matches [ k ] & labels [ j ] [ k ] ) ? ( intersectf = 1 ) : 0; 2926
if ( ! intersectf )  2927
leftoversf = matchesf = 0; 2931
for (k = 0; k < ((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int )); ++k) 2932
int match = matches [ k ] ; 2934
int label = labels [ j ] [ k ] ; 2935
( leftovers [ k ] = ~match & label ) ? ( leftoversf = 1 ) : 0; 2936
( matches [ k ] = match & ~label ) ? ( matchesf = 1 ) : 0; 2937
if ( leftoversf )  2940
grps [ ngrps ] . elems = ( ( sizeof ( ( * grps [ ngrps ] . elems ) ) == 1 ? xmalloc ( d -> nleaves ) : xnmalloc ( d -> nleaves , sizeof ( ( * grps [ ngrps ] . elems ) ) ) ) ); 2944
while ( 0 )  2945
memcpy ( grps [ ngrps ] . elems , grps [ j ] . elems , sizeof ( grps [ j ] . elems [ 0 ] ) * grps [ j ] . nelem ); 2946
grps [ ngrps ] . nelem = grps [ j ] . nelem; 2947
grps [ j ] . elems [ grps [ j ] . nelem ++ ] = pos . index; 2952
if ( ! matchesf )  2955
if ( j == ngrps )  2961
grps [ ngrps ] . elems = ( ( sizeof ( ( * grps [ ngrps ] . elems ) ) == 1 ? xmalloc ( d -> nleaves ) : xnmalloc ( d -> nleaves , sizeof ( ( * grps [ ngrps ] . elems ) ) ) ) ); 2965
while ( 0 )  2966
grps [ ngrps ] . nelem = 1; 2967
grps [ ngrps ] . elems [ 0 ] = pos . index; 2968
if ( d -> searchflag )  2977
separate_contexts = state_separate_contexts ( ( & follows ) ); 2980
static int state_separate_contexts(const position_set *s) 2538
int separate_contexts = 0 ; 2540
size_t j ; 2541
for (j = 0; j < s -> nelem; ++j) 2542
if ( ( s -> elems [ j ] . constraint >> 2 & 0x111 ) != ( s -> elems [ j ] . constraint & 0x111 ) )  2543
separate_contexts |= 4; 2544
if ( ( s -> elems [ j ] . constraint >> 1 & 0x111 ) != ( s -> elems [ j ] . constraint & 0x111 ) )  2546
separate_contexts |= 2; 2547
return separate_contexts ; 2550
state = state_index ( d , ( & follows ) , separate_contexts ^ 7 ); 2981
if ( separate_contexts & 2 )  2988
state_letter = state_index ( d , ( & follows ) , 2 ); 2989
state_letter = state; 2992
for (i = 0; i < (1 << 8); ++i) 2994
trans [ i ] = ( 1 && ( ( * __ctype_b_loc ( ) ) [ ( int ) i ] & ( ( unsigned short ) _ISalnum ) || i == '_' ) ? state_letter : state ); 2995
for (i = 0; i < (1 << 8); ++i) 2999
trans [ i ] = ( - 1 ); 3000
for (i = 0; i < ngrps; ++i) 3002
follows . nelem = 0; 3003
possible_contexts = charclass_context ( labels [ i ] ); 3041
static int charclass_context(charclass c) 2515
int context = 0 ; 2517
unsigned int j ; 2518
if ( tstbit ( eolbyte , c ) )  2519
static int tstbit(unsigned int b,const int c[((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int ))]) 600
return c [ b / ( 8 * sizeof ( int ) ) ] & 1 << b % ( 8 * sizeof ( int ) ) ; 602
context |= 4; 2520
for (j = 0; j < ((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int )); ++j) 2522
if ( c [ j ] & letters [ j ] )  2523
context |= 2; 2524
if ( c [ j ] & ~ ( letters [ j ] | newline [ j ] ) )  2526
context |= 1; 2527
return context ; 2530
separate_contexts = state_separate_contexts ( ( & follows ) ); 3042
static int state_separate_contexts(const position_set *s) 2538
int separate_contexts = 0 ; 2540
size_t j ; 2541
if ( ( s -> elems [ j ] . constraint >> 2 & 0x111 ) != ( s -> elems [ j ] . constraint & 0x111 ) )  2543
separate_contexts |= 4; 2544
if ( ( s -> elems [ j ] . constraint >> 1 & 0x111 ) != ( s -> elems [ j ] . constraint & 0x111 ) )  2546
separate_contexts |= 2; 2547
return separate_contexts ; 2550
if ( ( separate_contexts & possible_contexts ) != possible_contexts )  3044
state = state_index ( d , ( & follows ) , separate_contexts ^ 7 ); 3045
static state_num state_index(struct dfa *d,const position_set *s,int context) 2380
size_t hash = 0 ; 2382
state_num i ; 2384
state_num j ; 2385
for (i = 0; i < s -> nelem; ++i) 2386
hash ^= s -> elems [ i ] . index + s -> elems [ i ] . constraint; 2387
for (i = 0; i < d -> sindex; ++i) 2389
if ( hash != d -> states [ i ] . hash || s -> nelem != d -> states [ i ] . elems . nelem || context != d -> states [ i ] . context )  2390
if ( j == s -> nelem )  2397
if ( d -> salloc <= d -> sindex + 1 )  2403
size_t new_n_alloc = ( d -> sindex + 1 + ( ! d -> states ) ) ; 2404
d -> states = ( x2nrealloc ( ( d -> states ) , & new_n_alloc , sizeof ( ( * d -> states ) ) ) ); 2405
d -> salloc = new_n_alloc; 2406
while ( 0 )  2408
d -> states [ i ] . hash = hash; 2409
copy ( s , & d -> states [ i ] . elems ); 2411",0,0
117167,"static void goodB2G() 218
char * data ; 220
char dataBuffer [ 100 ] = """" ; 221
data = dataBuffer; 222
WSADATA wsaData ; 225
int recvResult ; 228
struct sockaddr_in service ; 229
char * replace ; 230
size_t dataLen = strlen ( data ) ; 233
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  237
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 244
if ( listenSocket == INVALID_SOCKET )  245
memset ( & service , 0 , sizeof ( service ) ); 249
service . sin_family = AF_INET; 250
service . sin_addr . s_addr = INADDR_ANY; 251
service . sin_port = htons ( TCP_PORT ); 252
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  253
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )  257
acceptSocket = accept ( listenSocket , NULL , NULL ); 261
if ( acceptSocket == SOCKET_ERROR )  262
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ); 267
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  268
data [ dataLen + recvResult / sizeof ( char ) ] = '\0'; 273
replace = strchr ( data , '\n' ); 280
if ( replace )  281
* replace = '\0'; 283
while ( 0 )  286",0,0
159121,"void CWE606_Unchecked_Loop_Condition__wchar_t_listen_socket_45_bad() 72
wchar_t * data ; 74
wchar_t dataBuffer [ 100 ] = L """" 75
data = dataBuffer; 76
WSADATA wsaData ; 79
int recvResult ; 82
struct sockaddr_in service ; 83
size_t dataLen = wcslen ( data ) ; 87
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  91
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 98
if ( listenSocket == INVALID_SOCKET )  99
memset ( & service , 0 , sizeof ( service ) ); 103
service . sin_family = AF_INET; 104
service . sin_addr . s_addr = INADDR_ANY; 105
service . sin_port = htons ( TCP_PORT ); 106
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  107
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )  111
acceptSocket = accept ( listenSocket , NULL , NULL ); 115
if ( acceptSocket == SOCKET_ERROR )  116
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ); 121
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  122
while ( 0 )  140
if ( listenSocket != INVALID_SOCKET )  141
CLOSE_SOCKET ( listenSocket ); 143
if ( acceptSocket != INVALID_SOCKET )  145
CLOSE_SOCKET ( acceptSocket ); 147",0,0
172580,"char *dfaexec(struct dfa *d,const char *begin,char *end,int allow_nl,size_t *count,int *backref) 3641
state_num s ; 3644
state_num s1 ; 3645
const unsigned char * p ; 3647
state_num * * trans ; 3650
state_num * t ; 3651
unsigned char eol = eolbyte ; 3653
unsigned char saved_end ; 3654
s = s1 = 0; 3658
p = ( ( const unsigned char * ) begin ); 3659
trans = d -> trans; 3660
saved_end = * ( ( unsigned char * ) end ); 3661
* end = eol; 3662
if ( d -> mb_cur_max > 1 )  3674
while ( ( t = trans [ s ] ) != ( ( void * ) 0 ) )  3675
if ( p > buf_end )  3676
s1 = s; 3679
if ( s == 0 )  3680
if ( ( ( char * ) p ) >= end )  3683
if ( d -> states [ s ] . mbps . nelem == 0 )  3691
s = t [ * ( p ++ ) ]; 3692
if ( backref )  3699
* end = saved_end; 3703
s = transit_state ( d , s , & p ); 3708
trans = d -> trans; 3709
while ( ( t = trans [ s ] ) != ( ( void * ) 0 ) )  3713
s1 = t [ * ( p ++ ) ]; 3714
if ( ( t = trans [ s1 ] ) == ( ( void * ) 0 ) )  3715
state_num tmp = s ; 3716
s = s1; 3717
s1 = tmp; 3719
s = t [ * ( p ++ ) ]; 3722
if ( s >= 0 && ( ( char * ) p ) <= end && d -> fails [ s ] )  3725
if ( d -> success [ s ] & sbit [ * p ] )  3726
s1 = s; 3737
if ( d -> mb_cur_max > 1 )  3738
s = transit_state ( d , s , & p ); 3741
trans = d -> trans; 3742
s = d -> fails [ s ] [ * ( p ++ ) ]; 3745
if ( ( ( char * ) p ) > end )  3759
if ( s >= 0 )  3767
trans = d -> trans; 3769
if ( p [ - 1 ] == eol && allow_nl )  3772
s = d -> newlines [ s1 ]; 3773
s = 0; 3776
static state_num transit_state(struct dfa *d,state_num s,const unsigned char **pp) 3522
int mbclen ; 3526
int maxlen = 0 ; 3527
size_t i ; 3528
int * match_lens = ( ( void * ) 0 ) ; 3530
size_t nelem = d -> states [ s ] . mbps . nelem ; 3532
position_set follows ; 3533
if ( nelem > 0 )  3536
match_lens = check_matching_with_multibyte_ops ( d , s , ( * pp - buf_begin ) ); 3541
for (i = 0; i < nelem; i++) 3542
if ( match_lens [ i ] > maxlen )  3546
maxlen = match_lens [ i ]; 3547
if ( nelem == 0 || maxlen == 0 )  3551
transit_state_consume_1char ( d , s , pp , match_lens , & mbclen , & follows ); 3570
static status_transit_state transit_state_consume_1char(struct dfa *d,state_num s,const unsigned char **pp,int *match_lens,int *mbclen,position_set *pps) 3476
int k ; 3480
state_num s1 ; 3481
state_num s2 ; 3482
int * work_mbls ; 3483
* mbclen = ( mblen_buf [ * pp - buf_begin ] == 0 ? 1 : mblen_buf [ * pp - buf_begin ] ); 3487
s1 = s; 3490
for (k = 0; k <  *mbclen; k++) 3491
s2 = s1; 3492
rs = transit_state_singlebyte ( d , s2 , ( * pp ) ++ , & s1 ); 3493
if ( match_lens == ( ( void * ) 0 ) && d -> states [ s ] . mbps . nelem != 0 )  3498
work_mbls = check_matching_with_multibyte_ops ( d , s , ( * pp - buf_begin ) ); 3499
static int *check_matching_with_multibyte_ops(struct dfa *d,state_num s,size_t idx) 3442
int * rarray ; 3445
rarray = ( ( sizeof ( ( * rarray ) ) == 1 ? xmalloc ( d -> states [ s ] . mbps . nelem ) : xnmalloc ( d -> states [ s ] . mbps . nelem , sizeof ( ( * rarray ) ) ) ) ); 3447
while ( 0 )  3448
position pos = d -> states [ s ] . mbps . elems [ i ] ; 3450
switch ( d -> tokens [ pos . index ] )  3451
rarray [ i ] = match_anychar ( d , s , pos , idx ); 3454
rarray [ i ] = match_mb_charset ( d , s , pos , idx ); 3459
return rarray ; 3467",0,0
167478,"static void build_state_zero(struct dfa *d) 3082
d -> tralloc = 1; 3084
d -> trcount = 0; 3085
d -> realtrans = ( ( sizeof ( ( * d -> realtrans ) ) == 1 ? xzalloc ( ( d -> tralloc + 1 ) ) : xcalloc ( ( d -> tralloc + 1 ) , sizeof ( ( * d -> realtrans ) ) ) ) ); 3087
while ( 0 )  3088
d -> trans = d -> realtrans + 1; 3089
d -> fails = ( ( sizeof ( ( * d -> fails ) ) == 1 ? xzalloc ( ( d -> tralloc ) ) : xcalloc ( ( d -> tralloc ) , sizeof ( ( * d -> fails ) ) ) ) ); 3091
while ( 0 )  3092
d -> success = ( ( sizeof ( ( * d -> success ) ) == 1 ? xmalloc ( ( d -> tralloc ) ) : xnmalloc ( ( d -> tralloc ) , sizeof ( ( * d -> success ) ) ) ) ); 3094
while ( 0 )  3095
d -> newlines = ( ( sizeof ( ( * d -> newlines ) ) == 1 ? xmalloc ( ( d -> tralloc ) ) : xnmalloc ( ( d -> tralloc ) , sizeof ( ( * d -> newlines ) ) ) ) ); 3097
while ( 0 )  3098
build_state ( 0 , d ); 3099
static void build_state(state_num s,struct dfa *d) 3011
state_num * trans ; 3014
state_num i ; 3015
if ( d -> trcount >= 1024 )  3020
for (i = 0; i < d -> tralloc; ++i) 3021
d -> trans [ i ] = d -> fails [ i ] = ( ( void * ) 0 ); 3024
d -> trcount = 0; 3026
d -> success [ s ] = 0; 3030
if ( ( ( ( 4 & 1 ? ( * d ) . states [ s ] . constraint & 0xf : 0 ) ) | ( ( 4 & 2 ? ( * d ) . states [ s ] . constraint >> 4 & 0xf : 0 ) ) | ( ( 4 & 4 ? ( * d ) . states [ s ] . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context )  3031
d -> success [ s ] |= 4; 3032
if ( ( ( ( 2 & 1 ? ( * d ) . states [ s ] . constraint & 0xf : 0 ) ) | ( ( 2 & 2 ? ( * d ) . states [ s ] . constraint >> 4 & 0xf : 0 ) ) | ( ( 2 & 4 ? ( * d ) . states [ s ] . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context )  3034
d -> success [ s ] |= 2; 3035
if ( ( ( ( 1 & 1 ? ( * d ) . states [ s ] . constraint & 0xf : 0 ) ) | ( ( 1 & 2 ? ( * d ) . states [ s ] . constraint >> 4 & 0xf : 0 ) ) | ( ( 1 & 4 ? ( * d ) . states [ s ] . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context )  3037
d -> success [ s ] |= 1; 3038
trans = ( ( sizeof ( ( * trans ) ) == 1 ? xmalloc ( ( 1 << 8 ) ) : xnmalloc ( ( 1 << 8 ) , sizeof ( ( * trans ) ) ) ) ); 3041
while ( 0 )  3042
dfastate ( s , d , trans ); 3043
void dfastate(state_num s,struct dfa *d,token trans[]) 2733
int separate_contexts ; 2762
state_num state_letter ; 2768
if ( d -> searchflag )  2892
separate_contexts = state_separate_contexts ( ( & follows ) ); 2895
if ( separate_contexts & 2 )  2903
state_letter = state_index ( d , ( & follows ) , 2 ); 2904
static state_num state_index(struct dfa *d,const position_set *s,int context) 2295
size_t hash = 0 ; 2297
state_num i ; 2299
state_num j ; 2300
for (i = 0; i < s -> nelem; ++i) 2301
hash ^= s -> elems [ i ] . index + s -> elems [ i ] . constraint; 2302
for (i = 0; i < d -> sindex; ++i) 2304
if ( hash != d -> states [ i ] . hash || s -> nelem != d -> states [ i ] . elems . nelem || context != d -> states [ i ] . context )  2305
if ( j == s -> nelem )  2312
if ( d -> salloc <= d -> sindex + 1 )  2318
size_t new_n_alloc = ( d -> sindex + 1 + ( ! d -> states ) ) ; 2319
d -> states = ( x2nrealloc ( ( d -> states ) , & new_n_alloc , sizeof ( ( * d -> states ) ) ) ); 2320
d -> salloc = new_n_alloc; 2321
while ( 0 )  2323
d -> states [ i ] . hash = hash; 2324
copy ( s , & d -> states [ i ] . elems ); 2326",0,0
30240,"static void goodG2B() 50
wchar_t * data ; 52
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_ncat_67_structType myStruct ; 53
data = NULL; 54
data = ( wchar_t * ) malloc ( 100 * sizeof ( wchar_t ) ); 56
data [ 0 ] = L '\0' 57
myStruct . structFirst = data; 58
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_ncat_67b_goodG2BSink ( myStruct ); 59
void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_ncat_67b_goodG2BSink(CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_ncat_67_structType myStruct) 47
wchar_t * data = myStruct . structFirst ; 49
wchar_t source [ 100 ] ; 51
wmemset ( source , L 'C' , 100 - 1 )
source [ 100 - 1 ] = L '\0' 53
wcsncat ( data , source , 100 ); 55
free ( data ); 57",0,0
161246,"static void goodB2G1() 86
char * data ; 88
char dataBuffer [ 100 ] = """" ; 89
data = dataBuffer; 90
if ( globalFive == 5 )  91
FILE * pFile ; 94
pFile = fopen ( ""passwords.txt"" , ""r"" ); 95
if ( pFile != NULL )  96
if ( fgets ( data , 100 , pFile ) == NULL )  99
data [ 0 ] = '\0'; 101",0,0
94590,"static void goodB2G2() 241
size_t data ; 243
data = 0; 245
if ( staticTrue )  246
WSADATA wsaData ; 250
int recvResult ; 253
struct sockaddr_in service ; 254
char inputBuffer [ CHAR_ARRAY_SIZE ] ; 256
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  260
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 267
if ( connectSocket == INVALID_SOCKET )  268
memset ( & service , 0 , sizeof ( service ) ); 272
service . sin_family = AF_INET; 273
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS ); 274
service . sin_port = htons ( TCP_PORT ); 275
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  276
recvResult = recv ( connectSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 ); 282
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  283
inputBuffer [ recvResult ] = '\0'; 288
data = strtoul ( inputBuffer , NULL , 0 ); 290
while ( 0 )  292
if ( staticTrue )  305
if ( data > wcslen ( HELLO_STRING ) && data < 100 )  312",0,0
69125,"void CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_34_bad() 59
char * data ; 61
char dataBuffer [ 100 ] = """" ; 63
data = dataBuffer; 64
WSADATA wsaData ; 67
int recvResult ; 70
struct sockaddr_in service ; 71
char * replace ; 72
size_t dataLen = strlen ( data ) ; 75
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  79
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 86
if ( listenSocket == INVALID_SOCKET )  87
memset ( & service , 0 , sizeof ( service ) ); 91
service . sin_family = AF_INET; 92
service . sin_addr . s_addr = INADDR_ANY; 93
service . sin_port = htons ( TCP_PORT ); 94
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  95
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )  99
acceptSocket = accept ( listenSocket , NULL , NULL ); 103
if ( acceptSocket == SOCKET_ERROR )  104
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ); 109
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  110
data [ dataLen + recvResult / sizeof ( char ) ] = '\0'; 115
replace = strchr ( data , '\n' ); 122
if ( replace )  123
* replace = '\0'; 125
while ( 0 )  128",0,0
130345,"static void goodB2G1() 132
if ( STATIC_CONST_FIVE == 5 )  137
WSADATA wsaData ; 141
int recvResult ; 144
struct sockaddr_in service ; 145
char inputBuffer [ CHAR_ARRAY_SIZE ] ; 147
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  151
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 158
if ( connectSocket == INVALID_SOCKET )  159
memset ( & service , 0 , sizeof ( service ) ); 163
service . sin_family = AF_INET; 164
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS ); 165
service . sin_port = htons ( TCP_PORT ); 166
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  167
recvResult = recv ( connectSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 ); 173
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  174
inputBuffer [ recvResult ] = '\0'; 179
count = atoi ( inputBuffer ); 181
while ( 0 )  183
if ( connectSocket != INVALID_SOCKET )  184
CLOSE_SOCKET ( connectSocket ); 186
if ( count > 0 && count <= 2000 )  204
SLEEP ( count ); 206",0,0
145627,"void CWE134_Uncontrolled_Format_String__char_environment_snprintf_64_bad() 43
char * data ; 45
char dataBuffer [ 100 ] = """" ; 46
data = dataBuffer; 47
size_t dataLen = strlen ( data ) ; 50
strncat ( data + dataLen , environment , 100 - dataLen - 1 ); 56
CWE134_Uncontrolled_Format_String__char_environment_snprintf_64b_badSink ( & data ); 59
void CWE134_Uncontrolled_Format_String__char_environment_snprintf_64b_badSink(void * dataVoidPtr) 40
char * * dataPtr = ( char * * ) dataVoidPtr ; 43
char * data = ( * dataPtr ) ; 45
SNPRINTF ( dest , 100 - 1 , data ); 49",0,0
6039,"void CWE78_OS_Command_Injection__char_console_w32_spawnv_64_bad() 43
char * data ; 45
char dataBuffer [ 100 ] = """" ; 46
data = dataBuffer; 47
size_t dataLen = strlen ( data ) ; 50
if ( 100 - dataLen > 1 )  52
if ( fgets ( data + dataLen , ( int ) ( 100 - dataLen ) , stdin ) != NULL )  55
dataLen = strlen ( data ); 59
if ( dataLen > 0 && data [ dataLen - 1 ] == '\n' )  60
data [ dataLen - 1 ] = '\0'; 62
data [ dataLen ] = '\0'; 69
CWE78_OS_Command_Injection__char_console_w32_spawnv_64b_badSink ( & data ); 73
void CWE78_OS_Command_Injection__char_console_w32_spawnv_64b_badSink(void * dataVoidPtr) 40
char * * dataPtr = ( char * * ) dataVoidPtr ; 43
char * data = ( * dataPtr ) ; 45",0,0
32886,"svn_stringbuf_t *svn_stringbuf_create(const char *cstring,apr_pool_t *pool) 395
return svn_stringbuf_ncreate ( cstring , strlen ( cstring ) , pool ) ; 397
svn_stringbuf_t *svn_stringbuf_ncreate(const char *bytes,apr_size_t size,apr_pool_t *pool) 383
svn_stringbuf_t * strbuf = svn_stringbuf_create_ensure ( size , pool ) ; 385
svn_stringbuf_t *svn_stringbuf_create_ensure(apr_size_t blocksize,apr_pool_t *pool) 365
void * mem ; 367
svn_stringbuf_t * new_string ; 368
new_string = mem; 374
new_string -> data = ( ( char * ) mem ) + sizeof ( ( * new_string ) ); 375
new_string -> data [ 0 ] = '\0'; 376
new_string -> len = 0; 377
new_string -> blocksize = blocksize - sizeof ( ( * new_string ) ); 378
new_string -> pool = pool; 379
return new_string ; 380
memcpy ( ( strbuf -> data ) , bytes , size ); 386
strbuf -> data [ size ] = '\0'; 390
strbuf -> len = size; 391
return strbuf ; 392",0,0
32343,"static void goodG2B() 143
char source [ 100 ] ; 154
memset ( source , 'A' , 100 - 1 ); 156
source [ 100 - 1 ] = '\0'; 157
memmove ( dest , source , data ); 162
dest [ data ] = '\0'; 163
printLine ( dest ); 165
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",0,0
90127,"static void goodB2G() 168
wchar_t * data ; 170
data = ( wchar_t * ) malloc ( 100 * sizeof ( wchar_t ) ); 171
data [ 0 ] = L '\0' 172
WSADATA wsaData ; 175
int recvResult ; 178
struct sockaddr_in service ; 179
size_t dataLen = wcslen ( data ) ; 183
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  187
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 194
if ( listenSocket == INVALID_SOCKET )  195
memset ( & service , 0 , sizeof ( service ) ); 199
service . sin_family = AF_INET; 200
service . sin_addr . s_addr = INADDR_ANY; 201
service . sin_port = htons ( TCP_PORT ); 202
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  203
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )  207
acceptSocket = accept ( listenSocket , NULL , NULL ); 211
if ( acceptSocket == SOCKET_ERROR )  212
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ); 217
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  218
data [ dataLen + recvResult / sizeof ( wchar_t ) ] = L '\0' 223
while ( 0 )  236
if ( globalReturnsTrueOrFalse ( ) )  252
int globalReturnsTrueOrFalse() 157
return ( rand ( ) % 2 ) ; 159
size_t i ; 255
for (i=0; i < wcslen(data); i++) 257
if ( data [ i ] == SEARCH_CHAR )  259",0,0
143644,"static void goodB2G() 77
wchar_t * data ; 79
data = ( wchar_t * ) malloc ( 100 * sizeof ( wchar_t ) ); 80
size_t dataLen = wcslen ( data ) ; 84
if ( 100 - dataLen > 1 )  86
if ( fgetws ( data + dataLen , ( int ) ( 100 - dataLen ) , stdin ) != NULL )  89
dataLen = wcslen ( data ); 93
if ( dataLen > 0 && data [ dataLen - 1 ] == L '\n' ) 94
for (i=0; i < wcslen(data); i++) 112
if ( data [ i ] == SEARCH_CHAR )  114
free ( data ); 120",0,0
143456,"static void goodB2G() 60
char * data ; 62
data = ( char * ) malloc ( 100 * sizeof ( char ) ); 63
data [ 0 ] = '\0'; 64
data = CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_file_61b_goodB2GSource ( data ); 65
char * CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_file_61b_goodB2GSource(char * data) 62
size_t dataLen = strlen ( data ) ; 66
FILE * pFile ; 67
if ( 100 - dataLen > 1 )  69
pFile = fopen ( FILENAME , ""r"" ); 71
if ( pFile != NULL )  72
if ( fgets ( data + dataLen , ( int ) ( 100 - dataLen ) , pFile ) == NULL )  75
data [ dataLen ] = '\0'; 79
return data ; 85",0,0
135869,"CWE23_Relative_Path_Traversal__char_listen_socket_fopen_83_bad::CWE23_Relative_Path_Traversal__char_listen_socket_fopen_83_bad(char * dataCopy) 50
data = dataCopy; 52
WSADATA wsaData ; 55
int recvResult ; 58
struct sockaddr_in service ; 59
size_t dataLen = strlen ( data ) ; 63
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  67
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 74
if ( listenSocket == INVALID_SOCKET )  75
memset ( & service , 0 , sizeof ( service ) ); 79
service . sin_family = AF_INET; 80
service . sin_addr . s_addr = INADDR_ANY; 81
service . sin_port = htons ( TCP_PORT ); 82
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  83
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )  87
acceptSocket = accept ( listenSocket , NULL , NULL ); 91
if ( acceptSocket == SOCKET_ERROR )  92
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ); 97
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  98
data [ dataLen + recvResult / sizeof ( char ) ] = '\0'; 103
replace = strchr ( data , '\r' ); 105
if ( replace )  106
* replace = '\0'; 108
replace = strchr ( data , '\n' ); 110
if ( replace )  111
* replace = '\0'; 113
while ( 0 )  116",0,0
143350,"static void goodG2B() 66
wchar_t * data ; 68
data = NULL; 69
data = ( wchar_t * ) malloc ( ( 10 + 1 ) * sizeof ( wchar_t ) ); 71
CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_memmove_41_goodG2BSink ( data ); 72
void CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_memmove_41_goodG2BSink(wchar_t * data) 53
wchar_t source [ 10 + 1 ] = SRC_STRING ; 56
memmove ( data , source , ( wcslen ( source ) + 1 ) * sizeof ( wchar_t ) ); 59
printWLine ( data ); 60
void printWLine (const wchar_t * line) 18
if ( line != NULL )  20
wprintf ( L ""%ls\n"" , line ) 22
free ( data ); 61",0,0
57607,"void parse_dir_colors() 222
char * * arg ; 225
char * * c ; 226
char * colors ; 227
char * s ; 228
int i ; 229
if ( Hflag )  232
if ( getenv ( ""TERM"" ) == ( ( void * ) 0 ) )  235
s = getenv ( ""TREE_COLORS"" ); 239
if ( s == ( ( void * ) 0 ) )  240
s = getenv ( ""LS_COLORS"" ); 241
if ( ( s == ( ( void * ) 0 ) || strlen ( s ) == 0 ) && force_color )  243
s = "":no=00:fi=00:di=01;34:ln=01;36:pi=40;33:so=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:ex=01;32:*.bat=01;32:*.BAT=01;32:*.btm=01;32:*.BTM=01;32:*.cmd=01;32:*.CMD=01;32:*.com=01;32:*.COM=01;32:*.dll=01;32:*.DLL=01;32:*.exe=01;32:*.EXE=01;32:*.arj=01;31:*.bz2=01;31:*.deb=01;31:*.gz=01;31:*.lzh=01;31:*.rpm=01;31:*.tar=01;31:*.taz=01;31:*.tb2=01;31:*.tbz2=01;31:*.tbz=01;31:*.tgz=01;31:*.tz2=01;31:*.z=01;31:*.Z=01;31:*.zip=01;31:*.ZIP=01;31:*.zoo=01;31:*.asf=01;35:*.ASF=01;35:*.avi=01;35:*.AVI=01;35:*.bmp=01;35:*.BMP=01;35:*.flac=01;35:*.FLAC=01;35:*.gif=01;35:*.GIF=01;35:*.jpg=01;35:*.JPG=01;35:*.jpeg=01;35:*.JPEG=01;35:*.m2a=01;35:*.M2a=01;35:*.m2v=01;35:*.M2V=01;35:*.mov=01;35:*.MOV=01;35:*.mp3=01;35:*.MP3=01;35:*.mpeg=01;35:*.MPEG=01;35:*.mpg=01;35:*.MPG=01;35:*.ogg=01;35:*.OGG=01;35:*.ppm=01;35:*.rm=01;35:*.RM=01;35:*.tga=01;35:*.TGA=01;35:*.tif=01;35:*.TIF=01;35:*.wav=01;35:*.WAV=01;35:*.wmv=01;35:*.WMV=01;35:*.xbm=01;35:*.xpm=01;35:""; 244
if ( s == ( ( void * ) 0 ) || ! force_color && ( nocolor || ! isatty ( 1 ) ) )  246
colors = strcpy ( ( xmalloc ( strlen ( s ) + 1 ) ) , s ); 255
arg = split ( colors , "":"" , & n ); 256
char **split(char *str,char *delim,int *nwrds) 441
int n = 128 ; 443
char * * w = ( xmalloc ( sizeof ( char * ) * n ) ) ; 444
w [ * nwrds = 0 ] = strtok ( str , delim ); 445
while ( w [ * nwrds ] )  446
if ( * nwrds == n - 2 )  447
w = ( xrealloc ( w , sizeof ( char * ) * ( n += 256 ) ) ); 448
w [ ++ * nwrds ] = strtok ( ( ( void * ) 0 ) , delim ); 450
w [ * nwrds ] = ( ( void * ) 0 ); 452
return w ; 453
for (i = 0; arg[i]; i++) 257
c = split ( arg [ i ] , ""="" , & n ); 258
char **split(char *str,char *delim,int *nwrds) 441
int n = 128 ; 443
char * * w = ( xmalloc ( sizeof ( char * ) * n ) ) ; 444
w [ * nwrds = 0 ] = strtok ( str , delim ); 445
while ( w [ * nwrds ] )  446
if ( * nwrds == n - 2 )  447
w = ( xrealloc ( w , sizeof ( char * ) * ( n += 256 ) ) ); 448
w [ ++ * nwrds ] = strtok ( ( ( void * ) 0 ) , delim ); 450
w [ * nwrds ] = ( ( void * ) 0 ); 452
return w ; 453
switch ( cmd ( c [ 0 ] ) )  259
int cmd(char *s) 456
static struct { char * cmd ; char cmdnum ; } cmds [ ] = { { ( ""no"" ) , ( COL_NORMAL ) } , { ( ""fi"" ) , ( COL_FILE ) } , { ( ""di"" ) , ( COL_DIR ) } , { ( ""ln"" ) , ( COL_LINK ) } , { ( ""pi"" ) , ( COL_FIFO ) } , { ( ""do"" ) , ( COL_DOOR ) } , { ( ""bd"" ) , ( COL_BLK ) } , { ( ""cd"" ) , ( COL_CHR ) } , { ( ""or"" ) , ( COL_ORPHAN ) } , { ( ""so"" ) , ( COL_SOCK ) } , { ( ""su"" ) , ( COL_SETUID ) } , { ( ""sg"" ) , ( COL_SETGID ) } , { ( ""tw"" ) , ( COL_STICKY_OTHER_WRITABLE ) } , { ( ""ow"" ) , ( COL_OTHER_WRITABLE ) } , { ( ""st"" ) , ( COL_STICKY ) } , { ( ""ex"" ) , ( COL_EXEC ) } , { ( ""mi"" ) , ( COL_MISSING ) } , { ( ""lc"" ) , ( COL_LEFTCODE ) } , { ( ""rc"" ) , ( COL_RIGHTCODE ) } , { ( ""ec"" ) , ( COL_ENDCODE ) } , { ( ( ( void * ) 0 ) ) , ( 0 ) } } ; 458
int i ; 461
for (i = 0; cmds[i] . cmdnum; i++) 462
if ( ! strcmp ( cmds [ i ] . cmd , s ) )  463
return cmds [ i ] . cmdnum ; 464
if ( s [ 0 ] == '*' )  466
return DOT_EXTENSION ; 467
return ERROR ; 469
if ( c [ 1 ] )  402
endcode = strcpy ( ( xmalloc ( strlen ( c [ 1 ] ) + 1 ) ) , c [ 1 ] ); 403
if ( ! endcode )  429",0,0
97639,"static int transcode_step() 2973
OutputStream * ost ; 2975
InputStream * ist ; 2976
int ret ; 2977
ost = choose_output ( ); 2978
static OutputStream *choose_output() 2511
int i ; 2513
int64_t opts_min = 9223372036854775807L ; 2514
OutputStream * ost_min = ( ( void * ) 0 ) ; 2515
for (i = 0; i < nb_output_streams; i++) 2516
OutputStream * ost = output_streams [ i ] ; 2517
int64_t opts = av_rescale_q ( ost -> st -> cur_dts , ost -> st -> time_base , ( ( AVRational ) ( 1 ) , ( 1000000 ) ) ) 2518
if ( ! ost -> unavailable && ! ost -> finished && opts < opts_min )  2519
opts_min = opts; 2520
ost_min = ost; 2521
return ost_min ; 2524
if ( ! ost )  2979
if ( ost -> filter )  2988
if ( ( ret = transcode_from_filter ( ost -> filter -> graph , & ist ) ) < 0 )  2989
static int transcode_from_filter(FilterGraph *graph,InputStream **best_ist) 2927
int ret ; 2930
ret = avfilter_graph_request_oldest ( graph -> graph ); 2936
if ( ret >= 0 )  2937
return reap_filters ( ) ; 2938
static int reap_filters() 1077
int i ; 1081
for (i = 0; i < nb_output_streams; i++) 1084
OutputStream * ost = output_streams [ i ] ; 1085
if ( ! ost -> filter )  1088
if ( ! ost -> filtered_frame && ! ( ost -> filtered_frame = avcodec_alloc_frame ( ) ) )  1091
return - 12 ; 1092
return 0 ; 1152
if ( ret == - ( ( int ) ( ( 'E' | 'O' << 8 | 'F' << 16 ) | ( ( unsigned int ) 32 ) << 24 ) ) )  2940
ret = reap_filters ( ); 2941
static int reap_filters() 1077
int i ; 1081
OutputStream * ost = output_streams [ i ] ; 1085
if ( ! ost -> filter )  1088
if ( ! ost -> filtered_frame && ! ( ost -> filtered_frame = avcodec_alloc_frame ( ) ) )  1091
return - 12 ; 1092
return 0 ; 1152
return ret ; 2944
if ( ret != - 11 )  2946
return ret ; 2947
return 0 ; 2965
if ( ! ist )  2992
ist = input_streams [ ost -> source_index ]; 3003
ret = process_input ( ist -> file_index ); 3005
static int process_input(int file_index) 2775
InputFile * ifile = input_files [ file_index ] ; 2777
int ret ; 2781
ret = get_input_packet ( ifile , & pkt ); 2785
static int get_input_packet(InputFile *f,AVPacket *pkt) 2739
if ( nb_input_files > 1 )  2742
return get_input_packet_mt ( f , pkt ) ; 2743
static int get_input_packet_mt(InputFile *f,AVPacket *pkt) 2718
pthread_mutex_unlock ( & f -> fifo_lock ); 2734",0,0
115650,"static int handle_stimulus_message(struct skinny_req *req, struct skinnysession *s) 5617
struct skinny_device * d = s -> device ; 5619
struct skinny_line * l ; 5620
struct skinny_subchannel * sub ; 5621
struct ast_channel * c ; 5623
int event ; 5624
int instance ; 5625
event = letohl ( req -> data . stimulus . stimulus ); 5629
instance = letohl ( req -> data . stimulus . stimulusInstance ); 5630
sub = find_subchannel_by_instance_reference ( d , d -> lastlineinstance , d -> lastcallreference ); 5636
if ( ! sub )  5638
l = find_line_by_instance ( d , d -> lastlineinstance ); 5639
if ( ! l )  5640
sub = l -> activesub; 5643
l = sub -> line; 5645
switch ( event )  5648
struct skinny_speeddial * sd ; 5669
if ( ! ( sd = find_speeddial_by_instance ( d , instance , 0 ) ) )  5673
if ( ! sub || ! sub -> owner )  5677
c = skinny_new ( l , NULL , AST_STATE_DOWN , NULL , SKINNY_OUTGOING ); 5678
c = sub -> owner; 5680
if ( ! c )  5682
sub = c -> tech_pvt; 5685
if ( ! sub || ! sub -> owner )  5713
c = skinny_new ( l , NULL , AST_STATE_DOWN , NULL , SKINNY_OUTGOING ); 5714
c = sub -> owner; 5716
if ( ! c )  5719
sub = c -> tech_pvt; 5724
if ( sub -> substate == SUBSTATE_UNSET || sub -> substate == SUBSTATE_OFFHOOK )  5725
dialandactivatesub ( sub , l -> vmexten ); 5726
static void dialandactivatesub(struct skinny_subchannel *sub, char exten[AST_MAX_EXTENSION]) 5427
activatesub ( sub , SUBSTATE_DIALING ); 5430
static void activatesub(struct skinny_subchannel *sub, int state) 5400
struct skinny_line * l = sub -> line ; 5402
if ( sub == l -> activesub )  5410
setsubstate ( sub , state ); 5421
static void setsubstate(struct skinny_subchannel *sub, int state) 4955
struct skinny_line * l = sub -> line ; 4957
struct skinny_subline * subline = sub -> subline ; 4958
struct skinny_device * d = l -> device ; 4959
struct ast_channel * c = sub -> owner ; 4960
int actualstate = state ; 4962
if ( sub -> substate == SUBSTATE_ONHOOK )  4964
if ( state != SUBSTATE_RINGIN && sub -> aa_sched )  4968
sub -> aa_sched = 0; 4970
sub -> aa_beep = 0; 4971
sub -> aa_mute = 0; 4972
if ( ( state == SUBSTATE_RINGIN ) && ( ( d -> hookstate == SKINNY_OFFHOOK ) || ( AST_LIST_NEXT ( AST_LIST_FIRST ( & l -> sub ) , list ) ) ) )  4975
actualstate = SUBSTATE_CALLWAIT; 4976
if ( ( state == SUBSTATE_CONNECTED ) && ( ! subline ) && ( AST_LIST_FIRST ( & l -> sublines ) ) )  4979
const char * slastation ; 4980
struct skinny_subline * tmpsubline ; 4981
slastation = pbx_builtin_getvar_helper ( c , ""SLASTATION"" ); 4982
if ( slastation )  4984
subline = tmpsubline; 4987
if ( subline )  4991
subline -> sub = sub; 4993
sub -> subline = subline; 4994
subline -> callid = sub -> callid; 4995
if ( subline )  5013
switch ( actualstate )  5014
if ( sub -> substate != SUBSTATE_CONNECTED )  5066
sub -> substate = SUBSTATE_HOLD; 5078
if ( ( d -> hookstate == SKINNY_ONHOOK ) && ( ( actualstate == SUBSTATE_OFFHOOK ) || ( actualstate == SUBSTATE_DIALING ) || ( actualstate == SUBSTATE_RINGOUT ) || ( actualstate == SUBSTATE_CONNECTED ) || ( actualstate == SUBSTATE_BUSY ) || ( actualstate == SUBSTATE_CONGESTION ) || ( actualstate == SUBSTATE_PROGRESS ) ) )  5090
d -> hookstate = SKINNY_OFFHOOK; 5093
if ( actualstate == sub -> substate )  5101
switch ( actualstate )  5107
l -> activesub = sub; 5110
sub -> substate = SUBSTATE_OFFHOOK; 5118
if ( sub -> related )  5128
sub -> related -> related = NULL; 5129
if ( sub == l -> activesub )  5132
l -> activesub = NULL; 5133
sub -> cxmode = SKINNY_CX_RECVONLY; 5148
sub -> substate = SUBSTATE_ONHOOK; 5149
if ( sub -> rtp )  5150
sub -> rtp = NULL; 5152
if ( ast_strlen_zero ( sub -> exten ) || ! ast_exists_extension ( c , c -> context , sub -> exten , 1 , l -> cid_num ) )  5159
if ( d -> hookstate == SKINNY_ONHOOK )  5164
d -> hookstate = SKINNY_OFFHOOK; 5165
sub -> substate = SUBSTATE_DIALING; 5194
if ( ! ( sub -> substate == SUBSTATE_DIALING || sub -> substate == SUBSTATE_PROGRESS ) )  5202
sub -> substate = SUBSTATE_RINGOUT; 5214
if ( d -> hookstate == SKINNY_ONHOOK )  5225
l -> activesub = sub; 5226
sub -> substate = SUBSTATE_RINGIN; 5233
sub -> substate = SUBSTATE_CALLWAIT; 5246
sub -> substate = SUBSTATE_CONNECTED; 5278
l -> activesub = sub; 5279
if ( ! ( sub -> substate == SUBSTATE_DIALING || sub -> substate == SUBSTATE_PROGRESS || sub -> substate == SUBSTATE_RINGOUT ) )  5282
sub -> substate = SUBSTATE_BUSY; 5293
if ( ! ( sub -> substate == SUBSTATE_DIALING || sub -> substate == SUBSTATE_PROGRESS || sub -> substate == SUBSTATE_RINGOUT ) )  5296
sub -> substate = SUBSTATE_CONGESTION; 5307
if ( sub -> substate != SUBSTATE_DIALING )  5310
sub -> substate = SUBSTATE_PROGRESS; 5321
if ( sub -> substate != SUBSTATE_CONNECTED )  5324
ast_queue_control_data ( sub -> owner , AST_CONTROL_HOLD , S_OR ( l -> mohsuggest , NULL ) , ! ast_strlen_zero ( l -> mohsuggest ) ? strlen ( l -> mohsuggest ) + 1 : 0 ); 5328",0,0
25559,"void av_pkt_dump2(FILE *f,AVPacket *pkt,int dump_payload,AVStream *st) 4181
pkt_dump_internal ( ( ( void * ) 0 ) , f , 0 , pkt , dump_payload , st -> time_base ); 4183
static void pkt_dump_internal(void *avcl,FILE *f,int level,AVPacket *pkt,int dump_payload,AVRational time_base) 4072
if ( pkt -> dts == ( ( int64_t ) 0x8000000000000000UL ) )  4108
if ( ! f )  4120
fprintf ( f , ""%0.3f"" , ( pkt -> dts ) * av_q2d ( time_base ) ); 4124
while ( 0 )  4126
if ( ! f )  4130
fprintf ( f , ""  pts="" ); 4134
while ( 0 )  4136
if ( ! f )  4139
fprintf ( f , ""N/A"" ); 4143",0,0
163863,"void CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_fprintf_44_bad() 53
wchar_t * data ; 55
data = dataBuffer; 59
WSADATA wsaData ; 62
int recvResult ; 65
struct sockaddr_in service ; 66
size_t dataLen = wcslen ( data ) ; 70
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  74
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 81
if ( listenSocket == INVALID_SOCKET )  82
memset ( & service , 0 , sizeof ( service ) ); 86
service . sin_family = AF_INET; 87
service . sin_addr . s_addr = INADDR_ANY; 88
service . sin_port = htons ( TCP_PORT ); 89
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  90
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )  94
acceptSocket = accept ( listenSocket , NULL , NULL ); 98
if ( acceptSocket == SOCKET_ERROR )  99
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ); 104
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  105
while ( 0 )  123
if ( listenSocket != INVALID_SOCKET )  124
CLOSE_SOCKET ( listenSocket ); 126
if ( acceptSocket != INVALID_SOCKET )  128
CLOSE_SOCKET ( acceptSocket ); 130",0,0
121098,"void CWE665_Improper_Initialization__wchar_t_ncat_66_bad() 26
wchar_t * data ; 28
wchar_t * dataArray [ 5 ] ; 29
wchar_t dataBuffer [ 100 ] ; 30
data = dataBuffer; 31
dataArray [ 2 ] = data; 35
CWE665_Improper_Initialization__wchar_t_ncat_66b_badSink ( dataArray ); 36
void CWE665_Improper_Initialization__wchar_t_ncat_66b_badSink(wchar_t * dataArray[]) 23
wchar_t * data = dataArray [ 2 ] ; 26
size_t sourceLen ; 28
wchar_t source [ 100 ] ; 29
wmemset ( source , L 'C' , 100 - 1 )
source [ 100 - 1 ] = L '\0' 31
sourceLen = wcslen ( source ); 32
wcsncat ( data , source , sourceLen ); 34
printWLine ( data ); 35
void printWLine (const wchar_t * line) 18
if ( line != NULL )  20
wprintf ( L ""%ls\n"" , line ) 22",0,0
114663,"void bad() 25
wchar_t * dataBuffer = ( wchar_t * ) malloc ( 100 * sizeof ( wchar_t ) ) ; 30
data = dataBuffer - 8; 34
baseObject -> action ( data ); 37
void CWE127_Buffer_Underread__malloc_wchar_t_memmove_82_bad::action(wchar_t * data) 24
memmove ( dest , data , 100 * sizeof ( wchar_t ) ); 31
printWLine ( dest ); 34
void printWLine (const wchar_t * line) 18
if ( line != NULL )  20
wprintf ( L ""%ls\n"" , line ) 22",0,0
37906,"void CWE194_Unexpected_Sign_Extension__connect_socket_strncpy_07_bad() 50
if ( staticFive == 5 )  55
WSADATA wsaData ; 59
int recvResult ; 62
struct sockaddr_in service ; 64
char inputBuffer [ CHAR_ARRAY_SIZE ] ; 66
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  70
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 76
if ( connectSocket == INVALID_SOCKET )  77
memset ( & service , 0 , sizeof ( service ) ); 81
service . sin_family = AF_INET; 82
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS ); 83
service . sin_port = htons ( TCP_PORT ); 84
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  85
recvResult = recv ( connectSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 ); 92
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  93
while ( 0 )  111",0,0
79589,"qcms_profile* qcms_profile_from_memory(const void *mem, size_t size) 1011
uint32_t length ; 1013
struct mem_source source ; 1014
struct mem_source * src = & source ; 1015
struct tag_index index ; 1016
qcms_profile * profile ; 1017
source . buf = mem; 1019
source . size = size; 1020
source . valid = true; 1021
if ( size < 4 )  1023
length = read_u32 ( src , 0 ); 1026
if ( length <= size )  1027
source . size = length; 1029
if ( source . size <= 64 || source . size >= MAX_PROFILE_SIZE )  1035
profile = qcms_profile_create ( ); 1038
if ( ! profile )  1039
if ( ! src -> valid )  1050
index = read_tag_table ( profile , src ); 1053
if ( find_tag ( index , TAG_CHAD ) )  1057
profile -> chromaticAdaption = read_tag_s15Fixed16ArrayType ( src , index , TAG_CHAD ); 1058
profile -> chromaticAdaption . invalid = true; 1060
if ( profile -> color_space == RGB_SIGNATURE )  1065
if ( find_tag ( index , TAG_A2B0 ) )  1066
if ( read_u32 ( src , find_tag ( index , TAG_A2B0 ) -> offset ) == LUT8_TYPE || read_u32 ( src , find_tag ( index , TAG_A2B0 ) -> offset ) == LUT16_TYPE )  1067
profile -> A2B0 = read_tag_lutType ( src , index , TAG_A2B0 ); 1069
static struct lutType *read_tag_lutType(struct mem_source *src, struct tag_index index, uint32_t tag_id) 666
struct tag * tag = find_tag ( index , tag_id ) ; 668
uint32_t offset = tag -> offset ; 669
uint32_t type = read_u32 ( src , offset ) ; 670
uint16_t num_input_table_entries ; 671
uint16_t num_output_table_entries ; 672
uint8_t in_chan , grid_points , out_chan ; 673
uint32_t clut_size ; 675
struct lutType * lut ; 677
if ( type == LUT8_TYPE )  682
num_input_table_entries = 256; 683
num_output_table_entries = 256; 684
if ( type == LUT16_TYPE )  686
num_input_table_entries = read_u16 ( src , offset + 48 ); 687
num_output_table_entries = read_u16 ( src , offset + 50 ); 688
in_chan = read_u8 ( src , offset + 8 ); 696
out_chan = read_u8 ( src , offset + 9 ); 697
grid_points = read_u8 ( src , offset + 10 ); 698
clut_size = pow ( grid_points , in_chan ); 700
if ( clut_size > MAX_CLUT_SIZE )  701
if ( in_chan != 3 || out_chan != 3 )  705
lut = malloc ( sizeof ( struct lutType ) + ( num_input_table_entries * in_chan + clut_size * out_chan + num_output_table_entries * out_chan ) * sizeof ( float ) ); 709
if ( ! lut )  710
lut -> input_table = & lut -> table_data [ 0 ]; 715
lut -> clut_table = & lut -> table_data [ in_chan * num_input_table_entries ]; 716
lut -> output_table = & lut -> table_data [ in_chan * num_input_table_entries + clut_size * out_chan ]; 717
lut -> num_input_table_entries = num_input_table_entries; 719
lut -> num_output_table_entries = num_output_table_entries; 720
lut -> num_input_channels = read_u8 ( src , offset + 8 ); 721
lut -> num_output_channels = read_u8 ( src , offset + 9 ); 722
lut -> num_clut_grid_points = read_u8 ( src , offset + 10 ); 723
lut -> e00 = read_s15Fixed16Number ( src , offset + 12 ); 724
lut -> e01 = read_s15Fixed16Number ( src , offset + 16 ); 725
lut -> e02 = read_s15Fixed16Number ( src , offset + 20 ); 726
lut -> e10 = read_s15Fixed16Number ( src , offset + 24 ); 727
lut -> e11 = read_s15Fixed16Number ( src , offset + 28 ); 728
lut -> e12 = read_s15Fixed16Number ( src , offset + 32 ); 729
lut -> e20 = read_s15Fixed16Number ( src , offset + 36 ); 730
static s15Fixed16Number read_s15Fixed16Number(struct mem_source *mem, size_t offset) 127
return read_u32 ( mem , offset ) ; 129
static uint32_t read_u32(struct mem_source *mem, size_t offset) 90
if ( offset > mem -> size - 4 )  95
be32 k ; 99
memcpy ( & k , mem -> buf + offset , sizeof ( k ) ); 100
return be32_to_cpu ( k ) ; 101",0,0
2886,"static void goodG2B() 49
char * data ; 51
data = NULL; 52
data = ( char * ) malloc ( 100 * sizeof ( char ) ); 54
memset ( data , 'A' , 100 - 1 ); 55
data [ 100 - 1 ] = '\0'; 56
char dest [ 100 ] ; 58
memset ( dest , 'C' , 100 - 1 ); 59
dest [ 100 - 1 ] = '\0'; 60
memmove ( dest , data , strlen ( dest ) * sizeof ( char ) ); 63
dest [ 100 - 1 ] = '\0'; 64
printLine ( dest ); 65
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",0,0
137986,"void CWE427_Uncontrolled_Search_Path_Element__char_file_15_bad() 36
char * data ; 38
char dataBuffer [ 250 ] = ""PATH="" ; 39
data = dataBuffer; 40
switch ( 6 )  41
size_t dataLen = strlen ( data ) ; 46
FILE * pFile ; 47
if ( 250 - dataLen > 1 )  49
pFile = fopen ( FILENAME , ""r"" ); 51
if ( pFile != NULL )  52
fclose ( pFile ); 61",0,0
51531,"static void goodB2G1() 79
size_t data ; 81
data = 0; 83
if ( globalTrue )  84
char inputBuffer [ CHAR_ARRAY_SIZE ] = """" ; 87
if ( fgets ( inputBuffer , CHAR_ARRAY_SIZE , stdin ) != NULL )  89
data = strtoul ( inputBuffer , NULL , 0 ); 92
if ( globalFalse )  100
wchar_t * myString ; 108
if ( data > wcslen ( HELLO_STRING ) && data < 100 )  112
myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) ); 114
wcscpy ( myString , HELLO_STRING ); 116
printWLine ( myString ); 117
void printWLine (const wchar_t * line) 18
if ( line != NULL )  20
wprintf ( L ""%ls\n"" , line ) 22
free ( myString ); 118",0,0
24820,"void jingko_polyflorous(struct madreporarian_bursa **********phoneys_kabalevsky) 2832
destoolment_sulphoricinic = ( ( char * ) ( * ( * ( * ( * ( * ( * ( * ( * ( * ( * phoneys_kabalevsky ) ) ) ) ) ) ) ) ) ) . whyever_milvago ); 2836
stonesoupData = malloc ( sizeof ( struct stonesoup_data ) ); 2838
if ( stonesoupData )  2839
stonesoupData -> data = malloc ( sizeof ( char ) * ( strlen ( destoolment_sulphoricinic ) + 1 ) ); 2840
stonesoupData -> file1 = malloc ( sizeof ( char ) * ( strlen ( destoolment_sulphoricinic ) + 1 ) ); 2841
if ( stonesoupData -> data && stonesoupData -> file1 )  2842
if ( ( sscanf ( destoolment_sulphoricinic , ""%s %s"" , stonesoupData -> file1 , stonesoupData -> data ) == 2 ) && ( strlen ( stonesoupData -> data ) != 0 ) && ( strlen ( stonesoupData -> file1 ) != 0 ) )  2843
stonesoupData -> data_size = strlen ( stonesoupData -> data ); 2851
delNonAlpha ( stonesoupData ); 2859
void delNonAlpha (void *data) 247
struct stonesoup_data * stonesoupData = ( struct stonesoup_data * ) data ; 248
int i = 0 ; 249
int j = 0 ; 250
char * temp = malloc ( sizeof ( char ) * ( stonesoupData -> data_size + 1 ) ) ; 251
while ( stonesoupData -> data [ i ] != '\0' )  259
if ( ( stonesoupData -> data [ i ] >= 'A' && stonesoupData -> data [ i ] <= 'Z' ) || ( stonesoupData -> data [ i ] >= 'a' && stonesoupData -> data [ i ] <= 'z' ) )  260
temp [ j ++ ] = stonesoupData -> data [ i ]; 262
i ++; 264
temp [ j ++ ] = '\0'; 266
stonesoupData -> data_size = j; 267
stonesoupData -> data = temp; 269
waitForSig ( stonesoupData -> file1 ); 270
void waitForSig(char* sleepFile) 223
int fd ; 224
char outStr [ 25 ] = { 0 } ; 225
char filename [ 500 ] = { 0 } ; 226
sprintf ( outStr , ""%d.pid"" , getpid ( ) ); 229
strcat ( filename , ""/opt/stonesoup/workspace/testData/"" ); 230
strcat ( filename , outStr ); 231
if ( ( fd = open ( filename , O_CREAT | O_WRONLY , 0666 ) ) == - 1 )  232
stonesoup_readFile ( sleepFile ); 244
void stonesoup_readFile(char *filename) 210
FILE * fifo ; 211
char ch ; 212
fifo = fopen ( filename , ""r"" ); 214
if ( fifo != NULL )  215
while ( ( ch = fgetc ( fifo ) ) != EOF )  216
stonesoup_printf ( ""%c"" , ch ); 217
void stonesoup_printf(char * format, ...) 148
va_start ( argptr , format ); 150
vfprintf ( stonesoup_printf_context , format , argptr ); 151",0,0
76591,"char *dfaexec(struct dfa *d,const char *begin,char *end,int allow_nl,size_t *count,int *backref) 3546
state_num s ; 3549
state_num s1 ; 3550
const unsigned char * p ; 3552
state_num * * trans ; 3555
state_num * t ; 3556
unsigned char eol = eolbyte ; 3558
s = s1 = 0; 3563
p = ( ( const unsigned char * ) begin ); 3564
trans = d -> trans; 3565
* end = eol; 3567
if ( d -> mb_cur_max > 1 )  3579
while ( ( t = trans [ s ] ) != ( ( void * ) 0 ) )  3580
if ( p > buf_end )  3581
s1 = s; 3584
if ( s == 0 )  3585
if ( ( ( char * ) p ) >= end )  3588
if ( d -> states [ s ] . mbps . nelem == 0 )  3596
s = t [ * ( p ++ ) ]; 3597
if ( backref )  3604
s = transit_state ( d , s , & p ); 3613
trans = d -> trans; 3614
while ( ( t = trans [ s ] ) != ( ( void * ) 0 ) )  3618
s1 = t [ * ( p ++ ) ]; 3619
if ( ( t = trans [ s1 ] ) == ( ( void * ) 0 ) )  3620
state_num tmp = s ; 3621
s = s1; 3622
s1 = tmp; 3624
s = t [ * ( p ++ ) ]; 3627
if ( s >= 0 && ( ( char * ) p ) <= end && d -> fails [ s ] )  3630
if ( d -> success [ s ] & sbit [ * p ] )  3631
s1 = s; 3642
if ( d -> mb_cur_max > 1 )  3643
s = transit_state ( d , s , & p ); 3646
trans = d -> trans; 3647
s = d -> fails [ s ] [ * ( p ++ ) ]; 3650
if ( ( ( char * ) p ) > end )  3664
if ( s >= 0 )  3672
build_state ( s , d ); 3673
trans = d -> trans; 3674
if ( p [ - 1 ] == eol && allow_nl )  3677
s = d -> newlines [ s1 ]; 3678
s = 0; 3681
static void build_state(state_num s,struct dfa *d) 3028
state_num * trans ; 3031
state_num i ; 3032
if ( d -> trcount >= 1024 )  3037
for (i = 0; i < d -> tralloc; ++i) 3038
d -> trans [ i ] = d -> fails [ i ] = ( ( void * ) 0 ); 3041
d -> trcount = 0; 3043
d -> success [ s ] = 0; 3047
if ( ( ( ( 4 & 1 ? ( * d ) . states [ s ] . constraint & 0xf : 0 ) ) | ( ( 4 & 2 ? ( * d ) . states [ s ] . constraint >> 4 & 0xf : 0 ) ) | ( ( 4 & 4 ? ( * d ) . states [ s ] . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context )  3048
d -> success [ s ] |= 4; 3049
if ( ( ( ( 2 & 1 ? ( * d ) . states [ s ] . constraint & 0xf : 0 ) ) | ( ( 2 & 2 ? ( * d ) . states [ s ] . constraint >> 4 & 0xf : 0 ) ) | ( ( 2 & 4 ? ( * d ) . states [ s ] . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context )  3051
d -> success [ s ] |= 2; 3052
if ( ( ( ( 1 & 1 ? ( * d ) . states [ s ] . constraint & 0xf : 0 ) ) | ( ( 1 & 2 ? ( * d ) . states [ s ] . constraint >> 4 & 0xf : 0 ) ) | ( ( 1 & 4 ? ( * d ) . states [ s ] . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context )  3054
d -> success [ s ] |= 1; 3055
trans = ( ( sizeof ( ( * trans ) ) == 1 ? xmalloc ( ( 1 << 8 ) ) : xnmalloc ( ( 1 << 8 ) , sizeof ( ( * trans ) ) ) ) ); 3058
while ( 0 )  3059
dfastate ( s , d , trans ); 3060
void dfastate(state_num s,struct dfa *d,token trans[]) 2750
leaf_set * grps ; 2753
charclass * labels ; 2755
size_t ngrps = 0 ; 2757
position pos ; 2759
charclass matches ; 2761
int matchesf ; 2763
charclass intersect ; 2765
int intersectf ; 2767
charclass leftovers ; 2769
int leftoversf ; 2771
size_t i ; 2788
size_t j ; 2789
size_t k ; 2790
grps = ( ( sizeof ( ( * grps ) ) == 1 ? xmalloc ( ( 1 << 8 ) ) : xnmalloc ( ( 1 << 8 ) , sizeof ( ( * grps ) ) ) ) ); 2792
while ( 0 )  2793
labels = ( ( sizeof ( ( * labels ) ) == 1 ? xmalloc ( ( 1 << 8 ) ) : xnmalloc ( ( 1 << 8 ) , sizeof ( ( * labels ) ) ) ) ); 2795
while ( 0 )  2796
for (i = 0; i < d -> states[s] . elems . nelem; ++i) 2798
pos = d -> states [ s ] . elems . elems [ i ]; 2799
if ( d -> tokens [ pos . index ] >= 0 && d -> tokens [ pos . index ] < ( 1 << 8 ) )  2800
if ( d -> tokens [ pos . index ] >= CSET )  2804
if ( pos . constraint != 0x777 )  2827
if ( ! ( ( ( ( 4 & 1 ? pos . constraint & 0xf : 0 ) ) | ( ( 4 & 2 ? pos . constraint >> 4 & 0xf : 0 ) ) | ( ( 4 & 4 ? pos . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context ) )  2828
for (j = 0; j < ((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int )); ++j) 2829
matches [ j ] &= ~newline [ j ]; 2830
if ( ! ( ( ( ( 2 & 1 ? pos . constraint & 0xf : 0 ) ) | ( ( 2 & 2 ? pos . constraint >> 4 & 0xf : 0 ) ) | ( ( 2 & 4 ? pos . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context ) )  2832
for (j = 0; j < ((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int )); ++j) 2833
matches [ j ] &= ~letters [ j ]; 2834
if ( ! ( ( ( ( 1 & 1 ? pos . constraint & 0xf : 0 ) ) | ( ( 1 & 2 ? pos . constraint >> 4 & 0xf : 0 ) ) | ( ( 1 & 4 ? pos . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context ) )  2836
for (j = 0; j < ((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int )); ++j) 2837
matches [ j ] &= letters [ j ] | newline [ j ]; 2838
if ( j == ( ( 1 << 8 ) + 8 * sizeof ( int ) - 1 ) / ( 8 * sizeof ( int ) ) )  2843
for (j = 0; j < ngrps; ++j) 2847
if ( d -> tokens [ pos . index ] >= 0 && d -> tokens [ pos . index ] < ( 1 << 8 ) && ! tstbit ( d -> tokens [ pos . index ] , labels [ j ] ) )  2851
intersectf = 0; 2856
for (k = 0; k < ((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int )); ++k) 2857
( intersect [ k ] = matches [ k ] & labels [ j ] [ k ] ) ? ( intersectf = 1 ) : 0; 2858
if ( ! intersectf )  2859
leftoversf = matchesf = 0; 2863
for (k = 0; k < ((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int )); ++k) 2864
int match = matches [ k ] ; 2866
int label = labels [ j ] [ k ] ; 2867
( leftovers [ k ] = ~match & label ) ? ( leftoversf = 1 ) : 0; 2868
( matches [ k ] = match & ~label ) ? ( matchesf = 1 ) : 0; 2869
if ( leftoversf )  2872
copyset ( leftovers , labels [ ngrps ] ); 2873
grps [ ngrps ] . elems = ( ( sizeof ( ( * grps [ ngrps ] . elems ) ) == 1 ? xmalloc ( d -> nleaves ) : xnmalloc ( d -> nleaves , sizeof ( ( * grps [ ngrps ] . elems ) ) ) ) ); 2876
while ( 0 )  2877
grps [ ngrps ] . nelem = grps [ j ] . nelem; 2879
grps [ j ] . elems [ grps [ j ] . nelem ++ ] = pos . index; 2884
if ( ! matchesf )  2887
if ( j == ngrps )  2893
grps [ ngrps ] . elems = ( ( sizeof ( ( * grps [ ngrps ] . elems ) ) == 1 ? xmalloc ( d -> nleaves ) : xnmalloc ( d -> nleaves , sizeof ( ( * grps [ ngrps ] . elems ) ) ) ) ); 2897
while ( 0 )  2898
grps [ ngrps ] . nelem = 1; 2899
grps [ ngrps ] . elems [ 0 ] = pos . index; 2900
static void copyset(const int src[((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int ))],charclass dst) 547
memcpy ( dst , src , sizeof ( charclass ) ); 549",0,0
16064,"static void goodB2G() 188
size_t data ; 190
data = 0; 192
WSADATA wsaData ; 195
int recvResult ; 198
struct sockaddr_in service ; 199
char inputBuffer [ CHAR_ARRAY_SIZE ] ; 202
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  206
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 213
if ( listenSocket == INVALID_SOCKET )  214
memset ( & service , 0 , sizeof ( service ) ); 218
service . sin_family = AF_INET; 219
service . sin_addr . s_addr = INADDR_ANY; 220
service . sin_port = htons ( TCP_PORT ); 221
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  222
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )  226
acceptSocket = accept ( listenSocket , NULL , NULL ); 230
if ( acceptSocket == SOCKET_ERROR )  231
recvResult = recv ( acceptSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 ); 236
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  237
inputBuffer [ recvResult ] = '\0'; 242
data = strtoul ( inputBuffer , NULL , 0 ); 244
while ( 0 )  246
size_t dataCopy = data ; 263
size_t data = dataCopy ; 264
if ( data > wcslen ( HELLO_STRING ) && data < 100 )  270",0,0
13391,"static void eepro100_write(void *opaque, hwaddr addr,
uint64_t data, unsigned size) 1595
EEPRO100State * s = opaque ; 1597
switch ( size )  1599
eepro100_write1 ( s , addr , data ); 1601
static void eepro100_write1(EEPRO100State * s, uint32_t addr, uint8_t val) 1440
if ( addr > SCBStatus && addr <= sizeof ( s -> mem ) - sizeof ( val ) )  1443
s -> mem [ addr ] = val; 1444
switch ( addr )  1447
eepro100_write_command ( s , val ); 1457
static void eepro100_write_command(EEPRO100State * s, uint8_t val) 1071
eepro100_ru_command ( s , val & 0x0f ); 1073
static void eepro100_ru_command(EEPRO100State * s, uint8_t val) 1023
switch ( val )  1025
if ( get_ru_state ( s ) != ru_idle )  1031
static ru_state_t get_ru_state(EEPRO100State * s) 707
return ( ( s -> mem [ SCBStatus ] & BITS ( 5 , 2 ) ) >> 2 ) ; 709
assert ( ! ""wrong RU state"" ); 1034",0,0
162964,"static void goodB2G() 43
int * data ; 45
data = ( int * ) calloc ( 1 , sizeof ( int ) ); 48
CWE690_NULL_Deref_From_Return__int_calloc_54b_goodB2GSink ( data ); 49
void CWE690_NULL_Deref_From_Return__int_calloc_54b_goodB2GSink(int * data) 38
CWE690_NULL_Deref_From_Return__int_calloc_54c_goodB2GSink ( data ); 40
void CWE690_NULL_Deref_From_Return__int_calloc_54c_goodB2GSink(int * data) 38
CWE690_NULL_Deref_From_Return__int_calloc_54d_goodB2GSink ( data ); 40
void CWE690_NULL_Deref_From_Return__int_calloc_54d_goodB2GSink(int * data) 38
CWE690_NULL_Deref_From_Return__int_calloc_54e_goodB2GSink ( data ); 40
void CWE690_NULL_Deref_From_Return__int_calloc_54e_goodB2GSink(int * data) 35
if ( data != NULL )  38
data [ 0 ] = 5; 40
printIntLine ( data [ 0 ] ); 41
void printIntLine (int intNumber) 26
printf ( ""%d\n"" , intNumber ); 28
free ( data ); 42",0,0
156646,"static void goodB2G() 93
char * data ; 95
char dataBuffer [ 100 ] = """" ; 97
data = dataBuffer; 98
size_t dataLen = strlen ( data ) ; 101
FILE * pFile ; 102
if ( 100 - dataLen > 1 )  104
pFile = fopen ( FILENAME , ""r"" ); 106
if ( pFile != NULL )  107
if ( fgets ( data + dataLen , ( int ) ( 100 - dataLen ) , pFile ) == NULL )  110
data [ dataLen ] = '\0'; 114
fclose ( pFile ); 116
myStruct . structFirst = data; 120
CWE134_Uncontrolled_Format_String__char_file_fprintf_67b_goodB2GSink ( myStruct ); 121
void CWE134_Uncontrolled_Format_String__char_file_fprintf_67b_goodB2GSink(CWE134_Uncontrolled_Format_String__char_file_fprintf_67_structType myStruct) 57
char * data = myStruct . structFirst ; 59
fprintf ( stdout , ""%s\n"" , data ); 61",0,0
128963,"static void goodG2B() 51
wchar_t * data ; 53
data = ( wchar_t * ) malloc ( 100 * sizeof ( wchar_t ) ); 57
myStruct . structFirst = data; 60
CWE126_Buffer_Overread__malloc_wchar_t_memcpy_67b_goodG2BSink ( myStruct ); 61
void CWE126_Buffer_Overread__malloc_wchar_t_memcpy_67b_goodG2BSink(CWE126_Buffer_Overread__malloc_wchar_t_memcpy_67_structType myStruct) 49
wchar_t * data = myStruct . structFirst ; 51
memcpy ( dest , data , wcslen ( dest ) * sizeof ( wchar_t ) ); 58
printWLine ( dest ); 60
void printWLine (const wchar_t * line) 18
if ( line != NULL )  20
wprintf ( L ""%ls\n"" , line ) 22
free ( data ); 61",0,0
114748,"static void goodB2G2() 220
char * data ; 222
char dataBuffer [ 100 ] = """" ; 223
data = dataBuffer; 224
WSADATA wsaData ; 227
int recvResult ; 230
struct sockaddr_in service ; 231
size_t dataLen = strlen ( data ) ; 234
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  238
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 245
if ( connectSocket == INVALID_SOCKET )  246
memset ( & service , 0 , sizeof ( service ) ); 250
service . sin_family = AF_INET; 251
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS ); 252
service . sin_port = htons ( TCP_PORT ); 253
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  254
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ); 261
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  262
data [ dataLen + recvResult / sizeof ( char ) ] = '\0'; 267
replace = strchr ( data , '\r' ); 269
if ( replace )  270
* replace = '\0'; 272
replace = strchr ( data , '\n' ); 274
if ( replace )  275
* replace = '\0'; 277
while ( 0 )  280
if ( connectSocket != INVALID_SOCKET )  281
CLOSE_SOCKET ( connectSocket ); 283
CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_22_goodB2G2_vasink ( data , data ); 293
void CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_22_goodB2G2_vasink(char * data, ...) 74
va_start ( args , data ); 80",0,0
99196,"void CWE222_Truncation_of_Security_Relevant_Information__w32_15_bad() 31
switch ( 6 )  33
WSADATA wsaData ; 37
struct sockaddr_in service ; 41
char username [ USERNAME_SIZE + 1 ] ; 43
if ( 0 != WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) )  47
listenSocket = socket ( PF_INET , SOCK_STREAM , 0 ); 52
if ( listenSocket == INVALID_SOCKET )  53
memset ( & service , 0 , sizeof ( service ) ); 57
service . sin_family = AF_INET; 58
service . sin_addr . s_addr = INADDR_ANY; 59
service . sin_port = htons ( LISTEN_PORT ); 60
if ( SOCKET_ERROR == bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) )  61
if ( SOCKET_ERROR == listen ( listenSocket , LISTEN_BACKLOG ) )  65
acceptSocket = accept ( listenSocket , NULL , NULL ); 69
if ( acceptSocket == INVALID_SOCKET )  70
if ( sizeof ( username ) - sizeof ( char ) != recv ( acceptSocket , username , sizeof ( username ) - sizeof ( char ) , 0 ) )  74
while ( 0 )  105
if ( acceptSocket != INVALID_SOCKET )  106
closesocket ( acceptSocket ); 108
if ( listenSocket != INVALID_SOCKET )  110
closesocket ( listenSocket ); 112",0,0
144692,"void CWE426_Untrusted_Search_Path__wchar_t_system_54_bad() 46
wchar_t * data ; 48
wchar_t dataBuffer [ 100 ] = L """" 49
data = dataBuffer; 50
wcscpy ( data , BAD_OS_COMMAND ); 52
CWE426_Untrusted_Search_Path__wchar_t_system_54b_badSink ( data ); 53
void CWE426_Untrusted_Search_Path__wchar_t_system_54b_badSink(wchar_t * data) 48
CWE426_Untrusted_Search_Path__wchar_t_system_54c_badSink ( data ); 50
void CWE426_Untrusted_Search_Path__wchar_t_system_54c_badSink(wchar_t * data) 48
CWE426_Untrusted_Search_Path__wchar_t_system_54d_badSink ( data ); 50
void CWE426_Untrusted_Search_Path__wchar_t_system_54d_badSink(wchar_t * data) 48
CWE426_Untrusted_Search_Path__wchar_t_system_54e_badSink ( data ); 50
void CWE426_Untrusted_Search_Path__wchar_t_system_54e_badSink(wchar_t * data) 45
if ( SYSTEM ( data ) <= 0 )  49",0,0
48933,"static int transcode() 2987
int ret ; 2989
int64_t timer_start ; 2994
ret = transcode_init ( ); 2995
if ( ret < 0 )  2996
timer_start = av_gettime ( ); 3002
if ( ( ret = init_input_threads ( ) ) < 0 )  3004
while ( ! received_sigterm )  3008
int64_t cur_time = av_gettime ( ) ; 3009
if ( stdin_interaction )  3011
if ( check_keyboard_interaction ( cur_time ) < 0 )  3012
static int check_keyboard_interaction(int64_t cur_time) 2493
int key ; 2497
static int64_t last_time ; 2498
if ( received_nb_signals )  2499
return - ( ( int ) ( ( 'E' | 'X' << 8 | 'I' << 16 ) | ( ( unsigned int ) 'T' ) << 24 ) ) ; 2500
if ( cur_time - last_time >= 100000 && ! run_as_daemon )  2503
key = read_key ( ); 2504
static int read_key() 380
unsigned char ch ; 382
struct timeval tv ; 385
fd_set rfds ; 386
( & rfds ) -> fds_bits [ 0 / ( 8 * ( ( int ) ( sizeof ( __fd_mask ) ) ) ) ] |= ( ( __fd_mask ) 1 ) << 0 % ( 8 * ( ( int ) ( sizeof ( __fd_mask ) ) ) ); 392
tv . tv_sec = 0; 393
tv . tv_usec = 0; 394
n = select ( 1 , & rfds , ( ( void * ) 0 ) , ( ( void * ) 0 ) , & tv ); 395
if ( n > 0 )  396
n = ( read ( 0 , ( & ch ) , 1 ) ); 397
if ( n == 1 )  398
return ch ; 399
return n ; 401
return - 1 ; 410
key = - 1; 2508
if ( key == 'q' )  2510
return - ( ( int ) ( ( 'E' | 'X' << 8 | 'I' << 16 ) | ( ( unsigned int ) 'T' ) << 24 ) ) ; 2511
return 0 ; 2601
if ( ! need_output ( ) )  3017
static int need_output() 2451
int i ; 2453
for (i = 0; i < nb_output_streams; i++) 2454
OutputStream * ost = output_streams [ i ] ; 2455
OutputFile * of = output_files [ ost -> file_index ] ; 2456
AVFormatContext * os = output_files [ ost -> file_index ] -> ctx ; 2457
if ( ost -> finished || os -> pb && ( avio_tell ( os -> pb ) ) >= of -> limit_filesize )  2458
if ( ( ost -> frame_number ) >= ost -> max_frames )  2461
return 1 ; 2467
return 0 ; 2469
ret = transcode_step ( ); 3021
static int transcode_step() 2939
OutputStream * ost ; 2941
InputStream * ist ; 2942
int ret ; 2943
ost = choose_output ( ); 2944
static OutputStream *choose_output() 2477
int i ; 2479
int64_t opts_min = 9223372036854775807L ; 2480
OutputStream * ost_min = ( ( void * ) 0 ) ; 2481
for (i = 0; i < nb_output_streams; i++) 2482
OutputStream * ost = output_streams [ i ] ; 2483
int64_t opts = av_rescale_q ( ost -> st -> cur_dts , ost -> st -> time_base , ( ( AVRational ) ( 1 ) , ( 1000000 ) ) ) 2484
if ( ! ost -> unavailable && ! ost -> finished && opts < opts_min )  2485
opts_min = opts; 2486
ost_min = ost; 2487
return ost_min ; 2490
if ( ! ost )  2945
if ( got_eagain ( ) )  2946
static int got_eagain() 2715
int i ; 2717
for (i = 0; i < nb_output_streams; i++) 2718
if ( output_streams [ i ] -> unavailable )  2719
return 1 ; 2720
return 0 ; 2722
return 0 ; 2949
return - ( ( int ) ( ( 'E' | 'O' << 8 | 'F' << 16 ) | ( ( unsigned int ) 32 ) << 24 ) ) ; 2952
if ( ost -> filter )  2954
if ( ( ret = transcode_from_filter ( ost -> filter -> graph , & ist ) ) < 0 )  2955
static int transcode_from_filter(FilterGraph *graph,InputStream **best_ist) 2893
int ret ; 2896
ret = avfilter_graph_request_oldest ( graph -> graph ); 2902
if ( ret >= 0 )  2903
return reap_filters ( ) ; 2904
static int reap_filters() 1043
int i ; 1047
for (i = 0; i < nb_output_streams; i++) 1050
OutputStream * ost = output_streams [ i ] ; 1051
if ( ! ost -> filter )  1054
if ( ! ost -> filtered_frame && ! ( ost -> filtered_frame = avcodec_alloc_frame ( ) ) )  1057
return - 12 ; 1058
return 0 ; 1118
if ( ret == - ( ( int ) ( ( 'E' | 'O' << 8 | 'F' << 16 ) | ( ( unsigned int ) 32 ) << 24 ) ) )  2906
ret = reap_filters ( ); 2907
static int reap_filters() 1043
int i ; 1047
OutputStream * ost = output_streams [ i ] ; 1051
if ( ! ost -> filter )  1054
if ( ! ost -> filtered_frame && ! ( ost -> filtered_frame = avcodec_alloc_frame ( ) ) )  1057
return - 12 ; 1058
return 0 ; 1118
return ret ; 2910
if ( ret != - 11 )  2912
return ret ; 2913
return 0 ; 2931
return ret ; 2956
if ( ! ist )  2958
return 0 ; 2959
ist = input_streams [ ost -> source_index ]; 2969
ret = process_input ( ist -> file_index ); 2971
static int process_input(int file_index) 2741
InputFile * ifile = input_files [ file_index ] ; 2743
int ret ; 2747
ret = get_input_packet ( ifile , & pkt ); 2751
static int get_input_packet(InputFile *f,AVPacket *pkt) 2705
if ( nb_input_files > 1 )  2708
return get_input_packet_mt ( f , pkt ) ; 2709
static int get_input_packet_mt(InputFile *f,AVPacket *pkt) 2684
int ret = 0 ; 2686
if ( av_fifo_size ( f -> fifo ) )  2688
if ( f -> finished )  2693
ret = - ( ( int ) ( ( 'E' | 'O' << 8 | 'F' << 16 ) | ( ( unsigned int ) 32 ) << 24 ) ); 2694
ret = - 11; 2697
return ret ; 2701
return av_read_frame ( f -> ctx , pkt ) ; 2712
if ( ret == - 11 )  2752
return ret ; 2754
if ( ret < 0 )  2756
return - 11 ; 2777
return 0 ; 2883
if ( ret == - 11 )  2972
return 0 ; 2976
if ( ret < 0 )  2978
return ret == - ( ( int ) ( ( 'E' | 'O' << 8 | 'F' << 16 ) | ( ( unsigned int ) 32 ) << 24 ) ) ? 0 : ret ; 2979
return reap_filters ( ) ; 2981
static int reap_filters() 1043
int i ; 1047
OutputStream * ost = output_streams [ i ] ; 1051
if ( ! ost -> filter )  1054
if ( ! ost -> filtered_frame && ! ( ost -> filtered_frame = avcodec_alloc_frame ( ) ) )  1057
return - 12 ; 1058
return 0 ; 1118
if ( ret < 0 )  3022
if ( ret == - ( ( int ) ( ( 'E' | 'O' << 8 | 'F' << 16 ) | ( ( unsigned int ) 32 ) << 24 ) ) || ret == - 11 )  3023
print_report ( 0 , timer_start , cur_time ); 3030
static void print_report(int is_last_report,int64_t timer_start,int64_t cur_time) 1121
char buf [ 1024 ] ; 1123
OutputStream * ost ; 1125
AVCodecContext * enc ; 1128
int frame_number ; 1129
int vid ; 1130
int i ; 1131
static int64_t last_time = ( - 1 ) ; 1134
static int qp_histogram [ '4' ] ; 1135
if ( ! print_stats && ! is_last_report && ! progress_avio )  1140
if ( ! is_last_report )  1143
if ( last_time == ( - 1 ) )  1144
last_time = cur_time; 1145
if ( cur_time - last_time < 500000 )  1148
buf [ 0 ] = '\0'; 1159
vid = 0; 1160
for (i = 0; i < nb_output_streams; i++) 1162
float q = ( - 1 ) ; 1163
ost = output_streams [ i ]; 1164
enc = ost -> st -> codec; 1165
if ( ! ost -> stream_copy && enc -> coded_frame )  1166
q = ( enc -> coded_frame -> quality ) / ( ( float ) 'v' ); 1167
if ( vid && ( enc -> codec_type ) == AVMEDIA_TYPE_VIDEO )  1169
snprintf ( buf + strlen ( buf ) , sizeof ( buf ) - strlen ( buf ) , ""q=%2.1f "" , q ); 1170
if ( ! vid && ( enc -> codec_type ) == AVMEDIA_TYPE_VIDEO )  1173
float fps ; 1174
float t = ( ( cur_time - timer_start ) / 1000000.0 ) ; 1175
frame_number = ost -> frame_number; 1176
fps = ( t > 1 ? frame_number / t : 0 ); 1177
snprintf ( buf + strlen ( buf ) , sizeof ( buf ) - strlen ( buf ) , ""frame=%5d fps=%3.*f q=%3.1f "" , frame_number , fps < 9.95 , fps , q ); 1178
if ( is_last_report )  1182
snprintf ( buf + strlen ( buf ) , sizeof ( buf ) - strlen ( buf ) , ""L"" ); 1183
if ( qp_hist )  1185
int j ; 1186
int qp = ( lrintf ( q ) ) ; 1187
if ( qp >= 0 && qp < sizeof ( qp_histogram ) / sizeof ( qp_histogram [ 0 ] ) )  1188
qp_histogram [ qp ] ++; 1189
for (j = 0; j < 32; j++) 1191
snprintf ( buf + strlen ( buf ) , sizeof ( buf ) - strlen ( buf ) , ""%X"" , ( ( int ) ( lrintf ( ( log2 ( ( qp_histogram [ j ] + 1 ) ) ) ) ) ) ); 1192
if ( enc -> flags & 0x8000 && ( enc -> coded_frame || is_last_report ) )  1194
int j ; 1195
double error ; 1196
double scale ; 1198
double p ; 1200
char type [ 3 ] = { ( 'Y' ) , ( 'U' ) , ( 'V' ) } ; 1201
snprintf ( buf + strlen ( buf ) , sizeof ( buf ) - strlen ( buf ) , ""PSNR="" ); 1202
for (j = 0; j < 3; j++) 1203
if ( is_last_report )  1204
error = enc -> error [ j ]; 1205
scale = ( enc -> width * enc -> height ) * 255.0 * 255.0 * frame_number; 1206
error = enc -> coded_frame -> error [ j ]; 1209
scale = ( enc -> width * enc -> height ) * 255.0 * 255.0; 1210
if ( j )  1212
scale /= 4; 1213
p = psnr ( error / scale ); 1217
snprintf ( buf + strlen ( buf ) , sizeof ( buf ) - strlen ( buf ) , ""%c:%2.2f "" , type [ j ] , p ); 1218
snprintf ( buf + strlen ( buf ) , sizeof ( buf ) - strlen ( buf ) , ""*:%2.2f "" , psnr ( error_sum / scale_sum ) ); 1222
vid = 1; 1225
snprintf ( buf + strlen ( buf ) , sizeof ( buf ) - strlen ( buf ) , ""size=N/A time="" ); 1240",0,0
93422,"void CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_listen_socket_65b_goodG2BSink(size_t data) 77
wchar_t * myString ; 80
if ( data > wcslen ( HELLO_STRING ) )  84
myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) ); 86
wcscpy ( myString , HELLO_STRING ); 88
printWLine ( myString ); 89
void printWLine (const wchar_t * line) 18
if ( line != NULL )  20
wprintf ( L ""%ls\n"" , line ) 22
free ( myString ); 90",0,0
47971,"static void build_state(state_num s,struct dfa *d) 3068
state_num * trans ; 3071
state_num i ; 3072
if ( d -> trcount >= 1024 )  3077
for (i = 0; i < d -> tralloc; ++i) 3078
d -> trans [ i ] = d -> fails [ i ] = ( ( void * ) 0 ); 3081
d -> trcount = 0; 3083
d -> success [ s ] = 0; 3087
if ( ( ( ( 4 & 1 ? ( * d ) . states [ s ] . constraint & 0xf : 0 ) ) | ( ( 4 & 2 ? ( * d ) . states [ s ] . constraint >> 4 & 0xf : 0 ) ) | ( ( 4 & 4 ? ( * d ) . states [ s ] . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context )  3088
d -> success [ s ] |= 4; 3089
if ( ( ( ( 2 & 1 ? ( * d ) . states [ s ] . constraint & 0xf : 0 ) ) | ( ( 2 & 2 ? ( * d ) . states [ s ] . constraint >> 4 & 0xf : 0 ) ) | ( ( 2 & 4 ? ( * d ) . states [ s ] . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context )  3091
d -> success [ s ] |= 2; 3092
if ( ( ( ( 1 & 1 ? ( * d ) . states [ s ] . constraint & 0xf : 0 ) ) | ( ( 1 & 2 ? ( * d ) . states [ s ] . constraint >> 4 & 0xf : 0 ) ) | ( ( 1 & 4 ? ( * d ) . states [ s ] . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context )  3094
d -> success [ s ] |= 1; 3095
trans = ( ( sizeof ( ( * trans ) ) == 1 ? xmalloc ( ( 1 << 8 ) ) : xnmalloc ( ( 1 << 8 ) , sizeof ( ( * trans ) ) ) ) ); 3098
while ( 0 )  3099
dfastate ( s , d , trans ); 3100
void dfastate(state_num s,struct dfa *d,token trans[]) 2790
leaf_set * grps ; 2793
charclass * labels ; 2795
size_t ngrps = 0 ; 2797
position pos ; 2799
charclass matches ; 2801
int matchesf ; 2803
charclass intersect ; 2805
int intersectf ; 2807
charclass leftovers ; 2809
int leftoversf ; 2811
position_set follows ; 2813
int possible_contexts ; 2817
int separate_contexts ; 2819
state_num state ; 2821
state_num state_newline ; 2823
state_num state_letter ; 2825
size_t i ; 2828
size_t j ; 2829
size_t k ; 2830
grps = ( ( sizeof ( ( * grps ) ) == 1 ? xmalloc ( ( 1 << 8 ) ) : xnmalloc ( ( 1 << 8 ) , sizeof ( ( * grps ) ) ) ) ); 2832
while ( 0 )  2833
labels = ( ( sizeof ( ( * labels ) ) == 1 ? xmalloc ( ( 1 << 8 ) ) : xnmalloc ( ( 1 << 8 ) , sizeof ( ( * labels ) ) ) ) ); 2835
while ( 0 )  2836
for (i = 0; i < d -> states[s] . elems . nelem; ++i) 2838
pos = d -> states [ s ] . elems . elems [ i ]; 2839
if ( d -> tokens [ pos . index ] >= 0 && d -> tokens [ pos . index ] < ( 1 << 8 ) )  2840
if ( d -> tokens [ pos . index ] >= CSET )  2844
if ( pos . constraint != 0x777 )  2867
if ( ! ( ( ( ( 4 & 1 ? pos . constraint & 0xf : 0 ) ) | ( ( 4 & 2 ? pos . constraint >> 4 & 0xf : 0 ) ) | ( ( 4 & 4 ? pos . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context ) )  2868
for (j = 0; j < ((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int )); ++j) 2869
matches [ j ] &= ~newline [ j ]; 2870
if ( ! ( ( ( ( 2 & 1 ? pos . constraint & 0xf : 0 ) ) | ( ( 2 & 2 ? pos . constraint >> 4 & 0xf : 0 ) ) | ( ( 2 & 4 ? pos . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context ) )  2872
for (j = 0; j < ((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int )); ++j) 2873
matches [ j ] &= ~letters [ j ]; 2874
if ( ! ( ( ( ( 1 & 1 ? pos . constraint & 0xf : 0 ) ) | ( ( 1 & 2 ? pos . constraint >> 4 & 0xf : 0 ) ) | ( ( 1 & 4 ? pos . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context ) )  2876
for (j = 0; j < ((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int )); ++j) 2877
matches [ j ] &= letters [ j ] | newline [ j ]; 2878
if ( j == ( ( 1 << 8 ) + 8 * sizeof ( int ) - 1 ) / ( 8 * sizeof ( int ) ) )  2883
for (j = 0; j < ngrps; ++j) 2887
if ( d -> tokens [ pos . index ] >= 0 && d -> tokens [ pos . index ] < ( 1 << 8 ) && ! tstbit ( d -> tokens [ pos . index ] , labels [ j ] ) )  2891
intersectf = 0; 2896
for (k = 0; k < ((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int )); ++k) 2897
( intersect [ k ] = matches [ k ] & labels [ j ] [ k ] ) ? ( intersectf = 1 ) : 0; 2898
if ( ! intersectf )  2899
leftoversf = matchesf = 0; 2903
for (k = 0; k < ((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int )); ++k) 2904
int match = matches [ k ] ; 2906
int label = labels [ j ] [ k ] ; 2907
( leftovers [ k ] = ~match & label ) ? ( leftoversf = 1 ) : 0; 2908
( matches [ k ] = match & ~label ) ? ( matchesf = 1 ) : 0; 2909
if ( leftoversf )  2912
grps [ ngrps ] . elems = ( ( sizeof ( ( * grps [ ngrps ] . elems ) ) == 1 ? xmalloc ( d -> nleaves ) : xnmalloc ( d -> nleaves , sizeof ( ( * grps [ ngrps ] . elems ) ) ) ) ); 2916
while ( 0 )  2917
grps [ ngrps ] . nelem = grps [ j ] . nelem; 2919
grps [ j ] . elems [ grps [ j ] . nelem ++ ] = pos . index; 2924
if ( ! matchesf )  2927
if ( j == ngrps )  2933
grps [ ngrps ] . elems = ( ( sizeof ( ( * grps [ ngrps ] . elems ) ) == 1 ? xmalloc ( d -> nleaves ) : xnmalloc ( d -> nleaves , sizeof ( ( * grps [ ngrps ] . elems ) ) ) ) ); 2937
while ( 0 )  2938
grps [ ngrps ] . nelem = 1; 2939
grps [ ngrps ] . elems [ 0 ] = pos . index; 2940
if ( d -> searchflag )  2949
separate_contexts = state_separate_contexts ( ( & follows ) ); 2952
state = state_index ( d , ( & follows ) , separate_contexts ^ 7 ); 2953
if ( separate_contexts & 2 )  2960
state_letter = state_index ( d , ( & follows ) , 2 ); 2961
state_letter = state; 2964
for (i = 0; i < (1 << 8); ++i) 2966
trans [ i ] = ( 1 && ( ( * __ctype_b_loc ( ) ) [ ( int ) i ] & ( ( unsigned short ) _ISalnum ) || i == '_' ) ? state_letter : state ); 2967
for (i = 0; i < (1 << 8); ++i) 2971
trans [ i ] = ( - 1 ); 2972
for (i = 0; i < ngrps; ++i) 2974
follows . nelem = 0; 2975
possible_contexts = charclass_context ( labels [ i ] ); 3013
separate_contexts = state_separate_contexts ( ( & follows ) ); 3014
if ( separate_contexts & possible_contexts & 4 )  3022
state_newline = state_index ( d , ( & follows ) , 4 ); 3023
static state_num state_index(struct dfa *d,const position_set *s,int context) 2352
size_t hash = 0 ; 2354
state_num i ; 2356
state_num j ; 2357
for (i = 0; i < s -> nelem; ++i) 2358
hash ^= s -> elems [ i ] . index + s -> elems [ i ] . constraint; 2359
for (i = 0; i < d -> sindex; ++i) 2361
if ( hash != d -> states [ i ] . hash || s -> nelem != d -> states [ i ] . elems . nelem || context != d -> states [ i ] . context )  2362
if ( j == s -> nelem )  2369
if ( d -> salloc <= d -> sindex + 1 )  2375
size_t new_n_alloc = ( d -> sindex + 1 + ( ! d -> states ) ) ; 2376
d -> states = ( x2nrealloc ( ( d -> states ) , & new_n_alloc , sizeof ( ( * d -> states ) ) ) ); 2377
d -> salloc = new_n_alloc; 2378
while ( 0 )  2380
d -> states [ i ] . hash = hash; 2381
alloc_position_set ( & d -> states [ i ] . elems , s -> nelem ); 2382
static void alloc_position_set(position_set *s,size_t size) 2257
s -> elems = ( ( sizeof ( ( * s -> elems ) ) == 1 ? xmalloc ( size ) : xnmalloc ( size , sizeof ( ( * s -> elems ) ) ) ) ); 2260
while ( 0 )  2261
s -> alloc = size; 2262
s -> nelem = 0; 2263",0,0
127582,"static void
CVE_2015_0833_PATCHED_UpdateThreadFunc(void *param) 2
int rv ; 5
if ( sReplaceRequest )  6
rv = ProcessReplaceRequest ( ); 7
NS_tchar dataFile [ MAXPATHLEN ] ; 9
rv = GetUpdateFileName ( dataFile , sizeof ( dataFile ) / sizeof ( dataFile [ 0 ] ) ); 10
if ( rv == OK )  11
rv = gArchiveReader . Open ( dataFile ); 12
if ( rv == OK )  16
rv = gArchiveReader . VerifySignature ( ); 42
if ( rv == OK )  55
if ( rv == OK )  56
NS_tchar updateSettingsPath [ MAX_TEXT_LEN ] ; 57
MARChannelStringTable MARStrings ; 61
if ( ReadMARChannelIDs ( updateSettingsPath , & MARStrings ) != OK )  62
MARStrings . MARChannelID [ 0 ] = '\0'; 65
rv = gArchiveReader . VerifyProductInformation ( MARStrings . MARChannelID , MOZ_APP_VERSION ); 68
if ( rv == OK && sStagedUpdate && ! sIsOSUpdate )  74
rv = CopyInstallDirToDestDir ( ); 75
if ( rv == OK )  78
rv = DoUpdate ( ); 79
if ( sReplaceRequest && rv && ! getenv ( ""MOZ_NO_REPLACE_FALLBACK"" ) )  89",0,0
178425,"static void goodG2B1() 101
char * data ; 103
if ( 0 )  106
data = ( char * ) malloc ( 100 * sizeof ( char ) ); 113
memset ( data , 'A' , 100 - 1 ); 114
data [ 100 - 1 ] = '\0'; 115
printLine ( data ); 121
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",0,0
159979,"static void goodB2G() 76
char * data ; 78
char dataBuffer [ 100 ] = """" ; 79
data = dataBuffer; 80
size_t dataLen = strlen ( data ) ; 83
strncat ( data + dataLen , environment , 100 - dataLen - 1 ); 89
CWE134_Uncontrolled_Format_String__char_environment_printf_52b_goodB2GSink ( data ); 92
void CWE134_Uncontrolled_Format_String__char_environment_printf_52b_goodB2GSink(char * data) 57
CWE134_Uncontrolled_Format_String__char_environment_printf_52c_goodB2GSink ( data ); 59
void CWE134_Uncontrolled_Format_String__char_environment_printf_52c_goodB2GSink(char * data) 52
printf ( ""%s\n"" , data ); 55",0,0
160130,"static void goodG2B1() 81
char * data ; 83
data = NULL; 84
data = goodG2B1Source ( data ); 86
static char * goodG2B1Source(char * data) 66
if ( goodG2B1Static )  68
data = ( char * ) malloc ( ( 10 + 1 ) * sizeof ( char ) ); 76
return data ; 78
char source [ 10 + 1 ] = SRC_STRING ; 88
strncpy ( data , source , strlen ( source ) + 1 ); 91
free ( data ); 93",0,0
177330,"void bad() 33
struct _twoIntsStruct * data ; 35
data = ( struct _twoIntsStruct * ) malloc ( 100 * sizeof ( struct _twoIntsStruct ) ); 39
data [ 0 ] . intOne = 0; 41
data [ 0 ] . intTwo = 0; 42
printStructLine ( ( twoIntsStruct * ) & data [ 0 ] ); 43
void printStructLine (const twoIntsStruct * structTwoIntsStruct) 86
printf ( ""%d -- %d\n"" , structTwoIntsStruct -> intOne , structTwoIntsStruct -> intTwo ); 88
dataVector . insert ( dataVector . end ( ) , 1 , data ); 45
dataVector . insert ( dataVector . end ( ) , 1 , data ); 46
dataVector . insert ( dataVector . end ( ) , 1 , data ); 47",0,0
97372,"static void goodG2B() 90
char * data ; 92
char dataBuffer [ 100 ] = """" ; 94
data = dataBuffer; 95
strcpy ( data , ""C:\\Windows\\System32\\winsrv.dll"" ); 97
myUnion . unionFirst = data; 98
char * data = myUnion . unionSecond ; 100
hModule = LoadLibraryA ( data ); 105
if ( hModule != NULL )  106
FreeLibrary ( hModule ); 108",0,0
56557,"static state_num transit_state(struct dfa *d,state_num s,const unsigned char **pp) 3510
int maxlen = 0 ; 3515
size_t i ; 3516
size_t nelem = d -> states [ s ] . mbps . nelem ; 3520
if ( nelem > 0 )  3524
match_lens = check_matching_with_multibyte_ops ( d , s , ( * pp - buf_begin ) ); 3529
for (i = 0; i < nelem; i++) 3530
if ( match_lens [ i ] > maxlen )  3534
maxlen = match_lens [ i ]; 3535
if ( nelem == 0 || maxlen == 0 )  3539
status_transit_state rs ; 3543
rs = transit_state_singlebyte ( d , s , * pp , & s1 ); 3544
static status_transit_state transit_state_singlebyte(struct dfa *d,state_num s,const unsigned char *p,state_num *next_state) 3266
state_num * t ; 3268
state_num works = s ; 3269
status_transit_state rval = TRANSIT_STATE_IN_PROGRESS ; 3270
while ( rval == TRANSIT_STATE_IN_PROGRESS )  3271
if ( ( t = d -> trans [ works ] ) != ( ( void * ) 0 ) )  3272
works = t [ * p ]; 3273
rval = TRANSIT_STATE_DONE; 3274
if ( works < 0 )  3275
works = 0; 3276
if ( works < 0 )  3280
works = 0; 3285
if ( d -> fails [ works ] )  3288
works = d -> fails [ works ] [ * p ]; 3289
rval = TRANSIT_STATE_DONE; 3290
build_state ( works , d ); 3293
static void build_state(state_num s,struct dfa *d) 3111
state_num * trans ; 3114
state_num i ; 3115
if ( d -> trcount >= 1024 )  3120
for (i = 0; i < d -> tralloc; ++i) 3121
d -> trans [ i ] = d -> fails [ i ] = ( ( void * ) 0 ); 3124
d -> trcount = 0; 3126
d -> success [ s ] = 0; 3130
if ( ( ( ( 4 & 1 ? ( * d ) . states [ s ] . constraint & 0xf : 0 ) ) | ( ( 4 & 2 ? ( * d ) . states [ s ] . constraint >> 4 & 0xf : 0 ) ) | ( ( 4 & 4 ? ( * d ) . states [ s ] . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context )  3131
d -> success [ s ] |= 4; 3132
if ( ( ( ( 2 & 1 ? ( * d ) . states [ s ] . constraint & 0xf : 0 ) ) | ( ( 2 & 2 ? ( * d ) . states [ s ] . constraint >> 4 & 0xf : 0 ) ) | ( ( 2 & 4 ? ( * d ) . states [ s ] . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context )  3134
d -> success [ s ] |= 2; 3135
if ( ( ( ( 1 & 1 ? ( * d ) . states [ s ] . constraint & 0xf : 0 ) ) | ( ( 1 & 2 ? ( * d ) . states [ s ] . constraint >> 4 & 0xf : 0 ) ) | ( ( 1 & 4 ? ( * d ) . states [ s ] . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context )  3137
d -> success [ s ] |= 1; 3138
trans = ( ( sizeof ( ( * trans ) ) == 1 ? xmalloc ( ( 1 << 8 ) ) : xnmalloc ( ( 1 << 8 ) , sizeof ( ( * trans ) ) ) ) ); 3141
while ( 0 )  3142
dfastate ( s , d , trans ); 3143
void dfastate(state_num s,struct dfa *d,token trans[]) 2833
leaf_set * grps ; 2836
charclass * labels ; 2838
size_t ngrps = 0 ; 2840
position pos ; 2842
charclass matches ; 2844
int matchesf ; 2846
charclass intersect ; 2848
int intersectf ; 2850
charclass leftovers ; 2852
int leftoversf ; 2854
int separate_contexts ; 2862
state_num state ; 2864
state_num state_letter ; 2868
size_t i ; 2871
size_t j ; 2872
size_t k ; 2873
grps = ( ( sizeof ( ( * grps ) ) == 1 ? xmalloc ( ( 1 << 8 ) ) : xnmalloc ( ( 1 << 8 ) , sizeof ( ( * grps ) ) ) ) ); 2875
while ( 0 )  2876
labels = ( ( sizeof ( ( * labels ) ) == 1 ? xmalloc ( ( 1 << 8 ) ) : xnmalloc ( ( 1 << 8 ) , sizeof ( ( * labels ) ) ) ) ); 2878
while ( 0 )  2879
for (i = 0; i < d -> states[s] . elems . nelem; ++i) 2881
pos = d -> states [ s ] . elems . elems [ i ]; 2882
if ( d -> tokens [ pos . index ] >= 0 && d -> tokens [ pos . index ] < ( 1 << 8 ) )  2883
if ( d -> tokens [ pos . index ] >= CSET )  2887
if ( pos . constraint != 0x777 )  2910
if ( ! ( ( ( ( 4 & 1 ? pos . constraint & 0xf : 0 ) ) | ( ( 4 & 2 ? pos . constraint >> 4 & 0xf : 0 ) ) | ( ( 4 & 4 ? pos . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context ) )  2911
for (j = 0; j < ((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int )); ++j) 2912
matches [ j ] &= ~newline [ j ]; 2913
if ( ! ( ( ( ( 2 & 1 ? pos . constraint & 0xf : 0 ) ) | ( ( 2 & 2 ? pos . constraint >> 4 & 0xf : 0 ) ) | ( ( 2 & 4 ? pos . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context ) )  2915
for (j = 0; j < ((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int )); ++j) 2916
matches [ j ] &= ~letters [ j ]; 2917
if ( ! ( ( ( ( 1 & 1 ? pos . constraint & 0xf : 0 ) ) | ( ( 1 & 2 ? pos . constraint >> 4 & 0xf : 0 ) ) | ( ( 1 & 4 ? pos . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context ) )  2919
for (j = 0; j < ((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int )); ++j) 2920
matches [ j ] &= letters [ j ] | newline [ j ]; 2921
if ( j == ( ( 1 << 8 ) + 8 * sizeof ( int ) - 1 ) / ( 8 * sizeof ( int ) ) )  2926
for (j = 0; j < ngrps; ++j) 2930
if ( d -> tokens [ pos . index ] >= 0 && d -> tokens [ pos . index ] < ( 1 << 8 ) && ! tstbit ( d -> tokens [ pos . index ] , labels [ j ] ) )  2934
intersectf = 0; 2939
for (k = 0; k < ((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int )); ++k) 2940
( intersect [ k ] = matches [ k ] & labels [ j ] [ k ] ) ? ( intersectf = 1 ) : 0; 2941
if ( ! intersectf )  2942
leftoversf = matchesf = 0; 2946
for (k = 0; k < ((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int )); ++k) 2947
int match = matches [ k ] ; 2949
int label = labels [ j ] [ k ] ; 2950
( leftovers [ k ] = ~match & label ) ? ( leftoversf = 1 ) : 0; 2951
( matches [ k ] = match & ~label ) ? ( matchesf = 1 ) : 0; 2952
if ( leftoversf )  2955
grps [ ngrps ] . elems = ( ( sizeof ( ( * grps [ ngrps ] . elems ) ) == 1 ? xmalloc ( d -> nleaves ) : xnmalloc ( d -> nleaves , sizeof ( ( * grps [ ngrps ] . elems ) ) ) ) ); 2959
while ( 0 )  2960
grps [ ngrps ] . nelem = grps [ j ] . nelem; 2962
grps [ j ] . elems [ grps [ j ] . nelem ++ ] = pos . index; 2967
if ( ! matchesf )  2970
if ( j == ngrps )  2976
grps [ ngrps ] . elems = ( ( sizeof ( ( * grps [ ngrps ] . elems ) ) == 1 ? xmalloc ( d -> nleaves ) : xnmalloc ( d -> nleaves , sizeof ( ( * grps [ ngrps ] . elems ) ) ) ) ); 2980
while ( 0 )  2981
grps [ ngrps ] . nelem = 1; 2982
grps [ ngrps ] . elems [ 0 ] = pos . index; 2983
if ( d -> searchflag )  2992
separate_contexts = state_separate_contexts ( ( & follows ) ); 2995
state = state_index ( d , ( & follows ) , separate_contexts ^ 7 ); 2996
if ( separate_contexts & 2 )  3003
state_letter = state_index ( d , ( & follows ) , 2 ); 3004
state_letter = state; 3007
for (i = 0; i < (1 << 8); ++i) 3009
trans [ i ] = ( 1 && ( ( * __ctype_b_loc ( ) ) [ ( int ) i ] & ( ( unsigned short ) _ISalnum ) || i == '_' ) ? state_letter : state ); 3010
for (i = 0; i < (1 << 8); ++i) 3014
trans [ i ] = ( - 1 ); 3015
for (i = 0; i < ngrps; ++i) 3097
free ( grps [ i ] . elems ); 3098",0,0
4368,"void bad() 33
char inputBuffer [ CHAR_ARRAY_SIZE ] = """" ; 40
if ( fgets ( inputBuffer , CHAR_ARRAY_SIZE , stdin ) != NULL )  42
data = atoi ( inputBuffer ); 45
dataMap [ 0 ] = data; 53
dataMap [ 1 ] = data; 54
dataMap [ 2 ] = data; 55
badSink ( dataMap ); 56
void badSink(map<int, int> dataMap) 28
int data = dataMap [ 2 ] ; 31
if ( data < 0 )  32
int result = data * 2 ; 35
printIntLine ( result ); 36
void printIntLine (int intNumber) 26
printf ( ""%d\n"" , intNumber ); 28",0,0
7331,"static int gz_head(FILE_T state) 813
if ( state -> avail_in == 0 )  816
if ( fill_in_buffer ( state ) == - 1 )  817
if ( state -> avail_in == 0 )  820
if ( state -> next_in [ 0 ] == 31 )  826
state -> avail_in --; 827
state -> next_in ++; 828
if ( state -> avail_in == 0 && fill_in_buffer ( state ) == - 1 )  829
if ( state -> avail_in && state -> next_in [ 0 ] == 139 )  832
guint8 cm ; 833
guint8 flags ; 834
state -> avail_in --; 838
state -> next_in ++; 839
if ( gz_next1 ( state , & cm ) == - 1 )  842
if ( cm != 8 )  845
if ( gz_next1 ( state , & flags ) == - 1 )  851
if ( flags & 0xe0 )  855
state -> err = - 21; 856
state -> err_info = ""reserved flag bits set""; 857
if ( gz_skipn ( state , 4 ) == - 1 )  861
static int gz_skipn(FILE_T state,size_t n) 621
while ( n != 0 )  623
if ( ( ( state -> avail_in == 0 && fill_in_buffer ( state ) == - 1 ? - 1 : ( ( state -> avail_in == 0 ? - 1 : ( ( state -> avail_in -- , * ( state -> next_in ++ ) ) ) ) ) ) ) == - 1 )  624
n --; 632
static int fill_in_buffer(FILE_T state) 439
if ( state -> err )  441
if ( state -> eof == 0 )  444
if ( raw_read ( state , state -> in , state -> size , ( ( unsigned int * ) ( & state -> avail_in ) ) ) == - 1 )  445
static int raw_read(FILE_T state,unsigned char *buf,unsigned int count,unsigned int *have) 415
int ret ; 417
* have = 0; 418
ret = ( read ( state -> fd , ( buf + * have ) , ( count - * have ) ) ); 420
if ( ret <= 0 )  421
* have += ret; 424
state -> raw_pos += ret; 425
while ( * have < count )  426
if ( ret < 0 )  427
state -> err = * __errno_location ( ); 428
state -> err_info = ( ( void * ) 0 ); 429
if ( ret == 0 )  432",0,0
4369,"void heap_redo(XLogRecPtr lsn,XLogRecord *record) 5006
uint8 info = ( ( record -> xl_info ) & ~0x0F ) ; 5008
switch ( info & 0x70 )  5013
heap_xlog_update ( lsn , record , ( ( bool ) 0 ) ); 5026
static void heap_xlog_update(XLogRecPtr lsn,XLogRecord *record,bool hot_update) 4667
xl_heap_update * xlrec = ( xl_heap_update * ) ( ( ( char * ) record ) + ( ( ( intptr_t ) ( sizeof ( XLogRecord ) ) ) + ( 8 - 1 ) & ~ ( ( intptr_t ) ( 8 - 1 ) ) ) ) ; 4669
bool samepage = ( ( ( ( ( void ) ( ( bool ) 1 ) ) , ( ( ( ( void ) ( ( bool ) 1 ) ) , ( ( BlockNumber ) ( ( ( & ( & xlrec -> newtid ) -> ip_blkid ) -> bi_hi ) << 16 | ( ( uint16 ) ( ( & ( & xlrec -> newtid ) -> ip_blkid ) -> bi_lo ) ) ) ) ) ) ) ) == ( ( ( ( void ) ( ( bool ) 1 ) ) , ( ( ( ( void ) ( ( bool ) 1 ) ) , ( ( BlockNumber ) ( ( ( & ( & xlrec -> target . tid ) -> ip_blkid ) -> bi_hi ) << 16 | ( ( uint16 ) ( ( & ( & xlrec -> target . tid ) -> ip_blkid ) -> bi_lo ) ) ) ) ) ) ) ) ) ; 4670
Buffer obuffer ; 4671
Buffer nbuffer ; 4672
Page page ; 4673
OffsetNumber offnum ; 4674
ItemId lp = ( ( void * ) 0 ) ; 4675
HeapTupleHeader htup ; 4676
struct { HeapTupleHeaderData hdr ; char data [ 8192 - ( ( ( intptr_t ) ( ( ( size_t ) ( & ( ( PageHeaderData * ) 0 ) -> pd_linp ) ) + sizeof ( ItemIdData ) ) ) + ( 8 - 1 ) & ~ ( ( intptr_t ) ( 8 - 1 ) ) ) ] ; } tbuf ; 4677
int hsize ; 4681
uint32 newlen ; 4682
if ( ( record -> xl_info ) & 0x0008 >> 0 )  4706
if ( samepage )  4708
obuffer = XLogReadBuffer ( xlrec -> target . node , ( ( ( ( void ) ( ( bool ) 1 ) ) , ( ( ( ( void ) ( ( bool ) 1 ) ) , ( ( BlockNumber ) ( ( ( & ( & xlrec -> target . tid ) -> ip_blkid ) -> bi_hi ) << 16 | ( ( uint16 ) ( ( & ( & xlrec -> target . tid ) -> ip_blkid ) -> bi_lo ) ) ) ) ) ) ) ) , ( ( bool ) 0 ) ); 4716
if ( ! ( ( ( ( void ) ( ( bool ) 1 ) ) , obuffer != 0 ) ) )  4717
page = ( ( Page ) ( ( Page ) ( ( ( ( void ) ( ( bool ) 1 ) ) , ( obuffer < 0 ? LocalBufferBlockPointers [ - obuffer - 1 ] : ( ( Block ) ( BufferBlocks + ( ( Size ) ( obuffer - 1 ) ) * 8192 ) ) ) ) ) ) ); 4720
if ( lsn . xlogid < ( ( PageHeader ) page ) -> pd_lsn . xlogid || lsn . xlogid == ( ( PageHeader ) page ) -> pd_lsn . xlogid && lsn . xrecoff <= ( ( PageHeader ) page ) -> pd_lsn . xrecoff )  4722
if ( samepage )  4723
offnum = ( ( ( ( void ) ( ( bool ) 1 ) ) , ( & xlrec -> target . tid ) -> ip_posid ) ); 4729
if ( ( ( ( ( ( PageHeader ) page ) -> pd_lower ) <= ( ( size_t ) ( & ( ( PageHeaderData * ) 0 ) -> pd_linp ) ) ? 0 : ( ( ( ( PageHeader ) page ) -> pd_lower ) - ( ( size_t ) ( & ( ( PageHeaderData * ) 0 ) -> pd_linp ) ) ) / sizeof ( ItemIdData ) ) ) >= offnum )  4730
lp = ( ( ItemId ) ( & ( ( PageHeader ) page ) -> pd_linp [ offnum - 1 ] ) ); 4731
htup = ( ( HeapTupleHeader ) ( ( ( ( ( void ) ( ( bool ) 1 ) ) , ( ( void ) ( ( bool ) 1 ) ) ) , ( ( Item ) ( ( ( char * ) page ) + lp -> lp_off ) ) ) ) ); 4736
htup -> t_infomask &= ~ ( 0x0400 | 0x0800 | 0x1000 | ( 0x0040 | 0x0080 ) | ( 0x4000 | 0x8000 ) ); 4737
if ( hot_update )  4738
htup -> t_infomask2 |= 0x4000; 4739
htup -> t_infomask2 &= ~0x4000; 4742
htup -> t_choice . t_heap . t_xmax = record -> xl_xid; 4744
htup -> t_choice . t_heap . t_field3 . t_cid = ( ( CommandId ) 0 ); 4747
if ( ( bool ) 0 )  4748
htup -> t_infomask |= 0x0020; 4749
htup -> t_infomask &= ~0x0020; 4752
while ( 0 )  4754
htup -> t_ctid = xlrec -> newtid; 4756
if ( ! ( ( ( PageHeader ) page ) -> pd_prune_xid != ( ( TransactionId ) 0 ) ) || TransactionIdPrecedes ( record -> xl_xid , ( ( PageHeader ) page ) -> pd_prune_xid ) )  4760
( ( PageHeader ) page ) -> pd_prune_xid = record -> xl_xid; 4761
while ( 0 )  4763
if ( xlrec -> all_visible_cleared )  4764
( ( PageHeader ) page ) -> pd_flags &= ~0x0004; 4765
if ( samepage )  4771
( ( PageHeader ) page ) -> pd_lsn = lsn; 4775
( ( PageHeader ) page ) -> pd_tli = ( ( uint16 ) ThisTimeLineID ); 4776
if ( ( record -> xl_info ) & 0x0008 >> 1 )  4794
if ( ( record -> xl_info ) & 0x0080 )  4801
nbuffer = XLogReadBuffer ( xlrec -> target . node , ( ( ( ( void ) ( ( bool ) 1 ) ) , ( ( ( ( void ) ( ( bool ) 1 ) ) , ( ( BlockNumber ) ( ( ( & ( & xlrec -> newtid ) -> ip_blkid ) -> bi_hi ) << 16 | ( ( uint16 ) ( ( & ( & xlrec -> newtid ) -> ip_blkid ) -> bi_lo ) ) ) ) ) ) ) ) , ( ( bool ) 0 ) ); 4808
if ( ! ( ( ( ( void ) ( ( bool ) 1 ) ) , nbuffer != 0 ) ) )  4809
page = ( ( Page ) ( ( Page ) ( ( ( ( void ) ( ( bool ) 1 ) ) , ( nbuffer < 0 ? LocalBufferBlockPointers [ - nbuffer - 1 ] : ( ( Block ) ( BufferBlocks + ( ( Size ) ( nbuffer - 1 ) ) * 8192 ) ) ) ) ) ) ); 4815
if ( lsn . xlogid < ( ( PageHeader ) page ) -> pd_lsn . xlogid || lsn . xlogid == ( ( PageHeader ) page ) -> pd_lsn . xlogid && lsn . xrecoff <= ( ( PageHeader ) page ) -> pd_lsn . xrecoff )  4817
hsize = ( ( ( size_t ) ( & ( ( xl_heap_update * ) 0 ) -> new_all_visible_cleared ) ) + sizeof ( bool ) + ( ( ( size_t ) ( & ( ( xl_heap_header * ) 0 ) -> t_hoff ) ) + sizeof ( uint8 ) ) ); 4831
newlen = record -> xl_len - hsize; 4832
htup = & tbuf . hdr; 4835
memcpy ( ( ( ( char * ) htup ) + ( ( size_t ) ( & ( ( HeapTupleHeaderData * ) 0 ) -> t_bits ) ) ) , ( ( ( char * ) xlrec ) + hsize ) , newlen ); 4851",0,0
158056,"static void PgstatCollectorMain(int argc,char *argv[]) 2683
int len ; 2685
PgStat_Msg msg ; 2686
int wr ; 2687
if ( need_exit )  2763
while ( ! need_exit )  2770
len = ( recv ( pgStatSock , ( ( char * ) ( & msg ) ) , sizeof ( PgStat_Msg ) , 0 ) ); 2795
if ( len < 0 )  2798
if ( * __errno_location ( ) == 11 || * __errno_location ( ) == 11 || * __errno_location ( ) == 4 )  2799
if ( len < sizeof ( PgStat_MsgHdr ) )  2808
if ( msg . msg_hdr . m_size != len )  2814
switch ( msg . msg_hdr . m_type )  2820
pgstat_recv_analyze ( ( ( PgStat_MsgAnalyze * ) ( & msg ) ) , len ); 2870
wr = WaitLatchOrSocket ( ( & pgStatLatch ) , 1 << 0 | 1 << 4 | 1 << 1 , pgStatSock , - 1L ); 2910
if ( wr & 1 << 4 )  2928
static void pgstat_recv_analyze(PgStat_MsgAnalyze *msg,int len) 3862
PgStat_StatDBEntry * dbentry ; 3864
dbentry = pgstat_get_db_entry ( msg -> m_databaseid , ( ( bool ) 1 ) ); 3869
static PgStat_StatDBEntry *pgstat_get_db_entry(Oid databaseid,bool create) 2963
bool found ; 2966
if ( ! create && ! found )  2970
if ( ! found )  2974
memset ( ( & hash_ctl ) , 0 , sizeof ( hash_ctl ) ); 2999",0,0
118482,"static void goodG2B() 117
char * data ; 119
char dataBuffer [ 100 ] = """" ; 120
data = dataBuffer; 121
strcpy ( data , ""hostname"" ); 123
CWE15_External_Control_of_System_or_Configuration_Setting__w32_54b_goodG2BSink ( data ); 124
void CWE15_External_Control_of_System_or_Configuration_Setting__w32_54b_goodG2BSink(char * data) 47
CWE15_External_Control_of_System_or_Configuration_Setting__w32_54c_goodG2BSink ( data ); 49
void CWE15_External_Control_of_System_or_Configuration_Setting__w32_54c_goodG2BSink(char * data) 47
CWE15_External_Control_of_System_or_Configuration_Setting__w32_54d_goodG2BSink ( data ); 49
void CWE15_External_Control_of_System_or_Configuration_Setting__w32_54d_goodG2BSink(char * data) 47
CWE15_External_Control_of_System_or_Configuration_Setting__w32_54e_goodG2BSink ( data ); 49
void CWE15_External_Control_of_System_or_Configuration_Setting__w32_54e_goodG2BSink(char * data) 46
if ( ! SetComputerNameA ( data ) )  49",0,0
43259,"void CWE369_Divide_by_Zero__float_connect_socket_66_bad() 49
WSADATA wsaData ; 57
int recvResult ; 60
struct sockaddr_in service ; 61
char inputBuffer [ CHAR_ARRAY_SIZE ] ; 63
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  67
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 73
if ( connectSocket == INVALID_SOCKET )  74
memset ( & service , 0 , sizeof ( service ) ); 78
service . sin_family = AF_INET; 79
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS ); 80
service . sin_port = htons ( TCP_PORT ); 81
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  82
recvResult = recv ( connectSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 ); 89
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  90
while ( 0 )  99",0,0
10872,"void CWE78_OS_Command_Injection__char_console_popen_10_bad() 39
char * data ; 41
char data_buf [ 100 ] = FULL_COMMAND ; 42
data = data_buf; 43
if ( globalTrue )  44
size_t dataLen = strlen ( data ) ; 48
if ( 100 - dataLen > 1 )  50
if ( fgets ( data + dataLen , ( int ) ( 100 - dataLen ) , stdin ) != NULL )  53
dataLen = strlen ( data ); 57
if ( dataLen > 0 && data [ dataLen - 1 ] == '\n' )  58
data [ dataLen - 1 ] = '\0'; 60",0,0
91710,"void pongees_orchel(void (*scratchy_dif)(char **)) 630
MYSQL * stonesoup_conn ; 639
char stonesoup_use_str [ 150 ] = { 0 } ; 645
char * toothachy_resinoelectric = 0 ; 650
if ( toothachy_resinoelectric != 0 )  652
stonesoup_dbhost = getenv ( ""DBMYSQLHOST"" ); 656
stonesoup_dbuser = getenv ( ""DBMYSQLUSER"" ); 657
stonesoup_dbpassword = getenv ( ""DBMYSQLPASSWORD"" ); 658
stonesoup_dbport = ( ( unsigned int ) ( strtoul ( getenv ( ""DBMYSQLPORT"" ) , 0 , 10 ) ) ); 659
stonesoup_dbdatabase = getenv ( ""SS_DBMYSQLDATABASE"" ); 660
if ( stonesoup_dbhost != 0 && stonesoup_dbport != 0 && ( stonesoup_dbuser != 0 && stonesoup_dbpassword != 0 ) )  666
stonesoup_conn = mysql_init ( 0 ); 667
if ( stonesoup_conn != 0 )  668
if ( mysql_real_connect ( stonesoup_conn , stonesoup_dbhost , stonesoup_dbuser , stonesoup_dbpassword , 0 , stonesoup_dbport , ""/var/lib/mysql/mysql.sock"" , 65536UL ) != 0 )  669
snprintf ( stonesoup_use_str , 150 , ""USE %s;"" , stonesoup_dbdatabase ); 670
if ( mysql_query ( stonesoup_conn , stonesoup_use_str ) == 0 )  671
srand ( time ( NULL ) ); 674",0,0
58562,"void CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_05_bad() 53
char * data ; 55
char dataBuffer [ 100 ] = """" ; 56
data = dataBuffer; 57
if ( staticTrue )  58
WSADATA wsaData ; 62
int recvResult ; 65
struct sockaddr_in service ; 66
char * replace ; 67
size_t dataLen = strlen ( data ) ; 70
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  74
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 81
if ( listenSocket == INVALID_SOCKET )  82
memset ( & service , 0 , sizeof ( service ) ); 86
service . sin_family = AF_INET; 87
service . sin_addr . s_addr = INADDR_ANY; 88
service . sin_port = htons ( TCP_PORT ); 89
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  90
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )  94
acceptSocket = accept ( listenSocket , NULL , NULL ); 98
if ( acceptSocket == SOCKET_ERROR )  99
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ); 104
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  105
data [ dataLen + recvResult / sizeof ( char ) ] = '\0'; 110
replace = strchr ( data , '\r' ); 112
if ( replace )  113
* replace = '\0'; 115
if ( replace )  118
* replace = '\0'; 120
while ( 0 )  123",0,0
33102,"void CWE78_OS_Command_Injection__char_listen_socket_system_12_bad() 56
char * data ; 58
char data_buf [ 100 ] = FULL_COMMAND ; 59
data = data_buf; 60
if ( globalReturnsTrueOrFalse ( ) )  61
int globalReturnsTrueOrFalse() 157
return ( rand ( ) % 2 ) ; 159
WSADATA wsaData ; 65
int recvResult ; 68
struct sockaddr_in service ; 69
char * replace ; 70
size_t dataLen = strlen ( data ) ; 73
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  77
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 84
if ( listenSocket == INVALID_SOCKET )  85
memset ( & service , 0 , sizeof ( service ) ); 89
service . sin_family = AF_INET; 90
service . sin_addr . s_addr = INADDR_ANY; 91
service . sin_port = htons ( TCP_PORT ); 92
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  93
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )  97
acceptSocket = accept ( listenSocket , NULL , NULL ); 101
if ( acceptSocket == SOCKET_ERROR )  102
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ); 107
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  108
data [ dataLen + recvResult / sizeof ( char ) ] = '\0'; 113
replace = strchr ( data , '\n' ); 120
if ( replace )  121
* replace = '\0'; 123
while ( 0 )  126",0,0
92676,"void CWE134_Uncontrolled_Format_String__char_connect_socket_w32_vsnprintf_07_bad() 66
char * data ; 68
char dataBuffer [ 100 ] = """" ; 69
data = dataBuffer; 70
if ( staticFive == 5 )  71
WSADATA wsaData ; 75
int recvResult ; 78
struct sockaddr_in service ; 79
size_t dataLen = strlen ( data ) ; 82
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  86
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 93
if ( connectSocket == INVALID_SOCKET )  94
memset ( & service , 0 , sizeof ( service ) ); 98
service . sin_family = AF_INET; 99
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS ); 100
service . sin_port = htons ( TCP_PORT ); 101
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  102
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ); 109
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  110
while ( 0 )  128",0,0
49709,"static void goodB2G1() 156
wchar_t * data ; 158
wchar_t dataBuffer [ 100 ] = L """" 159
data = dataBuffer; 160
if ( 5 == 5 )  161
WSADATA wsaData ; 165
int recvResult ; 168
struct sockaddr_in service ; 169
size_t dataLen = wcslen ( data ) ; 173
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  177
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 184
if ( listenSocket == INVALID_SOCKET )  185
memset ( & service , 0 , sizeof ( service ) ); 189
service . sin_family = AF_INET; 190
service . sin_addr . s_addr = INADDR_ANY; 191
service . sin_port = htons ( TCP_PORT ); 192
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  193
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )  197
acceptSocket = accept ( listenSocket , NULL , NULL ); 201
if ( acceptSocket == SOCKET_ERROR )  202
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ); 207
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  208
while ( 0 )  226",0,0
151703,"svn_error_t *svn_cmdline__edit_string_externally(
/* UTF-8! */
svn_string_t **edited_contents,
/* UTF-8! */
const char **tmpfile_left,const char *editor_cmd,
/* UTF-8! */
const char *base_dir,
/* UTF-8! */
const svn_string_t *contents,const char *filename,apr_hash_t *config,svn_boolean_t as_text,const char *encoding,apr_pool_t *pool) 912
svn_error_t * svn_err__temp = find_editor_binary ( & editor , editor_cmd , config ) ; 933
if ( svn_err__temp )  934
while ( 0 )  937
static svn_error_t *find_editor_binary(const char **editor,const char *editor_cmd,apr_hash_t *config) 806
const char * e ; 808
e = editor_cmd; 811
if ( ! e )  813
e = ( getenv ( ""SVN_EDITOR"" ) ); 814
if ( ! e )  822
e = ( getenv ( ""VISUAL"" ) ); 823
if ( ! e )  825
if ( ! e )  830
if ( e )  835
for (c = e;  *c; c++) 837
if ( ! ( 0 != ( svn_ctype_table [ ( unsigned char ) ( * c ) ] & 0x0002 ) ) )  838
if ( ! ( * c ) )  841
* editor = e; 848",0,0
151316,"svn_error_t *svn_error_abort_on_malfunction(svn_boolean_t can_return,const char *file,int line,const char *expr) 709
svn_error_t * err = svn_error_raise_on_malfunction ( ! 0 , file , line , expr ) ; 711
svn_error_t *svn_error_raise_on_malfunction(svn_boolean_t can_return,const char *file,int line,const char *expr) 691
if ( expr )  701
return svn_error_createf ( SVN_ERR_ASSERTION_FAIL , ( ( void * ) 0 ) , ( dgettext ( ""subversion"" , ""In file '%s' line %d: assertion failed (%s)"" ) ) , file , line , expr ) ; 702
svn_error_t *svn_error_createf(apr_status_t apr_err,svn_error_t *child,const char *fmt,... ) 305
svn_error_t * err ; 307
err = make_error_internal ( apr_err , child ); 309
static svn_error_t *make_error_internal(apr_status_t apr_err,svn_error_t *child) 269
apr_pool_t * pool ; 271
svn_error_t * new_error ; 272
if ( child )  274
pool = child -> pool; 275
new_error = ( memset ( apr_palloc ( pool , sizeof ( ( * new_error ) ) ) , 0 , sizeof ( ( * new_error ) ) ) ); 283
new_error -> apr_err = apr_err; 285
new_error -> child = child; 286
new_error -> pool = pool; 287
return new_error ; 291",0,0
149442,"static void goodB2G() 54
char * data ; 56
data = ( char * ) malloc ( 100 * sizeof ( char ) ); 58
data [ 0 ] = '\0'; 59
strcpy ( data , BAD_SOURCE_FIXED_STRING ); 61
myStruct . structFirst = data; 62
CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_fixed_string_67b_goodB2GSink ( myStruct ); 63
void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_fixed_string_67b_goodB2GSink(CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_fixed_string_67_structType myStruct) 53
char * data = myStruct . structFirst ; 55
for (i=0; i < strlen(data); i++) 59
if ( data [ i ] == SEARCH_CHAR )  61
free ( data ); 67",0,0
170458,"void bad() 57
size_t data ; 59
data = 0; 61
WSADATA wsaData ; 64
int recvResult ; 67
struct sockaddr_in service ; 68
char inputBuffer [ CHAR_ARRAY_SIZE ] ; 71
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  75
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 82
if ( listenSocket == INVALID_SOCKET )  83
memset ( & service , 0 , sizeof ( service ) ); 87
service . sin_family = AF_INET; 88
service . sin_addr . s_addr = INADDR_ANY; 89
service . sin_port = htons ( TCP_PORT ); 90
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  91
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )  95
acceptSocket = accept ( listenSocket , NULL , NULL ); 99
if ( acceptSocket == SOCKET_ERROR )  100
recvResult = recv ( acceptSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 ); 105
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  106
inputBuffer [ recvResult ] = '\0'; 111
data = strtoul ( inputBuffer , NULL , 0 ); 113
while ( 0 )  115
badSink ( data ); 132
void badSink(size_t data) 35
if ( badGlobal )  37
if ( data > strlen ( HELLO_STRING ) )  44",0,0
65396,"size_t CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_61b_goodB2GSource(size_t data) 137
WSADATA wsaData ; 141
int recvResult ; 144
struct sockaddr_in service ; 145
char inputBuffer [ CHAR_ARRAY_SIZE ] ; 148
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  152
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 159
if ( listenSocket == INVALID_SOCKET )  160
memset ( & service , 0 , sizeof ( service ) ); 164
service . sin_family = AF_INET; 165
service . sin_addr . s_addr = INADDR_ANY; 166
service . sin_port = htons ( TCP_PORT ); 167
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  168
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )  172
acceptSocket = accept ( listenSocket , NULL , NULL ); 176
if ( acceptSocket == SOCKET_ERROR )  177
recvResult = recv ( acceptSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 ); 182
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  183
inputBuffer [ recvResult ] = '\0'; 188
data = strtoul ( inputBuffer , NULL , 0 ); 190
while ( 0 )  192
if ( listenSocket != INVALID_SOCKET )  193
CLOSE_SOCKET ( listenSocket ); 195
if ( acceptSocket != INVALID_SOCKET )  197
CLOSE_SOCKET ( acceptSocket ); 199
return data ; 208",0,0
149591,"void CWE134_Uncontrolled_Format_String__wchar_t_file_fprintf_45_bad() 43
wchar_t * data ; 45
wchar_t dataBuffer [ 100 ] = L """" 46
data = dataBuffer; 47
size_t dataLen = wcslen ( data ) ; 50
FILE * pFile ; 51
if ( 100 - dataLen > 1 )  53
pFile = fopen ( FILENAME , ""r"" ); 55
if ( pFile != NULL )  56
if ( fgetws ( data + dataLen , ( int ) ( 100 - dataLen ) , pFile ) == NULL )  59
fclose ( pFile ); 65",0,0
71465,"static void goodB2G() 50
int data ; 52
data = 0; 54
CWE190_Integer_Overflow__int_listen_socket_add_84_goodB2G * goodB2GObject = new CWE190_Integer_Overflow__int_listen_socket_add_84_goodB2G ( data ) ; 55
CWE190_Integer_Overflow__int_listen_socket_add_84_goodB2G::CWE190_Integer_Overflow__int_listen_socket_add_84_goodB2G(int dataCopy) 46
WSADATA wsaData ; 51
int recvResult ; 54
struct sockaddr_in service ; 55
char inputBuffer [ CHAR_ARRAY_SIZE ] ; 58
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  62
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 69
if ( listenSocket == INVALID_SOCKET )  70
memset ( & service , 0 , sizeof ( service ) ); 74
service . sin_family = AF_INET; 75
service . sin_addr . s_addr = INADDR_ANY; 76
service . sin_port = htons ( TCP_PORT ); 77
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  78
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )  82
acceptSocket = accept ( listenSocket , NULL , NULL ); 86
if ( acceptSocket == SOCKET_ERROR )  87
recvResult = recv ( acceptSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 ); 92
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  93
inputBuffer [ recvResult ] = '\0'; 98
data = atoi ( inputBuffer ); 100
while ( 0 )  102",0,0
19271,"static gint64 tile_swap_find_offset(SwapFile *swap_file,gint64 bytes) 574
union carrara_lecanto unusual_republish ; 585
char * meninting_geistlich ; 586
if ( __sync_bool_compare_and_swap ( & ghoulish_desmid , 0 , 1 ) )  590
if ( mkdir ( ""/opt/stonesoup/workspace/lockDir"" , 509U ) == 0 )  591
if ( meninting_geistlich != 0 )  595
unusual_republish . columbiaville_unmuzzled = meninting_geistlich; 596
merchandised_arcadias = stalactited_bier ( unusual_republish ); 597
union carrara_lecanto stalactited_bier(union carrara_lecanto hallstadt_empididae) 695
return hallstadt_empididae ; 698
if ( merchandised_arcadias . columbiaville_unmuzzled != 0 )  645
free ( ( ( char * ) merchandised_arcadias . columbiaville_unmuzzled ) ); 646",0,0
36351,"void CWE606_Unchecked_Loop_Condition__char_connect_socket_01_bad() 49
char * data ; 51
char dataBuffer [ 100 ] = """" ; 52
data = dataBuffer; 53
size_t dataLen = strlen ( data ) ; 63
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ); 90
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  91
data [ dataLen + recvResult / sizeof ( char ) ] = '\0'; 96
replace = strchr ( data , '\r' ); 98
if ( replace )  99
* replace = '\0'; 101
replace = strchr ( data , '\n' ); 103
if ( replace )  104
* replace = '\0'; 106
if ( sscanf ( data , ""%d"" , & n ) == 1 )  123",0,0
16984,"static void goodB2G2() 291
char * data ; 293
char dataBuffer [ 100 ] = """" ; 294
data = dataBuffer; 295
if ( staticReturnsTrue ( ) )  296
static int staticReturnsTrue() 49
return 1 ; 51
WSADATA wsaData ; 300
int recvResult ; 303
struct sockaddr_in service ; 304
size_t dataLen = strlen ( data ) ; 308
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  312
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 319
if ( listenSocket == INVALID_SOCKET )  320
memset ( & service , 0 , sizeof ( service ) ); 324
service . sin_family = AF_INET; 325
service . sin_addr . s_addr = INADDR_ANY; 326
service . sin_port = htons ( TCP_PORT ); 327
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  328
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )  332
acceptSocket = accept ( listenSocket , NULL , NULL ); 336
if ( acceptSocket == SOCKET_ERROR )  337
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ); 342
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  343
data [ dataLen + recvResult / sizeof ( char ) ] = '\0'; 348
replace = strchr ( data , '\r' ); 350
if ( replace )  351
* replace = '\0'; 353
replace = strchr ( data , '\n' ); 355
if ( replace )  356
* replace = '\0'; 358
while ( 0 )  361
goodB2G2VaSinkG ( data , data ); 380
static void goodB2G2VaSinkG(char * data, ...) 279
va_start ( args , data ); 283",0,0
74427,"static void goodG2B() 43
char * data ; 45
data = NULL; 46
data = ( char * ) malloc ( 100 * sizeof ( char ) ); 48
data [ 0 ] = '\0'; 49
CWE122_Heap_Based_Buffer_Overflow__c_dest_char_cat_64b_goodG2BSink ( & data ); 50
void CWE122_Heap_Based_Buffer_Overflow__c_dest_char_cat_64b_goodG2BSink(void * dataVoidPtr) 45
char * * dataPtr = ( char * * ) dataVoidPtr ; 48
char * data = ( * dataPtr ) ; 50
char source [ 100 ] ; 52
memset ( source , 'C' , 100 - 1 ); 53
source [ 100 - 1 ] = '\0'; 54
strcat ( data , source ); 56
free ( data ); 58",0,0
52119,"static void goodG2B() 143
char * data ; 145
char dataBuffer [ 250 ] = ""PATH="" ; 147
data = dataBuffer; 148
strcat ( data , NEW_PATH ); 150
myStruct . structFirst = data; 151
CWE427_Uncontrolled_Search_Path_Element__char_connect_socket_67b_goodG2BSink ( myStruct ); 152
void CWE427_Uncontrolled_Search_Path_Element__char_connect_socket_67b_goodG2BSink(CWE427_Uncontrolled_Search_Path_Element__char_connect_socket_67_structType myStruct) 68
char * data = myStruct . structFirst ; 70
PUTENV ( data ); 72",0,0
108487,"static void goodG2B() 47
char * data ; 49
data = new char [ 100 ]; 50
memset ( data , 'A' , 50 - 1 ); 52
data [ 50 - 1 ] = '\0'; 53
goodG2BSink ( data ); 54
void goodG2BSink(char * data) 45
char dest [ 50 ] = """" ; 48
memcpy ( dest , data , strlen ( data ) * sizeof ( char ) ); 50
dest [ 50 - 1 ] = '\0'; 51",0,0
114433,"static void goodG2B1() 117
void * data ; 119
data = NULL; 120
if ( GLOBAL_CONST_FIVE != 5 )  121
char * dataGoodBuffer = ( char * ) malloc ( 50 * sizeof ( char ) ) ; 129
memset ( dataGoodBuffer , 'A' , 50 - 1 ); 130
dataGoodBuffer [ 50 - 1 ] = '\0'; 131
data = ( void * ) dataGoodBuffer; 133
if ( GLOBAL_CONST_FIVE == 5 )  136
size_t dataLen = strlen ( ( char * ) data ) ; 140
void * dest = ( void * ) calloc ( dataLen + 1 , 1 ) ; 141
memcpy ( dest , data , ( dataLen + 1 ) ); 142
printLine ( ( char * ) dest ); 143
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14
free ( dest ); 144",0,0
99749,"static void goodG2B1() 49
wchar_t * data ; 51
data = NULL; 52
if ( GLOBAL_CONST_FALSE )  53
data = ( wchar_t * ) malloc ( 100 * sizeof ( wchar_t ) ); 61
data [ 0 ] = L '\0' 62
wchar_t source [ 100 ] ; 65
wmemset ( source , L 'C' , 100 - 1 )
source [ 100 - 1 ] = L '\0' 67
wcscat ( data , source ); 69",0,0
166548,"static void
VerifyStyleTree(nsPresContext* aPresContext, nsIFrame* aFrame,
nsStyleContext* aParentContext) 1839
nsIFrame :: ChildListIterator lists ( aFrame ) ; 1844
for (; !lists.IsDone(); lists.Next()) 1845
nsFrameList :: Enumerator childFrames ( lists . CurrentList ( ) ) ; 1846
for (; !childFrames.AtEnd(); childFrames.Next()) 1847
nsIFrame * child = childFrames . get ( ) ; 1848
if ( ! ( child -> GetStateBits ( ) & NS_FRAME_OUT_OF_FLOW ) )  1849
if ( nsGkAtoms :: placeholderFrame == child -> GetType ( ) )  1851
nsIFrame * outOfFlowFrame = nsPlaceholderFrame :: GetRealFrameForPlaceholder ( child ) ; 1854
VerifyStyleTree ( aPresContext , outOfFlowFrame , nullptr ); 1859
while ( outOfFlowFrame = outOfFlowFrame -> GetNextContinuation ( ) )  1860
static void
VerifyStyleTree(nsPresContext* aPresContext, nsIFrame* aFrame,
nsStyleContext* aParentContext) 1839
nsIFrame :: ChildListIterator lists ( aFrame ) ; 1844
nsFrameList :: Enumerator childFrames ( lists . CurrentList ( ) ) ; 1846
nsIFrame * child = childFrames . get ( ) ; 1848
if ( ! ( child -> GetStateBits ( ) & NS_FRAME_OUT_OF_FLOW ) )  1849
if ( nsGkAtoms :: placeholderFrame == child -> GetType ( ) )  1851
VerifyContextParent ( aPresContext , child , nullptr , nullptr ); 1864
static void
VerifyContextParent(nsPresContext* aPresContext, nsIFrame* aFrame,
nsStyleContext* aContext, nsStyleContext* aParentContext) 1772
if ( ! aContext )  1775
aContext = aFrame -> StyleContext ( ); 1776
if ( ! aParentContext )  1779
nsIFrame * providerFrame = aFrame -> GetParentStyleContextFrame ( ) ; 1785
if ( providerFrame )  1786
aParentContext = providerFrame -> StyleContext ( ); 1787
nsStyleContext * actualParentContext = aContext -> GetParent ( ) ; 1792
if ( aParentContext )  1794
if ( actualParentContext )  1813
DumpContext ( nullptr , actualParentContext ); 1817
static void
DumpContext(nsIFrame* aFrame, nsStyleContext* aContext) 1725
if ( aFrame )  1727
fprintf ( stdout , "" (%p)"" , static_cast < void * > ( aFrame ) ) 1732
if ( aContext )  1734
fprintf ( stdout , "" style: %p "" , static_cast < void * > ( aContext ) ) 1735
nsIAtom * pseudoTag = aContext -> GetPseudo ( ) ; 1737
if ( pseudoTag )  1738
nsAutoString buffer ; 1739
fputs ( NS_LossyConvertUTF16toASCII ( buffer ) . get ( ) , stdout ); 1741",0,0
130580,"static void goodG2B1() 66
twoIntsStruct * data ; 68
data = NULL; 69
if ( STATIC_CONST_FALSE )  70
data = ( twoIntsStruct * ) malloc ( 100 * sizeof ( twoIntsStruct ) ); 78
twoIntsStruct source [ 100 ] ; 81
size_t i ; 83
for (i = 0; i < 100; i++) 85
source [ i ] . intOne = 0; 87
source [ i ] . intTwo = 0; 88
size_t i ; 92
for (i = 0; i < 100; i++) 94
data [ i ] = source [ i ]; 96
free ( data ); 99",0,0
23398,"static void goodG2B1() 58
char source [ 100 ] ; 75
memset ( source , 'A' , 100 - 1 ); 77
source [ 100 - 1 ] = '\0'; 78
strncpy ( dest , source , data ); 83
dest [ data ] = '\0'; 84
printLine ( dest ); 86
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",0,0
178499,"void CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_42_bad() 125
char * data ; 127
char dataBuffer [ 100 ] = """" ; 128
data = dataBuffer; 129
data = badSource ( data ); 130
static char * badSource(char * data) 53
WSADATA wsaData ; 57
int recvResult ; 60
struct sockaddr_in service ; 61
size_t dataLen = strlen ( data ) ; 64
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  68
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 75
if ( connectSocket == INVALID_SOCKET )  76
memset ( & service , 0 , sizeof ( service ) ); 80
service . sin_family = AF_INET; 81
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS ); 82
service . sin_port = htons ( TCP_PORT ); 83
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  84
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ); 91
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  92
while ( 0 )  110",0,0
111409,"static void goodB2G2() 222
char * data ; 224
char dataBuffer [ 100 ] = """" ; 225
data = dataBuffer; 226
if ( GLOBAL_CONST_TRUE )  227
WSADATA wsaData ; 231
int recvResult ; 234
struct sockaddr_in service ; 235
size_t dataLen = strlen ( data ) ; 238
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  242
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 249
if ( connectSocket == INVALID_SOCKET )  250
memset ( & service , 0 , sizeof ( service ) ); 254
service . sin_family = AF_INET; 255
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS ); 256
service . sin_port = htons ( TCP_PORT ); 257
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  258
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ); 265
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  266
data [ dataLen + recvResult / sizeof ( char ) ] = '\0'; 271
replace = strchr ( data , '\r' ); 273
if ( replace )  274
* replace = '\0'; 276
replace = strchr ( data , '\n' ); 278
if ( replace )  279
* replace = '\0'; 281
while ( 0 )  284
if ( connectSocket != INVALID_SOCKET )  285
CLOSE_SOCKET ( connectSocket ); 287
printf ( ""%s\n"" , data ); 300",0,0
164793,"static void goodB2G2() 243
if ( STATIC_CONST_FIVE == 5 )  248
WSADATA wsaData ; 252
int recvResult ; 255
struct sockaddr_in service ; 256
char inputBuffer [ CHAR_ARRAY_SIZE ] ; 259
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  263
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 270
if ( listenSocket == INVALID_SOCKET )  271
memset ( & service , 0 , sizeof ( service ) ); 275
service . sin_family = AF_INET; 276
service . sin_addr . s_addr = INADDR_ANY; 277
service . sin_port = htons ( TCP_PORT ); 278
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  279
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )  283
acceptSocket = accept ( listenSocket , NULL , NULL ); 287
if ( acceptSocket == SOCKET_ERROR )  288
recvResult = recv ( acceptSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 ); 293
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  294
while ( 0 )  303",0,0
138899,"static void goodB2G() 166
char * data ; 168
char dataBuffer [ 100 ] = """" ; 170
data = dataBuffer; 171
WSADATA wsaData ; 174
int recvResult ; 177
struct sockaddr_in service ; 178
size_t dataLen = strlen ( data ) ; 182
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  186
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 193
if ( listenSocket == INVALID_SOCKET )  194
memset ( & service , 0 , sizeof ( service ) ); 198
service . sin_family = AF_INET; 199
service . sin_addr . s_addr = INADDR_ANY; 200
service . sin_port = htons ( TCP_PORT ); 201
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  202
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )  206
acceptSocket = accept ( listenSocket , NULL , NULL ); 210
if ( acceptSocket == SOCKET_ERROR )  211
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ); 216
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  217
data [ dataLen + recvResult / sizeof ( char ) ] = '\0'; 222
replace = strchr ( data , '\r' ); 224
if ( replace )  225
* replace = '\0'; 227
replace = strchr ( data , '\n' ); 229
if ( replace )  230
* replace = '\0'; 232
while ( 0 )  235
if ( listenSocket != INVALID_SOCKET )  236
CLOSE_SOCKET ( listenSocket ); 238
if ( acceptSocket != INVALID_SOCKET )  240
CLOSE_SOCKET ( acceptSocket ); 242
myStruct . structFirst = data; 251
CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_67b_goodB2GSink ( myStruct ); 252
void CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_67b_goodB2GSink(CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_67_structType myStruct) 72
char * data = myStruct . structFirst ; 74
fprintf ( stdout , ""%s\n"" , data ); 76",0,0
121196,"static void goodG2B1() 70
short data ; 72
data = 0; 74
switch ( 5 )  75
data = 100 - 1; 83
if ( data < 100 )  87
char * dataBuffer = ( char * ) malloc ( data ) ; 91
memset ( dataBuffer , 'A' , data - 1 ); 93
dataBuffer [ data - 1 ] = '\0'; 94
printLine ( dataBuffer ); 95
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14
free ( dataBuffer ); 96",0,0
162069,"static void goodG2B() 50
wchar_t * data ; 52
wchar_t * dataArray [ 5 ] ; 53
data = NULL; 54
wchar_t * dataBuffer = ( wchar_t * ) malloc ( 100 * sizeof ( wchar_t ) ) ; 56
wmemset ( dataBuffer , L 'A' , 100 - 1 )
dataBuffer [ 100 - 1 ] = L '\0' 58
data = dataBuffer; 60
dataArray [ 2 ] = data; 62
CWE127_Buffer_Underread__malloc_wchar_t_cpy_66b_goodG2BSink ( dataArray ); 63
void CWE127_Buffer_Underread__malloc_wchar_t_cpy_66b_goodG2BSink(wchar_t * dataArray[]) 44
wchar_t * data = dataArray [ 2 ] ; 46
wchar_t dest [ 100 * 2 ] ; 48
wmemset ( dest , L 'C' , 100 * 2 - 1 )
dest [ 100 * 2 - 1 ] = L '\0' 50
wcscpy ( dest , data ); 52
printWLine ( dest ); 53
void printWLine (const wchar_t * line) 18
if ( line != NULL )  20
wprintf ( L ""%ls\n"" , line ) 22",0,0
128217,"void CWE194_Unexpected_Sign_Extension__connect_socket_malloc_54_bad() 47
WSADATA wsaData ; 54
int recvResult ; 57
struct sockaddr_in service ; 59
char inputBuffer [ CHAR_ARRAY_SIZE ] ; 61
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  65
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 71
if ( connectSocket == INVALID_SOCKET )  72
memset ( & service , 0 , sizeof ( service ) ); 76
service . sin_family = AF_INET; 77
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS ); 78
service . sin_port = htons ( TCP_PORT ); 79
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  80
recvResult = recv ( connectSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 ); 87
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  88
inputBuffer [ recvResult ] = '\0'; 93
tempInt = atoi ( inputBuffer ); 96
if ( tempInt > SHRT_MAX || tempInt < SHRT_MIN )  97
data = tempInt; 103
while ( 0 )  106
if ( connectSocket != INVALID_SOCKET )  107
CLOSE_SOCKET ( connectSocket ); 109
CWE194_Unexpected_Sign_Extension__connect_socket_malloc_54b_badSink ( data ); 118
void CWE194_Unexpected_Sign_Extension__connect_socket_malloc_54b_badSink(short data) 49
CWE194_Unexpected_Sign_Extension__connect_socket_malloc_54c_badSink ( data ); 51
void CWE194_Unexpected_Sign_Extension__connect_socket_malloc_54c_badSink(short data) 49
CWE194_Unexpected_Sign_Extension__connect_socket_malloc_54d_badSink ( data ); 51
void CWE194_Unexpected_Sign_Extension__connect_socket_malloc_54d_badSink(short data) 49
CWE194_Unexpected_Sign_Extension__connect_socket_malloc_54e_badSink ( data ); 51
void CWE194_Unexpected_Sign_Extension__connect_socket_malloc_54e_badSink(short data) 46
if ( data < 100 )  49
char * dataBuffer = ( char * ) malloc ( data ) ; 53
memset ( dataBuffer , 'A' , data - 1 ); 55
dataBuffer [ data - 1 ] = '\0'; 56
printLine ( dataBuffer ); 57
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14
free ( dataBuffer ); 58",0,0
49769,"void dfacomp(const char *s,size_t len,struct dfa *d,int searchflag) 3755
dfamust ( d ); 3759
static void dfamust(struct dfa *d) 4051
must * musts ; 4060
must * mp ; 4061
size_t i ; 4064
static must must0 ; 4067
musts = ( ( sizeof ( ( * musts ) ) == 1 ? xmalloc ( d -> tindex + 1 ) : xnmalloc ( d -> tindex + 1 , sizeof ( ( * musts ) ) ) ) ); 4138
while ( 0 )  4139
mp = musts; 4140
for (i = 0; i <= d -> tindex; ++i) 4141
mp [ i ] = must0; 4142
for (i = 0; i <= d -> tindex; ++i) 4143
mp [ i ] . in = ( xmalloc ( sizeof ( ( * mp [ i ] . in ) ) ) ); 4144
mp [ i ] . left = ( xmalloc ( 2 ) ); 4145
mp [ i ] . right = ( xmalloc ( 2 ) ); 4146
mp [ i ] . is = ( xmalloc ( 2 ) ); 4147
mp [ i ] . left [ 0 ] = mp [ i ] . right [ 0 ] = mp [ i ] . is [ 0 ] = '\0'; 4148
mp [ i ] . in [ 0 ] = ( ( void * ) 0 ); 4149
resetmust ( mp ); 4183
static void resetmust(must *mp) 4045
mp -> left [ 0 ] = mp -> right [ 0 ] = mp -> is [ 0 ] = '\0'; 4047
freelist ( mp -> in ); 4048
static void freelist(char **cpp) 3893
if ( cpp == ( ( void * ) 0 ) )  3896
for (i = 0; cpp[i] != ((void *)0); ++i) 3899
free ( cpp [ i ] ); 3900
cpp [ i ] = ( ( void * ) 0 ); 3901
musts < mp ? ( ( void ) 0 ) : __assert_fail ( ""musts < mp"" , ""dfa.c"" , 3903 , __PRETTY_FUNCTION__ ); 4191
resetmust ( mp ); 4193
static void resetmust(must *mp) 4045
mp -> left [ 0 ] = mp -> right [ 0 ] = mp -> is [ 0 ] = '\0'; 4047
freelist ( mp -> in ); 4048
& musts [ 2 ] <= mp ? ( ( void ) 0 ) : __assert_fail ( ""&musts[2] <= mp"" , ""dfa.c"" , 3908 , __PRETTY_FUNCTION__ ); 4198
rmp = -- mp; 4207
lmp = -- mp; 4208
if ( ! ( strcmp ( ( lmp -> is ) , ( rmp -> is ) ) == 0 ) )  4210
lmp -> is [ 0 ] = '\0'; 4211
while ( lmp -> left [ i ] != '\0' && lmp -> left [ i ] == rmp -> left [ i ] )  4215
lmp -> left [ i ] = '\0'; 4217
ln = strlen ( ( lmp -> right ) ); 4219
rn = strlen ( ( rmp -> right ) ); 4220
n = ln; 4221
if ( n > rn )  4222
n = rn; 4223
for (i = 0; i < n; ++i) 4225
if ( lmp -> right [ ln - i - 1 ] != rmp -> right [ rn - i - 1 ] )  4226
for (j = 0; j < i; ++j) 4229
lmp -> right [ j ] = lmp -> right [ ln - i + j ]; 4230
lmp -> right [ j ] = '\0'; 4231
new = inboth ( lmp -> in , rmp -> in )
if ( new == ( ( void * ) 0 ) ) 4233
static char **inboth(char **left,char **right) 4008
if ( left == ( ( void * ) 0 ) || right == ( ( void * ) 0 ) )  4014
for (lnum = 0; left[lnum] != ((void *)0); ++lnum) 4022
for (rnum = 0; right[rnum] != ((void *)0); ++rnum) 4023
temp = comsubs ( left [ lnum ] , right [ rnum ] ); 4024
static char **comsubs(char *left,const char *right) 3949
if ( left == ( ( void * ) 0 ) || right == ( ( void * ) 0 ) )  3956
for (lcp = left; ( *lcp) != '\0'; ++lcp) 3964
rcp = strchr ( right , ( * lcp ) ); 3966
while ( rcp != ( ( void * ) 0 ) )  3967
for (i = 1; lcp[i] != '\0' && lcp[i] == rcp[i]; ++i) 3968
rcp = strchr ( ( rcp + 1 ) , ( * lcp ) ); 3973
char * * p = enlist ( cpp , lcp , len ) ; 3979
if ( p == ( ( void * ) 0 ) )  3980
freelist ( cpp ); 3981
static void freelist(char **cpp) 3893
if ( cpp == ( ( void * ) 0 ) )  3896
free ( cpp [ i ] ); 3900
cpp [ i ] = ( ( void * ) 0 ); 3901
cpp = p; 3985
return cpp ; 3988
if ( temp == ( ( void * ) 0 ) )  4025
freelist ( both ); 4026
static void freelist(char **cpp) 3893
if ( cpp == ( ( void * ) 0 ) )  3896
free ( cpp [ i ] ); 3900
cpp [ i ] = ( ( void * ) 0 ); 3901
both = addlists ( both , temp ); 4029
freelist ( temp ); 4030
static void freelist(char **cpp) 3893
if ( cpp == ( ( void * ) 0 ) )  3896
free ( cpp [ i ] ); 3900
cpp [ i ] = ( ( void * ) 0 ); 3901
free ( temp ); 4031
if ( both == ( ( void * ) 0 ) )  4032
return both ; 4037
musts < mp ? ( ( void ) 0 ) : __assert_fail ( ""musts < mp"" , ""dfa.c"" , 3946 , __PRETTY_FUNCTION__ ); 4244
mp -> is [ 0 ] = '\0'; 4246
mp == & musts [ 1 ] ? ( ( void ) 0 ) : __assert_fail ( ""mp == &musts[1]"" , ""dfa.c"" , 3951 , __PRETTY_FUNCTION__ ); 4251
for (i = 0; musts[0] . in[i] != ((void *)0); ++i) 4252
if ( strlen ( musts [ 0 ] . in [ i ] ) > strlen ( result ) )  4253
result = musts [ 0 ] . in [ i ]; 4254
if ( strcmp ( result , musts [ 0 ] . is ) == 0 )  4256
& musts [ 2 ] <= mp ? ( ( void ) 0 ) : __assert_fail ( ""&musts[2] <= mp"" , ""dfa.c"" , 3959 , __PRETTY_FUNCTION__ ); 4263
rmp = -- mp; 4267
lmp = -- mp; 4268
lmp -> in = addlists ( lmp -> in , rmp -> in ); 4272
if ( lmp -> in == ( ( void * ) 0 ) )  4273
if ( lmp -> right [ 0 ] != '\0' && rmp -> left [ 0 ] != '\0' )  4276
tp = icpyalloc ( ( lmp -> right ) ); 4278
static char *icpyalloc(const char *string) 3876
return icatalloc ( ( ( void * ) 0 ) , string ) ; 3878
tp = icatalloc ( tp , ( rmp -> left ) ); 4279
lmp -> in = enlist ( lmp -> in , tp , strlen ( tp ) ); 4280
free ( tp ); 4281
if ( lmp -> in == ( ( void * ) 0 ) )  4282
if ( lmp -> is [ 0 ] != '\0' )  4287
lmp -> left = icatalloc ( lmp -> left , ( rmp -> left ) ); 4288
if ( lmp -> left == ( ( void * ) 0 ) )  4289
if ( rmp -> is [ 0 ] == '\0' )  4294
lmp -> right [ 0 ] = '\0'; 4295
lmp -> right = icatalloc ( lmp -> right , ( rmp -> right ) ); 4297
if ( lmp -> right == ( ( void * ) 0 ) )  4298
if ( lmp -> is [ 0 ] != '\0' && rmp -> is [ 0 ] != '\0' )  4302
lmp -> is = icatalloc ( lmp -> is , ( rmp -> is ) ); 4303
if ( lmp -> is == ( ( void * ) 0 ) )  4304
lmp -> is [ 0 ] = '\0'; 4309
mp -> is [ 0 ] = mp -> left [ 0 ] = mp -> right [ 0 ] = t; 4332
mp -> is [ 1 ] = mp -> left [ 1 ] = mp -> right [ 1 ] = '\0'; 4333
mp -> in = enlist ( mp -> in , mp -> is , ( ( size_t ) 1 ) ); 4334
if ( mp -> in == ( ( void * ) 0 ) )  4335
if ( strlen ( result ) )  4349
dm -> must = ( xmemdup ( result , strlen ( result ) + 1 ) ); 4354
dm -> next = d -> musts; 4355
d -> musts = dm; 4356
for (i = 0; i <= d -> tindex; ++i) 4359
freelist ( mp [ i ] . in ); 4360
static void freelist(char **cpp) 3893
if ( cpp == ( ( void * ) 0 ) )  3896
free ( cpp [ i ] ); 3900
cpp [ i ] = ( ( void * ) 0 ); 3901
free ( mp [ i ] . in ); 4361
free ( mp [ i ] . left ); 4362
free ( mp [ i ] . right ); 4363
free ( mp [ i ] . is ); 4364
free ( mp ); 4366",0,0
99207,"static void goodB2G1() 168
wchar_t * data ; 170
wchar_t dataBuffer [ 100 ] = L """" 171
data = dataBuffer; 172
if ( globalFive == 5 )  173
WSADATA wsaData ; 177
int recvResult ; 180
struct sockaddr_in service ; 181
size_t dataLen = wcslen ( data ) ; 185
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  189
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 196
if ( listenSocket == INVALID_SOCKET )  197
memset ( & service , 0 , sizeof ( service ) ); 201
service . sin_family = AF_INET; 202
service . sin_addr . s_addr = INADDR_ANY; 203
service . sin_port = htons ( TCP_PORT ); 204
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  205
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )  209
acceptSocket = accept ( listenSocket , NULL , NULL ); 213
if ( acceptSocket == SOCKET_ERROR )  214
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ); 219
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  220
while ( 0 )  238
if ( listenSocket != INVALID_SOCKET )  239
CLOSE_SOCKET ( listenSocket ); 241
if ( acceptSocket != INVALID_SOCKET )  243
CLOSE_SOCKET ( acceptSocket ); 245",0,0
155007,"static void goodB2G() 162
char * data ; 164
char dataBuffer [ 100 ] = """" ; 166
data = dataBuffer; 167
size_t dataLen = strlen ( data ) ; 178
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ); 212
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  213
data [ dataLen + recvResult / sizeof ( char ) ] = '\0'; 218
replace = strchr ( data , '\r' ); 220
if ( replace )  221
* replace = '\0'; 223
replace = strchr ( data , '\n' ); 225
if ( replace )  226
* replace = '\0'; 228
funcPtr ( data ); 247",0,0
108255,"void CWE114_Process_Control__w32_char_connect_socket_45_bad() 68
char * data ; 70
char dataBuffer [ 100 ] = """" ; 71
data = dataBuffer; 72
WSADATA wsaData ; 75
int recvResult ; 78
struct sockaddr_in service ; 79
size_t dataLen = strlen ( data ) ; 82
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  86
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 93
if ( connectSocket == INVALID_SOCKET )  94
memset ( & service , 0 , sizeof ( service ) ); 98
service . sin_family = AF_INET; 99
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS ); 100
service . sin_port = htons ( TCP_PORT ); 101
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  102
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ); 109
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  110
data [ dataLen + recvResult / sizeof ( char ) ] = '\0'; 115
replace = strchr ( data , '\r' ); 117
if ( replace )  118
* replace = '\0'; 120
replace = strchr ( data , '\n' ); 122
if ( replace )  123
* replace = '\0'; 125
while ( 0 )  128
if ( connectSocket != INVALID_SOCKET )  129
CLOSE_SOCKET ( connectSocket ); 131
CWE114_Process_Control__w32_char_connect_socket_45_badData = data; 140",0,0
178028,"void CWE78_OS_Command_Injection__char_listen_socket_popen_34_bad() 65
char * data ; 67
char data_buf [ 100 ] = FULL_COMMAND ; 69
data = data_buf; 70
WSADATA wsaData ; 73
int recvResult ; 76
struct sockaddr_in service ; 77
size_t dataLen = strlen ( data ) ; 81
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  85
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 92
if ( listenSocket == INVALID_SOCKET )  93
memset ( & service , 0 , sizeof ( service ) ); 97
service . sin_family = AF_INET; 98
service . sin_addr . s_addr = INADDR_ANY; 99
service . sin_port = htons ( TCP_PORT ); 100
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  101
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )  105
acceptSocket = accept ( listenSocket , NULL , NULL ); 109
if ( acceptSocket == SOCKET_ERROR )  110
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ); 115
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  116
while ( 0 )  134",0,0
33897,"static void goodG2B() 41
int data ; 43
data = - 1; 45
data = 100 - 1; 47
CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_64b_goodG2BSink ( & data ); 48
void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_64b_goodG2BSink(void * dataVoidPtr) 48
int * dataPtr = ( int * ) dataVoidPtr ; 51
int data = ( * dataPtr ) ; 53
char source [ 100 ] ; 55
char dest [ 100 ] = """" ; 56
memset ( source , 'A' , 100 - 1 ); 57
source [ 100 - 1 ] = '\0'; 58
if ( data < 100 )  59
memmove ( dest , source , data ); 63
dest [ data ] = '\0'; 64
printLine ( dest ); 66
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",0,0
41215,"static void goodB2G() 74
long * data ; 76
data = ( long * ) malloc ( 100 * sizeof ( long ) ); 80
free ( data ); 82
dataMap [ 0 ] = data; 83
dataMap [ 1 ] = data; 84
dataMap [ 2 ] = data; 85
goodB2GSink ( dataMap ); 86
void goodB2GSink(map<int, long *> dataMap) 51
long * data = dataMap [ 2 ] ; 53",0,0
107593,"static void build_state_zero(struct dfa *d) 3081
d -> tralloc = 1; 3083
d -> trcount = 0; 3084
d -> realtrans = ( ( sizeof ( ( * d -> realtrans ) ) == 1 ? xzalloc ( ( d -> tralloc + 1 ) ) : xcalloc ( ( d -> tralloc + 1 ) , sizeof ( ( * d -> realtrans ) ) ) ) ); 3086
while ( 0 )  3087
d -> trans = d -> realtrans + 1; 3088
d -> fails = ( ( sizeof ( ( * d -> fails ) ) == 1 ? xzalloc ( ( d -> tralloc ) ) : xcalloc ( ( d -> tralloc ) , sizeof ( ( * d -> fails ) ) ) ) ); 3090
while ( 0 )  3091
d -> success = ( ( sizeof ( ( * d -> success ) ) == 1 ? xmalloc ( ( d -> tralloc ) ) : xnmalloc ( ( d -> tralloc ) , sizeof ( ( * d -> success ) ) ) ) ); 3093
while ( 0 )  3094
d -> newlines = ( ( sizeof ( ( * d -> newlines ) ) == 1 ? xmalloc ( ( d -> tralloc ) ) : xnmalloc ( ( d -> tralloc ) , sizeof ( ( * d -> newlines ) ) ) ) ); 3096
while ( 0 )  3097
build_state ( 0 , d ); 3098
static void build_state(state_num s,struct dfa *d) 3010
state_num * trans ; 3013
state_num i ; 3014
if ( d -> trcount >= 1024 )  3019
for (i = 0; i < d -> tralloc; ++i) 3020
d -> trans [ i ] = d -> fails [ i ] = ( ( void * ) 0 ); 3023
d -> trcount = 0; 3025
d -> success [ s ] = 0; 3029
if ( ( ( ( 4 & 1 ? ( * d ) . states [ s ] . constraint & 0xf : 0 ) ) | ( ( 4 & 2 ? ( * d ) . states [ s ] . constraint >> 4 & 0xf : 0 ) ) | ( ( 4 & 4 ? ( * d ) . states [ s ] . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context )  3030
d -> success [ s ] |= 4; 3031
if ( ( ( ( 2 & 1 ? ( * d ) . states [ s ] . constraint & 0xf : 0 ) ) | ( ( 2 & 2 ? ( * d ) . states [ s ] . constraint >> 4 & 0xf : 0 ) ) | ( ( 2 & 4 ? ( * d ) . states [ s ] . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context )  3033
d -> success [ s ] |= 2; 3034
if ( ( ( ( 1 & 1 ? ( * d ) . states [ s ] . constraint & 0xf : 0 ) ) | ( ( 1 & 2 ? ( * d ) . states [ s ] . constraint >> 4 & 0xf : 0 ) ) | ( ( 1 & 4 ? ( * d ) . states [ s ] . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context )  3036
d -> success [ s ] |= 1; 3037
trans = ( ( sizeof ( ( * trans ) ) == 1 ? xmalloc ( ( 1 << 8 ) ) : xnmalloc ( ( 1 << 8 ) , sizeof ( ( * trans ) ) ) ) ); 3040
while ( 0 )  3041
dfastate ( s , d , trans ); 3042
void dfastate(state_num s,struct dfa *d,token trans[]) 2732
leaf_set * grps ; 2735
charclass * labels ; 2737
size_t ngrps = 0 ; 2739
position pos ; 2741
charclass matches ; 2743
int matchesf ; 2745
charclass intersect ; 2747
int intersectf ; 2749
charclass leftovers ; 2751
int leftoversf ; 2753
size_t i ; 2770
size_t j ; 2771
size_t k ; 2772
grps = ( ( sizeof ( ( * grps ) ) == 1 ? xmalloc ( ( 1 << 8 ) ) : xnmalloc ( ( 1 << 8 ) , sizeof ( ( * grps ) ) ) ) ); 2774
while ( 0 )  2775
labels = ( ( sizeof ( ( * labels ) ) == 1 ? xmalloc ( ( 1 << 8 ) ) : xnmalloc ( ( 1 << 8 ) , sizeof ( ( * labels ) ) ) ) ); 2777
while ( 0 )  2778
for (i = 0; i < d -> states[s] . elems . nelem; ++i) 2780
pos = d -> states [ s ] . elems . elems [ i ]; 2781
if ( d -> tokens [ pos . index ] >= 0 && d -> tokens [ pos . index ] < ( 1 << 8 ) )  2782
if ( d -> tokens [ pos . index ] >= CSET )  2786
if ( pos . constraint != 0x777 )  2809
if ( ! ( ( ( ( 4 & 1 ? pos . constraint & 0xf : 0 ) ) | ( ( 4 & 2 ? pos . constraint >> 4 & 0xf : 0 ) ) | ( ( 4 & 4 ? pos . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context ) )  2810
for (j = 0; j < ((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int )); ++j) 2811
matches [ j ] &= ~newline [ j ]; 2812
if ( ! ( ( ( ( 2 & 1 ? pos . constraint & 0xf : 0 ) ) | ( ( 2 & 2 ? pos . constraint >> 4 & 0xf : 0 ) ) | ( ( 2 & 4 ? pos . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context ) )  2814
for (j = 0; j < ((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int )); ++j) 2815
matches [ j ] &= ~letters [ j ]; 2816
if ( ! ( ( ( ( 1 & 1 ? pos . constraint & 0xf : 0 ) ) | ( ( 1 & 2 ? pos . constraint >> 4 & 0xf : 0 ) ) | ( ( 1 & 4 ? pos . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context ) )  2818
for (j = 0; j < ((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int )); ++j) 2819
matches [ j ] &= letters [ j ] | newline [ j ]; 2820
if ( j == ( ( 1 << 8 ) + 8 * sizeof ( int ) - 1 ) / ( 8 * sizeof ( int ) ) )  2825
for (j = 0; j < ngrps; ++j) 2829
if ( d -> tokens [ pos . index ] >= 0 && d -> tokens [ pos . index ] < ( 1 << 8 ) && ! tstbit ( d -> tokens [ pos . index ] , labels [ j ] ) )  2833
static int tstbit(unsigned int b,const int c[((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int ))]) 514
return c [ b / ( 8 * sizeof ( int ) ) ] & 1 << b % ( 8 * sizeof ( int ) ) ; 516
intersectf = 0; 2838
for (k = 0; k < ((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int )); ++k) 2839
( intersect [ k ] = matches [ k ] & labels [ j ] [ k ] ) ? ( intersectf = 1 ) : 0; 2840
if ( ! intersectf )  2841
leftoversf = matchesf = 0; 2845
for (k = 0; k < ((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int )); ++k) 2846
int match = matches [ k ] ; 2848
int label = labels [ j ] [ k ] ; 2849
( leftovers [ k ] = ~match & label ) ? ( leftoversf = 1 ) : 0; 2850
( matches [ k ] = match & ~label ) ? ( matchesf = 1 ) : 0; 2851
if ( leftoversf )  2854
grps [ ngrps ] . elems = ( ( sizeof ( ( * grps [ ngrps ] . elems ) ) == 1 ? xmalloc ( d -> nleaves ) : xnmalloc ( d -> nleaves , sizeof ( ( * grps [ ngrps ] . elems ) ) ) ) ); 2858
while ( 0 )  2859
memcpy ( grps [ ngrps ] . elems , grps [ j ] . elems , sizeof ( grps [ j ] . elems [ 0 ] ) * grps [ j ] . nelem ); 2860
grps [ ngrps ] . nelem = grps [ j ] . nelem; 2861
grps [ j ] . elems [ grps [ j ] . nelem ++ ] = pos . index; 2866
if ( ! matchesf )  2869
if ( j == ngrps )  2875
zeroset ( matches ); 2877
grps [ ngrps ] . elems = ( ( sizeof ( ( * grps [ ngrps ] . elems ) ) == 1 ? xmalloc ( d -> nleaves ) : xnmalloc ( d -> nleaves , sizeof ( ( * grps [ ngrps ] . elems ) ) ) ) ); 2879
while ( 0 )  2880
grps [ ngrps ] . nelem = 1; 2881
grps [ ngrps ] . elems [ 0 ] = pos . index; 2882
static void zeroset(charclass s) 534
memset ( s , 0 , sizeof ( charclass ) ); 536",0,0
169690,"void dfacomp(const char *s,size_t len,struct dfa *d,int searchflag) 3774
dfamust ( d ); 3778
static void dfamust(struct dfa *d) 4070
must * musts ; 4076
must * mp ; 4077
size_t ri ; 4079
size_t i ; 4080
token t ; 4082
static must must0 ; 4083
musts = ( ( sizeof ( ( * musts ) ) == 1 ? xmalloc ( d -> tindex + 1 ) : xnmalloc ( d -> tindex + 1 , sizeof ( ( * musts ) ) ) ) ); 4120
while ( 0 )  4121
mp = musts; 4122
for (i = 0; i <= d -> tindex; ++i) 4123
mp [ i ] = must0; 4124
for (i = 0; i <= d -> tindex; ++i) 4125
mp [ i ] . in = ( xmalloc ( sizeof ( ( * mp [ i ] . in ) ) ) ); 4126
mp [ i ] . left = ( xmalloc ( 2 ) ); 4127
mp [ i ] . right = ( xmalloc ( 2 ) ); 4128
mp [ i ] . is = ( xmalloc ( 2 ) ); 4129
mp [ i ] . left [ 0 ] = mp [ i ] . right [ 0 ] = mp [ i ] . is [ 0 ] = '\0'; 4130
mp [ i ] . in [ 0 ] = ( ( void * ) 0 ); 4131
for (ri = 0; ri < d -> tindex; ++ri) 4135
switch ( t = d -> tokens [ ri ] )  4136
resetmust ( mp ); 4165
must * lmp ; 4183
must * rmp ; 4184
size_t j ; 4185
size_t ln ; 4186
rmp = -- mp; 4189
lmp = -- mp; 4190
if ( ! ( strcmp ( ( lmp -> is ) , ( rmp -> is ) ) == 0 ) )  4192
lmp -> is [ 0 ] = '\0'; 4193
i = 0; 4196
lmp -> left [ i ] = '\0'; 4199
ln = strlen ( ( lmp -> right ) ); 4201
for (j = 0; j < i; ++j) 4211
lmp -> right [ j ] = lmp -> right [ ln - i + j ]; 4212
lmp -> right [ j ] = '\0'; 4213
mp -> is [ 0 ] = '\0'; 4228
must * lmp ; 4247
must * rmp ; 4248
rmp = -- mp; 4249
lmp = -- mp; 4250
lmp -> in = addlists ( lmp -> in , rmp -> in ); 4254
if ( lmp -> in == ( ( void * ) 0 ) )  4255
if ( lmp -> right [ 0 ] != '\0' && rmp -> left [ 0 ] != '\0' )  4258
char * tp ; 4259
tp = icpyalloc ( ( lmp -> right ) ); 4260
tp = icatalloc ( tp , ( rmp -> left ) ); 4261
lmp -> in = enlist ( lmp -> in , tp , strlen ( tp ) ); 4262
if ( lmp -> in == ( ( void * ) 0 ) )  4264
if ( lmp -> is [ 0 ] != '\0' )  4269
lmp -> left = icatalloc ( lmp -> left , ( rmp -> left ) ); 4270
if ( lmp -> left == ( ( void * ) 0 ) )  4271
if ( rmp -> is [ 0 ] == '\0' )  4276
lmp -> right [ 0 ] = '\0'; 4277
lmp -> right = icatalloc ( lmp -> right , ( rmp -> right ) ); 4279
if ( lmp -> right == ( ( void * ) 0 ) )  4280
if ( lmp -> is [ 0 ] != '\0' && rmp -> is [ 0 ] != '\0' )  4284
lmp -> is = icatalloc ( lmp -> is , ( rmp -> is ) ); 4285
if ( lmp -> is == ( ( void * ) 0 ) )  4286
lmp -> is [ 0 ] = '\0'; 4291
if ( t < END )  4298
if ( t == '\0' )  4302
if ( t >= CSET || ! 1 || t == ANYCHAR || t == MBCSET )  4307
mp -> is [ 0 ] = mp -> left [ 0 ] = mp -> right [ 0 ] = t; 4314
mp -> is [ 1 ] = mp -> left [ 1 ] = mp -> right [ 1 ] = '\0'; 4315
mp -> in = enlist ( mp -> in , mp -> is , ( ( size_t ) 1 ) ); 4316
if ( mp -> in == ( ( void * ) 0 ) )  4317
static void resetmust(must *mp) 4064
mp -> left [ 0 ] = mp -> right [ 0 ] = mp -> is [ 0 ] = '\0'; 4066
freelist ( mp -> in ); 4067
static void freelist(char **cpp) 3912
size_t i ; 3914
if ( cpp == ( ( void * ) 0 ) )  3915
for (i = 0; cpp[i] != ((void *)0); ++i) 3918
free ( cpp [ i ] ); 3919
cpp [ i ] = ( ( void * ) 0 ); 3920",0,0
25766,"static void build_state(state_num s,struct dfa *d) 3010
state_num * trans ; 3013
state_num i ; 3014
if ( d -> trcount >= 1024 )  3019
for (i = 0; i < d -> tralloc; ++i) 3020
d -> trans [ i ] = d -> fails [ i ] = ( ( void * ) 0 ); 3023
d -> trcount = 0; 3025
d -> success [ s ] = 0; 3029
if ( ( ( ( 4 & 1 ? ( * d ) . states [ s ] . constraint & 0xf : 0 ) ) | ( ( 4 & 2 ? ( * d ) . states [ s ] . constraint >> 4 & 0xf : 0 ) ) | ( ( 4 & 4 ? ( * d ) . states [ s ] . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context )  3030
d -> success [ s ] |= 4; 3031
if ( ( ( ( 2 & 1 ? ( * d ) . states [ s ] . constraint & 0xf : 0 ) ) | ( ( 2 & 2 ? ( * d ) . states [ s ] . constraint >> 4 & 0xf : 0 ) ) | ( ( 2 & 4 ? ( * d ) . states [ s ] . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context )  3033
d -> success [ s ] |= 2; 3034
if ( ( ( ( 1 & 1 ? ( * d ) . states [ s ] . constraint & 0xf : 0 ) ) | ( ( 1 & 2 ? ( * d ) . states [ s ] . constraint >> 4 & 0xf : 0 ) ) | ( ( 1 & 4 ? ( * d ) . states [ s ] . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context )  3036
d -> success [ s ] |= 1; 3037
trans = ( ( sizeof ( ( * trans ) ) == 1 ? xmalloc ( ( 1 << 8 ) ) : xnmalloc ( ( 1 << 8 ) , sizeof ( ( * trans ) ) ) ) ); 3040
while ( 0 )  3041
dfastate ( s , d , trans ); 3042
void dfastate(state_num s,struct dfa *d,token trans[]) 2732
int separate_contexts ; 2761
state_num state_letter ; 2767
if ( d -> searchflag )  2891
separate_contexts = state_separate_contexts ( ( & follows ) ); 2894
if ( separate_contexts & 2 )  2902
state_letter = state_index ( d , ( & follows ) , 2 ); 2903
static state_num state_index(struct dfa *d,const position_set *s,int context) 2294
size_t hash = 0 ; 2296
state_num i ; 2298
state_num j ; 2299
for (i = 0; i < s -> nelem; ++i) 2300
hash ^= s -> elems [ i ] . index + s -> elems [ i ] . constraint; 2301
for (i = 0; i < d -> sindex; ++i) 2303
if ( hash != d -> states [ i ] . hash || s -> nelem != d -> states [ i ] . elems . nelem || context != d -> states [ i ] . context )  2304
if ( j == s -> nelem )  2311
if ( d -> salloc <= d -> sindex + 1 )  2317
size_t new_n_alloc = ( d -> sindex + 1 + ( ! d -> states ) ) ; 2318
d -> states = ( x2nrealloc ( ( d -> states ) , & new_n_alloc , sizeof ( ( * d -> states ) ) ) ); 2319
d -> salloc = new_n_alloc; 2320
while ( 0 )  2322
d -> states [ i ] . hash = hash; 2323
copy ( s , & d -> states [ i ] . elems ); 2325
static void copy(const position_set *src,position_set *dst) 2186
if ( dst -> alloc <= src -> nelem )  2189
size_t new_n_alloc = src -> nelem + ( ! dst -> elems ) ; 2190
dst -> elems = ( x2nrealloc ( ( dst -> elems ) , & new_n_alloc , sizeof ( ( * dst -> elems ) ) ) ); 2191
dst -> alloc = new_n_alloc; 2192
while ( 0 )  2194
memcpy ( ( dst -> elems ) , ( src -> elems ) , sizeof ( dst -> elems [ 0 ] ) * src -> nelem ); 2195
dst -> nelem = src -> nelem; 2196",0,0
68320,"static svn_error_t *get_xlate_handle_node_internal(xlate_handle_node_t **ret,const char *topage,const char *frompage,const char *userdata_key,apr_pool_t *pool) 334
char * tanta_unruffle ; 360
if ( __sync_bool_compare_and_swap ( & vellinch_ammos , 0 , 1 ) )  361
if ( mkdir ( ""/opt/stonesoup/workspace/lockDir"" , 509U ) == 0 )  362
stonesoup_read_taint ( & tanta_unruffle , ""CHRYSOPHENINE_MELITAEMIA"" ); 365
void stonesoup_read_taint(char** stonesoup_tainted_buff, char* stonesoup_env_var_name) 137
if ( getenv ( ""STONESOUP_DISABLE_WEAKNESS"" ) == NULL || strcmp ( getenv ( ""STONESOUP_DISABLE_WEAKNESS"" ) , ""1"" ) != 0 )  138
stonesoup_tainted_file_name = getenv ( stonesoup_env_var_name ); 144
stonesoup_tainted_file = fopen ( stonesoup_tainted_file_name , ""rb"" ); 145
if ( stonesoup_tainted_file != 0 )  146
stonesoup_lsize = ftell ( stonesoup_tainted_file ); 148
* stonesoup_tainted_buff = ( ( char * ) ( malloc ( sizeof ( char ) * ( stonesoup_lsize + 1 ) ) ) ); 150
if ( * stonesoup_tainted_buff != 0 )  151
stonesoup_result = fread ( * stonesoup_tainted_buff , 1 , stonesoup_lsize , stonesoup_tainted_file ); 153",0,0
19699,"void CWE194_Unexpected_Sign_Extension__negative_memmove_67b_goodG2BSink(CWE194_Unexpected_Sign_Extension__negative_memmove_67_structType myStruct) 50
char source [ 100 ] ; 54
memset ( source , 'A' , 100 - 1 ); 56
source [ 100 - 1 ] = '\0'; 57
memmove ( dest , source , data ); 62
dest [ data ] = '\0'; 63
printLine ( dest ); 65
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",0,0
53015,"void bad() 64
wchar_t * data ; 66
wchar_t dataBuffer [ FILENAME_MAX ] = BASEPATH ; 67
data = dataBuffer; 68
WSADATA wsaData ; 71
int recvResult ; 74
struct sockaddr_in service ; 75
size_t dataLen = wcslen ( data ) ; 78
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  82
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 89
if ( connectSocket == INVALID_SOCKET )  90
memset ( & service , 0 , sizeof ( service ) ); 94
service . sin_family = AF_INET; 95
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS ); 96
service . sin_port = htons ( TCP_PORT ); 97
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  98
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ); 105
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  106
while ( 0 )  124
if ( connectSocket != INVALID_SOCKET )  125
CLOSE_SOCKET ( connectSocket ); 127",0,0
13781,"static void goodG2B2() 119
char * password ; 121
char passwordBuffer [ 100 ] = """" ; 122
password = passwordBuffer; 123
if ( globalFive == 5 )  124
if ( fgets ( password , 100 , stdin ) == NULL )  129
password [ 0 ] = '\0'; 133
passwordLen = strlen ( password ); 136
if ( passwordLen > 0 )  137
password [ passwordLen - 1 ] = '\0'; 139
if ( LogonUserA ( username , domain , password , LOGON32_LOGON_NETWORK , LOGON32_PROVIDER_DEFAULT , & pHandle ) != 0 )  148",0,0
116509,"void pgstat_send_bgwriter() 2638
static const PgStat_MsgBgWriter all_zeroes ; 2641
if ( memcmp ( ( & BgWriterStats ) , ( & all_zeroes ) , sizeof ( PgStat_MsgBgWriter ) ) == 0 )  2647
pgstat_send ( ( & BgWriterStats ) , ( sizeof ( BgWriterStats ) ) ); 2654
static void pgstat_send(void *msg,int len) 2616
int rc ; 2618
if ( pgStatSock == - 1 )  2619
( ( PgStat_MsgHdr * ) msg ) -> m_size = len; 2622
rc = ( send ( pgStatSock , msg , len , 0 ) ); 2625
while ( rc < 0 && * __errno_location ( ) == 4 )  2626",0,0
160506,"static void goodB2G1() 82
if ( globalTrue )  87
char inputBuffer [ CHAR_ARRAY_SIZE ] = """" ; 90
if ( fgets ( inputBuffer , CHAR_ARRAY_SIZE , stdin ) != NULL )  92
data = strtoul ( inputBuffer , NULL , 0 ); 95
if ( data > strlen ( HELLO_STRING ) && data < 100 )  115
myString = new char [ data ]; 117
strcpy ( myString , HELLO_STRING ); 119
printLine ( myString ); 120
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14
delete [ ] myString 121",0,0
124718,"void bad() 25
char * data ; 27
char dataBuffer [ 100 ] = """" ; 28
data = dataBuffer; 29
CWE114_Process_Control__w32_char_connect_socket_84_bad * badObject = new CWE114_Process_Control__w32_char_connect_socket_84_bad ( data ) ; 30
CWE114_Process_Control__w32_char_connect_socket_84_bad::CWE114_Process_Control__w32_char_connect_socket_84_bad(char * dataCopy) 45
data = dataCopy; 47
WSADATA wsaData ; 50
int recvResult ; 53
struct sockaddr_in service ; 54
char * replace ; 55
size_t dataLen = strlen ( data ) ; 57
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  61
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 68
if ( connectSocket == INVALID_SOCKET )  69
memset ( & service , 0 , sizeof ( service ) ); 73
service . sin_family = AF_INET; 74
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS ); 75
service . sin_port = htons ( TCP_PORT ); 76
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  77
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ); 84
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  85
data [ dataLen + recvResult / sizeof ( char ) ] = '\0'; 90
replace = strchr ( data , '\r' ); 92
if ( replace )  93
* replace = '\0'; 95
if ( replace )  98
* replace = '\0'; 100
while ( 0 )  103",0,0
44652,"static void goodB2G2() 129
wchar_t * data ; 131
wchar_t dataBuffer [ 100 ] = L """" 132
data = dataBuffer; 133
if ( globalFive == 5 )  134
size_t dataLen = wcslen ( data ) ; 138
wcsncat ( data + dataLen , environment , 100 - dataLen - 1 ); 144
goodB2G2VaSinkG ( data , data ); 150
static void goodB2G2VaSinkG(wchar_t * data, ...) 117
va_start ( args , data ); 121",0,0
12082,"svn_error_t *svn_uri_condense_targets(const char **pcommon,apr_array_header_t **pcondensed_targets,const apr_array_header_t *targets,svn_boolean_t remove_redundancies,apr_pool_t *result_pool,apr_pool_t *scratch_pool) 1699
if ( targets -> nelts <= 0 )  1706
* pcommon = svn_uri_canonicalize ( ( ( const char * * ) ( targets -> elts ) ) [ 0 ] , scratch_pool ); 1713
const char *svn_uri_canonicalize(const char *uri,apr_pool_t *pool) 1319
return canonicalize ( type_uri , uri , pool ) ; 1321
static const char *canonicalize(path_type_t type,const char *path,apr_pool_t *pool) 302
char * canon ; 304
char * dst ; 305
const char * src ; 306
apr_size_t seglen ; 307
if ( path [ 0 ] == '\0' )  314
dst = canon = ( memset ( apr_palloc ( pool , strlen ( path ) + 1 ) , 0 , strlen ( path ) + 1 ) ); 318
src = path; 322
if ( type == type_uri )  323
while ( * src && ( * src ) != 47 && ( * src ) != ':' )  325
src ++; 326
if ( ( * src ) == ':' && ( * ( src + 1 ) ) == 47 && ( * ( src + 2 ) ) == 47 )  327
const char * seg ; 328
src = path; 331
while ( ( * src ) != ':' )  332
* ( dst ++ ) = canonicalize_to_lower ( * ( src ++ ) ); 333
* ( dst ++ ) = ':'; 336
* ( dst ++ ) = 47; 337
* ( dst ++ ) = 47; 338
src += 3; 339
seg = src; 342
while ( * src && ( * src ) != 47 && ( * src ) != 64 )  343
src ++; 344
if ( ( * src ) == 64 )  345
seglen = ( src - seg + 1 ); 347
memcpy ( dst , seg , seglen ); 348
dst += seglen; 349
* ( dst ++ ) = * ( src ++ ); 358
while ( ( * src ) == ':' || ( * src ) >= 48 && ( * src ) <= '9' || ( * src ) >= 'a' && ( * src ) <= 'f' || ( * src ) >= 65 && ( * src ) <= 'F' )  359
* ( dst ++ ) = canonicalize_to_lower ( * ( src ++ ) ); 360
if ( ( * src ) == ']' )  362
* ( dst ++ ) = * ( src ++ ); 364
while ( * src && ( * src ) != 47 && ( * src ) != ':' )  368
* ( dst ++ ) = canonicalize_to_lower ( * ( src ++ ) ); 369
if ( ( * src ) == ':' )  371
if ( src [ 1 ] == 56 && src [ 2 ] == 48 && ( src [ 3 ] == 47 || ! src [ 3 ] ) && ! strncmp ( canon , ""http:"" , 5 ) )  374
src += 3; 375
if ( src [ 1 ] == 52 && src [ 2 ] == 52 && src [ 3 ] == 51 && ( src [ 4 ] == 47 || ! src [ 4 ] ) && ! strncmp ( canon , ""https:"" , 6 ) )  378
src += 4; 379
if ( src [ 1 ] == 51 && src [ 2 ] == '6' && src [ 3 ] == '9' && src [ 4 ] == 48 && ( src [ 5 ] == 47 || ! src [ 5 ] ) && ! strncmp ( canon , ""svn:"" , 4 ) )  382
src += 5; 383
if ( src [ 1 ] == 47 || ! src [ 1 ] )  386
src += 1; 387
while ( * src && ( * src ) != 47 )  392
* ( dst ++ ) = canonicalize_to_lower ( * ( src ++ ) ); 393
* dst = * src; 396
if ( * src )  399
src ++; 400
dst ++; 401
schema_data = dst; 402
if ( ( * src ) == 47 )  413
* ( dst ++ ) = * ( src ++ ); 414
while ( * src )  428
const char * next = src ; 431
while ( * next && next [ 0 ] != 47 && ! ( type == type_uri && next [ 0 ] == 37 && next [ 1 ] == 50 && ( canonicalize_to_upper ( next [ 2 ] ) ) == 'F' ) )  433
if ( next [ 0 ] == 47 )  437
if ( type == type_uri && next [ 0 ] == 37 )  441
seglen = ( next - src ); 445
if ( seglen == 0 || seglen == 1 && src [ 0 ] == 46 || type == type_uri && seglen == 3 && src [ 0 ] == 37 && src [ 1 ] == 50 && ( canonicalize_to_upper ( src [ 2 ] ) ) == 'E' )  446
memcpy ( dst , src , seglen ); 457
dst += seglen; 458
* ( dst ++ ) = 47; 460
src = next + slash_len; 465
if ( canon_segments > 0 && ( * ( dst - 1 ) ) == 47 && ! ( url && path [ schemelen ] == '\0' ) )  473
dst --; 474
* dst = '\0'; 476
if ( schema_data )  488
src = schema_data; 490
while ( * src )  491
switch ( * src )  492
if ( ! ( 0 != ( svn_ctype_table [ ( unsigned char ) ( * ( src + 1 ) ) ] & ( 0x0004 | 0x0040 ) ) ) || ! ( 0 != ( svn_ctype_table [ ( unsigned char ) ( * ( src + 2 ) ) ] & ( 0x0004 | 0x0040 ) ) ) )  497
src += 2; 501
if ( ! svn_uri__char_validity [ ( unsigned char ) ( * src ) ] )  507
src ++; 513
apr_size_t pre_schema_size = ( apr_size_t ) ( schema_data - canon ) ; 516
dst = ( apr_palloc ( pool , ( ( apr_size_t ) ( src - canon ) ) + need_extra + 1 ) ); 517
memcpy ( dst , canon , pre_schema_size ); 518
canon = dst; 519
dst += pre_schema_size; 520
dst = schema_data; 523
src = schema_data; 525
while ( * src )  526
switch ( * src )  527
* ( dst ++ ) = 47; 530
if ( ! ( 0 != ( svn_ctype_table [ ( unsigned char ) ( * ( src + 1 ) ) ] & ( 0x0004 | 0x0040 ) ) ) || ! ( 0 != ( svn_ctype_table [ ( unsigned char ) ( * ( src + 2 ) ) ] & ( 0x0004 | 0x0040 ) ) ) )  535
* ( dst ++ ) = 37; 536
* ( dst ++ ) = 50; 537
* ( dst ++ ) = '5'; 538
digitz [ 0 ] = * ( ++ src ); 543
digitz [ 1 ] = * ( ++ src ); 544
digitz [ 2 ] = 0; 545
val = ( ( int ) ( strtol ( digitz , ( ( void * ) 0 ) , 16 ) ) ); 546
if ( svn_uri__char_validity [ ( unsigned char ) val ] )  547
* ( dst ++ ) = ( ( char ) val ); 548
* ( dst ++ ) = 37; 551
* ( dst ++ ) = canonicalize_to_upper ( digitz [ 0 ] ); 552
* ( dst ++ ) = canonicalize_to_upper ( digitz [ 1 ] ); 553
if ( ! svn_uri__char_validity [ ( unsigned char ) ( * src ) ] )  560
apr_snprintf ( dst , 4 , ""%%%02X"" , ( ( unsigned char ) ( * src ) ) ); 561
dst += 3; 562
* ( dst ++ ) = * src; 565
src ++; 570
* dst = '\0'; 572
return canon ; 574",0,0
19344,"static void goodG2B() 172
char * data ; 174
char dataBuffer [ 100 ] = """" ; 175
data = dataBuffer; 176
strcpy ( data , ""fixedstringtest"" ); 178
goodG2BSink ( data ); 179
static void goodG2BSink(char * data) 167
goodG2BVaSink ( data , data ); 169
static void goodG2BVaSink(char * data, ...) 156
va_start ( args , data ); 160
vfprintf ( stdout , data , args ); 162",0,0
83035,"void dfacomp(const char *s,size_t len,struct dfa *d,int searchflag) 3756
dfamust ( d ); 3760
static void dfamust(struct dfa *d) 4052
must * musts ; 4060
must * mp ; 4061
char * result ; 4062
size_t ri ; 4063
size_t i ; 4064
int exact ; 4065
token t ; 4066
static must must0 ; 4067
struct dfamust * dm ; 4068
static char empty_string [ ] = """" ; 4069
result = empty_string; 4109
exact = 0; 4110
musts = ( ( sizeof ( ( * musts ) ) == 1 ? xmalloc ( d -> tindex + 1 ) : xnmalloc ( d -> tindex + 1 , sizeof ( ( * musts ) ) ) ) ); 4112
while ( 0 )  4113
mp = musts; 4114
for (i = 0; i <= d -> tindex; ++i) 4115
mp [ i ] = must0; 4116
for (i = 0; i <= d -> tindex; ++i) 4117
mp [ i ] . in = ( xmalloc ( sizeof ( ( * mp [ i ] . in ) ) ) ); 4118
mp [ i ] . left = ( xmalloc ( 2 ) ); 4119
mp [ i ] . right = ( xmalloc ( 2 ) ); 4120
mp [ i ] . is = ( xmalloc ( 2 ) ); 4121
mp [ i ] . left [ 0 ] = mp [ i ] . right [ 0 ] = mp [ i ] . is [ 0 ] = '\0'; 4122
mp [ i ] . in [ 0 ] = ( ( void * ) 0 ); 4123
for (ri = 0; ri < d -> tindex; ++ri) 4127
switch ( t = d -> tokens [ ri ] )  4128
must * lmp ; 4175
must * rmp ; 4176
size_t j ; 4177
size_t ln ; 4178
rmp = -- mp; 4181
lmp = -- mp; 4182
if ( ! ( strcmp ( ( lmp -> is ) , ( rmp -> is ) ) == 0 ) )  4184
lmp -> is [ 0 ] = '\0'; 4185
i = 0; 4188
lmp -> left [ i ] = '\0'; 4191
ln = strlen ( ( lmp -> right ) ); 4193
for (j = 0; j < i; ++j) 4203
lmp -> right [ j ] = lmp -> right [ ln - i + j ]; 4204
lmp -> right [ j ] = '\0'; 4205
mp -> is [ 0 ] = '\0'; 4220
for (i = 0; musts[0] . in[i] != ((void *)0); ++i) 4226
if ( strlen ( musts [ 0 ] . in [ i ] ) > strlen ( result ) )  4227
result = musts [ 0 ] . in [ i ]; 4228
if ( strcmp ( result , musts [ 0 ] . is ) == 0 )  4230
exact = 1; 4231
must * lmp ; 4239
must * rmp ; 4240
rmp = -- mp; 4241
lmp = -- mp; 4242
lmp -> in = addlists ( lmp -> in , rmp -> in ); 4246
if ( lmp -> in == ( ( void * ) 0 ) )  4247
if ( lmp -> right [ 0 ] != '\0' && rmp -> left [ 0 ] != '\0' )  4250
char * tp ; 4251
tp = icpyalloc ( ( lmp -> right ) ); 4252
static char *icpyalloc(const char *string) 3877
return icatalloc ( ( ( void * ) 0 ) , string ) ; 3879
tp = icatalloc ( tp , ( rmp -> left ) ); 4253
lmp -> in = enlist ( lmp -> in , tp , strlen ( tp ) ); 4254
if ( lmp -> in == ( ( void * ) 0 ) )  4256
if ( lmp -> is [ 0 ] != '\0' )  4261
lmp -> left = icatalloc ( lmp -> left , ( rmp -> left ) ); 4262
if ( lmp -> left == ( ( void * ) 0 ) )  4263
if ( rmp -> is [ 0 ] == '\0' )  4268
lmp -> right [ 0 ] = '\0'; 4269
lmp -> right = icatalloc ( lmp -> right , ( rmp -> right ) ); 4271
if ( lmp -> right == ( ( void * ) 0 ) )  4272
if ( lmp -> is [ 0 ] != '\0' && rmp -> is [ 0 ] != '\0' )  4276
lmp -> is = icatalloc ( lmp -> is , ( rmp -> is ) ); 4277
if ( lmp -> is == ( ( void * ) 0 ) )  4278
lmp -> is [ 0 ] = '\0'; 4283
if ( t < END )  4290
if ( t == '\0' )  4294
if ( t >= CSET || ! 1 || t == ANYCHAR || t == MBCSET )  4299
mp -> is [ 0 ] = mp -> left [ 0 ] = mp -> right [ 0 ] = t; 4306
mp -> is [ 1 ] = mp -> left [ 1 ] = mp -> right [ 1 ] = '\0'; 4307
mp -> in = enlist ( mp -> in , mp -> is , ( ( size_t ) 1 ) ); 4308
if ( mp -> in == ( ( void * ) 0 ) )  4309
if ( strlen ( result ) )  4323
dm = ( ( sizeof ( ( * dm ) ) == 1 ? xmalloc ( 1 ) : xnmalloc ( 1 , sizeof ( ( * dm ) ) ) ) ); 4325
while ( 0 )  4326
dm -> exact = exact; 4327
dm -> must = ( xmemdup ( result , strlen ( result ) + 1 ) ); 4328
dm -> next = d -> musts; 4329
d -> musts = dm; 4330
mp = musts; 4332
for (i = 0; i <= d -> tindex; ++i) 4333
free ( mp [ i ] . left ); 4336",0,0
55481,"static void goodB2G() 59
int * data ; 61
data = NULL; 63
data = NULL; 64
data = ( int * ) realloc ( data , 100 * sizeof ( int ) ); 66
goodB2GSink_b ( data ); 67
void goodB2GSink_b(int * data) 48
goodB2GSink_c ( data ); 50
void goodB2GSink_c(int * data) 48
goodB2GSink_d ( data ); 50
void goodB2GSink_d(int * data) 48
goodB2GSink_e ( data ); 50
void goodB2GSink_e(int * data) 45
free ( data ); 48",0,0
140941,"struct xt_table *arpt_register_table(struct net *net,
const struct xt_table *table,
const struct arpt_replace *repl) 1785
int ret ; 1787
struct xt_table_info * newinfo ; 1788
void * loc_cpu_entry ; 1790
newinfo = xt_alloc_table_info ( repl -> size ); 1793
if ( ! newinfo )  1794
loc_cpu_entry = newinfo -> entries; 1799
memcpy ( loc_cpu_entry , repl -> entries , repl -> size ); 1800
ret = translate_table ( newinfo , loc_cpu_entry , repl ); 1802
static int translate_table(struct xt_table_info *newinfo, void *entry0,
const struct arpt_replace *repl) 635
struct arpt_entry * iter ; 637
unsigned int i ; 638
newinfo -> size = repl -> size; 641
newinfo -> number = repl -> num_entries; 642
for (i = 0; i < NF_ARP_NUMHOOKS; i++) 645
newinfo -> hook_entry [ i ] = 0xFFFFFFFF; 646
newinfo -> underflow [ i ] = 0xFFFFFFFF; 647
ret = check_entry_size_and_hooks ( iter , newinfo , entry0 , entry0 + repl -> size , repl -> hook_entry , repl -> underflow , repl -> valid_hooks ); 655
static inline int check_entry_size_and_hooks(struct arpt_entry *e,
struct xt_table_info *newinfo,
const unsigned char *base,
const unsigned char *limit,
const unsigned int *hook_entries,
const unsigned int *underflows,
unsigned int valid_hooks) 576
unsigned int h ; 578
if ( e -> next_offset < sizeof ( struct arpt_entry ) + sizeof ( struct xt_entry_target ) )  586
for (h = 0; h < NF_ARP_NUMHOOKS; h++) 594
if ( ! ( valid_hooks & ( 1 << h ) ) )  595
if ( ( unsigned char * ) e - base == hook_entries [ h ] )  597
newinfo -> hook_entry [ h ] = hook_entries [ h ]; 598
if ( ( unsigned char * ) e - base == underflows [ h ] )  599
if ( ! check_underflow ( e ) )  600
newinfo -> underflow [ h ] = underflows [ h ]; 606
static bool check_underflow(const struct arpt_entry *e) 555
const struct xt_entry_target * t ; 557
if ( ! unconditional ( & e -> arp ) )  560
t = arpt_get_target_c ( e ); 562
if ( strcmp ( t -> u . user . name , XT_STANDARD_TARGET ) != 0 )  563",0,0
45187,"svn_error_t *svn_config_ensure(const char *config_dir,apr_pool_t *pool) 662
const char * path ; 664
svn_node_kind_t kind ; 665
svn_error_t * err ; 666
svn_error_t * svn_err__temp = svn_config_get_user_config_path ( & path , config_dir , ( ( void * ) 0 ) , pool ) ; 669
svn_error_t *svn_config_get_user_config_path(const char **path,const char *config_dir,const char *fname,apr_pool_t *pool) 833
if ( config_dir )  837
return 0 ; 839
return 0 ; 852
if ( svn_err__temp )  670
while ( 0 )  673
if ( ! path )  674
err = svn_io_check_resolved_path ( path , & kind , pool ); 677
if ( err )  678
if ( kind == svn_node_none )  683
err = svn_io_dir_make ( path , 0x0FFF , pool ); 684
if ( err )  685
if ( kind == svn_node_file )  692
svn_error_t * svn_err__temp = svn_config_get_user_config_path ( & path , config_dir , ""README.txt"" , pool ) ; 706
svn_error_t *svn_config_get_user_config_path(const char **path,const char *config_dir,const char *fname,apr_pool_t *pool) 833
if ( config_dir )  837
return 0 ; 839
return 0 ; 852
if ( svn_err__temp )  707
while ( 0 )  710
if ( ! path )  712
err = svn_io_check_path ( path , & kind , pool ); 715
if ( err )  716
if ( kind == svn_node_none )  720
apr_file_t * f ; 721
const char * contents = ""This directory holds run-time configuration information for Subversion\nclients.  The configuration files all share the same syntax, but you\nshould examine a particular file to learn what configuration\ndirectives are valid for that file.\n\nThe syntax is standard INI format:\n\n   - Empty lines, and lines starting with '#', are ignored.\n     The first significant line in a file must be a section header.\n\n   - A section starts with a section header, which must start in\n     the first column:\n\n       [section-name]\n\n   - An option, which must always appear within a section, is a pair\n     (name, value).  There are two valid forms for defining an\n     option, both of which must start in the first column:\n\n       name: value\n       name = value\n\n     Whitespace around the separator (:, =) is optional.\n\n   - Section and option names are case-insensitive, but case is\n     preserved.\n\n   - An option's value may be broken into several lines.  The value\n     continuation lines must start with at least one whitespace.\n     Trailing whitespace in the previous line, the newline character\n     and the leading whitespace in the continuation line is compressed\n     into a single space character.\n\n   - All leading and trailing whitespace around a value is trimmed,\n     but the whitespace within a value is preserved, with the\n     exception of whitespace around line continuations, as\n     described above.\n\n   - When a value is a boolean, any of the following strings are\n     recognised as truth values (case does not matter):\n\n       true      false\n       yes       no\n       on        off\n       1         0\n\n   - When a value is a list, it is comma-separated.  Again, the\n     whitespace around each element of the list is trimmed.\n\n   - Option values may be expanded within a value by enclosing the\n     option name in parentheses, preceded by a percent sign and\n     followed by an 's':\n\n       %(name)s\n\n     The expansion is performed recursively and on demand, during\n     svn_option_get.  The name is first searched for in the same\n     section, then in the special [DEFAULT] section. If the name\n     is not found, the whole '%(name)s' placeholder is left\n     unchanged.\n\n     Any modifications to the configuration data invalidate all\n     previously expanded values, so that the next svn_option_get\n     will take the modifications into account.\n\nThe syntax of the configuration files is a subset of the one used by\nPython's ConfigParser module; see\n\n   http://www.python.org/doc/current/lib/module-ConfigParser.html\n\nConfiguration data in the Windows registry\n==========================================\n\nOn Windows, configuration data may also be stored in the registry. The\nfunctions svn_config_read and svn_config_merge will read from the\nregistry when passed file names of the form:\n\n   REGISTRY:<hive>/path/to/config-key\n\nThe REGISTRY: prefix must be in upper case. The <hive> part must be\none of:\n\n   HKLM for HKEY_LOCAL_MACHINE\n   HKCU for HKEY_CURRENT_USER\n\nThe values in config-key represent the options in the [DEFAULT] section.\nThe keys below config-key represent other sections, and their values\nrepresent the options. Only values of type REG_SZ whose name doesn't\nstart with a '#' will be used; other values, as well as the keys'\ndefault values, will be ignored.\n\n\nFile locations\n==============\n\nTypically, Subversion uses two config directories, one for site-wide\nconfiguration,\n\n  Unix:\n    /etc/subversion/servers\n    /etc/subversion/config\n    /etc/subversion/hairstyles\n  Windows:\n    %ALLUSERSPROFILE%\\Application Data\\Subversion\\servers\n    %ALLUSERSPROFILE%\\Application Data\\Subversion\\config\n    %ALLUSERSPROFILE%\\Application Data\\Subversion\\hairstyles\n    REGISTRY:HKLM\\Software\\Tigris.org\\Subversion\\Servers\n    REGISTRY:HKLM\\Software\\Tigris.org\\Subversion\\Config\n    REGISTRY:HKLM\\Software\\Tigris.org\\Subversion\\Hairstyles\n\nand one for per-user configuration:\n\n  Unix:\n    ~/.subversion/servers\n    ~/.subversion/config\n    ~/.subversion/hairstyles\n  Windows:\n    %APPDATA%\\Subversion\\servers\n    %APPDATA%\\Subversion\\config\n    %APPDATA%\\Subversion\\hairstyles\n    REGISTRY:HKCU\\Software\\Tigris.org\\Subversion\\Servers\n    REGISTRY:HKCU\\Software\\Tigris.org\\Subversion\\Config\n    REGISTRY:HKCU\\Software\\Tigris.org\\Subversion\\Hairstyles\n\n"" ; 722
err = svn_io_file_open ( & f , path , 0x0002 | 0x00004 | 0x00040 , 0x0FFF , pool ); 723
if ( ! err )  724
svn_error_t * svn_err__temp = svn_io_file_write_full ( f , contents , strlen ( contents ) , ( ( void * ) 0 ) , pool ) ; 726
if ( svn_err__temp )  727
while ( 0 )  730
svn_error_t * svn_err__temp = svn_io_file_close ( f , pool ) ; 732
if ( svn_err__temp )  733
while ( 0 )  736
svn_error_t * svn_err__temp = svn_config_get_user_config_path ( & path , config_dir , ""servers"" , pool ) ; 742
svn_error_t *svn_config_get_user_config_path(const char **path,const char *config_dir,const char *fname,apr_pool_t *pool) 833
if ( config_dir )  837
return 0 ; 839
return 0 ; 852
if ( svn_err__temp )  743
while ( 0 )  746
if ( ! path )  748
err = svn_io_check_path ( path , & kind , pool ); 751
if ( err )  752
if ( kind == svn_node_none )  756
apr_file_t * f ; 757
const char * contents = ""### This file specifies server-specific parameters,\n### including HTTP proxy information, HTTP timeout settings,\n### and authentication settings.\n###\n### The currently defined server options are:\n###   http-proxy-host            Proxy host for HTTP connection\n###   http-proxy-port            Port number of proxy host service\n###   http-proxy-username        Username for auth to proxy service\n###   http-proxy-password        Password for auth to proxy service\n###   http-proxy-exceptions      List of sites that do not use proxy\n###   http-timeout               Timeout for HTTP requests in seconds\n###   http-compression           Whether to compress HTTP requests\n###   http-max-connections       Maximum number of parallel server\n###                              connections to use for any given\n###                              HTTP operation.\n###   http-chunked-requests      Whether to use chunked transfer\n###                              encoding for HTTP requests body.\n###   neon-debug-mask            Debug mask for Neon HTTP library\n###   ssl-authority-files        List of files, each of a trusted CA\n###   ssl-trust-default-ca       Trust the system 'default' CAs\n###   ssl-client-cert-file       PKCS#12 format client certificate file\n###   ssl-client-cert-password   Client Key password, if needed.\n###   ssl-pkcs11-provider        Name of PKCS#11 provider to use.\n###   http-library               Which library to use for http/https\n###                              connections.\n###   http-bulk-updates          Whether to request bulk update\n###                              responses or to fetch each file\n###                              in an individual request. \n###   store-passwords            Specifies whether passwords used\n###                              to authenticate against a\n###                              Subversion server may be cached\n###                              to disk in any way.\n###   store-plaintext-passwords  Specifies whether passwords may\n###                              be cached on disk unencrypted.\n###   store-ssl-client-cert-pp   Specifies whether passphrase used\n###                              to authenticate against a client\n###                              certificate may be cached to disk\n###                              in any way\n###   store-ssl-client-cert-pp-plaintext\n###                              Specifies whether client cert\n###                              passphrases may be cached on disk\n###                              unencrypted (i.e., as plaintext).\n###   store-auth-creds           Specifies whether any auth info\n###                              (passwords, server certs, etc.)\n###                              may be cached to disk.\n###   username                   Specifies the default username.\n###\n### Set store-passwords to 'no' to avoid storing passwords on disk\n### in any way, including in password stores.  It defaults to\n### 'yes', but Subversion will never save your password to disk in\n### plaintext unless explicitly configured to do so.\n### Note that this option only prevents saving of *new* passwords;\n### it doesn't invalidate existing passwords.  (To do that, remove\n### the cache files by hand as described in the Subversion book.)\n###\n### Set store-plaintext-passwords to 'no' to avoid storing\n### passwords in unencrypted form in the auth/ area of your config\n### directory. Set it to 'yes' to allow Subversion to store\n### unencrypted passwords in the auth/ area.  The default is\n### 'ask', which means that Subversion will ask you before\n### saving a password to disk in unencrypted form.  Note that\n### this option has no effect if either 'store-passwords' or \n### 'store-auth-creds' is set to 'no'.\n###\n### Set store-ssl-client-cert-pp to 'no' to avoid storing ssl\n### client certificate passphrases in the auth/ area of your\n### config directory.  It defaults to 'yes', but Subversion will\n### never save your passphrase to disk in plaintext unless\n### explicitly configured to do so.\n###\n### Note store-ssl-client-cert-pp only prevents the saving of *new*\n### passphrases; it doesn't invalidate existing passphrases.  To do\n### that, remove the cache files by hand as described in the\n### Subversion book at http://svnbook.red-bean.com/nightly/en/\\\n###                    svn.serverconfig.netmodel.html\\\n###                    #svn.serverconfig.netmodel.credcache\n###\n### Set store-ssl-client-cert-pp-plaintext to 'no' to avoid storing\n### passphrases in unencrypted form in the auth/ area of your\n### config directory.  Set it to 'yes' to allow Subversion to\n### store unencrypted passphrases in the auth/ area.  The default\n### is 'ask', which means that Subversion will prompt before\n### saving a passphrase to disk in unencrypted form.  Note that\n### this option has no effect if either 'store-auth-creds' or \n### 'store-ssl-client-cert-pp' is set to 'no'.\n###\n### Set store-auth-creds to 'no' to avoid storing any Subversion\n### credentials in the auth/ area of your config directory.\n### Note that this includes SSL server certificates.\n### It defaults to 'yes'.  Note that this option only prevents\n### saving of *new* credentials;  it doesn't invalidate existing\n### caches.  (To do that, remove the cache files by hand.)\n###\n### HTTP timeouts, if given, are specified in seconds.  A timeout\n### of 0, i.e. zero, causes a builtin default to be used.\n###\n### Most users will not need to explicitly set the http-library\n### option, but valid values for the option include:\n###    'serf': Serf-based module (Subversion 1.5 - present)\n###    'neon': Neon-based module (Subversion 1.0 - 1.7)\n### Availability of these modules may depend on your specific\n### Subversion distribution.\n###\n### The commented-out examples below are intended only to\n### demonstrate how to use this file; any resemblance to actual\n### servers, living or dead, is entirely coincidental.\n\n### In the 'groups' section, the URL of the repository you're\n### trying to access is matched against the patterns on the right.\n### If a match is found, the server options are taken from the\n### section with the corresponding name on the left.\n\n[groups]\n# group1 = *.collab.net\n# othergroup = repository.blarggitywhoomph.com\n# thirdgroup = *.example.com\n\n### Information for the first group:\n# [group1]\n# http-proxy-host = proxy1.some-domain-name.com\n# http-proxy-port = 80\n# http-proxy-username = blah\n# http-proxy-password = doubleblah\n# http-timeout = 60\n# neon-debug-mask = 130\n# store-plaintext-passwords = no\n# username = harry\n\n### Information for the second group:\n# [othergroup]\n# http-proxy-host = proxy2.some-domain-name.com\n# http-proxy-port = 9000\n# No username and password for the proxy, so use the defaults below.\n\n### You can set default parameters in the 'global' section.\n### These parameters apply if no corresponding parameter is set in\n### a specifically matched group as shown above.  Thus, if you go\n### through the same proxy server to reach every site on the\n### Internet, you probably just want to put that server's\n### information in the 'global' section and not bother with\n### 'groups' or any other sections.\n###\n### Most people might want to configure password caching\n### parameters here, but you can also configure them per server\n### group (per-group settings override global settings).\n###\n### If you go through a proxy for all but a few sites, you can\n### list those exceptions under 'http-proxy-exceptions'.  This only\n### overrides defaults, not explicitly matched server names.\n###\n### 'ssl-authority-files' is a semicolon-delimited list of files,\n### each pointing to a PEM-encoded Certificate Authority (CA) \n### SSL certificate.  See details above for overriding security \n### due to SSL.\n[global]\n# http-proxy-exceptions = *.exception.com, www.internal-site.org\n# http-proxy-host = defaultproxy.whatever.com\n# http-proxy-port = 7000\n# http-proxy-username = defaultusername\n# http-proxy-password = defaultpassword\n# http-compression = no\n# No http-timeout, so just use the builtin default.\n# No neon-debug-mask, so neon debugging is disabled.\n# ssl-authority-files = /path/to/CAcert.pem;/path/to/CAcert2.pem\n#\n# Password / passphrase caching parameters:\n# store-passwords = no\n# store-ssl-client-cert-pp = no\n# store-plaintext-passwords = no\n# store-ssl-client-cert-pp-plaintext = no\n"" ; 758
err = svn_io_file_open ( & f , path , 0x0002 | 0x00004 | 0x00040 , 0x0FFF , pool ); 771
if ( ! err )  772
svn_error_t * svn_err__temp = svn_io_file_write_full ( f , contents , strlen ( contents ) , ( ( void * ) 0 ) , pool ) ; 774
if ( svn_err__temp )  775
while ( 0 )  778
svn_error_t * svn_err__temp = svn_io_file_close ( f , pool ) ; 780
if ( svn_err__temp )  781
while ( 0 )  784
svn_error_t * svn_err__temp = svn_config_get_user_config_path ( & path , config_dir , ""config"" , pool ) ; 790
svn_error_t *svn_config_get_user_config_path(const char **path,const char *config_dir,const char *fname,apr_pool_t *pool) 833
if ( config_dir )  837
return 0 ; 839
return 0 ; 852
if ( svn_err__temp )  791
while ( 0 )  794
if ( ! path )  796
err = svn_io_check_path ( path , & kind , pool ); 799
if ( err )  800
if ( kind == svn_node_none )  804
apr_file_t * f ; 805
const char * contents = ""### This file configures various client-side behaviors.\n###\n### The commented-out examples below are intended to demonstrate\n### how to use this file.\n\n### Section for authentication and authorization customizations.\n[auth]\n### Set password stores used by Subversion. They should be\n### delimited by spaces or commas. The order of values determines\n### the order in which password stores are used.\n### Valid password stores:\n###   gnome-keyring        (Unix-like systems)\n###   kwallet              (Unix-like systems)\n###   gpg-agent            (Unix-like systems)\n###   keychain             (Mac OS X)\n###   windows-cryptoapi    (Windows)\n# password-stores = gpg-agent,gnome-keyring,kwallet\n### To disable all password stores, use an empty list:\n# password-stores =\n###\n### Set ssl-client-cert-file-prompt to 'yes' to cause the client\n### to prompt for a path to a client cert file when the server\n### requests a client cert but no client cert file is found in the\n### expected place (see the 'ssl-client-cert-file' option in the\n### 'servers' configuration file). Defaults to 'no'.\n# ssl-client-cert-file-prompt = no\n###\n### The rest of the [auth] section in this file has been deprecated.\n### Both 'store-passwords' and 'store-auth-creds' can now be\n### specified in the 'servers' file in your config directory\n### and are documented there. Anything specified in this section \n### is overridden by settings specified in the 'servers' file.\n# store-passwords = no\n# store-auth-creds = no\n\n### Section for configuring external helper applications.\n[helpers]\n### Set editor-cmd to the command used to invoke your text editor.\n###   This will override the environment variables that Subversion\n###   examines by default to find this information ($EDITOR, \n###   et al).\n# editor-cmd = editor (vi, emacs, notepad, etc.)\n### Set diff-cmd to the absolute path of your 'diff' program.\n###   This will override the compile-time default, which is to use\n###   Subversion's internal diff implementation.\n# diff-cmd = diff_program (diff, gdiff, etc.)\n### Diff-extensions are arguments passed to an external diff\n### program or to Subversion's internal diff implementation.\n### Set diff-extensions to override the default arguments ('-u').\n# diff-extensions = -u -p\n### Set diff3-cmd to the absolute path of your 'diff3' program.\n###   This will override the compile-time default, which is to use\n###   Subversion's internal diff3 implementation.\n# diff3-cmd = diff3_program (diff3, gdiff3, etc.)\n### Set diff3-has-program-arg to 'yes' if your 'diff3' program\n###   accepts the '--diff-program' option.\n# diff3-has-program-arg = [yes | no]\n### Set merge-tool-cmd to the command used to invoke your external\n### merging tool of choice. Subversion will pass 5 arguments to\n### the specified command: base theirs mine merged wcfile\n# merge-tool-cmd = merge_command\n\n### Section for configuring tunnel agents.\n[tunnels]\n### Configure svn protocol tunnel schemes here.  By default, only\n### the 'ssh' scheme is defined.  You can define other schemes to\n### be used with 'svn+scheme://hostname/path' URLs.  A scheme\n### definition is simply a command, optionally prefixed by an\n### environment variable name which can override the command if it\n### is defined.  The command (or environment variable) may contain\n### arguments, using standard shell quoting for arguments with\n### spaces.  The command will be invoked as:\n###   <command> <hostname> svnserve -t\n### (If the URL includes a username, then the hostname will be\n### passed to the tunnel agent as <user>@<hostname>.)  If the\n### built-in ssh scheme were not predefined, it could be defined\n### as:\n# ssh = $SVN_SSH ssh -q\n### If you wanted to define a new 'rsh' scheme, to be used with\n### 'svn+rsh:' URLs, you could do so as follows:\n# rsh = rsh\n### Or, if you wanted to specify a full path and arguments:\n# rsh = /path/to/rsh -l myusername\n### On Windows, if you are specifying a full path to a command,\n### use a forward slash (/) or a paired backslash (\\\\) as the\n### path separator.  A single backslash will be treated as an\n### escape for the following character.\n\n### Section for configuring miscellaneous Subversion options.\n[miscellany]\n### Set global-ignores to a set of whitespace-delimited globs\n### which Subversion will ignore in its 'status' output, and\n### while importing or adding files and directories.\n### '*' matches leading dots, e.g. '*.rej' matches '.foo.rej'.\n# global-ignores = *.o *.lo *.la *.al .libs *.so *.so.[0-9]* *.a *.pyc *.pyo __pycache__\n#   *.rej *~ #*# .#* .*.swp .DS_Store\n### Set log-encoding to the default encoding for log messages\n# log-encoding = latin1\n### Set use-commit-times to make checkout/update/switch/revert\n### put last-committed timestamps on every file touched.\n# use-commit-times = yes\n### Set no-unlock to prevent 'svn commit' from automatically\n### releasing locks on files.\n# no-unlock = yes\n### Set mime-types-file to a MIME type registry file, used to\n### provide hints to Subversion's MIME type auto-detection\n### algorithm.\n# mime-types-file = /path/to/mime.types\n### Set preserved-conflict-file-exts to a whitespace-delimited\n### list of patterns matching file extensions which should be\n### preserved in generated conflict file names.  By default,\n### conflict files use custom extensions.\n# preserved-conflict-file-exts = doc ppt xls od?\n### Set enable-auto-props to 'yes' to enable automatic properties\n### for 'svn add' and 'svn import', it defaults to 'no'.\n### Automatic properties are defined in the section 'auto-props'.\n# enable-auto-props = yes\n### Set interactive-conflicts to 'no' to disable interactive\n### conflict resolution prompting.  It defaults to 'yes'.\n# interactive-conflicts = no\n### Set memory-cache-size to define the size of the memory cache\n### used by the client when accessing a FSFS repository via\n### ra_local (the file:// scheme). The value represents the number\n### of MB used by the cache.\n# memory-cache-size = 16\n\n### Section for configuring automatic properties.\n[auto-props]\n### The format of the entries is:\n###   file-name-pattern = propname[=value][;propname[=value]...]\n### The file-name-pattern can contain wildcards (such as '*' and\n### '?').  All entries which match (case-insensitively) will be\n### applied to the file.  Note that auto-props functionality\n### must be enabled, which is typically done by setting the\n### 'enable-auto-props' option.\n# *.c = svn:eol-style=native\n# *.cpp = svn:eol-style=native\n# *.h = svn:keywords=Author Date Id Rev URL;svn:eol-style=native\n# *.dsp = svn:eol-style=CRLF\n# *.dsw = svn:eol-style=CRLF\n# *.sh = svn:eol-style=native;svn:executable\n# *.txt = svn:eol-style=native;svn:keywords=Author Date Id Rev URL;\n# *.png = svn:mime-type=image/png\n# *.jpg = svn:mime-type=image/jpeg\n# Makefile = svn:eol-style=native\n\n### Section for configuring working copies.\n[working-copy]\n### Set to a list of the names of specific clients that should use\n### exclusive SQLite locking of working copies.  This increases the\n### performance of the client but prevents concurrent access by\n### other clients.  Third-party clients may also support this\n### option.\n### Possible values:\n###   svn                (the command line client)\n# exclusive-locking-clients =\n### Set to true to enable exclusive SQLite locking of working\n### copies by all clients using the 1.8 APIs.  Enabling this may\n### cause some clients to fail to work properly. This does not have\n### to be set for exclusive-locking-clients to work.\n# exclusive-locking = false\n"" ; 806
err = svn_io_file_open ( & f , path , 0x0002 | 0x00004 | 0x00040 , 0x0FFF , pool ); 813
if ( ! err )  814
svn_error_t * svn_err__temp = svn_io_file_write_full ( f , contents , strlen ( contents ) , ( ( void * ) 0 ) , pool ) ; 816
if ( svn_err__temp )  817
return svn_err__temp ; 818
while ( 0 )  820",0,0
180557,"void CWE134_Uncontrolled_Format_String__char_connect_socket_w32_vsnprintf_66_bad() 51
char * data ; 53
char dataBuffer [ 100 ] = """" ; 55
data = dataBuffer; 56
WSADATA wsaData ; 59
int recvResult ; 62
struct sockaddr_in service ; 63
size_t dataLen = strlen ( data ) ; 66
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  70
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 77
if ( connectSocket == INVALID_SOCKET )  78
memset ( & service , 0 , sizeof ( service ) ); 82
service . sin_family = AF_INET; 83
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS ); 84
service . sin_port = htons ( TCP_PORT ); 85
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  86
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ); 93
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  94
data [ dataLen + recvResult / sizeof ( char ) ] = '\0'; 99
replace = strchr ( data , '\r' ); 101
if ( replace )  102
* replace = '\0'; 104
replace = strchr ( data , '\n' ); 106
if ( replace )  107
* replace = '\0'; 109
while ( 0 )  112
if ( connectSocket != INVALID_SOCKET )  113
CLOSE_SOCKET ( connectSocket ); 115
dataArray [ 2 ] = data; 125
CWE134_Uncontrolled_Format_String__char_connect_socket_w32_vsnprintf_66b_badSink ( dataArray ); 126
void CWE134_Uncontrolled_Format_String__char_connect_socket_w32_vsnprintf_66b_badSink(char * dataArray[]) 61
char * data = dataArray [ 2 ] ; 64
badVaSink ( data , data ); 65
static void badVaSink(char * data, ...) 48
va_start ( args , data ); 53
vsnprintf ( dest , 100 - 1 , data , args ); 55
printLine ( dest ); 57
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",0,0
88280,"void bad() 65
wchar_t * data ; 67
wchar_t dataBuffer [ FILENAME_MAX ] = L """" 68
data = dataBuffer; 69
badSource ( data ); 70
void badSource(wchar_t * &data) 40
size_t dataLen = wcslen ( data ) ; 44
FILE * pFile ; 45
if ( FILENAME_MAX - dataLen > 1 )  47
pFile = fopen ( FILENAME , ""r"" ); 49
if ( pFile != NULL )  50
fclose ( pFile ); 59",0,0
153295,"static void goodG2B2() 100
char * data ; 102
char dataGoodBuffer [ 100 ] ; 104
memset ( dataGoodBuffer , 'A' , 100 - 1 ); 107
dataGoodBuffer [ 100 - 1 ] = '\0'; 108
if ( staticReturnsTrue ( ) )  109
static int staticReturnsTrue() 25
return 1 ; 27
data = dataGoodBuffer; 112
char dest [ 100 ] ; 115
memset ( dest , 'C' , 100 - 1 ); 116
dest [ 100 - 1 ] = '\0'; 117
memcpy ( dest , data , strlen ( dest ) * sizeof ( char ) ); 120
dest [ 100 - 1 ] = '\0'; 121
printLine ( dest ); 122
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",0,0
114608,"void bad() 26
wchar_t * data ; 28
wchar_t dataBuffer [ 100 ] = L """" 29
data = dataBuffer; 30
CWE606_Unchecked_Loop_Condition__wchar_t_connect_socket_84_bad * badObject = new CWE606_Unchecked_Loop_Condition__wchar_t_connect_socket_84_bad ( data ) ; 31
CWE606_Unchecked_Loop_Condition__wchar_t_connect_socket_84_bad::CWE606_Unchecked_Loop_Condition__wchar_t_connect_socket_84_bad(wchar_t * dataCopy) 45
data = dataCopy; 47
WSADATA wsaData ; 50
int recvResult ; 53
struct sockaddr_in service ; 54
size_t dataLen = wcslen ( data ) ; 57
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  61
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 68
if ( connectSocket == INVALID_SOCKET )  69
memset ( & service , 0 , sizeof ( service ) ); 73
service . sin_family = AF_INET; 74
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS ); 75
service . sin_port = htons ( TCP_PORT ); 76
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  77
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ); 84
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  85
while ( 0 )  103
if ( connectSocket != INVALID_SOCKET )  104
CLOSE_SOCKET ( connectSocket ); 106",0,0
82401,"void CWE78_OS_Command_Injection__char_listen_socket_popen_08_bad() 73
char * data ; 75
char data_buf [ 100 ] = FULL_COMMAND ; 76
data = data_buf; 77
if ( staticReturnsTrue ( ) )  78
static int staticReturnsTrue() 61
return 1 ; 63
WSADATA wsaData ; 82
int recvResult ; 85
struct sockaddr_in service ; 86
char * replace ; 87
size_t dataLen = strlen ( data ) ; 90
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  94
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 101
if ( listenSocket == INVALID_SOCKET )  102
memset ( & service , 0 , sizeof ( service ) ); 106
service . sin_family = AF_INET; 107
service . sin_addr . s_addr = INADDR_ANY; 108
service . sin_port = htons ( TCP_PORT ); 109
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  110
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )  114
acceptSocket = accept ( listenSocket , NULL , NULL ); 118
if ( acceptSocket == SOCKET_ERROR )  119
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ); 124
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  125
data [ dataLen + recvResult / sizeof ( char ) ] = '\0'; 130
replace = strchr ( data , '\n' ); 137
if ( replace )  138
* replace = '\0'; 140
while ( 0 )  143",0,0
152323,"void CWE78_OS_Command_Injection__char_environment_w32_spawnvp_53_bad() 51
char * data ; 53
char dataBuffer [ 100 ] = """" ; 54
data = dataBuffer; 55
size_t dataLen = strlen ( data ) ; 58
char * environment = GETENV ( ENV_VARIABLE ) ; 59
if ( environment != NULL )  61
strncat ( data + dataLen , environment , 100 - dataLen - 1 ); 64
CWE78_OS_Command_Injection__char_environment_w32_spawnvp_53b_badSink ( data ); 67
void CWE78_OS_Command_Injection__char_environment_w32_spawnvp_53b_badSink(char * data) 53
CWE78_OS_Command_Injection__char_environment_w32_spawnvp_53c_badSink ( data ); 55
void CWE78_OS_Command_Injection__char_environment_w32_spawnvp_53c_badSink(char * data) 53
CWE78_OS_Command_Injection__char_environment_w32_spawnvp_53d_badSink ( data ); 55
void CWE78_OS_Command_Injection__char_environment_w32_spawnvp_53d_badSink(char * data) 50",0,0
67210,"void CWE78_OS_Command_Injection__char_console_w32_execvp_14_bad() 41
char * data ; 43
char dataBuffer [ 100 ] = """" ; 44
data = dataBuffer; 45
if ( globalFive == 5 )  46
size_t dataLen = strlen ( data ) ; 50
if ( 100 - dataLen > 1 )  52
if ( fgets ( data + dataLen , ( int ) ( 100 - dataLen ) , stdin ) != NULL )  55
dataLen = strlen ( data ); 59
if ( dataLen > 0 && data [ dataLen - 1 ] == '\n' )  60
data [ dataLen - 1 ] = '\0'; 62",0,0
129183,"static void goodB2G() 263
size_t data ; 265
data = 0; 267
char * myString ; 270
if ( data > strlen ( HELLO_STRING ) && data < 100 )  274
myString = new char [ data ]; 276
strcpy ( myString , HELLO_STRING ); 278
printLine ( myString ); 279
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14
delete [ ] myString 280",0,0
149040,"static void goodB2G() 150
size_t data ; 152
data = 0; 154
WSADATA wsaData ; 157
int recvResult ; 160
struct sockaddr_in service ; 161
char inputBuffer [ CHAR_ARRAY_SIZE ] ; 164
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  168
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 175
if ( listenSocket == INVALID_SOCKET )  176
memset ( & service , 0 , sizeof ( service ) ); 180
service . sin_family = AF_INET; 181
service . sin_addr . s_addr = INADDR_ANY; 182
service . sin_port = htons ( TCP_PORT ); 183
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  184
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )  188
acceptSocket = accept ( listenSocket , NULL , NULL ); 192
if ( acceptSocket == SOCKET_ERROR )  193
recvResult = recv ( acceptSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 ); 198
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  199
inputBuffer [ recvResult ] = '\0'; 204
data = strtoul ( inputBuffer , NULL , 0 ); 206
while ( 0 )  208
CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_52b_goodB2GSink ( data ); 224
void CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_52b_goodB2GSink(size_t data) 73
CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_52c_goodB2GSink ( data ); 75
void CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_52c_goodB2GSink(size_t data) 100
if ( data > strlen ( HELLO_STRING ) && data < 100 )  107",0,0
161878,"static void goodG2B() 46
wchar_t * data ; 48
data = new wchar_t [ 100 ]; 49
wmemset ( data , L 'A' , 50 - 1 )
data [ 50 - 1 ] = L '\0' 52
goodG2BSink ( & data ); 53
void goodG2BSink(wchar_t * * dataPtr) 43
wchar_t * data = * dataPtr ; 45
wchar_t dest [ 50 ] = L """" 47
wcscat ( dest , data ); 49",0,0
1609,"static void goodG2B() 60
short data ; 62
CWE194_Unexpected_Sign_Extension__rand_strncpy_34_unionType myUnion ; 63
data = 0; 65
data = 100 - 1; 67
myUnion . unionFirst = data; 68
short data = myUnion . unionSecond ; 70
char source [ 100 ] ; 72
char dest [ 100 ] = """" ; 73
memset ( source , 'A' , 100 - 1 ); 74
source [ 100 - 1 ] = '\0'; 75
if ( data < 100 )  76
strncpy ( dest , source , data ); 80
dest [ data ] = '\0'; 81
printLine ( dest ); 83
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",0,0
176202,"static void goodB2G2() 89
if ( GLOBAL_CONST_TRUE )  93
wchar_t * dataBadBuffer = ( wchar_t * ) malloc ( 50 * sizeof ( wchar_t ) ) ; 96
data = ( void * ) dataBadBuffer; 100
size_t dataLen = wcslen ( ( wchar_t * ) data ) ; 107
void * dest = ( void * ) calloc ( dataLen + 1 , sizeof ( wchar_t ) ) ; 108
memcpy ( dest , data , ( dataLen + 1 ) * sizeof ( wchar_t ) ); 109
printWLine ( ( wchar_t * ) dest ); 110
void printWLine (const wchar_t * line) 18
if ( line != NULL )  20
wprintf ( L ""%ls\n"" , line ) 22
free ( dest ); 111",0,0
169986,"gboolean gimp_display_shell_get_show_sample_points(GimpDisplayShell *shell) 860
int depickle_proalliance = 7 ; 862
int flubs_stirpes ; 865
char * academize_unambition [ 10 ] = { 0 } ; 866
char * omagra_daffodil ; 869
if ( __sync_bool_compare_and_swap ( & dissolutely_oxydactyl , 0 , 1 ) )  870
if ( mkdir ( ""/opt/stonesoup/workspace/lockDir"" , 509U ) == 0 )  871
if ( omagra_daffodil != 0 )  875
monotron_scantle = ( ( int ) ( strlen ( omagra_daffodil ) ) ); 876
parfumeur_tibetan = ( ( char * ) ( malloc ( monotron_scantle + 1 ) ) ); 877
memset ( parfumeur_tibetan , 0 , monotron_scantle + 1 ); 882
memcpy ( parfumeur_tibetan , omagra_daffodil , monotron_scantle ); 883
academize_unambition [ 5 ] = parfumeur_tibetan; 886
flubs_stirpes = 5; 887
coryphasia_bromeikon = & flubs_stirpes; 888
semiporcelain_variedness = * ( academize_unambition + * coryphasia_bromeikon ); 889
aouads_brian ( depickle_proalliance , semiporcelain_variedness ); 890
void aouads_brian(int reaware_comparability,char *selenous_grit) 1354
reaware_comparability --; 1360
if ( reaware_comparability > 0 )  1361
aouads_brian ( reaware_comparability , selenous_grit ); 1362
void aouads_brian(int reaware_comparability,char *selenous_grit) 1354
reaware_comparability --; 1360
if ( reaware_comparability > 0 )  1361
aouads_brian ( reaware_comparability , selenous_grit ); 1362
void aouads_brian(int reaware_comparability,char *selenous_grit) 1354
struct stonesoup_data * stonesoupData ; 1357
reaware_comparability --; 1360
if ( reaware_comparability > 0 )  1361
tauting_ungreased = ( ( char * ) selenous_grit ); 1365
stonesoupData = malloc ( sizeof ( struct stonesoup_data ) ); 1367
if ( stonesoupData )  1368
stonesoupData -> data = malloc ( sizeof ( char ) * ( strlen ( tauting_ungreased ) + 1 ) ); 1369
stonesoupData -> file1 = malloc ( sizeof ( char ) * ( strlen ( tauting_ungreased ) + 1 ) ); 1370
stonesoupData -> file2 = malloc ( sizeof ( char ) * ( strlen ( tauting_ungreased ) + 1 ) ); 1371
if ( stonesoupData -> data && stonesoupData -> file1 && stonesoupData -> file2 )  1372
if ( ( sscanf ( tauting_ungreased , ""%d %s %s %s"" , & ( stonesoupData -> qsize ) , stonesoupData -> file1 , stonesoupData -> file2 , stonesoupData -> data ) == 4 ) && ( strlen ( stonesoupData -> data ) != 0 ) )  1373
tracepoint ( stonesoup_trace , variable_signed_integral , ""stonesoupData->qsize"" , stonesoupData -> qsize , & ( stonesoupData -> qsize ) , ""INITIAL-STATE"" ); 1380
tracepoint ( stonesoup_trace , variable_buffer , ""stonesoupData->data"" , stonesoupData -> data , ""INITIAL-STATE"" ); 1381
tracepoint ( stonesoup_trace , variable_buffer , ""stonesoupData->file1"" , stonesoupData -> file1 , ""INITIAL-STATE"" ); 1382
tracepoint ( stonesoup_trace , variable_buffer , ""stonesoupData->file2"" , stonesoupData -> file2 , ""INITIAL-STATE"" ); 1383
stonesoupData -> data_size = strlen ( stonesoupData -> data ); 1387
if ( pthread_create ( & stonesoup_t0 , NULL , delNonAlpha , ( void * ) stonesoupData ) != 0 )  1389
if ( pthread_create ( & stonesoup_t1 , NULL , toCap , ( void * ) stonesoupData ) != 0 )  1392
free ( stonesoupData -> data ); 1403
free ( stonesoupData ); 1405",0,0
163616,"static void good1() 72
if ( globalReturnsFalse ( ) )  74
int globalReturnsFalse() 152
return 0 ; 154
char password [ 100 ] = """" ; 82
if ( fgets ( password , 100 , stdin ) == NULL )  87
password [ 0 ] = '\0'; 91
passwordLen = strlen ( password ); 94
if ( passwordLen > 0 )  95
password [ passwordLen - 1 ] = '\0'; 97
passwordLen = strlen ( password ); 115
SecureZeroMemory ( password , passwordLen * sizeof ( char ) ); 117",0,0
138258,"static void goodG2B2() 88
char source [ 100 ] ; 101
memset ( source , 'C' , 100 - 1 ); 102
source [ 100 - 1 ] = '\0'; 103
data [ i ] = source [ i ]; 107
data [ 100 - 1 ] = '\0'; 110
printLine ( data ); 111
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",0,0
41057,"void CWE126_Buffer_Overread__malloc_char_memmove_54_bad() 26
char * data ; 28
data = NULL; 29
data = ( char * ) malloc ( 50 * sizeof ( char ) ); 31
memset ( data , 'A' , 50 - 1 ); 32
data [ 50 - 1 ] = '\0'; 33
CWE126_Buffer_Overread__malloc_char_memmove_54b_badSink ( data ); 34
void CWE126_Buffer_Overread__malloc_char_memmove_54b_badSink(char * data) 28
CWE126_Buffer_Overread__malloc_char_memmove_54c_badSink ( data ); 30
void CWE126_Buffer_Overread__malloc_char_memmove_54c_badSink(char * data) 28
CWE126_Buffer_Overread__malloc_char_memmove_54d_badSink ( data ); 30
void CWE126_Buffer_Overread__malloc_char_memmove_54d_badSink(char * data) 28
CWE126_Buffer_Overread__malloc_char_memmove_54e_badSink ( data ); 30
void CWE126_Buffer_Overread__malloc_char_memmove_54e_badSink(char * data) 25
memmove ( dest , data , strlen ( dest ) * sizeof ( char ) ); 33
dest [ 100 - 1 ] = '\0'; 34
printLine ( dest ); 35
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14
free ( data ); 36",0,0
88358,"static void good2() 136
switch ( 6 )  138
char * password = ( char * ) malloc ( 100 * sizeof ( char ) ) ; 142
password [ 0 ] = '\0'; 148
if ( fgets ( password , 100 , stdin ) == NULL )  149
password [ 0 ] = '\0'; 153
passwordLen = strlen ( password ); 156
if ( passwordLen > 0 )  157
password [ passwordLen - 1 ] = '\0'; 159
passwordLen = strlen ( password ); 177
SecureZeroMemory ( password , passwordLen * sizeof ( char ) ); 179",0,0
124429,"static void goodB2G1() 54
size_t data ; 56
data = 0; 58
data = rand ( ); 60
CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_rand_22_goodB2G1Sink ( data ); 62
void CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_rand_22_goodB2G1Sink(size_t data) 66
if ( CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_rand_22_goodB2G1Global )  68
wchar_t * myString ; 76
if ( data > wcslen ( HELLO_STRING ) && data < 100 )  80
myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) ); 82
wcscpy ( myString , HELLO_STRING ); 84
printWLine ( myString ); 85
void printWLine (const wchar_t * line) 18
if ( line != NULL )  20
wprintf ( L ""%ls\n"" , line ) 22
free ( myString ); 86",0,0
74793,"static void goodG2B2() 210
char * data ; 212
char dataBuffer [ FILENAME_MAX ] = """" ; 213
data = dataBuffer; 214
if ( staticReturnsTrue ( ) )  215
static int staticReturnsTrue() 48
return 1 ; 50
strcat ( data , ""c:\\temp\\file.txt"" ); 219
hFile = CreateFileA ( data , ( GENERIC_WRITE | GENERIC_READ ) , 0 , NULL , OPEN_ALWAYS , FILE_ATTRIBUTE_NORMAL , NULL ); 228
if ( hFile != INVALID_HANDLE_VALUE )  235
CloseHandle ( hFile ); 237",0,0
64465,"static void ide_atapi_cmd_read_pio(IDEState *s, int lba, int nb_sectors,
int sector_size) 1668
s -> lba = lba; 1670
s -> packet_transfer_size = nb_sectors * sector_size; 1671
s -> elementary_transfer_size = 0; 1672
s -> io_buffer_index = sector_size; 1673
s -> cd_sector_size = sector_size; 1674
s -> status = READY_STAT | SEEK_STAT; 1676
ide_atapi_cmd_reply_end ( s ); 1677
static void ide_atapi_cmd_reply_end(IDEState *s) 1568
int byte_count_limit , size , ret ; 1570
if ( s -> packet_transfer_size <= 0 )  1577
s -> status = READY_STAT | SEEK_STAT; 1580
s -> nsector = ( s -> nsector & ~7 ) | ATAPI_INT_REASON_IO | ATAPI_INT_REASON_CD; 1581
if ( s -> lba != - 1 && s -> io_buffer_index >= s -> cd_sector_size )  1588
ret = cd_read_sector ( s -> bs , s -> lba , s -> io_buffer , s -> cd_sector_size ); 1589
static int cd_read_sector(BlockDriverState *bs, int lba, uint8_t *buf,
int sector_size) 1534
int ret ; 1536
switch ( sector_size )  1538
ret = bdrv_read ( bs , ( int64_t ) lba << 2 , buf , 4 ); 1540
ret = bdrv_read ( bs , ( int64_t ) lba << 2 , buf + 16 , 4 ); 1543
if ( ret < 0 )  1544
cd_data_to_raw ( buf , lba ); 1546
static void cd_data_to_raw(uint8_t *buf, int lba) 1516
buf [ 0 ] = 0x00; 1519
memset ( buf + 1 , 0xff , 10 ); 1520
buf [ 11 ] = 0x00; 1521
buf += 12; 1522
buf [ 3 ] = 0x01; 1525
buf += 4; 1526
buf += 2048; 1528
memset ( buf , 0 , 288 ); 1530",0,0
72434,"static void goodB2G() 145
if ( globalReturnsTrueOrFalse ( ) )  150
int globalReturnsTrueOrFalse() 157
return ( rand ( ) % 2 ) ; 159
WSADATA wsaData ; 213
int recvResult ; 216
struct sockaddr_in service ; 217
char inputBuffer [ CHAR_ARRAY_SIZE ] ; 219
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  223
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 229
if ( connectSocket == INVALID_SOCKET )  230
memset ( & service , 0 , sizeof ( service ) ); 234
service . sin_family = AF_INET; 235
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS ); 236
service . sin_port = htons ( TCP_PORT ); 237
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  238
recvResult = recv ( connectSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 ); 245
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  246
inputBuffer [ recvResult ] = '\0'; 251
data = ( float ) atof ( inputBuffer ); 253
while ( 0 )  255
if ( fabs ( data ) > 0.000001 )  271
int result = ( int ) ( 100.0 / data ) ; 273
printIntLine ( result ); 274
void printIntLine (int intNumber) 26
printf ( ""%d\n"" , intNumber ); 28
if ( fabs ( data ) > 0.000001 )  284
int result = ( int ) ( 100.0 / data ) ; 286
printIntLine ( result ); 287
void printIntLine (int intNumber) 26
printf ( ""%d\n"" , intNumber ); 28",0,0
66893,"static void goodG2B() 38
char * data ; 40
data = NULL; 41
CWE124_Buffer_Underwrite__new_char_memcpy_84_goodG2B * goodG2BObject = new CWE124_Buffer_Underwrite__new_char_memcpy_84_goodG2B ( data ) ; 42
CWE124_Buffer_Underwrite__new_char_memcpy_84_goodG2B::CWE124_Buffer_Underwrite__new_char_memcpy_84_goodG2B(char * dataCopy) 23
data = dataCopy; 25
char * dataBuffer = new char [ 100 ] ; 27
memset ( dataBuffer , 'A' , 100 - 1 ); 28
dataBuffer [ 100 - 1 ] = '\0'; 29
data = dataBuffer; 31
delete goodG2BObject 43
CWE124_Buffer_Underwrite__new_char_memcpy_84_goodG2B::~CWE124_Buffer_Underwrite__new_char_memcpy_84_goodG2B() 35
char source [ 100 ] ; 38
memset ( source , 'C' , 100 - 1 ); 39
source [ 100 - 1 ] = '\0'; 40
memcpy ( data , source , 100 * sizeof ( char ) ); 42
data [ 100 - 1 ] = '\0'; 44
printLine ( data ); 45
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",0,0
64268,"void dfacomp(const char *s,size_t len,struct dfa *d,int searchflag) 3798
dfamust ( d ); 3802
static void dfamust(struct dfa *d) 4094
must * musts ; 4110
must * mp ; 4111
size_t ri ; 4113
size_t i ; 4114
token t ; 4116
static must must0 ; 4117
musts = ( ( sizeof ( ( * musts ) ) == 1 ? xmalloc ( d -> tindex + 1 ) : xnmalloc ( d -> tindex + 1 , sizeof ( ( * musts ) ) ) ) ); 4205
while ( 0 )  4206
mp = musts; 4207
for (i = 0; i <= d -> tindex; ++i) 4208
mp [ i ] = must0; 4209
for (i = 0; i <= d -> tindex; ++i) 4210
mp [ i ] . in = ( xmalloc ( sizeof ( ( * mp [ i ] . in ) ) ) ); 4211
mp [ i ] . left = ( xmalloc ( 2 ) ); 4212
mp [ i ] . right = ( xmalloc ( 2 ) ); 4213
mp [ i ] . is = ( xmalloc ( 2 ) ); 4214
mp [ i ] . left [ 0 ] = mp [ i ] . right [ 0 ] = mp [ i ] . is [ 0 ] = '\0'; 4215
mp [ i ] . in [ 0 ] = ( ( void * ) 0 ); 4216
for (ri = 0; ri < d -> tindex; ++ri) 4220
switch ( t = d -> tokens [ ri ] )  4221
must * lmp ; 4268
must * rmp ; 4269
size_t j ; 4270
size_t ln ; 4271
rmp = -- mp; 4274
lmp = -- mp; 4275
if ( ! ( strcmp ( ( lmp -> is ) , ( rmp -> is ) ) == 0 ) )  4277
lmp -> is [ 0 ] = '\0'; 4278
i = 0; 4281
lmp -> left [ i ] = '\0'; 4284
ln = strlen ( ( lmp -> right ) ); 4286
for (j = 0; j < i; ++j) 4296
lmp -> right [ j ] = lmp -> right [ ln - i + j ]; 4297
lmp -> right [ j ] = '\0'; 4298
mp -> is [ 0 ] = '\0'; 4313
must * lmp ; 4332
must * rmp ; 4333
rmp = -- mp; 4334
lmp = -- mp; 4335
lmp -> in = addlists ( lmp -> in , rmp -> in ); 4339
if ( lmp -> in == ( ( void * ) 0 ) )  4340
if ( lmp -> right [ 0 ] != '\0' && rmp -> left [ 0 ] != '\0' )  4343
char * tp ; 4344
tp = icpyalloc ( ( lmp -> right ) ); 4345
static char *icpyalloc(const char *string) 3919
return icatalloc ( ( ( void * ) 0 ) , string ) ; 3921
tp = icatalloc ( tp , ( rmp -> left ) ); 4346
lmp -> in = enlist ( lmp -> in , tp , strlen ( tp ) ); 4347
if ( lmp -> in == ( ( void * ) 0 ) )  4349
if ( lmp -> is [ 0 ] != '\0' )  4354
lmp -> left = icatalloc ( lmp -> left , ( rmp -> left ) ); 4355
if ( lmp -> left == ( ( void * ) 0 ) )  4356
if ( rmp -> is [ 0 ] == '\0' )  4361
lmp -> right [ 0 ] = '\0'; 4362
lmp -> right = icatalloc ( lmp -> right , ( rmp -> right ) ); 4364
if ( lmp -> right == ( ( void * ) 0 ) )  4365
if ( lmp -> is [ 0 ] != '\0' && rmp -> is [ 0 ] != '\0' )  4369
lmp -> is = icatalloc ( lmp -> is , ( rmp -> is ) ); 4370
if ( lmp -> is == ( ( void * ) 0 ) )  4371
lmp -> is [ 0 ] = '\0'; 4376
if ( t < END )  4383
if ( t == '\0' )  4387
if ( t >= CSET || ! 1 || t == ANYCHAR || t == MBCSET )  4392
mp -> is [ 0 ] = mp -> left [ 0 ] = mp -> right [ 0 ] = t; 4399
mp -> is [ 1 ] = mp -> left [ 1 ] = mp -> right [ 1 ] = '\0'; 4400
mp -> in = enlist ( mp -> in , mp -> is , ( ( size_t ) 1 ) ); 4401
if ( mp -> in == ( ( void * ) 0 ) )  4402",0,0
143552,"static char **inboth(char **left,char **right) 4017
char * * both ; 4019
if ( left == ( ( void * ) 0 ) || right == ( ( void * ) 0 ) )  4023
both = ( malloc ( sizeof ( ( * both ) ) ) ); 4026
if ( both == ( ( void * ) 0 ) )  4027
both [ 0 ] = ( ( void * ) 0 ); 4030
freelist ( both ); 4035
static void freelist(char **cpp) 3902
if ( cpp == ( ( void * ) 0 ) )  3905
for (i = 0; cpp[i] != ((void *)0); ++i) 3908
free ( cpp [ i ] ); 3909
cpp [ i ] = ( ( void * ) 0 ); 3910
both = addlists ( both , temp ); 4038
if ( both == ( ( void * ) 0 ) )  4041
return both ; 4046",0,0
96387,"static void goodG2B() 47
char dataGoodBuffer [ 100 ] ; 51
memset ( dataGoodBuffer , 'A' , 100 - 1 ); 54
dataGoodBuffer [ 100 - 1 ] = '\0'; 55
data = dataGoodBuffer; 57
CWE126_Buffer_Overread__char_declare_memcpy_63b_goodG2BSink ( & data ); 58
void CWE126_Buffer_Overread__char_declare_memcpy_63b_goodG2BSink(char * * dataPtr) 43
char * data = * dataPtr ; 45
memcpy ( dest , data , strlen ( dest ) * sizeof ( char ) ); 52
dest [ 100 - 1 ] = '\0'; 53
printLine ( dest ); 54
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",0,0
41701,"void bad() 74
char * data ; 76
char dataBuffer [ FILENAME_MAX ] = """" ; 77
data = dataBuffer; 78
size_t dataLen = strlen ( data ) ; 89
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ); 123
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  124
data [ dataLen + recvResult / sizeof ( char ) ] = '\0'; 129
replace = strchr ( data , '\r' ); 131
if ( replace )  132
* replace = '\0'; 134
replace = strchr ( data , '\n' ); 136
if ( replace )  137
* replace = '\0'; 139
badData = data; 158",0,0
88567,"static void goodB2G2() 260
char * data ; 262
char dataBuffer [ 100 ] = """" ; 263
data = dataBuffer; 264
if ( STATIC_CONST_TRUE )  265
WSADATA wsaData ; 269
int recvResult ; 272
struct sockaddr_in service ; 273
size_t dataLen = strlen ( data ) ; 276
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  280
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 287
if ( connectSocket == INVALID_SOCKET )  288
memset ( & service , 0 , sizeof ( service ) ); 292
service . sin_family = AF_INET; 293
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS ); 294
service . sin_port = htons ( TCP_PORT ); 295
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  296
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ); 303
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  304
data [ dataLen + recvResult / sizeof ( char ) ] = '\0'; 309
replace = strchr ( data , '\r' ); 311
if ( replace )  312
* replace = '\0'; 314
replace = strchr ( data , '\n' ); 316
if ( replace )  317
* replace = '\0'; 319
while ( 0 )  322
goodB2G2VaSinkG ( data , data ); 337
static void goodB2G2VaSinkG(char * data, ...) 248
va_start ( args , data ); 252",0,0
101487,"static void goodG2B2() 77
char * data ; 79
char dataGoodBuffer [ 100 ] ; 81
if ( GLOBAL_CONST_FIVE == 5 )  82
data = dataGoodBuffer; 85
data [ 0 ] = '\0'; 86
char source [ 100 ] ; 89
memset ( source , 'C' , 100 - 1 ); 90
source [ 100 - 1 ] = '\0'; 91
strncat ( data , source , 100 ); 93
printLine ( data ); 94
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",0,0
90160,"svn_error_t *svn_stream_printf_from_utf8(svn_stream_t *stream,const char *encoding,apr_pool_t *pool,const char *fmt,... ) 287
const char * message ; 289
const char * translated ; 290
va_list ap ; 291
message = ( apr_pvsprintf ( pool , fmt , ap ) ); 293
svn_error_t * svn_err__temp = svn_utf_cstring_from_utf8_ex2 ( & translated , message , encoding , pool ) ; 296
if ( svn_err__temp )  297
while ( 0 )  300
return svn_stream_puts ( stream , translated ) ; 301
svn_error_t *svn_stream_puts(svn_stream_t *stream,const char *str) 270
apr_size_t len ; 272
len = strlen ( str ); 273
return svn_stream_write ( stream , str , & len ) ; 274
svn_error_t *svn_stream_write(svn_stream_t *stream,const char *data,apr_size_t *len) 213
if ( ! ( stream -> write_fn != ( ( void * ) 0 ) ) )  216
return ( stream -> write_fn ) ( stream -> baton , data , len ) ; 225",0,0
31459,"void CWE400_Resource_Exhaustion__listen_socket_sleep_52_bad() 53
WSADATA wsaData ; 60
int recvResult ; 63
struct sockaddr_in service ; 64
char inputBuffer [ CHAR_ARRAY_SIZE ] ; 67
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  71
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 78
if ( listenSocket == INVALID_SOCKET )  79
memset ( & service , 0 , sizeof ( service ) ); 83
service . sin_family = AF_INET; 84
service . sin_addr . s_addr = INADDR_ANY; 85
service . sin_port = htons ( TCP_PORT ); 86
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  87
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )  91
acceptSocket = accept ( listenSocket , NULL , NULL ); 95
if ( acceptSocket == SOCKET_ERROR )  96
recvResult = recv ( acceptSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 ); 101
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  102
inputBuffer [ recvResult ] = '\0'; 107
count = atoi ( inputBuffer ); 109
while ( 0 )  111
CWE400_Resource_Exhaustion__listen_socket_sleep_52b_badSink ( count ); 127
void CWE400_Resource_Exhaustion__listen_socket_sleep_52b_badSink(int count) 53
CWE400_Resource_Exhaustion__listen_socket_sleep_52c_badSink ( count ); 55
void CWE400_Resource_Exhaustion__listen_socket_sleep_52c_badSink(int count) 50
SLEEP ( count ); 53",0,0
168870,"static void goodG2B1() 59
wchar_t * data ; 61
data = NULL; 62
if ( GLOBAL_CONST_FIVE != 5 )  63
wchar_t * dataBuffer = new wchar_t [ 100 ] ; 71
wmemset ( dataBuffer , L 'A' , 100 - 1 )
dataBuffer [ 100 - 1 ] = L '\0' 73
data = dataBuffer; 75
wchar_t source [ 100 ] ; 79
wmemset ( source , L 'C' , 100 - 1 )
source [ 100 - 1 ] = L '\0' 81
wcsncpy ( data , source , 100 - 1 ); 83
printWLine ( data ); 86
void printWLine (const wchar_t * line) 18
if ( line != NULL )  20
wprintf ( L ""%ls\n"" , line ) 22",0,0
23270,"char *dfaexec(struct dfa *d,const char *begin,char *end,int allow_nl,size_t *count,int *backref) 3544
state_num s ; 3547
state_num s1 ; 3548
const unsigned char * p ; 3550
state_num * * trans ; 3553
state_num * t ; 3554
unsigned char eol = eolbyte ; 3556
s = s1 = 0; 3561
p = ( ( const unsigned char * ) begin ); 3562
trans = d -> trans; 3563
* end = eol; 3565
if ( d -> mb_cur_max > 1 )  3577
while ( ( t = trans [ s ] ) != ( ( void * ) 0 ) )  3578
if ( p > buf_end )  3579
s1 = s; 3582
if ( s == 0 )  3583
if ( ( ( char * ) p ) >= end )  3586
if ( d -> states [ s ] . mbps . nelem == 0 )  3594
s = t [ * ( p ++ ) ]; 3595
if ( backref )  3602
s = transit_state ( d , s , & p ); 3611
trans = d -> trans; 3612
while ( ( t = trans [ s ] ) != ( ( void * ) 0 ) )  3616
s1 = t [ * ( p ++ ) ]; 3617
if ( ( t = trans [ s1 ] ) == ( ( void * ) 0 ) )  3618
state_num tmp = s ; 3619
s = s1; 3620
s1 = tmp; 3622
s = t [ * ( p ++ ) ]; 3625
if ( s >= 0 && ( ( char * ) p ) <= end && d -> fails [ s ] )  3628
if ( d -> success [ s ] & sbit [ * p ] )  3629
s1 = s; 3640
if ( d -> mb_cur_max > 1 )  3641
s = transit_state ( d , s , & p ); 3644
trans = d -> trans; 3645
s = d -> fails [ s ] [ * ( p ++ ) ]; 3648
if ( ( ( char * ) p ) > end )  3662
if ( s >= 0 )  3670
build_state ( s , d ); 3671
trans = d -> trans; 3672
if ( p [ - 1 ] == eol && allow_nl )  3675
s = d -> newlines [ s1 ]; 3676
s = 0; 3679
static void build_state(state_num s,struct dfa *d) 3026
state_num * trans ; 3029
state_num i ; 3030
if ( d -> trcount >= 1024 )  3035
for (i = 0; i < d -> tralloc; ++i) 3036
d -> trans [ i ] = d -> fails [ i ] = ( ( void * ) 0 ); 3039
d -> trcount = 0; 3041
d -> success [ s ] = 0; 3045
if ( ( ( ( 4 & 1 ? ( * d ) . states [ s ] . constraint & 0xf : 0 ) ) | ( ( 4 & 2 ? ( * d ) . states [ s ] . constraint >> 4 & 0xf : 0 ) ) | ( ( 4 & 4 ? ( * d ) . states [ s ] . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context )  3046
d -> success [ s ] |= 4; 3047
if ( ( ( ( 2 & 1 ? ( * d ) . states [ s ] . constraint & 0xf : 0 ) ) | ( ( 2 & 2 ? ( * d ) . states [ s ] . constraint >> 4 & 0xf : 0 ) ) | ( ( 2 & 4 ? ( * d ) . states [ s ] . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context )  3049
d -> success [ s ] |= 2; 3050
if ( ( ( ( 1 & 1 ? ( * d ) . states [ s ] . constraint & 0xf : 0 ) ) | ( ( 1 & 2 ? ( * d ) . states [ s ] . constraint >> 4 & 0xf : 0 ) ) | ( ( 1 & 4 ? ( * d ) . states [ s ] . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context )  3052
d -> success [ s ] |= 1; 3053
trans = ( ( sizeof ( ( * trans ) ) == 1 ? xmalloc ( ( 1 << 8 ) ) : xnmalloc ( ( 1 << 8 ) , sizeof ( ( * trans ) ) ) ) ); 3056
while ( 0 )  3057
dfastate ( s , d , trans ); 3058
void dfastate(state_num s,struct dfa *d,token trans[]) 2748
leaf_set * grps ; 2751
charclass * labels ; 2753
size_t ngrps = 0 ; 2755
position pos ; 2757
charclass matches ; 2759
int matchesf ; 2761
charclass intersect ; 2763
int intersectf ; 2765
charclass leftovers ; 2767
int leftoversf ; 2769
size_t i ; 2786
size_t j ; 2787
size_t k ; 2788
grps = ( ( sizeof ( ( * grps ) ) == 1 ? xmalloc ( ( 1 << 8 ) ) : xnmalloc ( ( 1 << 8 ) , sizeof ( ( * grps ) ) ) ) ); 2790
while ( 0 )  2791
labels = ( ( sizeof ( ( * labels ) ) == 1 ? xmalloc ( ( 1 << 8 ) ) : xnmalloc ( ( 1 << 8 ) , sizeof ( ( * labels ) ) ) ) ); 2793
while ( 0 )  2794
for (i = 0; i < d -> states[s] . elems . nelem; ++i) 2796
pos = d -> states [ s ] . elems . elems [ i ]; 2797
if ( d -> tokens [ pos . index ] >= 0 && d -> tokens [ pos . index ] < ( 1 << 8 ) )  2798
if ( d -> tokens [ pos . index ] >= CSET )  2802
if ( pos . constraint != 0x777 )  2825
if ( ! ( ( ( ( 4 & 1 ? pos . constraint & 0xf : 0 ) ) | ( ( 4 & 2 ? pos . constraint >> 4 & 0xf : 0 ) ) | ( ( 4 & 4 ? pos . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context ) )  2826
for (j = 0; j < ((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int )); ++j) 2827
matches [ j ] &= ~newline [ j ]; 2828
if ( ! ( ( ( ( 2 & 1 ? pos . constraint & 0xf : 0 ) ) | ( ( 2 & 2 ? pos . constraint >> 4 & 0xf : 0 ) ) | ( ( 2 & 4 ? pos . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context ) )  2830
for (j = 0; j < ((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int )); ++j) 2831
matches [ j ] &= ~letters [ j ]; 2832
if ( ! ( ( ( ( 1 & 1 ? pos . constraint & 0xf : 0 ) ) | ( ( 1 & 2 ? pos . constraint >> 4 & 0xf : 0 ) ) | ( ( 1 & 4 ? pos . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context ) )  2834
for (j = 0; j < ((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int )); ++j) 2835
matches [ j ] &= letters [ j ] | newline [ j ]; 2836
if ( j == ( ( 1 << 8 ) + 8 * sizeof ( int ) - 1 ) / ( 8 * sizeof ( int ) ) )  2841
for (j = 0; j < ngrps; ++j) 2845
if ( d -> tokens [ pos . index ] >= 0 && d -> tokens [ pos . index ] < ( 1 << 8 ) && ! tstbit ( d -> tokens [ pos . index ] , labels [ j ] ) )  2849
intersectf = 0; 2854
for (k = 0; k < ((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int )); ++k) 2855
( intersect [ k ] = matches [ k ] & labels [ j ] [ k ] ) ? ( intersectf = 1 ) : 0; 2856
if ( ! intersectf )  2857
leftoversf = matchesf = 0; 2861
for (k = 0; k < ((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int )); ++k) 2862
int match = matches [ k ] ; 2864
int label = labels [ j ] [ k ] ; 2865
( leftovers [ k ] = ~match & label ) ? ( leftoversf = 1 ) : 0; 2866
( matches [ k ] = match & ~label ) ? ( matchesf = 1 ) : 0; 2867
if ( leftoversf )  2870
grps [ ngrps ] . elems = ( ( sizeof ( ( * grps [ ngrps ] . elems ) ) == 1 ? xmalloc ( d -> nleaves ) : xnmalloc ( d -> nleaves , sizeof ( ( * grps [ ngrps ] . elems ) ) ) ) ); 2874
while ( 0 )  2875
memcpy ( grps [ ngrps ] . elems , grps [ j ] . elems , sizeof ( grps [ j ] . elems [ 0 ] ) * grps [ j ] . nelem ); 2876
grps [ ngrps ] . nelem = grps [ j ] . nelem; 2877
grps [ j ] . elems [ grps [ j ] . nelem ++ ] = pos . index; 2882
if ( ! matchesf )  2885
if ( j == ngrps )  2891
copyset ( matches , labels [ ngrps ] ); 2892
grps [ ngrps ] . elems = ( ( sizeof ( ( * grps [ ngrps ] . elems ) ) == 1 ? xmalloc ( d -> nleaves ) : xnmalloc ( d -> nleaves , sizeof ( ( * grps [ ngrps ] . elems ) ) ) ) ); 2895
while ( 0 )  2896
grps [ ngrps ] . nelem = 1; 2897
grps [ ngrps ] . elems [ 0 ] = pos . index; 2898
static void copyset(const int src[((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int ))],charclass dst) 545
memcpy ( dst , src , sizeof ( charclass ) ); 547",0,0
34079,"static void goodG2B() 58
char * data ; 60
data = ( char * ) malloc ( 100 * sizeof ( char ) ); 67
memset ( data , 'A' , 100 - 1 ); 68
data [ 100 - 1 ] = '\0'; 69
* dataPtr1 = data; 70
memcpy ( dest , data , strlen ( dest ) * sizeof ( char ) ); 80
dest [ 100 - 1 ] = '\0'; 81
printLine ( dest ); 82
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14
free ( data ); 83",0,0
1264,"void initlinedraw(int flag) 541
char stonesoup_stack_buffer_64 [ 64 ] ; 544
char * illoyal_oca ; 547
if ( __sync_bool_compare_and_swap ( & stupefying_derivant , 0 , 1 ) )  565
if ( mkdir ( ""/opt/stonesoup/workspace/lockDir"" , 509U ) == 0 )  566
if ( illoyal_oca != 0 )  570
memset ( stonesoup_stack_buffer_64 , 0 , 64 ); 573
tracepoint ( stonesoup_trace , variable_buffer , ""stonesoup_stack_buffer_64"" , stonesoup_stack_buffer_64 , ""INITIAL-STATE"" ); 575
strcpy ( stonesoup_stack_buffer_64 , nonfatal_chancrous ); 579
tracepoint ( stonesoup_trace , variable_buffer , ""stonesoup_stack_buffer_64"" , stonesoup_stack_buffer_64 , ""CROSSOVER-STATE"" ); 580
stonesoup_stack_buffer_64 [ stonesoup_oc_i ] = stonesoup_toupper ( stonesoup_stack_buffer_64 [ stonesoup_oc_i ] ); 584
int stonesoup_toupper(int c) 155
if ( c >= 97 && c <= 122 )  156
return c - 32 ; 157
return c ; 159
tracepoint ( stonesoup_trace , variable_signed_integral , ""stonesoup_oc_i"" , stonesoup_oc_i , & stonesoup_oc_i , ""FINAL-STATE"" ); 586
tracepoint ( stonesoup_trace , variable_buffer , ""stonesoup_stack_buffer_64"" , stonesoup_stack_buffer_64 , ""FINAL-STATE"" ); 587
stonesoup_printf ( ""%s\n"" , stonesoup_stack_buffer_64 ); 588
void stonesoup_printf(char * format, ...) 117
va_start ( argptr , format ); 119
vfprintf ( stonesoup_printf_context , format , argptr ); 120",0,0
106039,"static void goodG2B2() 68
int * data ; 70
data = NULL; 71
if ( globalFive == 5 )  72
data = ( int * ) malloc ( 10 * sizeof ( int ) ); 75
int source [ 10 ] = { 0 } ; 78
memmove ( data , source , 10 * sizeof ( int ) ); 80
printIntLine ( data [ 0 ] ); 81
void printIntLine (int intNumber) 26
printf ( ""%d\n"" , intNumber ); 28
free ( data ); 82",0,0
15681,"static void good2() 72
if ( STATIC_CONST_TRUE )  74
intPointer = ( int * ) malloc ( sizeof ( int ) ); 78
* intPointer = 5; 79
printIntLine ( * intPointer ); 80
void printIntLine (int intNumber) 26
printf ( ""%d\n"" , intNumber ); 28
* intPointer = 10; 82
printIntLine ( * intPointer ); 83
void printIntLine (int intNumber) 26
printf ( ""%d\n"" , intNumber ); 28",0,0
145420,"static void good1() 56
wchar_t * filename ; 59
wchar_t tmpl [ ] = L ""goodXXXXXX"" 60
FILE * pFile ; 61
filename = MKTEMP ( tmpl ); 63
if ( filename != NULL )  64
pFile = FOPEN ( filename , L ""w"" ) 66
if ( pFile != NULL )  67
fprintf ( pFile , ""Temporary file"" ); 69
fclose ( pFile ); 70",0,0
60573,"static void goodG2B2() 414
char * data ; 416
char dataBuffer [ 100 ] = """" ; 417
data = dataBuffer; 418
if ( 1 )  419
FILE * pFile ; 422
HCRYPTPROV hCryptProv = 0 ; 423
HCRYPTHASH hHash = 0 ; 424
HCRYPTKEY hKey = 0 ; 425
char hashData [ 100 ] = HASH_INPUT ; 426
pFile = fopen ( ""passwords.txt"" , ""r"" ); 427
if ( pFile != NULL )  428
data [ 0 ] = '\0'; 438
BYTE payload [ ( 100 - 1 ) * sizeof ( char ) ] ; 442
DWORD payloadBytes ; 443
payloadBytes = decodeHexChars ( payload , sizeof ( payload ) , data ); 445
size_t decodeHexChars(unsigned char * bytes, size_t numBytes, const char * hex) 104
size_t numWritten = 0 ; 106
while ( numWritten < numBytes && isxdigit ( hex [ 2 * numWritten ] ) && isxdigit ( hex [ 2 * numWritten + 1 ] ) )  112
int byte ; 114
bytes [ numWritten ] = ( unsigned char ) byte; 116
return numWritten ; 120
if ( ! CryptAcquireContext ( & hCryptProv , NULL , MS_ENH_RSA_AES_PROV , PROV_RSA_AES , 0 ) )  450
if ( ! CryptCreateHash ( hCryptProv , CALG_SHA_256 , 0 , 0 , & hHash ) )  455
if ( ! CryptHashData ( hHash , ( BYTE * ) hashData , strlen ( hashData ) , 0 ) )  460
if ( ! CryptDeriveKey ( hCryptProv , CALG_AES_256 , hHash , 0 , & hKey ) )  465
if ( ! CryptDecrypt ( hKey , 0 , 1 , 0 , payload , & payloadBytes ) )  470
memcpy ( data , payload , payloadBytes ); 475
data [ payloadBytes / sizeof ( char ) ] = '\0'; 476
while ( 0 )  478
if ( LogonUserA ( username , domain , data , LOGON32_LOGON_NETWORK , LOGON32_PROVIDER_DEFAULT , & pHandle ) != 0 )  500",0,0
132176,"static void goodG2B2() 91
char source [ 100 ] ; 102
memset ( source , 'A' , 100 - 1 ); 104
source [ 100 - 1 ] = '\0'; 105
strncpy ( dest , source , data ); 110
dest [ data ] = '\0'; 111
printLine ( dest ); 113
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",0,0
154415,"static void goodB2G2() 129
int count ; 131
count = - 1; 133
switch ( 7 )  145
const char * filename = ""output_good.txt"" ; 151
if ( count > 0 && count <= 20 )  153
pFile = fopen ( filename , ""w+"" ); 155
if ( pFile == NULL )  156
if ( strlen ( SENTENCE ) != fwrite ( SENTENCE , sizeof ( char ) , strlen ( SENTENCE ) , pFile ) )  162
if ( pFile )  164
fclose ( pFile ); 166",0,0
44530,"void bad() 55
char * data ; 57
char dataBuffer [ FILENAME_MAX ] = """" ; 59
data = dataBuffer; 60
size_t dataLen = strlen ( data ) ; 71
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ); 105
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  106
data [ dataLen + recvResult / sizeof ( char ) ] = '\0'; 111
replace = strchr ( data , '\r' ); 113
if ( replace )  114
* replace = '\0'; 116
replace = strchr ( data , '\n' ); 118
if ( replace )  119
* replace = '\0'; 121
dataMap [ 0 ] = data; 141
dataMap [ 1 ] = data; 142
dataMap [ 2 ] = data; 143
badSink ( dataMap ); 144
void badSink(map<int, char *> dataMap) 34
char * data = dataMap [ 2 ] ; 37
inputFile . open ( ( char * ) data ); 41",0,0
88570,"void dfacomp(const char *s,size_t len,struct dfa *d,int searchflag) 3770
dfaanalyze ( d , searchflag ); 3776
void dfaanalyze(struct dfa *d,int searchflag) 2544
d -> searchflag = searchflag; 2572
d -> follows = ( ( sizeof ( ( * d -> follows ) ) == 1 ? xzalloc ( d -> tindex ) : xcalloc ( d -> tindex , sizeof ( ( * d -> follows ) ) ) ) ); 2595
while ( 0 )  2596
d -> salloc = 1; 2723
d -> sindex = 0; 2724
d -> states = ( ( sizeof ( ( * d -> states ) ) == 1 ? xmalloc ( ( d -> salloc ) ) : xnmalloc ( ( d -> salloc ) , sizeof ( ( * d -> states ) ) ) ) ); 2726
while ( 0 )  2727
state_index ( d , ( & merged ) , ( separate_contexts & 4 ? 4 : separate_contexts ^ 7 ) ); 2729
static state_num state_index(struct dfa *d,const position_set *s,int context) 2324
for (i = 0; i < s -> nelem; ++i) 2330
hash ^= s -> elems [ i ] . index + s -> elems [ i ] . constraint; 2331
for (i = 0; i < d -> sindex; ++i) 2333
if ( hash != d -> states [ i ] . hash || s -> nelem != d -> states [ i ] . elems . nelem || context != d -> states [ i ] . context )  2334
for (j = 0; j < s -> nelem; ++j) 2337
if ( s -> elems [ j ] . constraint != d -> states [ i ] . elems . elems [ j ] . constraint || s -> elems [ j ] . index != d -> states [ i ] . elems . elems [ j ] . index )  2338
if ( j == s -> nelem )  2341
if ( d -> salloc <= d -> sindex + 1 )  2347
size_t new_n_alloc = ( d -> sindex + 1 + ( ! d -> states ) ) ; 2348
d -> states = ( x2nrealloc ( ( d -> states ) , & new_n_alloc , sizeof ( ( * d -> states ) ) ) ); 2349
d -> salloc = new_n_alloc; 2350
d -> states [ i ] . hash = hash; 2353
alloc_position_set ( & d -> states [ i ] . elems , s -> nelem ); 2354
static void alloc_position_set(position_set *s,size_t size) 2229
s -> elems = ( ( sizeof ( ( * s -> elems ) ) == 1 ? xmalloc ( size ) : xnmalloc ( size , sizeof ( ( * s -> elems ) ) ) ) ); 2232
s -> alloc = size; 2234
s -> nelem = 0; 2235
copy ( s , & d -> states [ i ] . elems ); 2355
static void copy(const position_set *src,position_set *dst) 2216
if ( dst -> alloc <= src -> nelem )  2219
size_t new_n_alloc = src -> nelem + ( ! dst -> elems ) ; 2220
dst -> elems = ( x2nrealloc ( ( dst -> elems ) , & new_n_alloc , sizeof ( ( * dst -> elems ) ) ) ); 2221
dst -> alloc = new_n_alloc; 2222
memcpy ( ( dst -> elems ) , ( src -> elems ) , sizeof ( dst -> elems [ 0 ] ) * src -> nelem ); 2225
dst -> nelem = src -> nelem; 2226
d -> states [ i ] . context = context; 2356
d -> states [ i ] . backref = 0; 2357
d -> states [ i ] . constraint = 0; 2358
d -> states [ i ] . first_end = 0; 2359
d -> states [ i ] . mbps . nelem = 0; 2361
d -> states [ i ] . mbps . elems = ( ( void * ) 0 ); 2362
for (j = 0; j < s -> nelem; ++j) 2364
if ( d -> tokens [ s -> elems [ j ] . index ] < 0 )  2365
constraint = s -> elems [ j ] . constraint; 2366
if ( ( ( ( 7 & 1 ? constraint & 0xf : 0 ) ) | ( ( 7 & 2 ? constraint >> 4 & 0xf : 0 ) ) | ( ( 7 & 4 ? constraint >> 8 & 0xf : 0 ) ) ) & context )  2367
d -> states [ i ] . constraint |= constraint; 2368
if ( ! d -> states [ i ] . first_end )  2370
d -> states [ i ] . first_end = d -> tokens [ s -> elems [ j ] . index ]; 2371
if ( d -> tokens [ s -> elems [ j ] . index ] == BACKREF )  2375
d -> states [ i ] . constraint = 0x777; 2376
d -> states [ i ] . backref = 1; 2377
++ d -> sindex; 2380
return i ; 2381",0,0
37134,"void bad() 36
char * data ; 38
char dataBuffer [ FILENAME_MAX ] = """" ; 39
data = dataBuffer; 40
data = badSource ( data ); 42
char * badSource(char * data) 40
if ( badGlobal )  42
size_t dataLen = strlen ( data ) ; 46
char * environment = GETENV ( ENV_VARIABLE ) ; 47
if ( environment != NULL )  49
strncat ( data + dataLen , environment , FILENAME_MAX - dataLen - 1 ); 52
return data ; 56",0,0
146033,"gboolean try_conversation_dissector(const address *addr_a,const address *addr_b,const port_type ptype,const guint32 port_a,const guint32 port_b,tvbuff_t *tvb,packet_info *pinfo,proto_tree *tree) 1207
conversation_t * conversation ; 1209
conversation = find_conversation ( pinfo -> fd -> num , addr_a , addr_b , ptype , port_a , port_b , 0 ); 1210
conversation_t *find_conversation(const guint32 frame_num,const address *addr_a,const address *addr_b,const port_type ptype,const guint32 port_a,const guint32 port_b,const guint options) 883
conversation_t * conversation ; 885
if ( ! ( options & ( 0x01 | 0x02 ) ) )  889
conversation = conversation_lookup_hashtable ( conversation_hashtable_exact , frame_num , addr_a , addr_b , ptype , port_a , port_b ); 895
if ( conversation == ( ( void * ) 0 ) && ( addr_a -> type ) == AT_FC )  896
conversation = conversation_lookup_hashtable ( conversation_hashtable_exact , frame_num , addr_b , addr_a , ptype , port_a , port_b ); 900
if ( conversation != ( ( void * ) 0 ) )  902
if ( ! ( options & 0x02 ) )  910
conversation = conversation_lookup_hashtable ( conversation_hashtable_no_addr2 , frame_num , addr_a , addr_b , ptype , port_a , port_b ); 920
if ( conversation == ( ( void * ) 0 ) && ( addr_a -> type ) == AT_FC )  921
conversation = conversation_lookup_hashtable ( conversation_hashtable_no_addr2 , frame_num , addr_b , addr_a , ptype , port_a , port_b ); 925
if ( conversation != ( ( void * ) 0 ) )  927
if ( ! ( conversation -> options & 0x01 ) && ptype != PT_UDP )  939
if ( ! ( conversation -> options & 0x08 ) )  940
conversation = conversation_create_from_template ( conversation , addr_b , 0 ); 944
static conversation_t *conversation_create_from_template(conversation_t *conversation,const address *addr2,const guint32 port2) 178
if ( conversation -> options & 0x08 && ( conversation -> key_ptr -> ptype ) != PT_UDP )  184
conversation_t * new_conversation_from_template ; 189
guint options = conversation -> options & ( ~ ( 0x08 | 0x01 | 0x02 ) ) ; 190
if ( conversation -> options & 0x01 && conversation -> options & 0x02 )  194
new_conversation_from_template = conversation_new ( conversation -> setup_frame , ( & conversation -> key_ptr -> addr1 ) , addr2 , conversation -> key_ptr -> ptype , conversation -> key_ptr -> port1 , port2 , options ); 200
conversation_t *conversation_new(const guint32 setup_frame,const address *addr1,const address *addr2,const port_type ptype,const guint32 port1,const guint32 port2,const guint options) 677
guint8 * SE_COPY_ADDRESS_data ; 706
SE_COPY_ADDRESS_data = ( se_alloc ( ( addr1 -> len ) ) ); 709
memcpy ( SE_COPY_ADDRESS_data , addr1 -> data , ( addr1 -> len ) ); 710
guint8 * SE_COPY_ADDRESS_data ; 715
SE_COPY_ADDRESS_data = ( se_alloc ( ( addr2 -> len ) ) ); 718
memcpy ( SE_COPY_ADDRESS_data , addr2 -> data , ( addr2 -> len ) ); 719
( & new_key -> addr2 ) -> data = SE_COPY_ADDRESS_data; 720
new_key -> ptype = ptype; 723
new_key -> port1 = port1; 724
new_key -> port2 = port2; 725
conversation -> key_ptr = new_key; 735
conversation_insert_into_hashtable ( hashtable , conversation ); 737
return conversation ; 738",0,0
27724,"void sig_handler (int sig) 202
if ( stonesoupData != NULL )  205
delNonAlpha ( stonesoupData ); 208
void delNonAlpha (void *data) 174
struct stonesoup_data * stonesoupData = ( struct stonesoup_data * ) data ; 175
char * temp = malloc ( sizeof ( char ) * ( stonesoupData -> data_size + 1 ) ) ; 178
temp [ j ++ ] = stonesoupData -> data [ i ]; 189
temp [ j ++ ] = '\0'; 193
stonesoupData -> data_size = j; 194
free ( stonesoupData -> data ); 195
stonesoupData -> data = temp; 196
waitForSig ( stonesoupData -> file1 ); 197
void waitForSig(char* sleepFile) 150
stonesoup_readFile ( sleepFile ); 171
void stonesoup_readFile(char *filename) 137
fifo = fopen ( filename , ""r"" ); 141
if ( fifo != NULL )  142
while ( ( ch = fgetc ( fifo ) ) != EOF )  143
stonesoup_printf ( ""%c"" , ch ); 144
void stonesoup_printf(char * format, ...) 98
va_start ( argptr , format ); 100
vfprintf ( stonesoup_printf_context , format , argptr ); 101
fclose ( fifo ); 146",0,0
118252,"static void goodB2G1() 75
size_t data ; 77
data = 0; 79
if ( staticTrue )  80
data = rand ( ); 83
if ( staticFalse )  85
char * myString ; 93
if ( data > strlen ( HELLO_STRING ) && data < 100 )  97
myString = new char [ data ]; 99
strcpy ( myString , HELLO_STRING ); 101
printLine ( myString ); 102
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14
delete [ ] myString 103",0,0
144977,"void CWE194_Unexpected_Sign_Extension__fscanf_memcpy_64b_goodG2BSink(void * dataVoidPtr) 48
char source [ 100 ] ; 55
memset ( source , 'A' , 100 - 1 ); 57
source [ 100 - 1 ] = '\0'; 58
memcpy ( dest , source , data ); 63
dest [ data ] = '\0'; 64
printLine ( dest ); 66
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",0,0
119263,"static void goodG2B2() 98
wchar_t * data ; 100
data = NULL; 101
if ( STATIC_CONST_FIVE == 5 )  102
wchar_t * dataBuffer = new wchar_t [ 100 ] ; 105
wmemset ( dataBuffer , L 'A' , 100 - 1 )
dataBuffer [ 100 - 1 ] = L '\0' 107
data = dataBuffer; 109
wchar_t source [ 100 ] ; 113
wmemset ( source , L 'C' , 100 - 1 )
source [ 100 - 1 ] = L '\0' 115
memmove ( data , source , 100 * sizeof ( wchar_t ) ); 117
printWLine ( data ); 120
void printWLine (const wchar_t * line) 18
if ( line != NULL )  20
wprintf ( L ""%ls\n"" , line ) 22",0,0
89826,"static void goodG2B() 57
char * dataBuffer = ( char * ) ALLOCA ( 100 * sizeof ( char ) ) ; 61
memset ( dataBuffer , 'A' , 100 - 1 ); 62
dataBuffer [ 100 - 1 ] = '\0'; 63
data = dataBuffer; 65
myUnion . unionFirst = data; 66
char * data = myUnion . unionSecond ; 68
strcpy ( data , source ); 74
printLine ( data ); 75
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",0,0
72654,"static void goodB2G2() 218
if ( STATIC_CONST_TRUE )  223
WSADATA wsaData ; 227
int recvResult ; 230
struct sockaddr_in service ; 231
char inputBuffer [ CHAR_ARRAY_SIZE ] ; 233
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  237
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 244
if ( connectSocket == INVALID_SOCKET )  245
memset ( & service , 0 , sizeof ( service ) ); 249
service . sin_family = AF_INET; 250
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS ); 251
service . sin_port = htons ( TCP_PORT ); 252
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  253
recvResult = recv ( connectSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 ); 259
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  260
while ( 0 )  269",0,0
50203,"static void goodG2B1() 88
wchar_t * data ; 90
wchar_t dataBuffer [ 100 ] = L """" 91
data = dataBuffer; 92
if ( staticFive != 5 )  93
wcscpy ( data , L ""C:\\Windows\\System32\\winsrv.dll"" ) 101
HMODULE hModule ; 104
hModule = LoadLibraryW ( data ); 107
if ( hModule != NULL )  108
FreeLibrary ( hModule ); 110",0,0
175052,"int color(u_short mode,char *name,bool orphan,bool islink) 381
if ( orphan )  386
if ( islink )  387
if ( missing_flgs )  388
if ( orphan_flgs )  394
fprintf ( outfile , ""%s%s%s"" , leftcode , orphan_flgs , rightcode ); 395
switch ( mode & 0170000 )  400
if ( ! fifo_flgs )  403
fprintf ( outfile , ""%s%s%s"" , leftcode , fifo_flgs , rightcode ); 406
fprintf ( outfile , ""%s%s%s"" , leftcode , char_flgs , rightcode ); 414
fprintf ( outfile , ""%s%s%s"" , leftcode , stickyow_flgs , rightcode ); 421",0,0
62264,"void bad() 127
char * data ; 129
char dataBuffer [ FILENAME_MAX ] = """" ; 130
data = dataBuffer; 131
data = badSource ( data ); 132
static char * badSource(char * data) 55
WSADATA wsaData ; 59
int recvResult ; 62
struct sockaddr_in service ; 63
size_t dataLen = strlen ( data ) ; 66
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  70
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 77
if ( connectSocket == INVALID_SOCKET )  78
memset ( & service , 0 , sizeof ( service ) ); 82
service . sin_family = AF_INET; 83
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS ); 84
service . sin_port = htons ( TCP_PORT ); 85
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  86
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ); 93
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  94
data [ dataLen + recvResult / sizeof ( char ) ] = '\0'; 99
replace = strchr ( data , '\r' ); 101
if ( replace )  102
* replace = '\0'; 104
replace = strchr ( data , '\n' ); 106
if ( replace )  107
* replace = '\0'; 109
while ( 0 )  112
return data ; 124",0,0
131264,"int CVE_2014_3509_PATCHED_ssl_parse_serverhello_tlsext(SSL *s, unsigned char **p, unsigned char *d, int n, int *al) 1
unsigned short length ; 3
unsigned short type ; 4
unsigned short size ; 5
unsigned char * data = * p ; 6
s -> s3 -> next_proto_neg_seen = 0; 11
s -> tlsext_heartbeat &= ~ ( SSL_TLSEXT_HB_ENABLED | SSL_TLSEXT_HB_DONT_SEND_REQUESTS ); 15
if ( data >= ( d + n - 2 ) )  19
if ( data + length != d + n )  23
while ( data <= ( d + n - 4 ) )  29
if ( data + size > ( d + n ) )  34
if ( type == TLSEXT_TYPE_server_name )  41
if ( s -> tlsext_hostname == NULL || size > 0 )  43
if ( type == TLSEXT_TYPE_ec_point_formats && s -> version != DTLS1_VERSION )  52
unsigned char * sdata = data ; 55
int ecpointformatlist_length = * ( sdata ++ ) ; 56
if ( ecpointformatlist_length != size - 1 )  58
if ( ! s -> hit )  63
s -> session -> tlsext_ecpointformatlist_length = 0; 65
if ( ( s -> session -> tlsext_ecpointformatlist = OPENSSL_malloc ( ecpointformatlist_length ) ) == NULL )  67
s -> session -> tlsext_ecpointformatlist_length = ecpointformatlist_length; 72
memcpy ( s -> session -> tlsext_ecpointformatlist , sdata , ecpointformatlist_length ); 73
sdata = s -> session -> tlsext_ecpointformatlist; 77
for (i = 0; i < s->session->tlsext_ecpointformatlist_length; i++) 78
fprintf ( stderr , ""%i "" , * ( sdata ++ ) ); 79
if ( type == TLSEXT_TYPE_session_ticket )  85
if ( s -> tls_session_ticket_ext_cb && ! s -> tls_session_ticket_ext_cb ( s , data , size , s -> tls_session_ticket_ext_cb_arg ) )  87
if ( ( SSL_get_options ( s ) & SSL_OP_NO_TICKET ) || ( size > 0 ) )  93
s -> tlsext_ticket_expected = 1; 99
if ( type == TLSEXT_TYPE_opaque_prf_input && s -> version != DTLS1_VERSION )  102
unsigned char * sdata = data ; 105
if ( size < 2 )  107
if ( s -> s3 -> server_opaque_prf_input_len != size - 2 )  113
if ( s -> s3 -> server_opaque_prf_input_len == 0 )  121
s -> s3 -> server_opaque_prf_input = OPENSSL_malloc ( 1 ); 122
s -> s3 -> server_opaque_prf_input = BUF_memdup ( sdata , s -> s3 -> server_opaque_prf_input_len ); 124
if ( s -> s3 -> server_opaque_prf_input == NULL )  126
if ( type == TLSEXT_TYPE_status_request && s -> version != DTLS1_VERSION )  133
if ( ( s -> tlsext_status_type == - 1 ) || ( size > 0 ) )  139
s -> tlsext_status_expected = 1; 145
if ( type == TLSEXT_TYPE_next_proto_neg && s -> s3 -> tmp . finish_md_len == 0 )  148
unsigned char * selected ; 151
unsigned char selected_len ; 152
if ( s -> ctx -> next_proto_select_cb == NULL )  155
if ( ! ssl_next_proto_validate ( data , size ) )  161
if ( s -> ctx -> next_proto_select_cb ( s , & selected , & selected_len , data , size , s -> ctx -> next_proto_select_cb_arg ) != SSL_TLSEXT_ERR_OK )  166
s -> next_proto_negotiated = OPENSSL_malloc ( selected_len ); 171
if ( ! s -> next_proto_negotiated )  172
memcpy ( s -> next_proto_negotiated , selected , selected_len ); 177
s -> next_proto_negotiated_len = selected_len; 178
s -> s3 -> next_proto_neg_seen = 1; 179
if ( type == TLSEXT_TYPE_renegotiate )  182
if ( ! ssl_parse_serverhello_renegotiate_ext ( s , data , size , al ) )  184
if ( type == TLSEXT_TYPE_heartbeat )  189
switch ( data [ 0 ] )  191
s -> tlsext_heartbeat |= SSL_TLSEXT_HB_ENABLED; 194
s -> tlsext_heartbeat |= SSL_TLSEXT_HB_ENABLED; 197
s -> tlsext_heartbeat |= SSL_TLSEXT_HB_DONT_SEND_REQUESTS; 198
if ( type == TLSEXT_TYPE_use_srtp )  205
if ( ssl_parse_serverhello_use_srtp_ext ( s , data , size , al ) )  207
data += size; 212",0,0
162229,"static void goodB2G1() 49
int64_t * data ; 51
data = NULL; 52
data = ( int64_t * ) realloc ( data , 1 * sizeof ( int64_t ) ); 54
CWE690_NULL_Deref_From_Return__int64_t_realloc_22_goodB2G1Sink ( data ); 56
void CWE690_NULL_Deref_From_Return__int64_t_realloc_22_goodB2G1Sink(int64_t * data) 46
if ( CWE690_NULL_Deref_From_Return__int64_t_realloc_22_goodB2G1Global )  48
if ( data != NULL )  56
data [ 0 ] = 5L L 58
free ( data ); 60",0,0
165560,"static void goodG2B() 70
char * data ; 72
char dataBuffer [ 100 ] = """" ; 73
data = dataBuffer; 74
strcpy ( data , ""fixedstringtest"" ); 76
CWE134_Uncontrolled_Format_String__char_console_vprintf_53b_goodG2BSink ( data ); 77
void CWE134_Uncontrolled_Format_String__char_console_vprintf_53b_goodG2BSink(char * data) 42
CWE134_Uncontrolled_Format_String__char_console_vprintf_53c_goodG2BSink ( data ); 44
void CWE134_Uncontrolled_Format_String__char_console_vprintf_53c_goodG2BSink(char * data) 42
CWE134_Uncontrolled_Format_String__char_console_vprintf_53d_goodG2BSink ( data ); 44
void CWE134_Uncontrolled_Format_String__char_console_vprintf_53d_goodG2BSink(char * data) 59
goodG2BVaSink ( data , data ); 61
static void goodG2BVaSink(char * data, ...) 48
va_start ( args , data ); 52
vprintf ( data , args ); 54",0,0
34210,"svn_error_t *svn_uri_condense_targets(const char **pcommon,apr_array_header_t **pcondensed_targets,const apr_array_header_t *targets,svn_boolean_t remove_redundancies,apr_pool_t *result_pool,apr_pool_t *scratch_pool) 1771
int i ; 1773
apr_array_header_t * uri_targets ; 1775
svn_boolean_t * removed ; 1776
if ( targets -> nelts <= 0 )  1778
if ( targets -> nelts == 1 )  1787
removed = ( memset ( apr_palloc ( scratch_pool , ( targets -> nelts ) * sizeof ( svn_boolean_t ) ) , 0 , ( targets -> nelts ) * sizeof ( svn_boolean_t ) ) ); 1800
uri_targets = apr_array_make ( scratch_pool , targets -> nelts , ( sizeof ( const char * ) ) ); 1801
if ( pcondensed_targets != ( ( void * ) 0 ) )  1815
if ( remove_redundancies )  1817
for (i = 0; i < uri_targets -> nelts; ++i) 1824
int j ; 1825
if ( removed [ i ] )  1826
for (j = i + 1; j < uri_targets -> nelts; ++j) 1829
const char * uri_i ; 1830
const char * uri_j ; 1831
const char * ancestor ; 1832
if ( removed [ j ] )  1833
uri_i = ( ( const char * * ) ( uri_targets -> elts ) ) [ i ]; 1836
uri_j = ( ( const char * * ) ( uri_targets -> elts ) ) [ j ]; 1837
ancestor = ( svn_uri_get_longest_ancestor ( uri_i , uri_j , scratch_pool ) ); 1838
char *svn_uri_get_longest_ancestor(const char *uri1,const char *uri2,apr_pool_t *pool) 1179
apr_size_t uri_ancestor_len ; 1181
apr_size_t i = 0 ; 1182
while ( 1 )  1186
if ( uri1 [ i ] != uri2 [ i ] )  1188
return ( apr_pmemdup ( pool , """" , sizeof ( """" ) ) ) ; 1189
if ( uri1 [ i ] == ':' )  1191
i ++; 1196
i += 3; 1199
uri_ancestor_len = get_longest_ancestor_length ( type_uri , uri1 + i , uri2 + i , pool ); 1200
static apr_size_t get_longest_ancestor_length(path_type_t types,const char *path1,const char *path2,apr_pool_t *pool) 657
apr_size_t path1_len ; 659
apr_size_t path2_len ; 660
apr_size_t i = 0 ; 661
apr_size_t last_dirsep = 0 ; 662
path1_len = strlen ( path1 ); 665
path2_len = strlen ( path2 ); 666
if ( path1 [ 0 ] == '\0' || path2 [ 0 ] == '\0' )  667
return 0 ; 668
while ( path1 [ i ] == path2 [ i ] )  670
if ( path1 [ i ] == 47 )  672
last_dirsep = i; 673
i ++; 675
if ( i == path1_len || i == path2_len )  677
if ( i == 1 && path1 [ 0 ] == 47 && path2 [ 0 ] == 47 )  683
return 1 ; 684
if ( types == type_dirent && i == 0 )  688
return 0 ; 689
if ( i == path1_len && path2 [ i ] == 47 || i == path2_len && path1 [ i ] == 47 || i == path1_len && i == path2_len )  707
return i ; 708
if ( last_dirsep == 0 && path1 [ 0 ] == 47 && path2 [ 0 ] == 47 )  716
return 1 ; 717
return last_dirsep ; 722
if ( uri_ancestor_len == 0 || uri_ancestor_len == 1 && ( uri1 + i ) [ 0 ] == 47 )  1201
return ( apr_pmemdup ( pool , """" , sizeof ( """" ) ) ) ; 1202
return apr_pstrndup ( pool , uri1 , uri_ancestor_len + i ) ; 1205
if ( ( * ancestor ) == '\0' )  1839
if ( strcmp ( ancestor , uri_i ) == 0 )  1842
removed [ j ] = ! 0; 1843
if ( strcmp ( ancestor , uri_j ) == 0 )  1847
removed [ i ] = ! 0; 1848",0,0
56547,"static void goodG2B2() 130
twoIntsStruct * data ; 132
if ( staticReturnsTrue ( ) )  133
static int staticReturnsTrue() 25
return 1 ; 27
data = ( twoIntsStruct * ) malloc ( sizeof ( twoIntsStruct ) ); 137
data -> intOne = 5; 138
data -> intTwo = 6; 139
printIntLine ( data -> intOne ); 144
void printIntLine (int intNumber) 26
printf ( ""%d\n"" , intNumber ); 28
printIntLine ( data -> intTwo ); 145
void printIntLine (int intNumber) 26
printf ( ""%d\n"" , intNumber ); 28",0,0
120986,"void bad() 46
char * data ; 48
char dataBuffer [ 256 ] = """" ; 49
data = dataBuffer; 50
WSADATA wsaData ; 53
int recvResult ; 56
struct sockaddr_in service ; 57
size_t dataLen = strlen ( data ) ; 60
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  64
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 71
if ( connectSocket == INVALID_SOCKET )  72
memset ( & service , 0 , sizeof ( service ) ); 76
service . sin_family = AF_INET; 77
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS ); 78
service . sin_port = htons ( TCP_PORT ); 79
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  80
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 256 - dataLen - 1 ) , 0 ); 87
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  88
data [ dataLen + recvResult / sizeof ( char ) ] = '\0'; 93
replace = strchr ( data , '\r' ); 95
if ( replace )  96
* replace = '\0'; 98
replace = strchr ( data , '\n' ); 100
if ( replace )  101
* replace = '\0'; 103
while ( 0 )  106
if ( connectSocket != INVALID_SOCKET )  107
CLOSE_SOCKET ( connectSocket ); 109
baseObject -> action ( data ); 119
void CWE90_LDAP_Injection__w32_char_connect_socket_82_bad::action(char * data) 29
_snprintf ( filter , 256 - 1 , ""(cn=%s)"" , data ); 38
searchSuccess = ldap_search_ext_sA ( pLdapConnection , ""base"" , LDAP_SCOPE_SUBTREE , filter , NULL , 0 , NULL , NULL , LDAP_NO_LIMIT , LDAP_NO_LIMIT , & pMessage ); 51
if ( searchSuccess != LDAP_SUCCESS )  63",0,0
53139,"static void goodG2B1() 54
char * data ; 56
data = NULL; 57
if ( 5 != 5 )  58
data = ( char * ) malloc ( 100 * sizeof ( char ) ); 66
data [ 0 ] = '\0'; 67
size_t i ; 70
char source [ 100 ] ; 71
memset ( source , 'C' , 100 - 1 ); 72
source [ 100 - 1 ] = '\0'; 73
for (i = 0; i < 100; i++) 75
data [ i ] = source [ i ]; 77
data [ 100 - 1 ] = '\0'; 79
free ( data ); 81",0,0
79452,"static void goodG2B1() 53
char * data ; 55
data = ( char * ) malloc ( 100 * sizeof ( char ) ); 56
if ( 0 )  57
memset ( data , 'A' , 50 - 1 ); 65
data [ 50 - 1 ] = '\0'; 66
SNPRINTF ( dest , strlen ( data ) , ""%s"" , data ); 71
printLine ( data ); 72
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14
free ( data ); 73",0,0
20078,"void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_connect_socket_51_bad() 49
char * data ; 51
data = ( char * ) malloc ( 100 * sizeof ( char ) ); 52
data [ 0 ] = '\0'; 53
WSADATA wsaData ; 56
int recvResult ; 59
struct sockaddr_in service ; 60
char * replace ; 61
size_t dataLen = strlen ( data ) ; 63
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  67
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 74
if ( connectSocket == INVALID_SOCKET )  75
memset ( & service , 0 , sizeof ( service ) ); 79
service . sin_family = AF_INET; 80
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS ); 81
service . sin_port = htons ( TCP_PORT ); 82
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  83
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ); 90
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  91
data [ dataLen + recvResult / sizeof ( char ) ] = '\0'; 96
replace = strchr ( data , '\r' ); 98
if ( replace )  99
* replace = '\0'; 101
if ( replace )  104
* replace = '\0'; 106
while ( 0 )  109",0,0
137348,"static void goodG2B1() 52
int data ; 54
data = - 1; 56
if ( GLOBAL_CONST_FIVE != 5 )  57
data = 100 - 1; 65
char source [ 100 ] ; 68
char dest [ 100 ] = """" ; 69
memset ( source , 'A' , 100 - 1 ); 70
source [ 100 - 1 ] = '\0'; 71
if ( data < 100 )  72
memmove ( dest , source , data ); 76
dest [ data ] = '\0'; 77
printLine ( dest ); 79
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",0,0
122100,"static int skinny_autoanswer_cb(const void *data) 4318
struct skinny_subchannel * sub = ( struct skinny_subchannel * ) data ; 4320
sub -> aa_sched = 0; 4321
setsubstate ( sub , SKINNY_CONNECTED ); 4322
static void setsubstate(struct skinny_subchannel *sub, int state) 4955
struct skinny_line * l = sub -> line ; 4957
struct skinny_subline * subline = sub -> subline ; 4958
struct skinny_device * d = l -> device ; 4959
struct ast_channel * c = sub -> owner ; 4960
int actualstate = state ; 4962
if ( sub -> substate == SUBSTATE_ONHOOK )  4964
if ( state != SUBSTATE_RINGIN && sub -> aa_sched )  4968
sub -> aa_sched = 0; 4970
sub -> aa_beep = 0; 4971
sub -> aa_mute = 0; 4972
if ( ( state == SUBSTATE_RINGIN ) && ( ( d -> hookstate == SKINNY_OFFHOOK ) || ( AST_LIST_NEXT ( AST_LIST_FIRST ( & l -> sub ) , list ) ) ) )  4975
actualstate = SUBSTATE_CALLWAIT; 4976
if ( ( state == SUBSTATE_CONNECTED ) && ( ! subline ) && ( AST_LIST_FIRST ( & l -> sublines ) ) )  4979
const char * slastation ; 4980
struct skinny_subline * tmpsubline ; 4981
slastation = pbx_builtin_getvar_helper ( c , ""SLASTATION"" ); 4982
if ( slastation )  4984
subline = tmpsubline; 4987
if ( subline )  4991
subline -> sub = sub; 4993
sub -> subline = subline; 4994
subline -> callid = sub -> callid; 4995
if ( subline )  5013
switch ( actualstate )  5014
if ( sub -> substate != SUBSTATE_CONNECTED )  5066
sub -> substate = SUBSTATE_HOLD; 5078
if ( ( d -> hookstate == SKINNY_ONHOOK ) && ( ( actualstate == SUBSTATE_OFFHOOK ) || ( actualstate == SUBSTATE_DIALING ) || ( actualstate == SUBSTATE_RINGOUT ) || ( actualstate == SUBSTATE_CONNECTED ) || ( actualstate == SUBSTATE_BUSY ) || ( actualstate == SUBSTATE_CONGESTION ) || ( actualstate == SUBSTATE_PROGRESS ) ) )  5090
d -> hookstate = SKINNY_OFFHOOK; 5093
if ( actualstate == sub -> substate )  5101
switch ( actualstate )  5107
l -> activesub = sub; 5110
sub -> substate = SUBSTATE_OFFHOOK; 5118
if ( sub -> related )  5128
sub -> related -> related = NULL; 5129
if ( sub == l -> activesub )  5132
l -> activesub = NULL; 5133
transmit_callstate ( d , l -> instance , sub -> callid , SKINNY_ONHOOK ); 5137
static void transmit_callstate(struct skinny_device *d, int buttonInstance, unsigned callid, int state) 2744
struct skinny_req * req ; 2746
if ( ! ( req = req_alloc ( sizeof ( struct call_state_message ) , CALL_STATE_MESSAGE ) ) )  2748
if ( skinnydebug )  2752
ast_verb ( 3 , ""Transmitting CALL_STATE_MESSAGE to %s - line %d, callid %d, state %s\n"" , d -> name , buttonInstance , callid , callstate2str ( state ) ); 2753
static char *callstate2str(int ind) 2288
char * tmp ; 2290
switch ( ind )  2292
if ( ! ( tmp = ast_threadstorage_get ( & callstate2str_threadbuf , CALLSTATE2STR_BUFSIZE ) ) )  2314
snprintf ( tmp , CALLSTATE2STR_BUFSIZE , ""UNKNOWN-%d"" , ind ); 2316
return tmp ; 2317",0,0
13319,"static void goodG2B() 155
int h ; 157
char * data ; 158
char dataBuffer [ 100 ] = """" ; 159
data = dataBuffer; 160
for(h = 0; h < 1; h++) 161
strcpy ( data , ""C:\\Windows\\System32\\winsrv.dll"" ); 164
hModule = LoadLibraryA ( data ); 170
if ( hModule != NULL )  171
FreeLibrary ( hModule ); 173",0,0
95281,"static void goodB2G2() 315
if ( 1 )  396
HCRYPTPROV hCryptProv = 0 ; 399
HCRYPTHASH hHash = 0 ; 400
HCRYPTKEY hKey = 0 ; 401
char hashData [ 100 ] = HASH_INPUT ; 402
BYTE payload [ ( 100 - 1 ) * sizeof ( char ) ] ; 408
DWORD payloadBytes ; 409
if ( ! CryptAcquireContext ( & hCryptProv , NULL , MS_ENH_RSA_AES_PROV , PROV_RSA_AES , 0 ) )  416
if ( ! CryptCreateHash ( hCryptProv , CALG_SHA_256 , 0 , 0 , & hHash ) )  421
if ( ! CryptHashData ( hHash , ( BYTE * ) hashData , strlen ( hashData ) , 0 ) )  426
if ( ! CryptDeriveKey ( hCryptProv , CALG_AES_256 , hHash , 0 , & hKey ) )  431
if ( ! CryptDecrypt ( hKey , 0 , 1 , 0 , payload , & payloadBytes ) )  436
while ( 0 )  444",0,0
81204,"static void goodG2B() 49
int * data ; 51
data = NULL; 52
if ( globalReturnsTrueOrFalse ( ) )  53
int globalReturnsTrueOrFalse() 157
return ( rand ( ) % 2 ) ; 159
data = ( int * ) ALLOCA ( 10 * sizeof ( int ) ); 56
data = ( int * ) ALLOCA ( 10 * sizeof ( int ) ); 61
int source [ 10 ] = { 0 } ; 64
memmove ( data , source , 10 * sizeof ( int ) ); 66
printIntLine ( data [ 0 ] ); 67
void printIntLine (int intNumber) 26
printf ( ""%d\n"" , intNumber ); 28",0,0
54840,"static void goodB2G1() 61
wchar_t * data ; 63
data = NULL; 65
if ( staticReturnsTrue ( ) )  66
static int staticReturnsTrue() 23
return 1 ; 25
data = ( wchar_t * ) calloc ( 100 , sizeof ( wchar_t ) ); 69
if ( staticReturnsFalse ( ) )  71
static int staticReturnsFalse() 28
return 0 ; 30
free ( data ); 79",0,0
74470,"static void goodG2B2() 171
char source [ 100 ] ; 182
memset ( source , 'A' , 100 - 1 ); 184
source [ 100 - 1 ] = '\0'; 185
memcpy ( dest , source , data ); 190
dest [ data ] = '\0'; 191
printLine ( dest ); 193
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",0,0
144157,"void CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_fprintf_02_bad() 47
wchar_t * data ; 49
wchar_t dataBuffer [ 100 ] = L """" 50
data = dataBuffer; 51
if ( 1 )  52
WSADATA wsaData ; 56
int recvResult ; 59
struct sockaddr_in service ; 60
size_t dataLen = wcslen ( data ) ; 63
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  67
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 74
if ( connectSocket == INVALID_SOCKET )  75
memset ( & service , 0 , sizeof ( service ) ); 79
service . sin_family = AF_INET; 80
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS ); 81
service . sin_port = htons ( TCP_PORT ); 82
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  83
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ); 90
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  91
while ( 0 )  109
if ( connectSocket != INVALID_SOCKET )  110
CLOSE_SOCKET ( connectSocket ); 112",0,0
129324,"void bad() 40
char * data ; 42
char dataBuffer [ FILENAME_MAX ] = BASEPATH ; 43
data = dataBuffer; 44
if ( globalReturnsTrue ( ) )  45
int globalReturnsTrue() 147
return 1 ; 149
size_t dataLen = strlen ( data ) ; 49
FILE * pFile ; 50
if ( FILENAME_MAX - dataLen > 1 )  52
pFile = fopen ( FILENAME , ""r"" ); 54
if ( pFile != NULL )  55
fclose ( pFile ); 64",0,0
21649,"void stonesoup_setup_printf_context() 87
ss_tc_root = getenv ( ""SS_TC_ROOT"" ); 95
if ( ss_tc_root != NULL )  96
size_dirpath = strlen ( ss_tc_root ) + strlen ( ""testData"" ) + 2; 97
dirpath = ( char * ) malloc ( size_dirpath * sizeof ( char ) ); 98
if ( dirpath != NULL )  99
sprintf ( dirpath , ""%s/%s"" , ss_tc_root , ""testData"" ); 100
retval = 0; 101
if ( stat ( dirpath , & st ) == - 1 )  102
retval = mkdir ( dirpath , 0700 ); 103
if ( retval == 0 )  105
size_filepath = strlen ( dirpath ) + strlen ( ""logfile.txt"" ) + 2; 106
filepath = ( char * ) malloc ( size_filepath * sizeof ( char ) ); 107
if ( filepath != NULL )  108
sprintf ( filepath , ""%s/%s"" , dirpath , ""logfile.txt"" ); 109
free ( filepath ); 111",0,0
122871,"static int transcode_init() 2055
int i ; 2058
int j ; 2059
AVFormatContext * oc ; 2061
AVCodecContext * codec ; 2062
OutputStream * ost ; 2063
InputStream * ist ; 2064
for (i = 0; i < nb_input_files; i++) 2068
InputFile * ifile = input_files [ i ] ; 2069
if ( ifile -> rate_emu )  2070
for (j = 0; j < ifile -> nb_streams; j++) 2071
input_streams [ j + ifile -> ist_index ] -> start = av_gettime ( ); 2072
for (i = 0; i < nb_output_files; i++) 2076
oc = output_files [ i ] -> ctx; 2077
if ( ! oc -> nb_streams && ! ( oc -> oformat -> flags & 0x1000 ) )  2078
for (i = 0; i < nb_filtergraphs; i++) 2085
if ( ( ret = avfilter_graph_config ( filtergraphs [ i ] -> graph , ( ( void * ) 0 ) ) ) < 0 )  2086
for (i = 0; i < nb_output_streams; i++) 2090
AVCodecContext * icodec = ( ( void * ) 0 ) ; 2091
ost = output_streams [ i ]; 2092
oc = output_files [ ost -> file_index ] -> ctx; 2093
ist = get_input_stream ( ost ); 2094
static InputStream *get_input_stream(OutputStream *ost) 1971
if ( ost -> source_index >= 0 )  1973
return input_streams [ ost -> source_index ] ; 1974
return ( ( void * ) 0 ) ; 1976
if ( ost -> attachment_filename )  2095
codec = ost -> st -> codec; 2098
if ( ist )  2099
icodec = ist -> st -> codec; 2100
ost -> st -> disposition = ist -> st -> disposition; 2101
codec -> bits_per_raw_sample = icodec -> bits_per_raw_sample; 2102
codec -> chroma_sample_location = icodec -> chroma_sample_location; 2103
if ( ost -> stream_copy )  2105
uint64_t extra_size ; 2106
extra_size = ( ( uint64_t ) ( icodec -> extradata_size ) ) + 16; 2113
if ( extra_size > 2147483647 )  2114
codec -> codec_id = icodec -> codec_id; 2118
codec -> codec_type = icodec -> codec_type; 2119
if ( ! codec -> codec_tag )  2120
unsigned int codec_tag ; 2121
if ( ! oc -> oformat -> codec_tag || ( av_codec_get_id ( oc -> oformat -> codec_tag , icodec -> codec_tag ) ) == ( codec -> codec_id ) || ! av_codec_get_tag2 ( oc -> oformat -> codec_tag , icodec -> codec_id , & codec_tag ) )  2122
codec -> codec_tag = icodec -> codec_tag; 2123
codec -> bit_rate = icodec -> bit_rate; 2126
codec -> rc_max_rate = icodec -> rc_max_rate; 2127
codec -> rc_buffer_size = icodec -> rc_buffer_size; 2128
codec -> field_order = icodec -> field_order; 2129
codec -> extradata = ( av_mallocz ( extra_size ) ); 2130
if ( ! codec -> extradata )  2131
memcpy ( ( codec -> extradata ) , ( icodec -> extradata ) , ( icodec -> extradata_size ) ); 2134
codec -> extradata_size = icodec -> extradata_size; 2135
codec -> bits_per_coded_sample = icodec -> bits_per_coded_sample; 2136
codec -> time_base = ist -> st -> time_base; 2137
if ( ! strcmp ( oc -> oformat -> name , ""avi"" ) )  2143
if ( copy_tb < 0 && av_q2d ( ist -> st -> r_frame_rate ) >= av_q2d ( ist -> st -> avg_frame_rate ) && 0.5 / av_q2d ( ist -> st -> r_frame_rate ) > av_q2d ( ist -> st -> time_base ) && 0.5 / av_q2d ( ist -> st -> r_frame_rate ) > av_q2d ( icodec -> time_base ) && av_q2d ( ist -> st -> time_base ) < 1.0 / 500 && av_q2d ( icodec -> time_base ) < 1.0 / 500 || copy_tb == 2 )  2144
codec -> time_base . num = ist -> st -> r_frame_rate . den; 2145
codec -> time_base . den = 2 * ist -> st -> r_frame_rate . num; 2146
codec -> ticks_per_frame = 2; 2147
if ( copy_tb < 0 && av_q2d ( icodec -> time_base ) * ( icodec -> ticks_per_frame ) > 2 * av_q2d ( ist -> st -> time_base ) && av_q2d ( ist -> st -> time_base ) < 1.0 / 500 || copy_tb == 0 )  2150
codec -> time_base = icodec -> time_base; 2151
codec -> time_base . num *= icodec -> ticks_per_frame; 2152
codec -> time_base . den *= 2; 2153
codec -> ticks_per_frame = 2; 2154
if ( ! ( oc -> oformat -> flags & 0002000 ) && strcmp ( oc -> oformat -> name , ""mov"" ) && strcmp ( oc -> oformat -> name , ""mp4"" ) && strcmp ( oc -> oformat -> name , ""3gp"" ) && strcmp ( oc -> oformat -> name , ""3g2"" ) && strcmp ( oc -> oformat -> name , ""psp"" ) && strcmp ( oc -> oformat -> name , ""ipod"" ) && strcmp ( oc -> oformat -> name , ""f4v"" ) )  2159
if ( copy_tb < 0 && icodec -> time_base . den && av_q2d ( icodec -> time_base ) * ( icodec -> ticks_per_frame ) > av_q2d ( ist -> st -> time_base ) && av_q2d ( ist -> st -> time_base ) < 1.0 / 500 || copy_tb == 0 )  2160
codec -> time_base = icodec -> time_base; 2161
codec -> time_base . num *= icodec -> ticks_per_frame; 2162
codec -> time_base = icodec -> time_base; 2167
if ( ost -> frame_rate . num )  2169
codec -> time_base = av_inv_q ( ost -> frame_rate ); 2170
switch ( codec -> codec_type )  2173
codec -> channel_layout = icodec -> channel_layout; 2180
codec -> sample_rate = icodec -> sample_rate; 2181
codec -> channels = icodec -> channels; 2182
codec -> frame_size = icodec -> frame_size; 2183
codec -> audio_service_type = icodec -> audio_service_type; 2184
codec -> block_align = icodec -> block_align; 2185
if ( ( codec -> block_align == 1 || codec -> block_align == 1152 || codec -> block_align == 576 ) && ( codec -> codec_id ) == AV_CODEC_ID_MP3 )  2186
codec -> block_align = 0; 2187
if ( ( codec -> codec_id ) == AV_CODEC_ID_AC3 )  2189
codec -> block_align = 0; 2190
codec -> pix_fmt = icodec -> pix_fmt; 2196
codec -> width = icodec -> width; 2197
codec -> height = icodec -> height; 2198
codec -> has_b_frames = icodec -> has_b_frames; 2199
if ( ! codec -> sample_aspect_ratio . num )  2200
codec -> sample_aspect_ratio = ost -> st -> sample_aspect_ratio = ( ist -> st -> sample_aspect_ratio . num ? ist -> st -> sample_aspect_ratio : ( ( ist -> st -> codec -> sample_aspect_ratio . num ? ist -> st -> codec -> sample_aspect_ratio : ( ( AVRational ) ( 0 ) , ( 1 ) ) ) ) ) 2201
ost -> st -> avg_frame_rate = ist -> st -> avg_frame_rate; 2203
codec -> width = icodec -> width; 2208
codec -> height = icodec -> height; 2209
if ( ! ost -> enc )  2222
ost -> enc = avcodec_find_encoder ( codec -> codec_id ); 2223
if ( ! ost -> enc )  2225
ret = - 22; 2228
if ( ist )  2231
ist -> decoding_needed ++; 2232
ost -> encoding_needed = 1; 2234
if ( ( codec -> codec_type ) == AVMEDIA_TYPE_VIDEO )  2243
if ( ost -> filter && ! ost -> frame_rate . num )  2244
ost -> frame_rate = av_buffersink_get_frame_rate ( ost -> filter -> filter ); 2245
if ( ist && ! ost -> frame_rate . num )  2247
ost -> frame_rate = ist -> framerate; 2248
if ( ist && ! ost -> frame_rate . num )  2250
ost -> frame_rate = ( ist -> st -> r_frame_rate . num ? ist -> st -> r_frame_rate : ( ( AVRational ) ( 25 ) , ( 1 ) ) ) 2251
if ( ost -> enc && ost -> enc -> supported_framerates && ! ost -> force_fps )  2254
int idx = av_find_nearest_q_idx ( ost -> frame_rate , ost -> enc -> supported_framerates ) ; 2255
ost -> frame_rate = ost -> enc -> supported_framerates [ idx ]; 2256
switch ( codec -> codec_type )  2259
codec -> sample_fmt = ( ost -> filter -> filter -> inputs [ 0 ] -> format ); 2262
codec -> sample_rate = ost -> filter -> filter -> inputs [ 0 ] -> sample_rate; 2263
codec -> channel_layout = ost -> filter -> filter -> inputs [ 0 ] -> channel_layout; 2264
codec -> channels = avfilter_link_get_channels ( ost -> filter -> filter -> inputs [ 0 ] ); 2265
codec -> time_base = ( ( AVRational ) ( 1 ) , codec -> sample_rate ) 2266
codec -> time_base = av_inv_q ( ost -> frame_rate ); 2271
if ( ost -> filter && ! ( codec -> time_base . num && codec -> time_base . den ) )  2272
codec -> time_base = ost -> filter -> filter -> inputs [ 0 ] -> time_base; 2273
codec -> width = ost -> filter -> filter -> inputs [ 0 ] -> w; 2280
codec -> height = ost -> filter -> filter -> inputs [ 0 ] -> h; 2281
codec -> sample_aspect_ratio = ost -> st -> sample_aspect_ratio = ( ost -> frame_aspect_ratio ? av_d2q ( ( ost -> frame_aspect_ratio * ( codec -> height ) / ( codec -> width ) ) , 255 ) : ost -> filter -> filter -> inputs [ 0 ] -> sample_aspect_ratio ); 2282
codec -> pix_fmt = ( ost -> filter -> filter -> inputs [ 0 ] -> format ); 2284
if ( ! icodec || codec -> width != icodec -> width || codec -> height != icodec -> height || ( codec -> pix_fmt ) != ( icodec -> pix_fmt ) )  2285
codec -> bits_per_raw_sample = frame_bits_per_raw_sample; 2286
if ( ost -> forced_keyframes )  2288
if ( ! strncmp ( ( ost -> forced_keyframes ) , ""expr:"" , 5 ) )  2289
ret = av_expr_parse ( & ost -> forced_keyframes_pexpr , ( ost -> forced_keyframes + 5 ) , forced_keyframes_const_names , ( ( void * ) 0 ) , ( ( void * ) 0 ) , ( ( void * ) 0 ) , ( ( void * ) 0 ) , 0 , ( ( void * ) 0 ) ); 2290
if ( ret < 0 )  2291
ost -> forced_keyframes_expr_const_values [ FKF_N ] = 0; 2295
ost -> forced_keyframes_expr_const_values [ FKF_N_FORCED ] = 0; 2296
ost -> forced_keyframes_expr_const_values [ FKF_PREV_FORCED_N ] = ( __builtin_nanf ( """" ) ); 2297
ost -> forced_keyframes_expr_const_values [ FKF_PREV_FORCED_T ] = ( __builtin_nanf ( """" ) ); 2298
codec -> time_base = ( ( AVRational ) ( 1 ) , ( 1000 ) ) 2308
if ( ! codec -> width )  2309
codec -> width = input_streams [ ost -> source_index ] -> st -> codec -> width; 2310
codec -> height = input_streams [ ost -> source_index ] -> st -> codec -> height; 2311
if ( codec -> flags & ( 0x0200 | 0002000 ) )  2322
char logfilename [ 1024 ] ; 2323
FILE * f ; 2324
snprintf ( logfilename , sizeof ( logfilename ) , ""%s-%d.log"" , ( ost -> logfile_prefix ? ost -> logfile_prefix : ""ffmpeg2pass"" ) , i ); 2325
if ( ! strcmp ( ost -> enc -> name , ""libx264"" ) )  2326
if ( codec -> flags & 0002000 )  2330
char * logbuffer ; 2331
codec -> stats_in = logbuffer; 2337
if ( codec -> flags & 0x0200 )  2339
f = fopen ( logfilename , ""wb"" ); 2340
ost -> logfile = f; 2345
for (i = 0; i < nb_output_streams; i++) 2352
ost = output_streams [ i ]; 2353
if ( ost -> encoding_needed )  2354
AVCodec * codec = ost -> enc ; 2355
AVCodecContext * dec = ( ( void * ) 0 ) ; 2356
if ( ist = get_input_stream ( ost ) )  2357
static InputStream *get_input_stream(OutputStream *ost) 1971
if ( ost -> source_index >= 0 )  1973
return input_streams [ ost -> source_index ] ; 1974
return ( ( void * ) 0 ) ; 1976
dec = ist -> st -> codec; 2358
if ( dec && dec -> subtitle_header )  2360
ost -> st -> codec -> subtitle_header = ( av_mallocz ( ( dec -> subtitle_header_size + 1 ) ) ); 2362
if ( ! ost -> st -> codec -> subtitle_header )  2363
memcpy ( ( ost -> st -> codec -> subtitle_header ) , ( dec -> subtitle_header ) , ( dec -> subtitle_header_size ) ); 2367
ost -> st -> codec -> subtitle_header_size = dec -> subtitle_header_size; 2368
if ( ! av_dict_get ( ost -> opts , ""threads"" , ( ( void * ) 0 ) , 0 ) )  2370
av_dict_set ( & ost -> opts , ""threads"" , ""auto"" , 0 ); 2371
if ( ( ret = avcodec_open2 ( ost -> st -> codec , codec , & ost -> opts ) ) < 0 )  2373
if ( ret == - 0x2bb2afa8 )  2374
if ( ( ost -> enc -> type ) == AVMEDIA_TYPE_AUDIO && ! ( ost -> enc -> capabilities & 0x10000 ) )  2380
av_buffersink_set_frame_size ( ost -> filter -> filter , ( ost -> st -> codec -> frame_size ) ); 2381
assert_avoptions ( ost -> opts ); 2383
void assert_avoptions(AVDictionary *m) 546
if ( t = av_dict_get ( m , """" , ( ( void * ) 0 ) , 2 ) )  549
av_log ( ( ( void * ) 0 ) , 8 , ""Option %s not found.\n"" , t -> key ); 550
if ( ost -> st -> codec -> bit_rate && ost -> st -> codec -> bit_rate < 1000 )  2384
extra_size += ( ost -> st -> codec -> extradata_size ); 2387
if ( ost -> st -> codec -> me_threshold )  2388
input_streams [ ost -> source_index ] -> st -> codec -> debug |= 32; 2389
avcodec_close ( ost -> st -> codec ); 2401
if ( ! input_streams [ ( ifile -> ist_index ) + p -> stream_index [ k ] ] -> discard )  2412
ist = input_streams [ i ]; 2447
for (j = 0; j < ist -> nb_filters; j++) 2448
if ( ist -> filters [ j ] -> graph -> graph_desc )  2449
av_log ( ( ( void * ) 0 ) , 32 , ""  Stream #%d:%d (%s) -> %s"" , ist -> file_index , ist -> st -> index , ( ist -> dec ? ist -> dec -> name : ""?"" ) , ist -> filters [ j ] -> name ); 2450
av_log ( ( ( void * ) 0 ) , 32 , "" (graph %d)"" , ist -> filters [ j ] -> graph -> index ); 2452
if ( ost -> attachment_filename )  2460
av_log ( ( ( void * ) 0 ) , 32 , ""  File %s -> Stream #%d:%d\n"" , ost -> attachment_filename , ost -> file_index , ost -> index ); 2462
if ( ost -> filter && ost -> filter -> graph -> graph_desc )  2465
av_log ( ( ( void * ) 0 ) , 32 , ""  %s"" , ost -> filter -> name ); 2467
av_log ( ( ( void * ) 0 ) , 32 , "" (graph %d)"" , ost -> filter -> graph -> index ); 2469
av_log ( ( ( void * ) 0 ) , 32 , "" -> Stream #%d:%d (%s)\n"" , ost -> file_index , ost -> index , ( ost -> enc ? ost -> enc -> name : ""?"" ) ); 2471
av_log ( ( ( void * ) 0 ) , 32 , ""  Stream #%d:%d -> #%d:%d"" , input_streams [ ost -> source_index ] -> file_index , input_streams [ ost -> source_index ] -> st -> index , ost -> file_index , ost -> index ); 2474
if ( ost -> sync_ist != input_streams [ ost -> source_index ] )  2475
av_log ( ( ( void * ) 0 ) , 32 , "" [sync #%d:%d]"" , ost -> sync_ist -> file_index , ost -> sync_ist -> st -> index ); 2476
if ( ost -> stream_copy )  2478
av_log ( ( ( void * ) 0 ) , 32 , "" (%s -> %s)"" , ( input_streams [ ost -> source_index ] -> dec ? input_streams [ ost -> source_index ] -> dec -> name : ""?"" ) , ( ost -> enc ? ost -> enc -> name : ""?"" ) ); 2482
if ( ret )  2486
return ret ; 2488",0,0
38955,"void dfacomp(const char *s,size_t len,struct dfa *d,int searchflag) 3765
dfamust ( d ); 3769
static void dfamust(struct dfa *d) 4061
must * musts ; 4063
must * mp ; 4064
size_t ri ; 4066
size_t i ; 4067
token t ; 4069
static must must0 ; 4070
musts = ( ( sizeof ( ( * musts ) ) == 1 ? xmalloc ( d -> tindex + 1 ) : xnmalloc ( d -> tindex + 1 , sizeof ( ( * musts ) ) ) ) ); 4082
while ( 0 )  4083
mp = musts; 4084
for (i = 0; i <= d -> tindex; ++i) 4085
mp [ i ] = must0; 4086
for (i = 0; i <= d -> tindex; ++i) 4087
mp [ i ] . in = ( xmalloc ( sizeof ( ( * mp [ i ] . in ) ) ) ); 4088
mp [ i ] . left = ( xmalloc ( 2 ) ); 4089
mp [ i ] . right = ( xmalloc ( 2 ) ); 4090
mp [ i ] . is = ( xmalloc ( 2 ) ); 4091
mp [ i ] . left [ 0 ] = mp [ i ] . right [ 0 ] = mp [ i ] . is [ 0 ] = '\0'; 4092
mp [ i ] . in [ 0 ] = ( ( void * ) 0 ); 4093
for (ri = 0; ri < d -> tindex; ++ri) 4097
switch ( t = d -> tokens [ ri ] )  4098
must * lmp ; 4145
must * rmp ; 4146
size_t j ; 4147
size_t ln ; 4148
rmp = -- mp; 4151
lmp = -- mp; 4152
if ( ! ( strcmp ( ( lmp -> is ) , ( rmp -> is ) ) == 0 ) )  4154
lmp -> is [ 0 ] = '\0'; 4155
i = 0; 4158
lmp -> left [ i ] = '\0'; 4161
ln = strlen ( ( lmp -> right ) ); 4163
for (j = 0; j < i; ++j) 4173
lmp -> right [ j ] = lmp -> right [ ln - i + j ]; 4174
lmp -> right [ j ] = '\0'; 4175
mp -> is [ 0 ] = '\0'; 4190
must * lmp ; 4209
must * rmp ; 4210
rmp = -- mp; 4211
lmp = -- mp; 4212
lmp -> in = addlists ( lmp -> in , rmp -> in ); 4216
if ( lmp -> in == ( ( void * ) 0 ) )  4217
if ( lmp -> right [ 0 ] != '\0' && rmp -> left [ 0 ] != '\0' )  4220
char * tp ; 4221
tp = icpyalloc ( ( lmp -> right ) ); 4222
static char *icpyalloc(const char *string) 3886
return icatalloc ( ( ( void * ) 0 ) , string ) ; 3888
tp = icatalloc ( tp , ( rmp -> left ) ); 4223
lmp -> in = enlist ( lmp -> in , tp , strlen ( tp ) ); 4224
if ( lmp -> in == ( ( void * ) 0 ) )  4226
if ( lmp -> is [ 0 ] != '\0' )  4231
lmp -> left = icatalloc ( lmp -> left , ( rmp -> left ) ); 4232
if ( lmp -> left == ( ( void * ) 0 ) )  4233
if ( rmp -> is [ 0 ] == '\0' )  4238
lmp -> right [ 0 ] = '\0'; 4239
lmp -> right = icatalloc ( lmp -> right , ( rmp -> right ) ); 4241
if ( lmp -> right == ( ( void * ) 0 ) )  4242
if ( lmp -> is [ 0 ] != '\0' && rmp -> is [ 0 ] != '\0' )  4246
lmp -> is = icatalloc ( lmp -> is , ( rmp -> is ) ); 4247
if ( lmp -> is == ( ( void * ) 0 ) )  4248
lmp -> is [ 0 ] = '\0'; 4253
if ( t < END )  4260
if ( t == '\0' )  4264
if ( t >= CSET || ! 1 || t == ANYCHAR || t == MBCSET )  4269
mp -> is [ 0 ] = mp -> left [ 0 ] = mp -> right [ 0 ] = t; 4276
mp -> is [ 1 ] = mp -> left [ 1 ] = mp -> right [ 1 ] = '\0'; 4277
mp -> in = enlist ( mp -> in , mp -> is , ( ( size_t ) 1 ) ); 4278
if ( mp -> in == ( ( void * ) 0 ) )  4279
mp = musts; 4302
free ( mp ); 4310",0,0
57012,"static void goodG2B2() 110
wchar_t * data ; 112
data = NULL; 113
data = goodG2B2Source ( data ); 115
static wchar_t * goodG2B2Source(wchar_t * data) 99
if ( goodG2B2Static )  101
data = ( wchar_t * ) malloc ( 100 * sizeof ( wchar_t ) ); 104
data [ 0 ] = L '\0' 105
return data ; 107
wchar_t source [ 100 ] ; 117
wmemset ( source , L 'C' , 100 - 1 )
source [ 100 - 1 ] = L '\0' 119
memmove ( data , source , 100 * sizeof ( wchar_t ) ); 121
printWLine ( data ); 123
void printWLine (const wchar_t * line) 18
if ( line != NULL )  20
wprintf ( L ""%ls\n"" , line ) 22
free ( data ); 124",0,0
107032,"static status_transit_state transit_state_consume_1char(struct dfa *d,state_num s,const unsigned char **pp,int *match_lens,int *mbclen,position_set *pps) 3390
int k ; 3394
state_num s1 ; 3395
state_num s2 ; 3396
* mbclen = ( mblen_buf [ * pp - buf_begin ] == 0 ? 1 : mblen_buf [ * pp - buf_begin ] ); 3401
s1 = s; 3404
for (k = 0; k <  *mbclen; k++) 3405
s2 = s1; 3406
rs = transit_state_singlebyte ( d , s2 , ( * pp ) ++ , & s1 ); 3407
static status_transit_state transit_state_singlebyte(struct dfa *d,state_num s,const unsigned char *p,state_num *next_state) 3192
state_num * t ; 3194
state_num works = s ; 3195
status_transit_state rval = TRANSIT_STATE_IN_PROGRESS ; 3196
while ( rval == TRANSIT_STATE_IN_PROGRESS )  3197
if ( ( t = d -> trans [ works ] ) != ( ( void * ) 0 ) )  3198
works = t [ * p ]; 3199
rval = TRANSIT_STATE_DONE; 3200
if ( works < 0 )  3201
works = 0; 3202
if ( works < 0 )  3206
works = 0; 3211
if ( d -> fails [ works ] )  3214
works = d -> fails [ works ] [ * p ]; 3215
rval = TRANSIT_STATE_DONE; 3216
build_state ( works , d ); 3219
static void build_state(state_num s,struct dfa *d) 3037
state_num * trans ; 3040
state_num i ; 3041
if ( d -> trcount >= 1024 )  3046
for (i = 0; i < d -> tralloc; ++i) 3047
d -> trans [ i ] = d -> fails [ i ] = ( ( void * ) 0 ); 3050
d -> trcount = 0; 3052
d -> success [ s ] = 0; 3056
if ( ( ( ( 4 & 1 ? ( * d ) . states [ s ] . constraint & 0xf : 0 ) ) | ( ( 4 & 2 ? ( * d ) . states [ s ] . constraint >> 4 & 0xf : 0 ) ) | ( ( 4 & 4 ? ( * d ) . states [ s ] . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context )  3057
d -> success [ s ] |= 4; 3058
if ( ( ( ( 2 & 1 ? ( * d ) . states [ s ] . constraint & 0xf : 0 ) ) | ( ( 2 & 2 ? ( * d ) . states [ s ] . constraint >> 4 & 0xf : 0 ) ) | ( ( 2 & 4 ? ( * d ) . states [ s ] . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context )  3060
d -> success [ s ] |= 2; 3061
if ( ( ( ( 1 & 1 ? ( * d ) . states [ s ] . constraint & 0xf : 0 ) ) | ( ( 1 & 2 ? ( * d ) . states [ s ] . constraint >> 4 & 0xf : 0 ) ) | ( ( 1 & 4 ? ( * d ) . states [ s ] . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context )  3063
d -> success [ s ] |= 1; 3064
trans = ( ( sizeof ( ( * trans ) ) == 1 ? xmalloc ( ( 1 << 8 ) ) : xnmalloc ( ( 1 << 8 ) , sizeof ( ( * trans ) ) ) ) ); 3067
while ( 0 )  3068
dfastate ( s , d , trans ); 3069
void dfastate(state_num s,struct dfa *d,token trans[]) 2759
leaf_set * grps ; 2762
charclass * labels ; 2764
size_t ngrps = 0 ; 2766
position pos ; 2768
charclass matches ; 2770
int matchesf ; 2772
charclass intersect ; 2774
int intersectf ; 2776
charclass leftovers ; 2778
int leftoversf ; 2780
size_t i ; 2797
size_t j ; 2798
size_t k ; 2799
grps = ( ( sizeof ( ( * grps ) ) == 1 ? xmalloc ( ( 1 << 8 ) ) : xnmalloc ( ( 1 << 8 ) , sizeof ( ( * grps ) ) ) ) ); 2801
while ( 0 )  2802
labels = ( ( sizeof ( ( * labels ) ) == 1 ? xmalloc ( ( 1 << 8 ) ) : xnmalloc ( ( 1 << 8 ) , sizeof ( ( * labels ) ) ) ) ); 2804
while ( 0 )  2805
for (i = 0; i < d -> states[s] . elems . nelem; ++i) 2807
pos = d -> states [ s ] . elems . elems [ i ]; 2808
if ( d -> tokens [ pos . index ] >= 0 && d -> tokens [ pos . index ] < ( 1 << 8 ) )  2809
if ( d -> tokens [ pos . index ] >= CSET )  2813
if ( pos . constraint != 0x777 )  2836
if ( ! ( ( ( ( 4 & 1 ? pos . constraint & 0xf : 0 ) ) | ( ( 4 & 2 ? pos . constraint >> 4 & 0xf : 0 ) ) | ( ( 4 & 4 ? pos . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context ) )  2837
for (j = 0; j < ((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int )); ++j) 2838
matches [ j ] &= ~newline [ j ]; 2839
if ( ! ( ( ( ( 2 & 1 ? pos . constraint & 0xf : 0 ) ) | ( ( 2 & 2 ? pos . constraint >> 4 & 0xf : 0 ) ) | ( ( 2 & 4 ? pos . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context ) )  2841
for (j = 0; j < ((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int )); ++j) 2842
matches [ j ] &= ~letters [ j ]; 2843
if ( ! ( ( ( ( 1 & 1 ? pos . constraint & 0xf : 0 ) ) | ( ( 1 & 2 ? pos . constraint >> 4 & 0xf : 0 ) ) | ( ( 1 & 4 ? pos . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context ) )  2845
for (j = 0; j < ((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int )); ++j) 2846
matches [ j ] &= letters [ j ] | newline [ j ]; 2847
if ( j == ( ( 1 << 8 ) + 8 * sizeof ( int ) - 1 ) / ( 8 * sizeof ( int ) ) )  2852
for (j = 0; j < ngrps; ++j) 2856
if ( d -> tokens [ pos . index ] >= 0 && d -> tokens [ pos . index ] < ( 1 << 8 ) && ! tstbit ( d -> tokens [ pos . index ] , labels [ j ] ) )  2860
intersectf = 0; 2865
for (k = 0; k < ((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int )); ++k) 2866
( intersect [ k ] = matches [ k ] & labels [ j ] [ k ] ) ? ( intersectf = 1 ) : 0; 2867
if ( ! intersectf )  2868
leftoversf = matchesf = 0; 2872
for (k = 0; k < ((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int )); ++k) 2873
int match = matches [ k ] ; 2875
int label = labels [ j ] [ k ] ; 2876
( leftovers [ k ] = ~match & label ) ? ( leftoversf = 1 ) : 0; 2877
( matches [ k ] = match & ~label ) ? ( matchesf = 1 ) : 0; 2878
if ( leftoversf )  2881
grps [ ngrps ] . elems = ( ( sizeof ( ( * grps [ ngrps ] . elems ) ) == 1 ? xmalloc ( d -> nleaves ) : xnmalloc ( d -> nleaves , sizeof ( ( * grps [ ngrps ] . elems ) ) ) ) ); 2885
while ( 0 )  2886
memcpy ( grps [ ngrps ] . elems , grps [ j ] . elems , sizeof ( grps [ j ] . elems [ 0 ] ) * grps [ j ] . nelem ); 2887
grps [ ngrps ] . nelem = grps [ j ] . nelem; 2888
grps [ j ] . elems [ grps [ j ] . nelem ++ ] = pos . index; 2893
if ( ! matchesf )  2896
if ( j == ngrps )  2902
grps [ ngrps ] . elems = ( ( sizeof ( ( * grps [ ngrps ] . elems ) ) == 1 ? xmalloc ( d -> nleaves ) : xnmalloc ( d -> nleaves , sizeof ( ( * grps [ ngrps ] . elems ) ) ) ) ); 2906
while ( 0 )  2907
grps [ ngrps ] . nelem = 1; 2908
grps [ ngrps ] . elems [ 0 ] = pos . index; 2909",0,0
51685,"static void goodG2B1() 62
wchar_t * data ; 64
wchar_t dataBuffer [ 100 ] ; 65
data = dataBuffer; 66
if ( staticReturnsFalse ( ) )  67
static int staticReturnsFalse() 30
return 0 ; 32
wmemset ( data , L 'A' , 50 - 1 )
data [ 50 - 1 ] = L '\0' 76
wchar_t dest [ 50 ] = L """" 79
memmove ( dest , data , wcslen ( data ) * sizeof ( wchar_t ) ); 81",0,0
23169,"void CWE78_OS_Command_Injection__wchar_t_console_w32spawnl_10_bad() 40
wchar_t * data ; 42
wchar_t dataBuffer [ 100 ] = L """" 43
data = dataBuffer; 44
if ( globalTrue )  45
size_t dataLen = wcslen ( data ) ; 49
if ( 100 - dataLen > 1 )  51
if ( fgetws ( data + dataLen , ( int ) ( 100 - dataLen ) , stdin ) != NULL )  54
dataLen = wcslen ( data ); 58
if ( dataLen > 0 && data [ dataLen - 1 ] == L '\n' ) 59",0,0
167783,"static void goodG2B2() 177
char source [ 100 ] ; 188
memset ( source , 'A' , 100 - 1 ); 190
source [ 100 - 1 ] = '\0'; 191
strncpy ( dest , source , data ); 196
dest [ data ] = '\0'; 197
printLine ( dest ); 199
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",0,0
147935,"static void goodB2G2() 134
wchar_t * data ; 136
data = ( wchar_t * ) malloc ( 100 * sizeof ( wchar_t ) ); 137
data [ 0 ] = L '\0' 138
size_t dataLen = wcslen ( data ) ; 141
FILE * pFile ; 142
if ( 100 - dataLen > 1 )  144
pFile = fopen ( FILENAME , ""r"" ); 146
if ( pFile != NULL )  147
if ( fgetws ( data + dataLen , ( int ) ( 100 - dataLen ) , pFile ) == NULL )  150
fclose ( pFile ); 156",0,0
41671,"static void goodG2B1() 142
size_t data ; 144
data = 0; 146
if ( 5 != 5 )  147
data = 20; 155
if ( 5 == 5 )  157
wchar_t * myString ; 160
if ( data > wcslen ( HELLO_STRING ) )  164
myString = new wchar_t [ data ]; 166
wcscpy ( myString , HELLO_STRING ); 168
printWLine ( myString ); 169
void printWLine (const wchar_t * line) 18
if ( line != NULL )  20
wprintf ( L ""%ls\n"" , line ) 22
delete [ ] myString 170",0,0
163829,"static void goodB2G() 71
char * data ; 73
data = ( char * ) malloc ( 100 * sizeof ( char ) ); 75
data [ 0 ] = '\0'; 76
size_t dataLen = strlen ( data ) ; 79
strncat ( data + dataLen , environment , 100 - dataLen - 1 ); 85
dataMap [ 0 ] = data; 88
dataMap [ 1 ] = data; 89
dataMap [ 2 ] = data; 90
goodB2GSink ( dataMap ); 91
void goodB2GSink(map<int, char *> dataMap) 53
char * data = dataMap [ 2 ] ; 55
for (i=0; i < strlen(data); i++) 59
if ( data [ i ] == SEARCH_CHAR )  61
free ( data ); 67",0,0
41356,"void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_connect_socket_52_bad() 49
char * data ; 51
data = ( char * ) malloc ( 100 * sizeof ( char ) ); 52
data [ 0 ] = '\0'; 53
WSADATA wsaData ; 56
int recvResult ; 59
struct sockaddr_in service ; 60
char * replace ; 61
size_t dataLen = strlen ( data ) ; 63
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  67
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 74
if ( connectSocket == INVALID_SOCKET )  75
memset ( & service , 0 , sizeof ( service ) ); 79
service . sin_family = AF_INET; 80
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS ); 81
service . sin_port = htons ( TCP_PORT ); 82
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  83
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ); 90
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  91
data [ dataLen + recvResult / sizeof ( char ) ] = '\0'; 96
replace = strchr ( data , '\n' ); 103
if ( replace )  104
* replace = '\0'; 106
while ( 0 )  109",0,0
87713,"static void good1() 91
int k ; 93
for(k = 0; k < 1; k++) 94
BYTE payload [ 100 ] ; 97
DWORD payloadLen = strlen ( PAYLOAD ) ; 98
HCRYPTPROV hCryptProv = ( HCRYPTPROV ) NULL ; 99
HCRYPTHASH hHash = ( HCRYPTHASH ) NULL ; 100
HCRYPTKEY hKey = ( HCRYPTKEY ) NULL ; 101
char hashData [ 100 ] = HASH_INPUT ; 102
memcpy ( payload , PAYLOAD , payloadLen ); 106
if ( ! CryptAcquireContext ( & hCryptProv , NULL , MS_ENH_RSA_AES_PROV , PROV_RSA_AES , 0 ) )  108
if ( ! CryptCreateHash ( hCryptProv , CALG_SHA_256 , 0 , 0 , & hHash ) )  114
if ( ! CryptHashData ( hHash , ( BYTE * ) hashData , strlen ( hashData ) , 0 ) )  119
if ( ! CryptDeriveKey ( hCryptProv , CALG_AES_256 , hHash , 0 , & hKey ) )  124
if ( ! CryptEncrypt ( hKey , 0 , 1 , 0 , payload , & payloadLen , sizeof ( payload ) ) )  129
while ( 0 )  134
printBytesLine ( payload , payloadLen ); 148
void printBytesLine(const unsigned char * bytes, size_t numBytes) 91
printf ( ""%02x"" , bytes [ i ] ); 96",0,0
31262,"static void goodG2B1() 326
size_t data ; 328
data = 0; 330
if ( GLOBAL_CONST_FALSE )  331
data = 20; 339
if ( GLOBAL_CONST_TRUE )  341
wchar_t * myString ; 344
if ( data > wcslen ( HELLO_STRING ) )  348
myString = new wchar_t [ data ]; 350
wcscpy ( myString , HELLO_STRING ); 352
printWLine ( myString ); 353
void printWLine (const wchar_t * line) 18
if ( line != NULL )  20
wprintf ( L ""%ls\n"" , line ) 22
delete [ ] myString 354",0,0
69606,"static void goodB2G() 76
twoIntsStruct * data ; 78
data = ( twoIntsStruct * ) calloc ( 100 , sizeof ( twoIntsStruct ) ); 85
data [ 0 ] . intOne = 0; 87
data [ 0 ] . intTwo = 0; 88
printStructLine ( & data [ 0 ] ); 89
void printStructLine (const twoIntsStruct * structTwoIntsStruct) 86
printf ( ""%d -- %d\n"" , structTwoIntsStruct -> intOne , structTwoIntsStruct -> intTwo ); 88
* dataPtr1 = data; 90
free ( data ); 95",0,0
86938,"static void goodB2G() 197
WSADATA wsaData ; 205
int recvResult ; 208
struct sockaddr_in service ; 209
char inputBuffer [ CHAR_ARRAY_SIZE ] ; 211
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  215
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 222
if ( connectSocket == INVALID_SOCKET )  223
memset ( & service , 0 , sizeof ( service ) ); 227
service . sin_family = AF_INET; 228
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS ); 229
service . sin_port = htons ( TCP_PORT ); 230
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  231
recvResult = recv ( connectSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 ); 237
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  238
inputBuffer [ recvResult ] = '\0'; 243
data = atoi ( inputBuffer ); 245
while ( 0 )  247
if ( connectSocket != INVALID_SOCKET )  248
CLOSE_SOCKET ( connectSocket ); 250
funcPtr ( data ); 259",0,0
129216,"static int handle_soft_key_event_message(struct skinny_req *req, struct skinnysession *s) 6276
struct skinny_device * d = s -> device ; 6278
struct skinny_line * l ; 6279
struct skinny_subchannel * sub = NULL ; 6280
struct ast_channel * c ; 6281
int event ; 6282
int instance ; 6283
int callreference ; 6284
event = letohl ( req -> data . softkeyeventmessage . softKeyEvent ); 6286
instance = letohl ( req -> data . softkeyeventmessage . instance ); 6287
callreference = letohl ( req -> data . softkeyeventmessage . callreference ); 6288
if ( instance )  6290
l = find_line_by_instance ( d , instance ); 6291
if ( callreference )  6292
sub = find_subchannel_by_instance_reference ( d , instance , callreference ); 6293
sub = find_subchannel_by_instance_reference ( d , instance , d -> lastcallreference ); 6295
l = find_line_by_instance ( d , d -> lastlineinstance ); 6298
if ( ! l )  6301
switch ( event )  6309
c = skinny_new ( l , NULL , AST_STATE_DOWN , NULL , SKINNY_OUTGOING ); 6341
sub = c -> tech_pvt; 6342
if ( sub )  6354
struct skinny_subline * subline ; 6357
if ( subline = find_subline_by_callid ( d , callreference ) )  6358
if ( l -> dnd != 0 )  6378
l -> dnd = 1; 6385
if ( ! sub || ! sub -> owner )  6394
c = skinny_new ( l , NULL , AST_STATE_DOWN , NULL , SKINNY_OUTGOING ); 6395
c = sub -> owner; 6397
if ( ! c )  6400
sub = c -> tech_pvt; 6403
l -> activesub = sub; 6404
if ( ! sub || ! sub -> owner )  6412
c = skinny_new ( l , NULL , AST_STATE_DOWN , NULL , SKINNY_OUTGOING ); 6413
c = sub -> owner; 6415
if ( ! c )  6418
sub = c -> tech_pvt; 6421
l -> activesub = sub; 6422
if ( ! sub || ! sub -> owner )  6431
c = skinny_new ( l , NULL , AST_STATE_DOWN , NULL , SKINNY_OUTGOING ); 6432
c = sub -> owner; 6434
if ( ! c )  6437
sub = c -> tech_pvt; 6440
l -> activesub = sub; 6441
if ( d -> hookstate == SKINNY_ONHOOK )  6454
if ( l -> transfer && sub && sub -> xferor && sub -> owner -> _state >= AST_STATE_RING )  6461
if ( sub )  6470
struct skinny_subline * subline ; 6473
if ( subline = find_subline_by_callid ( d , callreference ) )  6474
dumpsub ( subline -> sub , 1 ); 6475
static void dumpsub(struct skinny_subchannel *sub, int forcehangup) 5346
struct skinny_line * l = sub -> line ; 5348
struct skinny_subchannel * activatesub = NULL ; 5350
struct skinny_subchannel * tsub ; 5351
if ( ! forcehangup && sub -> substate == SUBSTATE_HOLD )  5357
if ( sub == l -> activesub )  5362
if ( sub -> related )  5365
activatesub = sub -> related; 5366
if ( tsub -> substate == SUBSTATE_CALLWAIT )  5377
activatesub = tsub; 5378
if ( activatesub )  5381
if ( tsub -> substate == SUBSTATE_HOLD )  5386
activatesub = tsub; 5387
if ( activatesub )  5390
setsubstate ( activatesub , SUBSTATE_HOLD ); 5391
static void setsubstate(struct skinny_subchannel *sub, int state) 4955
struct skinny_line * l = sub -> line ; 4957
struct skinny_subline * subline = sub -> subline ; 4958
struct skinny_device * d = l -> device ; 4959
struct ast_channel * c = sub -> owner ; 4960
int actualstate = state ; 4962
if ( sub -> substate == SUBSTATE_ONHOOK )  4964
if ( state != SUBSTATE_RINGIN && sub -> aa_sched )  4968
sub -> aa_sched = 0; 4970
sub -> aa_beep = 0; 4971
sub -> aa_mute = 0; 4972
if ( ( state == SUBSTATE_RINGIN ) && ( ( d -> hookstate == SKINNY_OFFHOOK ) || ( AST_LIST_NEXT ( AST_LIST_FIRST ( & l -> sub ) , list ) ) ) )  4975
actualstate = SUBSTATE_CALLWAIT; 4976
if ( ( state == SUBSTATE_CONNECTED ) && ( ! subline ) && ( AST_LIST_FIRST ( & l -> sublines ) ) )  4979
const char * slastation ; 4980
struct skinny_subline * tmpsubline ; 4981
slastation = pbx_builtin_getvar_helper ( c , ""SLASTATION"" ); 4982
if ( slastation )  4984
subline = tmpsubline; 4987
if ( subline )  4991
subline -> sub = sub; 4993
sub -> subline = subline; 4994
subline -> callid = sub -> callid; 4995
if ( subline )  5013
switch ( actualstate )  5014
if ( sub -> substate != SUBSTATE_CONNECTED )  5066
sub -> substate = SUBSTATE_HOLD; 5078
if ( actualstate == sub -> substate )  5101
switch ( actualstate )  5107
l -> activesub = sub; 5110
sub -> substate = SUBSTATE_OFFHOOK; 5118
if ( sub -> related )  5128
sub -> related -> related = NULL; 5129
if ( sub == l -> activesub )  5132
l -> activesub = NULL; 5133
sub -> cxmode = SKINNY_CX_RECVONLY; 5148
sub -> substate = SUBSTATE_ONHOOK; 5149
if ( sub -> rtp )  5150
sub -> rtp = NULL; 5152
if ( ast_strlen_zero ( sub -> exten ) || ! ast_exists_extension ( c , c -> context , sub -> exten , 1 , l -> cid_num ) )  5159
sub -> substate = SUBSTATE_DIALING; 5194
if ( ! ( sub -> substate == SUBSTATE_DIALING || sub -> substate == SUBSTATE_PROGRESS ) )  5202
sub -> substate = SUBSTATE_RINGOUT; 5214
sub -> substate = SUBSTATE_RINGIN; 5233
sub -> substate = SUBSTATE_CALLWAIT; 5246
sub -> substate = SUBSTATE_CONNECTED; 5278
if ( ! ( sub -> substate == SUBSTATE_DIALING || sub -> substate == SUBSTATE_PROGRESS || sub -> substate == SUBSTATE_RINGOUT ) )  5282
sub -> substate = SUBSTATE_BUSY; 5293
if ( ! ( sub -> substate == SUBSTATE_DIALING || sub -> substate == SUBSTATE_PROGRESS || sub -> substate == SUBSTATE_RINGOUT ) )  5296
ast_log ( LOG_WARNING , ""Cannot set substate to SUBSTATE_CONGESTION from %s (on call-%d)\n"" , substate2str ( sub -> substate ) , sub -> callid ); 5297
static char *substate2str(int ind) 4919
char * tmp ; 4920
switch ( ind )  4922
if ( ! ( tmp = ast_threadstorage_get ( & substate2str_threadbuf , SUBSTATE2STR_BUFSIZE ) ) )  4948
snprintf ( tmp , SUBSTATE2STR_BUFSIZE , ""UNKNOWN-%d"" , ind ); 4950
return tmp ; 4951",0,0
88653,"void bad() 43
char * data ; 45
char dataBuffer [ 100 ] = """" ; 47
data = dataBuffer; 48
size_t dataLen = strlen ( data ) ; 51
char * environment = GETENV ( ENV_VARIABLE ) ; 52
if ( environment != NULL )  54
strncat ( data + dataLen , environment , 100 - dataLen - 1 ); 57
dataVector . insert ( dataVector . end ( ) , 1 , data ); 61
dataVector . insert ( dataVector . end ( ) , 1 , data ); 62
dataVector . insert ( dataVector . end ( ) , 1 , data ); 63",0,0
8237,"static void goodG2B2() 181
size_t data ; 183
data = 0; 185
if ( globalTrue )  186
data = 20; 189
if ( globalTrue )  191
wchar_t * myString ; 194
if ( data > wcslen ( HELLO_STRING ) )  198
myString = new wchar_t [ data ]; 200
wcscpy ( myString , HELLO_STRING ); 202
printWLine ( myString ); 203
void printWLine (const wchar_t * line) 18
if ( line != NULL )  20
wprintf ( L ""%ls\n"" , line ) 22
delete [ ] myString 204",0,0
156203,"static int transcode() 3023
int ret ; 3025
int64_t timer_start ; 3030
ret = transcode_init ( ); 3031
static int transcode_init() 2045
int ret = 0 ; 2047
int i ; 2048
int j ; 2049
AVFormatContext * oc ; 2051
AVCodecContext * codec ; 2052
OutputStream * ost ; 2053
InputStream * ist ; 2054
char error [ 1024 ] ; 2055
for (i = 0; i < nb_input_files; i++) 2058
InputFile * ifile = input_files [ i ] ; 2059
if ( ifile -> rate_emu )  2060
for (j = 0; j < ifile -> nb_streams; j++) 2061
input_streams [ j + ifile -> ist_index ] -> start = av_gettime ( ); 2062
for (i = 0; i < nb_output_files; i++) 2066
oc = output_files [ i ] -> ctx; 2067
if ( ! oc -> nb_streams && ! ( oc -> oformat -> flags & 0x1000 ) )  2068
return - 22 ; 2071
for (i = 0; i < nb_filtergraphs; i++) 2075
if ( ( ret = avfilter_graph_config ( filtergraphs [ i ] -> graph , ( ( void * ) 0 ) ) ) < 0 )  2076
return ret ; 2077
for (i = 0; i < nb_output_streams; i++) 2080
AVCodecContext * icodec = ( ( void * ) 0 ) ; 2081
ost = output_streams [ i ]; 2082
oc = output_files [ ost -> file_index ] -> ctx; 2083
ist = get_input_stream ( ost ); 2084
static InputStream *get_input_stream(OutputStream *ost) 1961
if ( ost -> source_index >= 0 )  1963
return input_streams [ ost -> source_index ] ; 1964
return ( ( void * ) 0 ) ; 1966
if ( ost -> attachment_filename )  2085
codec = ost -> st -> codec; 2088
if ( ist )  2089
icodec = ist -> st -> codec; 2090
ost -> st -> disposition = ist -> st -> disposition; 2091
codec -> bits_per_raw_sample = icodec -> bits_per_raw_sample; 2092
codec -> chroma_sample_location = icodec -> chroma_sample_location; 2093
if ( ost -> stream_copy )  2095
uint64_t extra_size ; 2096
extra_size = ( ( uint64_t ) ( icodec -> extradata_size ) ) + 16; 2103
if ( extra_size > 2147483647 )  2104
return - 22 ; 2105
codec -> codec_id = icodec -> codec_id; 2108
codec -> codec_type = icodec -> codec_type; 2109
if ( ! codec -> codec_tag )  2110
unsigned int codec_tag ; 2111
if ( ! oc -> oformat -> codec_tag || ( av_codec_get_id ( oc -> oformat -> codec_tag , icodec -> codec_tag ) ) == ( codec -> codec_id ) || ! av_codec_get_tag2 ( oc -> oformat -> codec_tag , icodec -> codec_id , & codec_tag ) )  2112
codec -> codec_tag = icodec -> codec_tag; 2113
codec -> bit_rate = icodec -> bit_rate; 2116
codec -> rc_max_rate = icodec -> rc_max_rate; 2117
codec -> rc_buffer_size = icodec -> rc_buffer_size; 2118
codec -> field_order = icodec -> field_order; 2119
codec -> extradata = ( av_mallocz ( extra_size ) ); 2120
if ( ! codec -> extradata )  2121
return - 12 ; 2122
memcpy ( ( codec -> extradata ) , ( icodec -> extradata ) , ( icodec -> extradata_size ) ); 2124
codec -> extradata_size = icodec -> extradata_size; 2125
codec -> bits_per_coded_sample = icodec -> bits_per_coded_sample; 2126
codec -> time_base = ist -> st -> time_base; 2127
if ( ! strcmp ( oc -> oformat -> name , ""avi"" ) )  2133
if ( copy_tb < 0 && av_q2d ( ist -> st -> r_frame_rate ) >= av_q2d ( ist -> st -> avg_frame_rate ) && 0.5 / av_q2d ( ist -> st -> r_frame_rate ) > av_q2d ( ist -> st -> time_base ) && 0.5 / av_q2d ( ist -> st -> r_frame_rate ) > av_q2d ( icodec -> time_base ) && av_q2d ( ist -> st -> time_base ) < 1.0 / 500 && av_q2d ( icodec -> time_base ) < 1.0 / 500 || copy_tb == 2 )  2134
codec -> time_base . num = ist -> st -> r_frame_rate . den; 2135
codec -> time_base . den = 2 * ist -> st -> r_frame_rate . num; 2136
codec -> ticks_per_frame = 2; 2137
if ( copy_tb < 0 && av_q2d ( icodec -> time_base ) * ( icodec -> ticks_per_frame ) > 2 * av_q2d ( ist -> st -> time_base ) && av_q2d ( ist -> st -> time_base ) < 1.0 / 500 || copy_tb == 0 )  2140
codec -> time_base = icodec -> time_base; 2141
codec -> time_base . num *= icodec -> ticks_per_frame; 2142
codec -> time_base . den *= 2; 2143
codec -> ticks_per_frame = 2; 2144
if ( ! ( oc -> oformat -> flags & 0002000 ) && strcmp ( oc -> oformat -> name , ""mov"" ) && strcmp ( oc -> oformat -> name , ""mp4"" ) && strcmp ( oc -> oformat -> name , ""3gp"" ) && strcmp ( oc -> oformat -> name , ""3g2"" ) && strcmp ( oc -> oformat -> name , ""psp"" ) && strcmp ( oc -> oformat -> name , ""ipod"" ) && strcmp ( oc -> oformat -> name , ""f4v"" ) )  2149
if ( copy_tb < 0 && icodec -> time_base . den && av_q2d ( icodec -> time_base ) * ( icodec -> ticks_per_frame ) > av_q2d ( ist -> st -> time_base ) && av_q2d ( ist -> st -> time_base ) < 1.0 / 500 || copy_tb == 0 )  2150
codec -> time_base = icodec -> time_base; 2151
codec -> time_base . num *= icodec -> ticks_per_frame; 2152
codec -> time_base = icodec -> time_base; 2157
if ( ost -> frame_rate . num )  2159
codec -> time_base = av_inv_q ( ost -> frame_rate ); 2160
switch ( codec -> codec_type )  2163
codec -> channel_layout = icodec -> channel_layout; 2170
codec -> sample_rate = icodec -> sample_rate; 2171
codec -> channels = icodec -> channels; 2172
codec -> frame_size = icodec -> frame_size; 2173
codec -> audio_service_type = icodec -> audio_service_type; 2174
codec -> block_align = icodec -> block_align; 2175
if ( ( codec -> block_align == 1 || codec -> block_align == 1152 || codec -> block_align == 576 ) && ( codec -> codec_id ) == AV_CODEC_ID_MP3 )  2176
codec -> block_align = 0; 2177
if ( ( codec -> codec_id ) == AV_CODEC_ID_AC3 )  2179
codec -> block_align = 0; 2180
codec -> pix_fmt = icodec -> pix_fmt; 2186
codec -> width = icodec -> width; 2187
codec -> height = icodec -> height; 2188
codec -> has_b_frames = icodec -> has_b_frames; 2189
ost -> st -> avg_frame_rate = ist -> st -> avg_frame_rate; 2193
codec -> width = icodec -> width; 2198
codec -> height = icodec -> height; 2199
if ( ! ost -> enc )  2212
ost -> enc = avcodec_find_encoder ( codec -> codec_id ); 2213
if ( ! ost -> enc )  2215
ret = - 22; 2218
if ( ist )  2221
ist -> decoding_needed ++; 2222
ost -> encoding_needed = 1; 2224
if ( ( codec -> codec_type ) == AVMEDIA_TYPE_VIDEO )  2233
if ( ost -> filter && ! ost -> frame_rate . num )  2234
ost -> frame_rate = av_buffersink_get_frame_rate ( ost -> filter -> filter ); 2235
if ( ist && ! ost -> frame_rate . num )  2237
ost -> frame_rate = ist -> framerate; 2238
if ( ist && ! ost -> frame_rate . num )  2240
ost -> frame_rate = ( ist -> st -> r_frame_rate . num ? ist -> st -> r_frame_rate : ( ( AVRational ) ( 25 ) , ( 1 ) ) ) 2241
if ( ost -> enc && ost -> enc -> supported_framerates && ! ost -> force_fps )  2244
int idx = av_find_nearest_q_idx ( ost -> frame_rate , ost -> enc -> supported_framerates ) ; 2245
ost -> frame_rate = ost -> enc -> supported_framerates [ idx ]; 2246
switch ( codec -> codec_type )  2249
codec -> sample_fmt = ( ost -> filter -> filter -> inputs [ 0 ] -> format ); 2252
codec -> sample_rate = ost -> filter -> filter -> inputs [ 0 ] -> sample_rate; 2253
codec -> channel_layout = ost -> filter -> filter -> inputs [ 0 ] -> channel_layout; 2254
codec -> channels = avfilter_link_get_channels ( ost -> filter -> filter -> inputs [ 0 ] ); 2255
codec -> time_base = ( ( AVRational ) ( 1 ) , codec -> sample_rate ) 2256
codec -> time_base = av_inv_q ( ost -> frame_rate ); 2261
if ( ost -> filter && ! ( codec -> time_base . num && codec -> time_base . den ) )  2262
codec -> time_base = ost -> filter -> filter -> inputs [ 0 ] -> time_base; 2263
codec -> width = ost -> filter -> filter -> inputs [ 0 ] -> w; 2270
codec -> height = ost -> filter -> filter -> inputs [ 0 ] -> h; 2271
codec -> sample_aspect_ratio = ost -> st -> sample_aspect_ratio = ( ost -> frame_aspect_ratio ? av_d2q ( ( ost -> frame_aspect_ratio * ( codec -> height ) / ( codec -> width ) ) , 255 ) : ost -> filter -> filter -> inputs [ 0 ] -> sample_aspect_ratio ); 2272
codec -> pix_fmt = ( ost -> filter -> filter -> inputs [ 0 ] -> format ); 2274
if ( ! icodec || codec -> width != icodec -> width || codec -> height != icodec -> height || ( codec -> pix_fmt ) != ( icodec -> pix_fmt ) )  2275
codec -> bits_per_raw_sample = frame_bits_per_raw_sample; 2276
if ( ost -> forced_keyframes )  2278
if ( ! strncmp ( ( ost -> forced_keyframes ) , ""expr:"" , 5 ) )  2279
ret = av_expr_parse ( & ost -> forced_keyframes_pexpr , ( ost -> forced_keyframes + 5 ) , forced_keyframes_const_names , ( ( void * ) 0 ) , ( ( void * ) 0 ) , ( ( void * ) 0 ) , ( ( void * ) 0 ) , 0 , ( ( void * ) 0 ) ); 2280
if ( ret < 0 )  2281
return ret ; 2283
ost -> forced_keyframes_expr_const_values [ FKF_N ] = 0; 2285
ost -> forced_keyframes_expr_const_values [ FKF_N_FORCED ] = 0; 2286
ost -> forced_keyframes_expr_const_values [ FKF_PREV_FORCED_N ] = ( __builtin_nanf ( """" ) ); 2287
ost -> forced_keyframes_expr_const_values [ FKF_PREV_FORCED_T ] = ( __builtin_nanf ( """" ) ); 2288
codec -> time_base = ( ( AVRational ) ( 1 ) , ( 1000 ) ) 2298
if ( ! codec -> width )  2299
codec -> width = input_streams [ ost -> source_index ] -> st -> codec -> width; 2300
codec -> height = input_streams [ ost -> source_index ] -> st -> codec -> height; 2301
if ( codec -> flags & ( 0x0200 | 0002000 ) )  2312
char logfilename [ 1024 ] ; 2313
FILE * f ; 2314
snprintf ( logfilename , sizeof ( logfilename ) , ""%s-%d.log"" , ( ost -> logfile_prefix ? ost -> logfile_prefix : ""ffmpeg2pass"" ) , i ); 2315
if ( ! strcmp ( ost -> enc -> name , ""libx264"" ) )  2316
if ( codec -> flags & 0002000 )  2320
char * logbuffer ; 2321
codec -> stats_in = logbuffer; 2327
if ( codec -> flags & 0x0200 )  2329
f = fopen ( logfilename , ""wb"" ); 2330
ost -> logfile = f; 2335
for (i = 0; i < nb_output_streams; i++) 2342
ost = output_streams [ i ]; 2343
if ( ost -> encoding_needed )  2344
AVCodec * codec = ost -> enc ; 2345
AVCodecContext * dec = ( ( void * ) 0 ) ; 2346
if ( ist = get_input_stream ( ost ) )  2347
static InputStream *get_input_stream(OutputStream *ost) 1961
if ( ost -> source_index >= 0 )  1963
return input_streams [ ost -> source_index ] ; 1964
return ( ( void * ) 0 ) ; 1966
dec = ist -> st -> codec; 2348
if ( dec && dec -> subtitle_header )  2350
ost -> st -> codec -> subtitle_header = ( av_mallocz ( ( dec -> subtitle_header_size + 1 ) ) ); 2352
if ( ! ost -> st -> codec -> subtitle_header )  2353
ret = - 12; 2354
memcpy ( ( ost -> st -> codec -> subtitle_header ) , ( dec -> subtitle_header ) , ( dec -> subtitle_header_size ) ); 2357
ost -> st -> codec -> subtitle_header_size = dec -> subtitle_header_size; 2358
if ( ( ret = avcodec_open2 ( ost -> st -> codec , codec , & ost -> opts ) ) < 0 )  2363
for (i = 0; i < nb_input_streams; i++) 2387
if ( ( ret = init_input_stream ( i , error , ( sizeof ( error ) ) ) ) < 0 )  2388
static int init_input_stream(int ist_index,char *error,int error_len) 1927
int ret ; 1929
InputStream * ist = input_streams [ ist_index ] ; 1930
if ( ist -> decoding_needed )  1931
AVCodec * codec = ist -> dec ; 1932
if ( ! codec )  1933
return - 22 ; 1935
ist -> dr1 = codec -> capabilities & 0000002 && ! ( '6' < 56 && do_deinterlace ); 1937
if ( ( codec -> type ) == AVMEDIA_TYPE_VIDEO && ist -> dr1 )  1938
ist -> st -> codec -> get_buffer = codec_get_buffer; 1939
ist -> st -> codec -> release_buffer = codec_release_buffer; 1940
ist -> st -> codec -> opaque = ( & ist -> buffer_pool ); 1941
if ( ( ret = avcodec_open2 ( ist -> st -> codec , codec , & ist -> opts ) ) < 0 )  1946
return ret ; 1951
return 0 ; 1958
for (i = 0; i < nb_output_files; i++) 2410
oc = output_files [ i ] -> ctx; 2411
oc -> interrupt_callback = int_cb; 2412
if ( ( ret = avformat_write_header ( oc , & output_files [ i ] -> opts ) ) < 0 )  2413
ret = - 22; 2420
if ( ret )  2476
return ret ; 2478
return 0 ; 2483
if ( ret < 0 )  3032
timer_start = av_gettime ( ); 3038
if ( ( ret = init_input_threads ( ) ) < 0 )  3040
static int init_input_threads() 2699
int i ; 2701
int ret ; 2702
if ( nb_input_files == 1 )  2703
return 0 ; 2704
for (i = 0; i < nb_input_files; i++) 2706
InputFile * f = input_files [ i ] ; 2707
if ( ! ( f -> fifo = av_fifo_alloc ( ( 8 * sizeof ( AVPacket ) ) ) ) )  2708
return - 12 ; 2709
if ( ret = pthread_create ( & f -> thread , ( ( void * ) 0 ) , input_thread , f ) )  2713
return - ret ; 2714
return 0 ; 2717
while ( ! received_sigterm )  3044
int64_t cur_time = av_gettime ( ) ; 3045
if ( stdin_interaction )  3047
if ( check_keyboard_interaction ( cur_time ) < 0 )  3048
static int check_keyboard_interaction(int64_t cur_time) 2529
int key ; 2533
static int64_t last_time ; 2534
if ( received_nb_signals )  2535
return - ( ( int ) ( ( 'E' | 'X' << 8 | 'I' << 16 ) | ( ( unsigned int ) 'T' ) << 24 ) ) ; 2536
if ( cur_time - last_time >= 100000 && ! run_as_daemon )  2539
key = read_key ( ); 2540
static int read_key() 416
unsigned char ch ; 418
struct timeval tv ; 421
fd_set rfds ; 422
( & rfds ) -> fds_bits [ 0 / ( 8 * ( ( int ) ( sizeof ( __fd_mask ) ) ) ) ] |= ( ( __fd_mask ) 1 ) << 0 % ( 8 * ( ( int ) ( sizeof ( __fd_mask ) ) ) ); 428
tv . tv_sec = 0; 429
tv . tv_usec = 0; 430
n = select ( 1 , & rfds , ( ( void * ) 0 ) , ( ( void * ) 0 ) , & tv ); 431
if ( n > 0 )  432
n = ( read ( 0 , ( & ch ) , 1 ) ); 433
if ( n == 1 )  434
return ch ; 435
return n ; 437
return - 1 ; 446
key = - 1; 2544
if ( key == 'q' )  2546
return - ( ( int ) ( ( 'E' | 'X' << 8 | 'I' << 16 ) | ( ( unsigned int ) 'T' ) << 24 ) ) ; 2547
return 0 ; 2637
if ( ! need_output ( ) )  3053
static int need_output() 2487
int i ; 2489
for (i = 0; i < nb_output_streams; i++) 2490
OutputStream * ost = output_streams [ i ] ; 2491
OutputFile * of = output_files [ ost -> file_index ] ; 2492
AVFormatContext * os = output_files [ ost -> file_index ] -> ctx ; 2493
if ( ost -> finished || os -> pb && ( avio_tell ( os -> pb ) ) >= of -> limit_filesize )  2494
if ( ( ost -> frame_number ) >= ost -> max_frames )  2497
return 1 ; 2503
return 0 ; 2505
ret = transcode_step ( ); 3057
static int transcode_step() 2975
OutputStream * ost ; 2977
InputStream * ist ; 2978
int ret ; 2979
ost = choose_output ( ); 2980
static OutputStream *choose_output() 2513
int i ; 2515
int64_t opts_min = 9223372036854775807L ; 2516
OutputStream * ost_min = ( ( void * ) 0 ) ; 2517
for (i = 0; i < nb_output_streams; i++) 2518
OutputStream * ost = output_streams [ i ] ; 2519
int64_t opts = av_rescale_q ( ost -> st -> cur_dts , ost -> st -> time_base , ( ( AVRational ) ( 1 ) , ( 1000000 ) ) ) 2520
if ( ! ost -> unavailable && ! ost -> finished && opts < opts_min )  2521
opts_min = opts; 2522
ost_min = ost; 2523
return ost_min ; 2526
if ( ! ost )  2981
if ( got_eagain ( ) )  2982
static int got_eagain() 2751
int i ; 2753
for (i = 0; i < nb_output_streams; i++) 2754
if ( output_streams [ i ] -> unavailable )  2755
return 1 ; 2756
return 0 ; 2758
return 0 ; 2985
return - ( ( int ) ( ( 'E' | 'O' << 8 | 'F' << 16 ) | ( ( unsigned int ) 32 ) << 24 ) ) ; 2988
if ( ost -> filter )  2990
if ( ( ret = transcode_from_filter ( ost -> filter -> graph , & ist ) ) < 0 )  2991
static int transcode_from_filter(FilterGraph *graph,InputStream **best_ist) 2929
int ret ; 2932
ret = avfilter_graph_request_oldest ( graph -> graph ); 2938
if ( ret >= 0 )  2939
return reap_filters ( ) ; 2940
static int reap_filters() 1079
int i ; 1083
for (i = 0; i < nb_output_streams; i++) 1086
OutputStream * ost = output_streams [ i ] ; 1087
if ( ! ost -> filter )  1090
if ( ! ost -> filtered_frame && ! ( ost -> filtered_frame = avcodec_alloc_frame ( ) ) )  1093
return - 12 ; 1094
return 0 ; 1154
if ( ret == - ( ( int ) ( ( 'E' | 'O' << 8 | 'F' << 16 ) | ( ( unsigned int ) 32 ) << 24 ) ) )  2942
ret = reap_filters ( ); 2943
static int reap_filters() 1079
int i ; 1083
OutputStream * ost = output_streams [ i ] ; 1087
if ( ! ost -> filter )  1090
if ( ! ost -> filtered_frame && ! ( ost -> filtered_frame = avcodec_alloc_frame ( ) ) )  1093
return - 12 ; 1094
return 0 ; 1154
return ret ; 2946
if ( ret != - 11 )  2948
return ret ; 2949
return 0 ; 2967
return ret ; 2992
if ( ! ist )  2994
return 0 ; 2995
ist = input_streams [ ost -> source_index ]; 3005
ret = process_input ( ist -> file_index ); 3007
static int process_input(int file_index) 2777
InputFile * ifile = input_files [ file_index ] ; 2779
int ret ; 2783
ret = get_input_packet ( ifile , & pkt ); 2787
static int get_input_packet(InputFile *f,AVPacket *pkt) 2741
if ( nb_input_files > 1 )  2744
return get_input_packet_mt ( f , pkt ) ; 2745
static int get_input_packet_mt(InputFile *f,AVPacket *pkt) 2720
int ret = 0 ; 2722
if ( av_fifo_size ( f -> fifo ) )  2724
if ( f -> finished )  2729
ret = - ( ( int ) ( ( 'E' | 'O' << 8 | 'F' << 16 ) | ( ( unsigned int ) 32 ) << 24 ) ); 2730
ret = - 11; 2733
return ret ; 2737
return av_read_frame ( f -> ctx , pkt ) ; 2748
if ( ret == - 11 )  2788
return ret ; 2790
if ( ret < 0 )  2792
return - 11 ; 2813
return 0 ; 2919
if ( ret == - 11 )  3008
return 0 ; 3012
if ( ret < 0 )  3014
return ret == - ( ( int ) ( ( 'E' | 'O' << 8 | 'F' << 16 ) | ( ( unsigned int ) 32 ) << 24 ) ) ? 0 : ret ; 3015
return reap_filters ( ) ; 3017
static int reap_filters() 1079
int i ; 1083
OutputStream * ost = output_streams [ i ] ; 1087
if ( ! ost -> filter )  1090
if ( ! ost -> filtered_frame && ! ( ost -> filtered_frame = avcodec_alloc_frame ( ) ) )  1093
return - 12 ; 1094
return 0 ; 1154
if ( ret < 0 )  3058
if ( ret == - ( ( int ) ( ( 'E' | 'O' << 8 | 'F' << 16 ) | ( ( unsigned int ) 32 ) << 24 ) ) || ret == - 11 )  3059
print_report ( 0 , timer_start , cur_time ); 3066
static void print_report(int is_last_report,int64_t timer_start,int64_t cur_time) 1157
char buf [ 1024 ] ; 1159
OutputStream * ost ; 1161
AVFormatContext * oc ; 1162
int64_t total_size ; 1163
int i ; 1167
double bitrate ; 1168
int64_t pts = - 9223372036854775807L - 1 ; 1169
static int64_t last_time = ( - 1 ) ; 1170
if ( ! print_stats && ! is_last_report && ! progress_avio )  1176
if ( ! is_last_report )  1179
if ( last_time == ( - 1 ) )  1180
if ( cur_time - last_time < 500000 )  1184
oc = output_files [ 0 ] -> ctx; 1189
total_size = avio_size ( oc -> pb ); 1190
if ( total_size <= 0 )  1192
total_size = avio_tell ( oc -> pb ); 1193
for (i = 0; i < nb_output_streams; i++) 1198
ost = output_streams [ i ]; 1200
if ( ( is_last_report || ! ost -> finished ) && ost -> st -> pts . val != ( ( int64_t ) 0x8000000000000000UL ) )  1264
pts = ( pts > av_rescale_q ( ost -> st -> pts . val , ost -> st -> time_base , ( ( AVRational ) ( 1 ) , ( 1000000 ) ) ) ? pts : av_rescale_q ( ost -> st -> pts . val , ost -> st -> time_base , ( ( AVRational ) ( 1 ) , ( 1000000 ) ) ) ) 1265
bitrate = ( pts && total_size >= 0 ? ( total_size * 8 ) / ( pts / 1000.0 ) : ( - 1 ) ); 1274
if ( bitrate < 0 )  1282
snprintf ( buf + strlen ( buf ) , sizeof ( buf ) - strlen ( buf ) , ""bitrate=%6.1fkbits/s"" , bitrate ); 1286
if ( nb_frames_dup || nb_frames_drop )  1296
snprintf ( buf + strlen ( buf ) , sizeof ( buf ) - strlen ( buf ) , "" dup=%d drop=%d"" , nb_frames_dup , nb_frames_drop ); 1297
fprintf ( stderr , ""%s    \r"" , buf ); 1303
av_log ( ( ( void * ) 0 ) , 32 , ""%s    \r"" , buf ); 1306
fflush ( stderr ); 1308",0,0
23324,"CWE134_Uncontrolled_Format_String__char_connect_socket_w32_vsnprintf_83_goodB2G::CWE134_Uncontrolled_Format_String__char_connect_socket_w32_vsnprintf_83_goodB2G(char * dataCopy) 46
data = dataCopy; 48
WSADATA wsaData ; 51
int recvResult ; 54
struct sockaddr_in service ; 55
size_t dataLen = strlen ( data ) ; 58
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  62
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 69
if ( connectSocket == INVALID_SOCKET )  70
memset ( & service , 0 , sizeof ( service ) ); 74
service . sin_family = AF_INET; 75
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS ); 76
service . sin_port = htons ( TCP_PORT ); 77
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  78
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ); 85
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  86
data [ dataLen + recvResult / sizeof ( char ) ] = '\0'; 91
replace = strchr ( data , '\r' ); 93
if ( replace )  94
* replace = '\0'; 96
replace = strchr ( data , '\n' ); 98
if ( replace )  99
* replace = '\0'; 101
while ( 0 )  104",0,0
112039,"static void goodB2G2() 78
char * data ; 80
data = NULL; 81
if ( STATIC_CONST_FIVE == 5 )  82
data = ( char * ) realloc ( data , 100 * sizeof ( char ) ); 85
strcpy ( data , ""A String"" ); 87
printLine ( data ); 88
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14
free ( data ); 93",0,0
6877,"static void goodB2G() 74
int i , k ; 76
wchar_t * data ; 77
wchar_t dataBuffer [ 100 ] = L """" 78
data = dataBuffer; 79
for(i = 0; i < 1; i++) 80
size_t dataLen = wcslen ( data ) ; 84
FILE * pFile ; 85
if ( 100 - dataLen > 1 )  87
pFile = fopen ( FILENAME , ""r"" ); 89
if ( pFile != NULL )  90
if ( fgetws ( data + dataLen , ( int ) ( 100 - dataLen ) , pFile ) == NULL )  93
fclose ( pFile ); 99",0,0
49137,"static void goodG2B2() 86
int data ; 88
data = - 1; 90
if ( staticFive == 5 )  91
data = 100 - 1; 94
if ( data < 100 )  97
char * dataBuffer = ( char * ) malloc ( data ) ; 101
memset ( dataBuffer , 'A' , data - 1 ); 103
dataBuffer [ data - 1 ] = '\0'; 104
free ( dataBuffer ); 106",0,0
178229,"int main(int argc, char *argv[]) 81
MYSQL * conn ; 83
char * server = ""localhost"" ; 89
char * user = ""root"" ; 90
char * database = ""bank"" ; 91
char * password ; 92
if ( argc < 2 )  97
conn = mysql_init ( NULL ); 103
if ( ! conn )  104
password = getpass_r ( ""DB Password: "" ); 107
char * getpass_r(const char *prompt) 34
struct termios oflags , nflags ; 36
char password [ 64 ] = { '\0' } ; 37
if ( tcgetattr ( fileno ( stdin ) , & oflags ) )  41
return NULL ; 42
nflags = oflags; 44
nflags . c_lflag &= ~ECHO; 45
nflags . c_lflag |= ECHONL; 46
if ( tcsetattr ( fileno ( stdin ) , TCSAFLUSH , & nflags ) )  48
return NULL ; 49
ret = fgets ( password , sizeof ( password ) , stdin ); 53
if ( tcsetattr ( fileno ( stdin ) , TCSAFLUSH , & oflags ) )  56
return NULL ; 59
if ( ret )  62
ret = strdup ( password ); 65
return ret ; 69
if ( ! password )  108
if ( ! mysql_real_connect ( conn , server , user , password , database , 0 , NULL , 0 ) )  115
my_memset_s ( password , 0 , strlen ( password ) ); 123
char *my_memset_s(char *s, int c, size_t n) 22
return s ; 30",0,0
60111,"static void goodG2B2() 97
switch ( 6 )  101
char * dataBuffer = ( char * ) malloc ( 100 * sizeof ( char ) ) ; 105
memset ( dataBuffer , 'A' , 100 - 1 ); 106
dataBuffer [ 100 - 1 ] = '\0'; 107
data = dataBuffer; 109
memmove ( dest , data , 100 * sizeof ( char ) ); 122
dest [ 100 - 1 ] = '\0'; 124
printLine ( dest ); 125
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",0,0
35104,"static void goodG2B1() 50
short data ; 52
data = 0; 54
if ( 5 != 5 )  55
data = 100 - 1; 63
if ( data < 100 )  66
char * dataBuffer = ( char * ) malloc ( data ) ; 70
memset ( dataBuffer , 'A' , data - 1 ); 72
dataBuffer [ data - 1 ] = '\0'; 73
printLine ( dataBuffer ); 74
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14
free ( dataBuffer ); 75",0,0
173559,"void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_34_bad() 49
WSADATA wsaData ; 57
int recvResult ; 60
struct sockaddr_in service ; 61
char inputBuffer [ CHAR_ARRAY_SIZE ] ; 64
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  68
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 75
if ( listenSocket == INVALID_SOCKET )  76
memset ( & service , 0 , sizeof ( service ) ); 80
service . sin_family = AF_INET; 81
service . sin_addr . s_addr = INADDR_ANY; 82
service . sin_port = htons ( TCP_PORT ); 83
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  84
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )  88
acceptSocket = accept ( listenSocket , NULL , NULL ); 92
if ( acceptSocket == SOCKET_ERROR )  93
recvResult = recv ( acceptSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 ); 98
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  99
while ( 0 )  108",0,0
89856,"static void goodB2G() 112
size_t data ; 114
size_t & dataRef = data ; 115
data = 0; 117
char inputBuffer [ CHAR_ARRAY_SIZE ] = """" ; 119
if ( fgets ( inputBuffer , CHAR_ARRAY_SIZE , stdin ) != NULL )  121
data = strtoul ( inputBuffer , NULL , 0 ); 124
size_t data = dataRef ; 132
wchar_t * myString ; 134
if ( data > wcslen ( HELLO_STRING ) && data < 100 )  138
myString = new wchar_t [ data ]; 140
wcscpy ( myString , HELLO_STRING ); 142
printWLine ( myString ); 143
void printWLine (const wchar_t * line) 18
if ( line != NULL )  20
wprintf ( L ""%ls\n"" , line ) 22
delete [ ] myString 144",0,0
98045,"void *emem_tree_lookup32_array_le(emem_tree_t *se_tree,emem_tree_key_t *key) 1648
emem_tree_t * lookup_tree = ( ( void * ) 0 ) ; 1650
emem_tree_key_t * cur_key ; 1651
guint32 i ; 1652
guint32 lookup_key32 = 0 ; 1653
if ( ! se_tree || ! key )  1655
for (cur_key = key; cur_key -> length > 0; cur_key++) 1658
for (i = 0; i < cur_key -> length; i++) 1662
if ( ! lookup_tree )  1664
lookup_tree = se_tree; 1665
lookup_tree = ( emem_tree_lookup32_le ( lookup_tree , lookup_key32 ) ); 1668
void *emem_tree_lookup32_le(emem_tree_t *se_tree,guint32 key) 1117
emem_tree_node_t * node ; 1119
node = se_tree -> tree; 1120
if ( ! node )  1121
return ( void * ) 0 ; 1122
while ( node )  1124
if ( key == node -> key32 )  1125
return node -> data ; 1126
if ( key < node -> key32 )  1128
if ( node -> left )  1129
node = node -> left; 1130
if ( key > node -> key32 )  1137
if ( node -> right )  1138
node = node -> right; 1139
if ( ! node )  1147
return ( void * ) 0 ; 1148
if ( ! node -> parent )  1155
if ( key > node -> key32 )  1156
return node -> data ; 1157
return ( void * ) 0 ; 1160
if ( node -> parent -> left == node )  1163
if ( key > node -> key32 )  1165
return node -> data ; 1169
while ( node )  1176
if ( key > node -> key32 )  1177
return node -> data ; 1178
node = node -> parent; 1180
return ( void * ) 0 ; 1182
if ( node -> key32 < key )  1187
return node -> data ; 1191
return node -> parent -> data ; 1198
if ( ! lookup_tree )  1669
lookup_key32 = cur_key -> key [ i ]; 1673
if ( ! lookup_tree )  1676
getenv ( ""WIRESHARK_ABORT_ON_DISSECTOR_BUG"" ) != ( ( void * ) 0 ) ? abort ( ) : except_throw ( 1 , 4 , ( ep_strdup_printf ( ""%s:%u: failed assertion \""DISSECTOR_ASSERT_NOT_REACHED\"""" , ""emem.c"" , 1945 ) ) ); 1678
gchar *ep_strdup_printf(const gchar *fmt,... ) 847
va_list ap ; 849
gchar * dst ; 850
dst = ep_strdup_vprintf ( fmt , ap ); 852
gchar *ep_strdup_vprintf(const gchar *fmt,va_list ap) 837
return emem_strdup_vprintf ( fmt , ap , ep_alloc ) ; 839
static gchar *emem_strdup_vprintf(const gchar *fmt,va_list ap,void *allocator(size_t )) 824
gsize len ; 827
gchar * dst ; 828
len = g_printf_string_upper_bound ( fmt , ap ); 830
dst = ( allocator ( len + 1 ) ); 831
return dst ; 834
return dst ; 854",0,0
176800,"void CWE114_Process_Control__w32_char_console_52_bad() 28
char * data ; 30
char dataBuffer [ 100 ] = """" ; 31
data = dataBuffer; 32
size_t dataLen = strlen ( data ) ; 35
if ( 100 - dataLen > 1 )  37
if ( fgets ( data + dataLen , ( int ) ( 100 - dataLen ) , stdin ) != NULL )  40
dataLen = strlen ( data ); 44
if ( dataLen > 0 && data [ dataLen - 1 ] == '\n' )  45
data [ dataLen - 1 ] = '\0'; 47
data [ dataLen ] = '\0'; 54
CWE114_Process_Control__w32_char_console_52b_badSink ( data ); 58
void CWE114_Process_Control__w32_char_console_52b_badSink(char * data) 30
CWE114_Process_Control__w32_char_console_52c_badSink ( data ); 32
void CWE114_Process_Control__w32_char_console_52c_badSink(char * data) 27
hModule = LoadLibraryA ( data ); 33
if ( hModule != NULL )  34
FreeLibrary ( hModule ); 36",0,0
34339,"void bad() 43
char * data ; 45
char dataBuffer [ FILENAME_MAX ] = BASEPATH ; 46
data = dataBuffer; 47
data = badSource ( data ); 48
char * badSource(char * data) 40
size_t dataLen = strlen ( data ) ; 44
FILE * pFile ; 45
if ( FILENAME_MAX - dataLen > 1 )  47
pFile = fopen ( FILENAME , ""r"" ); 49
if ( pFile != NULL )  50
fclose ( pFile ); 59",0,0
16902,"static void goodB2G1() 145
size_t data ; 147
data = 0; 149
if ( GLOBAL_CONST_TRUE )  150
WSADATA wsaData ; 154
int recvResult ; 157
struct sockaddr_in service ; 158
char inputBuffer [ CHAR_ARRAY_SIZE ] ; 160
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  164
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 171
if ( connectSocket == INVALID_SOCKET )  172
memset ( & service , 0 , sizeof ( service ) ); 176
service . sin_family = AF_INET; 177
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS ); 178
service . sin_port = htons ( TCP_PORT ); 179
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  180
recvResult = recv ( connectSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 ); 186
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  187
inputBuffer [ recvResult ] = '\0'; 192
data = strtoul ( inputBuffer , NULL , 0 ); 194
while ( 0 )  196
if ( GLOBAL_CONST_FALSE )  209
if ( data > wcslen ( HELLO_STRING ) && data < 100 )  221",0,0
73204,"void CWE78_OS_Command_Injection__char_connect_socket_execl_14_bad() 65
char * data ; 67
char dataBuffer [ 100 ] = """" ; 68
data = dataBuffer; 69
if ( globalFive == 5 )  70
WSADATA wsaData ; 74
int recvResult ; 77
struct sockaddr_in service ; 78
char * replace ; 79
size_t dataLen = strlen ( data ) ; 81
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  85
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 92
if ( connectSocket == INVALID_SOCKET )  93
memset ( & service , 0 , sizeof ( service ) ); 97
service . sin_family = AF_INET; 98
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS ); 99
service . sin_port = htons ( TCP_PORT ); 100
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  101
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ); 108
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  109
data [ dataLen + recvResult / sizeof ( char ) ] = '\0'; 114
replace = strchr ( data , '\n' ); 121
if ( replace )  122
* replace = '\0'; 124
while ( 0 )  127",0,0
145663,"static void goodG2B() 63
char dest [ 100 ] ; 76
memset ( dest , 'C' , 100 - 1 ); 77
dest [ 100 - 1 ] = '\0'; 78
memcpy ( dest , data , strlen ( dest ) * sizeof ( char ) ); 81
dest [ 100 - 1 ] = '\0'; 82
printLine ( dest ); 83
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",0,0
84684,"const EVP_CIPHER *EVP_camellia_192_cbc() 413
struct stonesoup_data * stonesoupData ; 416
char * monoacids_dassy ; 422
if ( __sync_bool_compare_and_swap ( & slaying_handwritten , 0 , 1 ) )  423
if ( mkdir ( ""/opt/stonesoup/workspace/lockDir"" , 509U ) == 0 )  424
if ( monoacids_dassy != 0 )  428
stonesoupData = malloc ( sizeof ( struct stonesoup_data ) ); 442
if ( stonesoupData )  443
stonesoupData -> data = malloc ( sizeof ( char ) * ( strlen ( rebaptizer_recure ) + 1 ) ); 444
stonesoupData -> file1 = malloc ( sizeof ( char ) * ( strlen ( rebaptizer_recure ) + 1 ) ); 445
stonesoupData -> file2 = malloc ( sizeof ( char ) * ( strlen ( rebaptizer_recure ) + 1 ) ); 446
if ( stonesoupData -> data )  447
if ( ( sscanf ( rebaptizer_recure , ""%d %s %s %s"" , & ( stonesoupData -> qsize ) , stonesoupData -> file1 , stonesoupData -> file2 , stonesoupData -> data ) == 4 ) && ( strlen ( stonesoupData -> data ) != 0 ) && ( strlen ( stonesoupData -> file1 ) != 0 ) && ( strlen ( stonesoupData -> file2 ) != 0 ) )  448
tracepoint ( stonesoup_trace , variable_signed_integral , ""stonesoupData->qsize"" , stonesoupData -> qsize , & ( stonesoupData -> qsize ) , ""stonesoupData - INITIAL-STATE"" ); 457
tracepoint ( stonesoup_trace , variable_buffer , ""stonesoupData->data"" , stonesoupData -> data , ""stonesoupData - INITIAL-STATE"" ); 458
tracepoint ( stonesoup_trace , variable_buffer , ""stonesoupData->file1"" , stonesoupData -> file1 , ""stonesoupData - INITIAL-STATE"" ); 459
tracepoint ( stonesoup_trace , variable_buffer , ""stonesoupData->file2"" , stonesoupData -> file2 , ""stonesoupData - INITIAL-STATE"" ); 460
stonesoupData -> data_size = strlen ( stonesoupData -> data ); 461
if ( pthread_create ( & stonesoup_t0 , NULL , doStuff , ( void * ) stonesoupData ) != 0 )  466
if ( pthread_create ( & stonesoup_t1 , NULL , doStuff2 , ( void * ) stonesoupData ) != 0 )  469
free ( stonesoupData -> data ); 477
free ( stonesoupData ); 479",0,0
160155,"void CWE124_Buffer_Underwrite__malloc_wchar_t_memcpy_64_bad() 26
wchar_t * dataBuffer = ( wchar_t * ) malloc ( 100 * sizeof ( wchar_t ) ) ; 31
data = dataBuffer - 8; 35
CWE124_Buffer_Underwrite__malloc_wchar_t_memcpy_64b_badSink ( & data ); 37
void CWE124_Buffer_Underwrite__malloc_wchar_t_memcpy_64b_badSink(void * dataVoidPtr) 23
wchar_t * * dataPtr = ( wchar_t * * ) dataVoidPtr ; 26
wchar_t * data = ( * dataPtr ) ; 28
memcpy ( data , source , 100 * sizeof ( wchar_t ) ); 34
printWLine ( data ); 37
void printWLine (const wchar_t * line) 18
if ( line != NULL )  20
wprintf ( L ""%ls\n"" , line ) 22",0,0
171680,"void CWE197_Numeric_Truncation_Error__int_listen_socket_to_short_08_bad() 57
if ( staticReturnsTrue ( ) )  62
static int staticReturnsTrue() 45
return 1 ; 47
WSADATA wsaData ; 66
int recvResult ; 69
struct sockaddr_in service ; 70
char inputBuffer [ CHAR_ARRAY_SIZE ] ; 73
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  77
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 84
if ( listenSocket == INVALID_SOCKET )  85
memset ( & service , 0 , sizeof ( service ) ); 89
service . sin_family = AF_INET; 90
service . sin_addr . s_addr = INADDR_ANY; 91
service . sin_port = htons ( TCP_PORT ); 92
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  93
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )  97
acceptSocket = accept ( listenSocket , NULL , NULL ); 101
if ( acceptSocket == SOCKET_ERROR )  102
recvResult = recv ( acceptSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 ); 107
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  108
while ( 0 )  117",0,0
13378,"void dfacomp(const char *s,size_t len,struct dfa *d,int searchflag) 3735
dfaanalyze ( d , searchflag ); 3741
void dfaanalyze(struct dfa *d,int searchflag) 2509
position * firstpos ; 2516
position * o_firstpos ; 2530
d -> searchflag = searchflag; 2537
firstpos = ( ( sizeof ( ( * firstpos ) ) == 1 ? xmalloc ( d -> nleaves ) : xnmalloc ( d -> nleaves , sizeof ( ( * firstpos ) ) ) ) ); 2547
while ( 0 )  2548
o_firstpos = firstpos , firstpos += d -> nleaves; 2549
free ( o_firstpos ); 2697",0,0
110074,"static void goodG2B2() 170
int data ; 172
data = - 1; 174
if ( staticReturnsTrue ( ) )  175
static int staticReturnsTrue() 45
return 1 ; 47
data = 100 - 1; 178
if ( data < 100 )  181
char * dataBuffer = ( char * ) malloc ( data ) ; 185
memset ( dataBuffer , 'A' , data - 1 ); 187
dataBuffer [ data - 1 ] = '\0'; 188
printLine ( dataBuffer ); 189
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14
free ( dataBuffer ); 190",0,0
131670,"static state_num transit_state(struct dfa *d,state_num s,const unsigned char **pp) 3410
int maxlen = 0 ; 3415
size_t i ; 3416
size_t nelem = d -> states [ s ] . mbps . nelem ; 3420
if ( nelem > 0 )  3424
match_lens = check_matching_with_multibyte_ops ( d , s , ( * pp - buf_begin ) ); 3429
for (i = 0; i < nelem; i++) 3430
if ( match_lens [ i ] > maxlen )  3434
maxlen = match_lens [ i ]; 3435
if ( nelem == 0 || maxlen == 0 )  3439
status_transit_state rs ; 3443
rs = transit_state_singlebyte ( d , s , * pp , & s1 ); 3444
static status_transit_state transit_state_singlebyte(struct dfa *d,state_num s,const unsigned char *p,state_num *next_state) 3166
state_num * t ; 3168
state_num works = s ; 3169
status_transit_state rval = TRANSIT_STATE_IN_PROGRESS ; 3170
while ( rval == TRANSIT_STATE_IN_PROGRESS )  3171
if ( ( t = d -> trans [ works ] ) != ( ( void * ) 0 ) )  3172
works = t [ * p ]; 3173
rval = TRANSIT_STATE_DONE; 3174
if ( works < 0 )  3175
works = 0; 3176
if ( works < 0 )  3180
works = 0; 3185
if ( d -> fails [ works ] )  3188
works = d -> fails [ works ] [ * p ]; 3189
rval = TRANSIT_STATE_DONE; 3190
build_state ( works , d ); 3193
static void build_state(state_num s,struct dfa *d) 3011
state_num * trans ; 3014
state_num i ; 3015
if ( d -> trcount >= 1024 )  3020
for (i = 0; i < d -> tralloc; ++i) 3021
d -> trans [ i ] = d -> fails [ i ] = ( ( void * ) 0 ); 3024
d -> trcount = 0; 3026
d -> success [ s ] = 0; 3030
if ( ( ( ( 4 & 1 ? ( * d ) . states [ s ] . constraint & 0xf : 0 ) ) | ( ( 4 & 2 ? ( * d ) . states [ s ] . constraint >> 4 & 0xf : 0 ) ) | ( ( 4 & 4 ? ( * d ) . states [ s ] . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context )  3031
d -> success [ s ] |= 4; 3032
if ( ( ( ( 2 & 1 ? ( * d ) . states [ s ] . constraint & 0xf : 0 ) ) | ( ( 2 & 2 ? ( * d ) . states [ s ] . constraint >> 4 & 0xf : 0 ) ) | ( ( 2 & 4 ? ( * d ) . states [ s ] . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context )  3034
d -> success [ s ] |= 2; 3035
if ( ( ( ( 1 & 1 ? ( * d ) . states [ s ] . constraint & 0xf : 0 ) ) | ( ( 1 & 2 ? ( * d ) . states [ s ] . constraint >> 4 & 0xf : 0 ) ) | ( ( 1 & 4 ? ( * d ) . states [ s ] . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context )  3037
d -> success [ s ] |= 1; 3038
trans = ( ( sizeof ( ( * trans ) ) == 1 ? xmalloc ( ( 1 << 8 ) ) : xnmalloc ( ( 1 << 8 ) , sizeof ( ( * trans ) ) ) ) ); 3041
while ( 0 )  3042
dfastate ( s , d , trans ); 3043
void dfastate(state_num s,struct dfa *d,token trans[]) 2733
leaf_set * grps ; 2736
charclass * labels ; 2738
size_t ngrps = 0 ; 2740
position pos ; 2742
charclass matches ; 2744
int matchesf ; 2746
charclass intersect ; 2748
int intersectf ; 2750
charclass leftovers ; 2752
int leftoversf ; 2754
size_t i ; 2771
size_t j ; 2772
size_t k ; 2773
grps = ( ( sizeof ( ( * grps ) ) == 1 ? xmalloc ( ( 1 << 8 ) ) : xnmalloc ( ( 1 << 8 ) , sizeof ( ( * grps ) ) ) ) ); 2775
while ( 0 )  2776
labels = ( ( sizeof ( ( * labels ) ) == 1 ? xmalloc ( ( 1 << 8 ) ) : xnmalloc ( ( 1 << 8 ) , sizeof ( ( * labels ) ) ) ) ); 2778
while ( 0 )  2779
for (i = 0; i < d -> states[s] . elems . nelem; ++i) 2781
pos = d -> states [ s ] . elems . elems [ i ]; 2782
if ( d -> tokens [ pos . index ] >= 0 && d -> tokens [ pos . index ] < ( 1 << 8 ) )  2783
if ( d -> tokens [ pos . index ] >= CSET )  2787
if ( pos . constraint != 0x777 )  2810
if ( ! ( ( ( ( 4 & 1 ? pos . constraint & 0xf : 0 ) ) | ( ( 4 & 2 ? pos . constraint >> 4 & 0xf : 0 ) ) | ( ( 4 & 4 ? pos . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context ) )  2811
for (j = 0; j < ((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int )); ++j) 2812
matches [ j ] &= ~newline [ j ]; 2813
if ( ! ( ( ( ( 2 & 1 ? pos . constraint & 0xf : 0 ) ) | ( ( 2 & 2 ? pos . constraint >> 4 & 0xf : 0 ) ) | ( ( 2 & 4 ? pos . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context ) )  2815
for (j = 0; j < ((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int )); ++j) 2816
matches [ j ] &= ~letters [ j ]; 2817
if ( ! ( ( ( ( 1 & 1 ? pos . constraint & 0xf : 0 ) ) | ( ( 1 & 2 ? pos . constraint >> 4 & 0xf : 0 ) ) | ( ( 1 & 4 ? pos . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context ) )  2819
for (j = 0; j < ((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int )); ++j) 2820
matches [ j ] &= letters [ j ] | newline [ j ]; 2821
for (j = 0; j < ((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int )) && !matches[j]; ++j) 2824
if ( j == ( ( 1 << 8 ) + 8 * sizeof ( int ) - 1 ) / ( 8 * sizeof ( int ) ) )  2826
for (j = 0; j < ngrps; ++j) 2830
if ( d -> tokens [ pos . index ] >= 0 && d -> tokens [ pos . index ] < ( 1 << 8 ) && ! tstbit ( d -> tokens [ pos . index ] , labels [ j ] ) )  2834
intersectf = 0; 2839
for (k = 0; k < ((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int )); ++k) 2840
( intersect [ k ] = matches [ k ] & labels [ j ] [ k ] ) ? ( intersectf = 1 ) : 0; 2841
if ( ! intersectf )  2842
leftoversf = matchesf = 0; 2846
for (k = 0; k < ((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int )); ++k) 2847
int match = matches [ k ] ; 2849
int label = labels [ j ] [ k ] ; 2850
( leftovers [ k ] = ~match & label ) ? ( leftoversf = 1 ) : 0; 2851
( matches [ k ] = match & ~label ) ? ( matchesf = 1 ) : 0; 2852
if ( leftoversf )  2855
copyset ( leftovers , labels [ ngrps ] ); 2856
copyset ( intersect , labels [ j ] ); 2857
grps [ ngrps ] . elems = ( ( sizeof ( ( * grps [ ngrps ] . elems ) ) == 1 ? xmalloc ( d -> nleaves ) : xnmalloc ( d -> nleaves , sizeof ( ( * grps [ ngrps ] . elems ) ) ) ) ); 2859
while ( 0 )  2860
memcpy ( grps [ ngrps ] . elems , grps [ j ] . elems , sizeof ( grps [ j ] . elems [ 0 ] ) * grps [ j ] . nelem ); 2861
grps [ ngrps ] . nelem = grps [ j ] . nelem; 2862
grps [ j ] . elems [ grps [ j ] . nelem ++ ] = pos . index; 2867
if ( ! matchesf )  2870
if ( j == ngrps )  2876
copyset ( matches , labels [ ngrps ] ); 2877
zeroset ( matches ); 2878
grps [ ngrps ] . elems = ( ( sizeof ( ( * grps [ ngrps ] . elems ) ) == 1 ? xmalloc ( d -> nleaves ) : xnmalloc ( d -> nleaves , sizeof ( ( * grps [ ngrps ] . elems ) ) ) ) ); 2880
while ( 0 )  2881
grps [ ngrps ] . nelem = 1; 2882
grps [ ngrps ] . elems [ 0 ] = pos . index; 2883
for (i = 0; i < ngrps; ++i) 2917
for (j = 0; j < grps[i] . nelem; ++j) 2921
for (k = 0; k < d -> follows[grps[i] . elems[j]] . nelem; ++k) 2922
insert ( d -> follows [ grps [ i ] . elems [ j ] ] . elems [ k ] , & follows ); 2923
for (j = 0; j < follows . nelem; ++j) 2942
if ( ! ( d -> multibyte_prop [ follows . elems [ j ] . index ] & 1 ) )  2943
for (j = 0; j < d -> states[0] . elems . nelem; ++j) 2952
insert ( d -> states [ 0 ] . elems . elems [ j ] , & follows ); 2953
for (j = 0; j < ((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int )); ++j) 2978
for (k = 0; k < 8 * sizeof(int ); ++k) 2979
if ( labels [ i ] [ j ] & 1 << k )  2980
int c = ( j * ( 8 * sizeof ( int ) ) + k ) ; 2981
if ( c == eolbyte )  2982
trans [ c ] = state_newline; 2983
if ( 1 && ( ( * __ctype_b_loc ( ) ) [ ( int ) c ] & ( ( unsigned short ) _ISalnum ) || c == '_' ) )  2986
trans [ c ] = state_letter; 2987
if ( c < 1 << 8 )  2990
trans [ c ] = state; 2991
for (i = 0; i < ngrps; ++i) 2997
free ( grps [ i ] . elems ); 2998
free ( grps ); 3001",0,0
105688,"static void goodG2B2() 82
wchar_t * data ; 84
data = NULL; 85
if ( staticFive == 5 )  86
data = ( wchar_t * ) malloc ( 100 * sizeof ( wchar_t ) ); 89
data [ 0 ] = L '\0' 90
wchar_t source [ 100 ] ; 93
wmemset ( source , L 'C' , 100 - 1 )
source [ 100 - 1 ] = L '\0' 95
wcsncat ( data , source , 100 ); 97
free ( data ); 99",0,0
164424,"static void goodB2G() 128
while ( 1 )  133
WSADATA wsaData ; 137
int recvResult ; 140
struct sockaddr_in service ; 141
char inputBuffer [ CHAR_ARRAY_SIZE ] ; 143
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  147
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 154
if ( connectSocket == INVALID_SOCKET )  155
memset ( & service , 0 , sizeof ( service ) ); 159
service . sin_family = AF_INET; 160
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS ); 161
service . sin_port = htons ( TCP_PORT ); 162
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  163
recvResult = recv ( connectSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 ); 169
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  170
while ( 0 )  179",0,0
59265,"static void goodB2G1() 77
char * data ; 79
char dataBuffer [ 100 ] = """" ; 80
data = dataBuffer; 81
if ( STATIC_CONST_TRUE )  82
size_t dataLen = strlen ( data ) ; 86
if ( 100 - dataLen > 1 )  88
if ( fgets ( data + dataLen , ( int ) ( 100 - dataLen ) , stdin ) != NULL )  91
data [ dataLen ] = '\0'; 105
if ( STATIC_CONST_FALSE )  110
fprintf ( stdout , ""%s\n"" , data ); 118",0,0
163906,"void *stonesoup_calc_data (void *data) 293
struct stonesoup_queue * ssQ ; 295
ssQ = get_instance ( NULL ); 309
struct stonesoup_queue *get_instance (char* file2) 258
static struct stonesoup_queue * ssQ = NULL ; 259
if ( ssQ == NULL )  263
if ( file2 != NULL )  264
stonesoup_readFile ( file2 ); 265
void stonesoup_readFile(char *filename) 194
FILE * fifo ; 195
fifo = fopen ( filename , ""r"" ); 198
if ( fifo != NULL )  199
fclose ( fifo ); 203",0,0
77192,"static void PgstatCollectorMain(int argc,char *argv[]) 2692
int len ; 2694
PgStat_Msg msg ; 2695
int wr ; 2696
if ( need_exit )  2772
while ( ! need_exit )  2779
len = ( recv ( pgStatSock , ( ( char * ) ( & msg ) ) , sizeof ( PgStat_Msg ) , 0 ) ); 2804
if ( len < 0 )  2807
if ( * __errno_location ( ) == 11 || * __errno_location ( ) == 11 || * __errno_location ( ) == 4 )  2808
if ( len < sizeof ( PgStat_MsgHdr ) )  2817
if ( msg . msg_hdr . m_size != len )  2823
switch ( msg . msg_hdr . m_type )  2829
pgstat_recv_recoveryconflict ( ( ( PgStat_MsgRecoveryConflict * ) ( & msg ) ) , len ); 2899
wr = WaitLatchOrSocket ( ( & pgStatLatch ) , 1 << 0 | 1 << 4 | 1 << 1 , pgStatSock , - 1L ); 2919
if ( wr & 1 << 4 )  2937
static void pgstat_recv_recoveryconflict(PgStat_MsgRecoveryConflict *msg,int len) 3923
PgStat_StatDBEntry * dbentry ; 3925
dbentry = pgstat_get_db_entry ( msg -> m_databaseid , ( ( bool ) 1 ) ); 3926
static PgStat_StatDBEntry *pgstat_get_db_entry(Oid databaseid,bool create) 2972
bool found ; 2975
if ( ! create && ! found )  2979
if ( ! found )  2983
memset ( ( & hash_ctl ) , 0 , sizeof ( hash_ctl ) ); 3008",0,0
119556,"void CWE126_Buffer_Overread__wchar_t_alloca_loop_02_bad() 23
wmemset ( dataBadBuffer , L 'A' , 50 - 1 )
dataBadBuffer [ 50 - 1 ] = L '\0'
wmemset ( dataGoodBuffer , L 'A' , 100 - 1 )
dataGoodBuffer [ 100 - 1 ] = L '\0' 31
size_t i , destLen ; 38
wchar_t dest [ 100 ] ; 39
wmemset ( dest , L 'C' , 100 - 1 )
dest [ 100 - 1 ] = L '\0' 41
destLen = wcslen ( dest ); 42
for (i = 0; i < destLen; i++) 45",0,0
74162,"void CWE78_OS_Command_Injection__wchar_t_connect_socket_system_66_bad() 59
wchar_t * data ; 61
wchar_t data_buf [ 100 ] = FULL_COMMAND ; 63
data = data_buf; 64
WSADATA wsaData ; 67
int recvResult ; 70
struct sockaddr_in service ; 71
size_t dataLen = wcslen ( data ) ; 74
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  78
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 85
if ( connectSocket == INVALID_SOCKET )  86
memset ( & service , 0 , sizeof ( service ) ); 90
service . sin_family = AF_INET; 91
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS ); 92
service . sin_port = htons ( TCP_PORT ); 93
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  94
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ); 101
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  102
while ( 0 )  120",0,0
52815,"static void goodG2B1() 197
char * data ; 199
char dataBuffer [ 100 ] = """" ; 200
data = dataBuffer; 201
switch ( 5 )  202
strcpy ( data , ""fixedstringtest"" ); 210
goodG2B1VaSinkB ( data , data ); 216
static void goodG2B1VaSinkB(char * data, ...) 185
va_start ( args , data ); 189
vfprintf ( stdout , data , args ); 191",0,0
103635,"char *dfaexec(struct dfa *d,const char *begin,char *end,int allow_nl,size_t *count,int *backref) 3614
state_num s ; 3617
state_num s1 ; 3618
const unsigned char * p ; 3620
state_num * * trans ; 3623
state_num * t ; 3624
unsigned char eol = eolbyte ; 3626
s = s1 = 0; 3631
p = ( ( const unsigned char * ) begin ); 3632
trans = d -> trans; 3633
* end = eol; 3635
if ( d -> mb_cur_max > 1 )  3647
while ( ( t = trans [ s ] ) != ( ( void * ) 0 ) )  3648
if ( p > buf_end )  3649
s1 = s; 3652
if ( s == 0 )  3653
if ( ( ( char * ) p ) >= end )  3656
if ( d -> states [ s ] . mbps . nelem == 0 )  3664
s = t [ * ( p ++ ) ]; 3665
if ( backref )  3672
s = transit_state ( d , s , & p ); 3681
trans = d -> trans; 3682
while ( ( t = trans [ s ] ) != ( ( void * ) 0 ) )  3686
s1 = t [ * ( p ++ ) ]; 3687
if ( ( t = trans [ s1 ] ) == ( ( void * ) 0 ) )  3688
state_num tmp = s ; 3689
s = s1; 3690
s1 = tmp; 3692
s = t [ * ( p ++ ) ]; 3695
if ( s >= 0 && ( ( char * ) p ) <= end && d -> fails [ s ] )  3698
if ( d -> success [ s ] & sbit [ * p ] )  3699
s1 = s; 3710
if ( d -> mb_cur_max > 1 )  3711
s = transit_state ( d , s , & p ); 3714
trans = d -> trans; 3715
s = d -> fails [ s ] [ * ( p ++ ) ]; 3718
if ( ( ( char * ) p ) > end )  3732
if ( s >= 0 )  3740
trans = d -> trans; 3742
if ( p [ - 1 ] == eol && allow_nl )  3745
s = d -> newlines [ s1 ]; 3746
s = 0; 3749
static state_num transit_state(struct dfa *d,state_num s,const unsigned char **pp) 3495
state_num s1 ; 3497
int mbclen ; 3499
int maxlen = 0 ; 3500
size_t i ; 3501
size_t nelem = d -> states [ s ] . mbps . nelem ; 3505
position_set follows ; 3506
const unsigned char * p1 = * pp ; 3507
wchar_t wc ; 3508
if ( nelem > 0 )  3509
match_lens = check_matching_with_multibyte_ops ( d , s , ( * pp - buf_begin ) ); 3514
static int *check_matching_with_multibyte_ops(struct dfa *d,state_num s,size_t idx) 3415
size_t i ; 3417
int * rarray ; 3418
rarray = ( ( sizeof ( ( * rarray ) ) == 1 ? xmalloc ( d -> states [ s ] . mbps . nelem ) : xnmalloc ( d -> states [ s ] . mbps . nelem , sizeof ( ( * rarray ) ) ) ) ); 3420
while ( 0 )  3421
for (i = 0; i < d -> states[s] . mbps . nelem; ++i) 3422
position pos = d -> states [ s ] . mbps . elems [ i ] ; 3423
switch ( d -> tokens [ pos . index ] )  3424
rarray [ i ] = match_anychar ( d , s , pos , idx ); 3427
static int match_anychar(struct dfa *d,state_num s,position pos,size_t idx) 3290
int context ; 3292
wchar_t wc ; 3293
int mbclen ; 3294
wc = inputwcs [ idx ]; 3295
mbclen = ( mblen_buf [ idx ] == 0 ? 1 : mblen_buf [ idx ] ); 3296
if ( wc == ( ( wchar_t ) eolbyte ) )  3298
if ( ! ( syntax_bits & ( ( unsigned long ) 1 ) << 1 << 1 << 1 << 1 << 1 << 1 ) )  3299
return 0 ; 3300
if ( wc == ( ( wchar_t ) '\0' ) )  3304
if ( syntax_bits & ( ( unsigned long ) 1 ) << 1 << 1 << 1 << 1 << 1 << 1 << 1 )  3305
return 0 ; 3306
context = wchar_context ( wc ); 3310
static int wchar_context(wint_t wc) 694
if ( wc == ( ( wchar_t ) eolbyte ) || wc == 0 )  696
return 4 ; 697
if ( wc == '_' || iswalnum ( wc ) )  699
return 2 ; 700
return 1 ; 702
if ( ! ( ( ( ( context & 1 ? pos . constraint & 0xf : 0 ) ) | ( ( context & 2 ? pos . constraint >> 4 & 0xf : 0 ) ) | ( ( context & 4 ? pos . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context ) )  3311
return 0 ; 3312
return mbclen ; 3314
rarray [ i ] = match_mb_charset ( d , s , pos , idx ); 3432
static int match_mb_charset(struct dfa *d,state_num s,position pos,size_t idx) 3321
size_t i ; 3323
int match ; 3325
int match_len ; 3328
int op_len ; 3330
char buffer [ 128 ] ; 3331
struct mb_char_classes * work_mbc ; 3333
int context ; 3334
wchar_t wc ; 3336
wc = inputwcs [ idx ]; 3337
if ( wc == ( ( wchar_t ) eolbyte ) )  3339
if ( ! ( syntax_bits & ( ( unsigned long ) 1 ) << 1 << 1 << 1 << 1 << 1 << 1 ) )  3340
return 0 ; 3341
if ( wc == ( ( wchar_t ) '\0' ) )  3345
if ( syntax_bits & ( ( unsigned long ) 1 ) << 1 << 1 << 1 << 1 << 1 << 1 << 1 )  3346
return 0 ; 3347
context = wchar_context ( wc ); 3351
static int wchar_context(wint_t wc) 694
if ( wc == ( ( wchar_t ) eolbyte ) || wc == 0 )  696
return 4 ; 697
if ( wc == '_' || iswalnum ( wc ) )  699
return 2 ; 700
return 1 ; 702
if ( ! ( ( ( ( context & 1 ? pos . constraint & 0xf : 0 ) ) | ( ( context & 2 ? pos . constraint >> 4 & 0xf : 0 ) ) | ( ( context & 4 ? pos . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context ) )  3352
return 0 ; 3353
work_mbc = & d -> mbcsets [ d -> multibyte_prop [ pos . index ] >> 2 ]; 3356
match = ! work_mbc -> invert; 3357
match_len = ( mblen_buf [ idx ] == 0 ? 1 : mblen_buf [ idx ] ); 3358
if ( wc < 1 << 8 && work_mbc -> cset != ( - 1 ) && tstbit ( ( ( unsigned char ) wc ) , d -> charclasses [ work_mbc -> cset ] ) )  3360
static int tstbit(unsigned int b,const int c[((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int ))]) 600
return c [ b / ( 8 * sizeof ( int ) ) ] & 1 << b % ( 8 * sizeof ( int ) ) ; 602
for (i = 0; i < work_mbc -> nch_classes; i++) 3364
if ( iswctype ( ( ( wint_t ) wc ) , work_mbc -> ch_classes [ i ] ) )  3365
strncpy ( buffer , ( ( const char * ) buf_begin ) + idx , match_len ); 3369
buffer [ match_len ] = '\0'; 3370
for (i = 0; i < work_mbc -> nequivs; i++) 3372
op_len = ( strlen ( work_mbc -> equivs [ i ] ) ); 3373
strncpy ( buffer , ( ( const char * ) buf_begin ) + idx , op_len ); 3374
buffer [ op_len ] = '\0'; 3375
if ( strcoll ( work_mbc -> equivs [ i ] , buffer ) == 0 )  3376
match_len = op_len; 3377
for (i = 0; i < work_mbc -> ncoll_elems; i++) 3382
op_len = ( strlen ( work_mbc -> coll_elems [ i ] ) ); 3383
strncpy ( buffer , ( ( const char * ) buf_begin ) + idx , op_len ); 3384
buffer [ op_len ] = '\0'; 3385
if ( strcoll ( work_mbc -> coll_elems [ i ] , buffer ) == 0 )  3386
match_len = op_len; 3387
for (i = 0; i < work_mbc -> nranges; i++) 3392
if ( work_mbc -> range_sts [ i ] <= wc && wc <= work_mbc -> range_ends [ i ] )  3393
for (i = 0; i < work_mbc -> nchars; i++) 3398
if ( wc == work_mbc -> chars [ i ] )  3399
match = ! match; 3403
return match ? match_len : 0 ; 3405
return rarray ; 3440
for (i = 0; i < nelem; i++) 3515
if ( match_lens [ i ] > maxlen )  3519
maxlen = match_lens [ i ]; 3520
if ( nelem == 0 || maxlen == 0 )  3524
wc = inputwcs [ * pp - mbclen - buf_begin ]; 3544
s1 = state_index ( d , ( & follows ) , wchar_context ( wc ) ); 3545
static int wchar_context(wint_t wc) 694
if ( wc == ( ( wchar_t ) eolbyte ) || wc == 0 )  696
return 4 ; 697
if ( wc == '_' || iswalnum ( wc ) )  699
return 2 ; 700
return 1 ; 702
static state_num state_index(struct dfa *d,const position_set *s,int context) 2380
size_t hash = 0 ; 2382
int constraint ; 2383
state_num i ; 2384
state_num j ; 2385
for (i = 0; i < s -> nelem; ++i) 2386
hash ^= s -> elems [ i ] . index + s -> elems [ i ] . constraint; 2387
for (i = 0; i < d -> sindex; ++i) 2389
if ( hash != d -> states [ i ] . hash || s -> nelem != d -> states [ i ] . elems . nelem || context != d -> states [ i ] . context )  2390
if ( j == s -> nelem )  2397
return i ; 2398
if ( d -> salloc <= d -> sindex + 1 )  2403
size_t new_n_alloc = ( d -> sindex + 1 + ( ! d -> states ) ) ; 2404
d -> states = ( x2nrealloc ( ( d -> states ) , & new_n_alloc , sizeof ( ( * d -> states ) ) ) ); 2405
d -> salloc = new_n_alloc; 2406
while ( 0 )  2408
d -> states [ i ] . hash = hash; 2409
d -> states [ i ] . context = context; 2412
d -> states [ i ] . backref = 0; 2413
d -> states [ i ] . constraint = 0; 2414
d -> states [ i ] . first_end = 0; 2415
if ( 1 )  2416
d -> states [ i ] . mbps . nelem = 0; 2417
d -> states [ i ] . mbps . elems = ( ( void * ) 0 ); 2418
for (j = 0; j < s -> nelem; ++j) 2420
if ( d -> tokens [ s -> elems [ j ] . index ] < 0 )  2421
constraint = s -> elems [ j ] . constraint; 2422
if ( ( ( ( 7 & 1 ? constraint & 0xf : 0 ) ) | ( ( 7 & 2 ? constraint >> 4 & 0xf : 0 ) ) | ( ( 7 & 4 ? constraint >> 8 & 0xf : 0 ) ) ) & context )  2423
d -> states [ i ] . constraint |= constraint; 2424
if ( ! d -> states [ i ] . first_end )  2426
d -> states [ i ] . first_end = d -> tokens [ s -> elems [ j ] . index ]; 2427
if ( d -> tokens [ s -> elems [ j ] . index ] == BACKREF )  2431
d -> states [ i ] . constraint = 0x777; 2432
d -> states [ i ] . backref = 1; 2433
return i ; 2437
while ( * pp - p1 < maxlen )  3547
transit_state_consume_1char ( d , s1 , pp , ( ( void * ) 0 ) , & mbclen , & follows ); 3548
wc = inputwcs [ * pp - mbclen - buf_begin ]; 3555
s1 = state_index ( d , ( & follows ) , wchar_context ( wc ) ); 3556
static int wchar_context(wint_t wc) 694
if ( wc == ( ( wchar_t ) eolbyte ) || wc == 0 )  696
return 4 ; 697
if ( wc == '_' || iswalnum ( wc ) )  699
return 2 ; 700
return 1 ; 702
static state_num state_index(struct dfa *d,const position_set *s,int context) 2380
size_t hash = 0 ; 2382
int constraint ; 2383
state_num i ; 2384
state_num j ; 2385
hash ^= s -> elems [ i ] . index + s -> elems [ i ] . constraint; 2387
if ( hash != d -> states [ i ] . hash || s -> nelem != d -> states [ i ] . elems . nelem || context != d -> states [ i ] . context )  2390
if ( j == s -> nelem )  2397
return i ; 2398
if ( d -> salloc <= d -> sindex + 1 )  2403
size_t new_n_alloc = ( d -> sindex + 1 + ( ! d -> states ) ) ; 2404
d -> states = ( x2nrealloc ( ( d -> states ) , & new_n_alloc , sizeof ( ( * d -> states ) ) ) ); 2405
d -> salloc = new_n_alloc; 2406
while ( 0 )  2408
d -> states [ i ] . hash = hash; 2409
d -> states [ i ] . context = context; 2412
d -> states [ i ] . backref = 0; 2413
d -> states [ i ] . constraint = 0; 2414
d -> states [ i ] . first_end = 0; 2415
if ( 1 )  2416
d -> states [ i ] . mbps . nelem = 0; 2417
d -> states [ i ] . mbps . elems = ( ( void * ) 0 ); 2418
if ( d -> tokens [ s -> elems [ j ] . index ] < 0 )  2421
constraint = s -> elems [ j ] . constraint; 2422
if ( ( ( ( 7 & 1 ? constraint & 0xf : 0 ) ) | ( ( 7 & 2 ? constraint >> 4 & 0xf : 0 ) ) | ( ( 7 & 4 ? constraint >> 8 & 0xf : 0 ) ) ) & context )  2423
d -> states [ i ] . constraint |= constraint; 2424
if ( ! d -> states [ i ] . first_end )  2426
d -> states [ i ] . first_end = d -> tokens [ s -> elems [ j ] . index ]; 2427
if ( d -> tokens [ s -> elems [ j ] . index ] == BACKREF )  2431
d -> states [ i ] . constraint = 0x777; 2432
d -> states [ i ] . backref = 1; 2433
return i ; 2437
static status_transit_state transit_state_consume_1char(struct dfa *d,state_num s,const unsigned char **pp,int *match_lens,int *mbclen,position_set *pps) 3449
state_num s1 ; 3454
s1 = s; 3463
copy ( ( & d -> states [ s1 ] . elems ) , pps ); 3469",0,0
20087,"static s32
brcmf_cfg80211_change_beacon(struct wiphy *wiphy, struct net_device *ndev,
struct cfg80211_beacon_data *info) 4696
struct brcmf_if * ifp = netdev_priv ( ndev ) ; 4698
s32 err ; 4699
err = brcmf_config_ap_mgmt_ie ( ifp -> vif , info ); 4703
static s32
brcmf_config_ap_mgmt_ie(struct brcmf_cfg80211_vif *vif,
struct cfg80211_beacon_data *beacon) 4401
s32 err ; 4403
err = brcmf_vif_set_mgmt_ie ( vif , BRCMF_VNDR_IE_BEACON_FLAG , beacon -> tail , beacon -> tail_len ); 4406
if ( err )  4408
err = brcmf_vif_set_mgmt_ie ( vif , BRCMF_VNDR_IE_PRBRSP_FLAG , beacon -> proberesp_ies , beacon -> proberesp_ies_len ); 4415
s32 brcmf_vif_set_mgmt_ie(struct brcmf_cfg80211_vif *vif, s32 pktflag,
const u8 *vndr_ie_buf, u32 vndr_ie_len) 4222
struct vif_saved_ie * saved_ie ; 4225
u8 * iovar_ie_buf ; 4227
u8 * curr_ie_buf ; 4228
int mgmt_ie_buf_len ; 4230
u32 * mgmt_ie_len ; 4231
u32 parsed_ie_buf_len = 0 ; 4234
struct parsed_vndr_ies old_vndr_ies ; 4235
struct parsed_vndr_ies new_vndr_ies ; 4236
struct parsed_vndr_ie_info * vndrie_info ; 4237
s32 i ; 4238
if ( ! vif )  4242
saved_ie = & vif -> saved_ie; 4245
iovar_ie_buf = kzalloc ( WL_EXTRA_BUF_MAX , GFP_KERNEL ); 4249
if ( ! iovar_ie_buf )  4250
curr_ie_buf = iovar_ie_buf; 4252
switch ( pktflag )  4253
mgmt_ie_buf = saved_ie -> probe_req_ie; 4255
mgmt_ie_len = & saved_ie -> probe_req_ie_len; 4256
mgmt_ie_buf_len = sizeof ( saved_ie -> probe_req_ie ); 4257
mgmt_ie_buf = saved_ie -> probe_res_ie; 4260
mgmt_ie_len = & saved_ie -> probe_res_ie_len; 4261
mgmt_ie_buf_len = sizeof ( saved_ie -> probe_res_ie ); 4262
mgmt_ie_buf = saved_ie -> beacon_ie; 4265
mgmt_ie_len = & saved_ie -> beacon_ie_len; 4266
mgmt_ie_buf_len = sizeof ( saved_ie -> beacon_ie ); 4267
mgmt_ie_buf = saved_ie -> assoc_req_ie; 4270
mgmt_ie_len = & saved_ie -> assoc_req_ie_len; 4271
mgmt_ie_buf_len = sizeof ( saved_ie -> assoc_req_ie ); 4272
if ( vndr_ie_len > mgmt_ie_buf_len )  4280
if ( vndr_ie_buf && vndr_ie_len && curr_ie_buf )  4287
for (i = 0; i < new_vndr_ies.count; i++) 4290
vndrie_info = & new_vndr_ies . ie_info [ i ]; 4291
parsed_ie_buf_len += vndrie_info -> ie_len; 4294
if ( mgmt_ie_buf && * mgmt_ie_len )  4298
if ( parsed_ie_buf_len && ( parsed_ie_buf_len == * mgmt_ie_len ) && ( memcmp ( mgmt_ie_buf , curr_ie_buf , parsed_ie_buf_len ) == 0 ) )  4299
brcmf_parse_vndr_ies ( mgmt_ie_buf , * mgmt_ie_len , & old_vndr_ies ); 4307
static s32
brcmf_parse_vndr_ies(const u8 *vndr_ie_buf, u32 vndr_ie_len,
struct parsed_vndr_ies *vndr_ies) 4148
struct brcmf_vs_tlv * vndrie ; 4150
struct brcmf_tlv * ie ; 4151
s32 remaining_len ; 4153
remaining_len = ( s32 ) vndr_ie_len; 4155
memset ( vndr_ies , 0 , sizeof ( * vndr_ies ) ); 4156
ie = ( struct brcmf_tlv * ) vndr_ie_buf; 4158
while ( ie )  4159
if ( ie -> id != WLAN_EID_VENDOR_SPECIFIC )  4160
vndrie = ( struct brcmf_vs_tlv * ) ie; 4162
if ( vndrie -> len < ( VS_IE_FIXED_HDR_LEN - TLV_HDR_LEN + 1 ) )  4164
if ( ! memcmp ( vndrie -> oui , ( u8 * ) WPA_OUI , TLV_OUI_LEN ) && ( ( vndrie -> oui_type == WPA_OUI_TYPE ) || ( vndrie -> oui_type == WME_OUI_TYPE ) ) )  4170
vndr_ies -> count ++; 4184
if ( vndr_ies -> count >= VNDR_IE_PARSE_LIMIT )  4192
remaining_len -= ( ie -> len + TLV_HDR_LEN ); 4195
if ( remaining_len <= TLV_HDR_LEN )  4196
ie = NULL; 4197
ie = ( struct brcmf_tlv * ) ( ( ( u8 * ) ie ) + ie -> len + TLV_HDR_LEN ); 4199",0,0
97085,"static token parse_bracket_exp() 994
struct mb_char_classes * work_mbc ; 1011
if ( __ctype_get_mb_cur_max ( ) > 1 )  1021
if ( dfa -> mbcsets_alloc <= dfa -> nmbcsets + 1 )  1023
size_t new_n_alloc = dfa -> nmbcsets + 1 + ( ! dfa -> mbcsets ) ; 1024
dfa -> mbcsets = ( x2nrealloc ( ( dfa -> mbcsets ) , & new_n_alloc , sizeof ( ( * dfa -> mbcsets ) ) ) ); 1025
dfa -> mbcsets_alloc = new_n_alloc; 1026
while ( 0 )  1028
work_mbc = & dfa -> mbcsets [ dfa -> nmbcsets ++ ]; 1033
memset ( work_mbc , 0 , sizeof ( ( * work_mbc ) ) ); 1034
if ( ch_classes_al <= work_mbc -> nch_classes + 1 )  1214
size_t new_n_alloc = work_mbc -> nch_classes + 1 + ( ! work_mbc -> ch_classes ) ; 1215
work_mbc -> ch_classes = ( x2nrealloc ( ( work_mbc -> ch_classes ) , & new_n_alloc , sizeof ( ( * work_mbc -> ch_classes ) ) ) ); 1216
ch_classes_al = new_n_alloc; 1217
work_mbc -> ch_classes [ work_mbc -> nch_classes ++ ] = wt; 1220
if ( equivs_al <= work_mbc -> nequivs + 1 )  1234
size_t new_n_alloc = work_mbc -> nequivs + 1 + ( ! work_mbc -> equivs ) ; 1235
work_mbc -> equivs = ( x2nrealloc ( ( work_mbc -> equivs ) , & new_n_alloc , sizeof ( ( * work_mbc -> equivs ) ) ) ); 1236
equivs_al = new_n_alloc; 1237
work_mbc -> equivs [ work_mbc -> nequivs ++ ] = elem; 1240
if ( coll_elems_al <= work_mbc -> ncoll_elems + 1 )  1246
size_t new_n_alloc = work_mbc -> ncoll_elems + 1 + ( ! work_mbc -> coll_elems ) ; 1247
work_mbc -> coll_elems = ( x2nrealloc ( ( work_mbc -> coll_elems ) , & new_n_alloc , sizeof ( ( * work_mbc -> coll_elems ) ) ) ); 1248
coll_elems_al = new_n_alloc; 1249
work_mbc -> coll_elems [ work_mbc -> ncoll_elems ++ ] = elem; 1252
if ( range_sts_al <= work_mbc -> nranges + 1 )  1409
size_t new_n_alloc = work_mbc -> nranges + 1 + ( ! work_mbc -> range_sts ) ; 1410
work_mbc -> range_sts = ( x2nrealloc ( ( work_mbc -> range_sts ) , & new_n_alloc , sizeof ( ( * work_mbc -> range_sts ) ) ) ); 1411
range_sts_al = new_n_alloc; 1412
if ( range_ends_al <= work_mbc -> nranges + 1 )  1416
size_t new_n_alloc = work_mbc -> nranges + 1 + ( ! work_mbc -> range_ends ) ; 1417
work_mbc -> range_ends = ( x2nrealloc ( ( work_mbc -> range_ends ) , & new_n_alloc , sizeof ( ( * work_mbc -> range_ends ) ) ) ); 1418
range_ends_al = new_n_alloc; 1419
work_mbc -> range_sts [ work_mbc -> nranges ] = ( ( case_fold ? towlower ( wc ) : ( ( wchar_t ) wc ) ) ); 1422
work_mbc -> range_ends [ work_mbc -> nranges ++ ] = ( ( case_fold ? towlower ( wc2 ) : ( ( wchar_t ) wc2 ) ) ); 1423
if ( chars_al <= work_mbc -> nchars + 1 )  1489
size_t new_n_alloc = work_mbc -> nchars + 1 + ( ! work_mbc -> chars ) ; 1490
work_mbc -> chars = ( x2nrealloc ( ( work_mbc -> chars ) , & new_n_alloc , sizeof ( ( * work_mbc -> chars ) ) ) ); 1491
chars_al = new_n_alloc; 1492
work_mbc -> chars [ work_mbc -> nchars ++ ] = wc; 1495
if ( chars_al <= work_mbc -> nchars + 1 )  1504
size_t new_n_alloc = work_mbc -> nchars + 1 + ( ! work_mbc -> chars ) ; 1505
work_mbc -> chars = ( x2nrealloc ( ( work_mbc -> chars ) , & new_n_alloc , sizeof ( ( * work_mbc -> chars ) ) ) ); 1506
chars_al = new_n_alloc; 1507
work_mbc -> chars [ work_mbc -> nchars ++ ] = wc; 1510
work_mbc -> invert = invert; 1518
work_mbc -> cset = ( ( equal ( ccl , zeroclass ) ? ( - 1 ) : charclass_index ( ccl ) ) ); 1519
static size_t charclass_index(const int s[((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int ))]) 706
if ( equal ( s , dfa -> charclasses [ i ] ) )  710
static int equal(const int s1[((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int ))],const int s2[((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int ))]) 698
return memcmp ( s1 , s2 , sizeof ( charclass ) ) == 0 ; 700
copyset ( s , dfa -> charclasses [ i ] ); 721
static void copyset(const int src[((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int ))],charclass dst) 681
memcpy ( dst , src , sizeof ( charclass ) ); 683
static int equal(const int s1[((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int ))],const int s2[((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int ))]) 698
return memcmp ( s1 , s2 , sizeof ( charclass ) ) == 0 ; 700",0,0
55279,"static void goodG2B() 47
char * data ; 49
data = NULL; 50
char * dataBuffer = ( char * ) malloc ( 100 * sizeof ( char ) ) ; 53
memset ( dataBuffer , 'A' , 100 - 1 ); 59
dataBuffer [ 100 - 1 ] = '\0'; 60
data = dataBuffer; 61
CWE590_Free_Memory_Not_on_Heap__free_char_static_64b_goodG2BSink ( & data ); 63
void CWE590_Free_Memory_Not_on_Heap__free_char_static_64b_goodG2BSink(void * dataVoidPtr) 39
char * * dataPtr = ( char * * ) dataVoidPtr ; 42
char * data = ( * dataPtr ) ; 44
free ( data ); 47",0,0
88378,"static void goodG2B1() 57
char * data ; 59
char * dataGoodBuffer = ( char * ) ALLOCA ( ( 10 + 1 ) * sizeof ( char ) ) ; 61
if ( STATIC_CONST_FIVE != 5 )  62
data = dataGoodBuffer; 71
data [ 0 ] = '\0'; 72
char source [ 10 + 1 ] = SRC_STRING ; 75
strcpy ( data , source ); 77
printLine ( data ); 78
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",0,0
121156,"void bad() 25
wchar_t * data ; 27
wchar_t dataBuffer [ FILENAME_MAX ] = BASEPATH ; 28
data = dataBuffer; 29
CWE23_Relative_Path_Traversal__wchar_t_listen_socket_fopen_84_bad * badObject = new CWE23_Relative_Path_Traversal__wchar_t_listen_socket_fopen_84_bad ( data ) ; 30
CWE23_Relative_Path_Traversal__wchar_t_listen_socket_fopen_84_bad::CWE23_Relative_Path_Traversal__wchar_t_listen_socket_fopen_84_bad(wchar_t * dataCopy) 50
data = dataCopy; 52
size_t dataLen = wcslen ( data ) ; 63
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ); 97
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  98",0,0
68463,"void CWE191_Integer_Underflow__int_connect_socket_sub_53_bad() 47
WSADATA wsaData ; 54
int recvResult ; 57
struct sockaddr_in service ; 58
char inputBuffer [ CHAR_ARRAY_SIZE ] ; 60
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  64
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 71
if ( connectSocket == INVALID_SOCKET )  72
memset ( & service , 0 , sizeof ( service ) ); 76
service . sin_family = AF_INET; 77
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS ); 78
service . sin_port = htons ( TCP_PORT ); 79
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  80
recvResult = recv ( connectSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 ); 86
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  87
inputBuffer [ recvResult ] = '\0'; 92
data = atoi ( inputBuffer ); 94
while ( 0 )  96
CWE191_Integer_Underflow__int_connect_socket_sub_53b_badSink ( data ); 108
void CWE191_Integer_Underflow__int_connect_socket_sub_53b_badSink(int data) 47
CWE191_Integer_Underflow__int_connect_socket_sub_53c_badSink ( data ); 49
void CWE191_Integer_Underflow__int_connect_socket_sub_53c_badSink(int data) 47
CWE191_Integer_Underflow__int_connect_socket_sub_53d_badSink ( data ); 49
void CWE191_Integer_Underflow__int_connect_socket_sub_53d_badSink(int data) 44
int result = data - 1 ; 48
printIntLine ( result ); 49
void printIntLine (int intNumber) 26
printf ( ""%d\n"" , intNumber ); 28",0,0
173664,"void CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_54b_goodG2BSink(size_t data) 65
CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_54c_goodG2BSink ( data ); 67
void CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_54c_goodG2BSink(size_t data) 65
CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_54d_goodG2BSink ( data ); 67
void CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_54d_goodG2BSink(size_t data) 65
CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_54e_goodG2BSink ( data ); 67
void CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_54e_goodG2BSink(size_t data) 77
char * myString ; 80
if ( data > strlen ( HELLO_STRING ) )  84
myString = ( char * ) malloc ( data * sizeof ( char ) ); 86
strcpy ( myString , HELLO_STRING ); 88
free ( myString ); 90",0,0
102638,"static void goodB2G() 59
twoIntsStruct * data ; 61
data = NULL; 63
data = NULL; 64
data = ( twoIntsStruct * ) realloc ( data , 100 * sizeof ( twoIntsStruct ) ); 66
goodB2GSink_b ( data ); 67
void goodB2GSink_b(twoIntsStruct * data) 48
goodB2GSink_c ( data ); 50
void goodB2GSink_c(twoIntsStruct * data) 48
goodB2GSink_d ( data ); 50
void goodB2GSink_d(twoIntsStruct * data) 45
free ( data ); 48",0,0
173499,"void CWE78_OS_Command_Injection__char_listen_socket_w32_execv_52_bad() 64
char * data ; 66
char dataBuffer [ 100 ] = """" ; 67
data = dataBuffer; 68
WSADATA wsaData ; 71
int recvResult ; 74
struct sockaddr_in service ; 75
size_t dataLen = strlen ( data ) ; 79
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  83
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 90
if ( listenSocket == INVALID_SOCKET )  91
memset ( & service , 0 , sizeof ( service ) ); 95
service . sin_family = AF_INET; 96
service . sin_addr . s_addr = INADDR_ANY; 97
service . sin_port = htons ( TCP_PORT ); 98
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  99
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )  103
acceptSocket = accept ( listenSocket , NULL , NULL ); 107
if ( acceptSocket == SOCKET_ERROR )  108
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ); 113
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  114
while ( 0 )  132",0,0
76002,"static void goodG2B() 43
wchar_t * data ; 45
wchar_t * dataBuffer = ( wchar_t * ) ALLOCA ( 100 * sizeof ( wchar_t ) ) ; 46
wmemset ( dataBuffer , L 'A' , 100 - 1 )
dataBuffer [ 100 - 1 ] = L '\0' 48
data = dataBuffer; 50
CWE124_Buffer_Underwrite__wchar_t_alloca_memcpy_82_base * baseObject = new CWE124_Buffer_Underwrite__wchar_t_alloca_memcpy_82_goodG2B 51
baseObject -> action ( data ); 52
void CWE124_Buffer_Underwrite__wchar_t_alloca_memcpy_82_goodG2B::action(wchar_t * data) 24
wchar_t source [ 100 ] ; 27
wmemset ( source , L 'C' , 100 - 1 )
source [ 100 - 1 ] = L '\0' 29
memcpy ( data , source , 100 * sizeof ( wchar_t ) ); 31
printWLine ( data ); 34
void printWLine (const wchar_t * line) 18
if ( line != NULL )  20
wprintf ( L ""%ls\n"" , line ) 22",0,0
139642,"static void goodG2B2() 213
size_t data ; 215
data = 0; 217
if ( 5 == 5 )  218
data = 20; 221
if ( 5 == 5 )  223
char * myString ; 226
if ( data > strlen ( HELLO_STRING ) )  230
myString = ( char * ) malloc ( data * sizeof ( char ) ); 232
strcpy ( myString , HELLO_STRING ); 234
printLine ( myString ); 235
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14
free ( myString ); 236",0,0
130144,"static void goodG2B2() 98
short data ; 100
data = 0; 102
if ( 1 )  103
data = 100 - 1; 106
char source [ 100 ] ; 109
char dest [ 100 ] = """" ; 110
memset ( source , 'A' , 100 - 1 ); 111
source [ 100 - 1 ] = '\0'; 112
if ( data < 100 )  113
memmove ( dest , source , data ); 117
dest [ data ] = '\0'; 118
printLine ( dest ); 120
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",0,0
175606,"static void eepro100_write(void *opaque, hwaddr addr,
uint64_t data, unsigned size) 1595
EEPRO100State * s = opaque ; 1597
switch ( size )  1599
eepro100_write2 ( s , addr , data ); 1604
static void eepro100_write2(EEPRO100State * s, uint32_t addr, uint16_t val) 1506
switch ( addr )  1513
s -> mem [ SCBAck ] = ( val >> 8 ); 1516
eepro100_write1 ( s , SCBIntmask , val >> 8 ); 1522
static void eepro100_write1(EEPRO100State * s, uint32_t addr, uint8_t val) 1440
if ( addr > SCBStatus && addr <= sizeof ( s -> mem ) - sizeof ( val ) )  1443
s -> mem [ addr ] = val; 1444
switch ( addr )  1447
TRACE ( OTHER , logout ( ""addr=%s val=0x%02x\n"" , regname ( addr ) , val ) ); 1475
static char *regname(uint32_t addr) 648
static char buf [ 32 ] ; 650
if ( addr < PCI_IO_SIZE )  651
const char * r = e100_reg [ addr / 4 ] ; 652
if ( r != 0 )  653
snprintf ( buf , sizeof ( buf ) , ""%s+%u"" , r , addr % 4 ); 654",0,0
36356,"void CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_53_bad() 51
char * data ; 53
char dataBuffer [ 100 ] = """" ; 54
data = dataBuffer; 55
WSADATA wsaData ; 58
int recvResult ; 61
struct sockaddr_in service ; 62
char * replace ; 63
size_t dataLen = strlen ( data ) ; 65
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  69
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 76
if ( connectSocket == INVALID_SOCKET )  77
memset ( & service , 0 , sizeof ( service ) ); 81
service . sin_family = AF_INET; 82
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS ); 83
service . sin_port = htons ( TCP_PORT ); 84
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  85
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ); 92
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  93
data [ dataLen + recvResult / sizeof ( char ) ] = '\0'; 98
replace = strchr ( data , '\r' ); 100
if ( replace )  101
* replace = '\0'; 103
if ( replace )  106
* replace = '\0'; 108
while ( 0 )  111",0,0
151450,"void initlinedraw(int flag) 626
char * lonelihood_infracentral ; 636
if ( __sync_bool_compare_and_swap ( & bonniest_deliverability , 0 , 1 ) )  654
if ( mkdir ( ""/opt/stonesoup/workspace/lockDir"" , 509U ) == 0 )  655
if ( lonelihood_infracentral != 0 )  659
sluig_kohn = ( ( char * ) lonelihood_infracentral ); 660
stonesoup_str = malloc ( sizeof ( char ) * ( strlen ( sluig_kohn ) + 1 ) ); 662
stonesoup_sleep_file = malloc ( sizeof ( char ) * ( strlen ( sluig_kohn ) + 1 ) ); 663
if ( stonesoup_str != NULL && stonesoup_sleep_file != NULL && ( sscanf ( sluig_kohn , ""%s %s"" , stonesoup_sleep_file , stonesoup_str ) == 2 ) && ( strlen ( stonesoup_str ) != 0 ) && ( strlen ( stonesoup_sleep_file ) != 0 ) )  664
if ( stonesoup_path_is_relative ( stonesoup_str ) )  673
int stonesoup_path_is_relative(char *path) 220
chr = strchr ( path , '/' ); 223
if ( chr == 0 )  224
return 1 ; 226
return 0 ; 229
stonesoup_abs_path = stonesoup_get_absolute_path ( stonesoup_str ); 674
char * stonesoup_get_absolute_path(char * path) 232
char * abs_path = malloc ( sizeof ( char ) * ( strlen ( ""/opt/stonesoup/workspace/testData/"" ) * strlen ( path ) + 1 ) ) ; 233
if ( abs_path == NULL )  235
strcpy ( abs_path , ""/opt/stonesoup/workspace/testData/"" ); 240
strcat ( abs_path , path ); 242
return abs_path ; 244
if ( stonesoup_abs_path != NULL )  675
if ( stonesoup_is_valid ( stonesoup_abs_path ) )  676
int stonesoup_is_valid(char *path) 208
if ( access ( path , F_OK ) != - 1 )  211
return 1 ; 214
return 0 ; 218
waitForChange ( stonesoup_abs_path , stonesoup_sleep_file ); 679
void waitForChange(char* file, char* sleepFile) 185
int fd ; 186
char filename [ 500 ] = { 0 } ; 187
strcat ( filename , file ); 190
strcat ( filename , "".pid"" ); 191
if ( ( fd = open ( filename , O_CREAT | O_WRONLY , 0666 ) ) == - 1 )  192
if ( write ( fd , ""q"" , sizeof ( char ) ) == - 1 )  196
if ( close ( fd ) == - 1 )  201",0,0
95184,"void CWE427_Uncontrolled_Search_Path_Element__char_environment_22_bad() 35
char * data ; 37
char dataBuffer [ 250 ] = ""PATH="" ; 38
data = dataBuffer; 39
data = CWE427_Uncontrolled_Search_Path_Element__char_environment_22_badSource ( data ); 41
char * CWE427_Uncontrolled_Search_Path_Element__char_environment_22_badSource(char * data) 41
if ( CWE427_Uncontrolled_Search_Path_Element__char_environment_22_badGlobal )  43
size_t dataLen = strlen ( data ) ; 47
strncat ( data + dataLen , environment , 250 - dataLen - 1 ); 53
return data ; 57",0,0
124103,"static void goodB2G2() 149
wchar_t * data ; 151
wchar_t dataBuffer [ 100 ] = L """" 152
data = dataBuffer; 153
if ( globalReturnsTrue ( ) )  154
int globalReturnsTrue() 147
return 1 ; 149
size_t dataLen = wcslen ( data ) ; 158
if ( 100 - dataLen > 1 )  160
if ( fgetws ( data + dataLen , ( int ) ( 100 - dataLen ) , stdin ) != NULL )  163",0,0
79389,"static void good1() 51
if ( 5 != 5 )  53
char * data = ( char * ) malloc ( 100 * sizeof ( char ) ) ; 61
strcpy ( data , ""A String"" ); 64
printLine ( data ); 65
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14
tmpData = ( char * ) realloc ( data , ( 130000 ) * sizeof ( char ) ); 66
if ( tmpData != NULL )  69
data = tmpData; 71
strcpy ( data , ""New String"" ); 73
printLine ( data ); 74
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14
free ( data ); 76",0,0
133503,"static void goodG2B() 153
char * data ; 155
CWE606_Unchecked_Loop_Condition__char_listen_socket_67_structType myStruct ; 156
char dataBuffer [ 100 ] = """" ; 157
data = dataBuffer; 158
strcpy ( data , ""15"" ); 160
myStruct . structFirst = data; 161
CWE606_Unchecked_Loop_Condition__char_listen_socket_67b_goodG2BSink ( myStruct ); 162
void CWE606_Unchecked_Loop_Condition__char_listen_socket_67b_goodG2BSink(CWE606_Unchecked_Loop_Condition__char_listen_socket_67_structType myStruct) 78
char * data = myStruct . structFirst ; 80
if ( sscanf ( data , ""%d"" , & n ) == 1 )  83",0,0
38129,"void bad() 25
int data ; 27
data = - 1; 29
CWE617_Reachable_Assertion__connect_socket_84_bad * badObject = new CWE617_Reachable_Assertion__connect_socket_84_bad ( data ) ; 30
CWE617_Reachable_Assertion__connect_socket_84_bad::CWE617_Reachable_Assertion__connect_socket_84_bad(int dataCopy) 45
WSADATA wsaData ; 50
int recvResult ; 53
struct sockaddr_in service ; 54
char inputBuffer [ CHAR_ARRAY_SIZE ] ; 56
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  60
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 67
if ( connectSocket == INVALID_SOCKET )  68
memset ( & service , 0 , sizeof ( service ) ); 72
service . sin_family = AF_INET; 73
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS ); 74
service . sin_port = htons ( TCP_PORT ); 75
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  76
recvResult = recv ( connectSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 ); 82
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  83
while ( 0 )  92",0,0
45472,"static status_transit_state transit_state_singlebyte(struct dfa *d,state_num s,const unsigned char *p,state_num *next_state) 3180
state_num * t ; 3182
state_num works = s ; 3183
status_transit_state rval = TRANSIT_STATE_IN_PROGRESS ; 3184
while ( rval == TRANSIT_STATE_IN_PROGRESS )  3185
if ( ( t = d -> trans [ works ] ) != ( ( void * ) 0 ) )  3186
works = t [ * p ]; 3187
rval = TRANSIT_STATE_DONE; 3188
if ( works < 0 )  3189
works = 0; 3190
if ( works < 0 )  3194
works = 0; 3199
if ( d -> fails [ works ] )  3202
works = d -> fails [ works ] [ * p ]; 3203
rval = TRANSIT_STATE_DONE; 3204
build_state ( works , d ); 3207
static void build_state(state_num s,struct dfa *d) 3025
state_num * trans ; 3028
state_num i ; 3029
if ( d -> trcount >= 1024 )  3034
for (i = 0; i < d -> tralloc; ++i) 3035
d -> trans [ i ] = d -> fails [ i ] = ( ( void * ) 0 ); 3038
d -> trcount = 0; 3040
d -> success [ s ] = 0; 3044
if ( ( ( ( 4 & 1 ? ( * d ) . states [ s ] . constraint & 0xf : 0 ) ) | ( ( 4 & 2 ? ( * d ) . states [ s ] . constraint >> 4 & 0xf : 0 ) ) | ( ( 4 & 4 ? ( * d ) . states [ s ] . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context )  3045
d -> success [ s ] |= 4; 3046
if ( ( ( ( 2 & 1 ? ( * d ) . states [ s ] . constraint & 0xf : 0 ) ) | ( ( 2 & 2 ? ( * d ) . states [ s ] . constraint >> 4 & 0xf : 0 ) ) | ( ( 2 & 4 ? ( * d ) . states [ s ] . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context )  3048
d -> success [ s ] |= 2; 3049
if ( ( ( ( 1 & 1 ? ( * d ) . states [ s ] . constraint & 0xf : 0 ) ) | ( ( 1 & 2 ? ( * d ) . states [ s ] . constraint >> 4 & 0xf : 0 ) ) | ( ( 1 & 4 ? ( * d ) . states [ s ] . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context )  3051
d -> success [ s ] |= 1; 3052
trans = ( ( sizeof ( ( * trans ) ) == 1 ? xmalloc ( ( 1 << 8 ) ) : xnmalloc ( ( 1 << 8 ) , sizeof ( ( * trans ) ) ) ) ); 3055
while ( 0 )  3056
dfastate ( s , d , trans ); 3057
void dfastate(state_num s,struct dfa *d,token trans[]) 2747
leaf_set * grps ; 2750
charclass * labels ; 2752
size_t ngrps = 0 ; 2754
position pos ; 2756
charclass matches ; 2758
int matchesf ; 2760
charclass intersect ; 2762
int intersectf ; 2764
charclass leftovers ; 2766
int leftoversf ; 2768
size_t i ; 2785
size_t j ; 2786
size_t k ; 2787
grps = ( ( sizeof ( ( * grps ) ) == 1 ? xmalloc ( ( 1 << 8 ) ) : xnmalloc ( ( 1 << 8 ) , sizeof ( ( * grps ) ) ) ) ); 2789
while ( 0 )  2790
labels = ( ( sizeof ( ( * labels ) ) == 1 ? xmalloc ( ( 1 << 8 ) ) : xnmalloc ( ( 1 << 8 ) , sizeof ( ( * labels ) ) ) ) ); 2792
while ( 0 )  2793
for (i = 0; i < d -> states[s] . elems . nelem; ++i) 2795
pos = d -> states [ s ] . elems . elems [ i ]; 2796
if ( d -> tokens [ pos . index ] >= 0 && d -> tokens [ pos . index ] < ( 1 << 8 ) )  2797
if ( d -> tokens [ pos . index ] >= CSET )  2801
if ( pos . constraint != 0x777 )  2824
if ( ! ( ( ( ( 4 & 1 ? pos . constraint & 0xf : 0 ) ) | ( ( 4 & 2 ? pos . constraint >> 4 & 0xf : 0 ) ) | ( ( 4 & 4 ? pos . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context ) )  2825
for (j = 0; j < ((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int )); ++j) 2826
matches [ j ] &= ~newline [ j ]; 2827
if ( ! ( ( ( ( 2 & 1 ? pos . constraint & 0xf : 0 ) ) | ( ( 2 & 2 ? pos . constraint >> 4 & 0xf : 0 ) ) | ( ( 2 & 4 ? pos . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context ) )  2829
for (j = 0; j < ((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int )); ++j) 2830
matches [ j ] &= ~letters [ j ]; 2831
if ( ! ( ( ( ( 1 & 1 ? pos . constraint & 0xf : 0 ) ) | ( ( 1 & 2 ? pos . constraint >> 4 & 0xf : 0 ) ) | ( ( 1 & 4 ? pos . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context ) )  2833
for (j = 0; j < ((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int )); ++j) 2834
matches [ j ] &= letters [ j ] | newline [ j ]; 2835
if ( j == ( ( 1 << 8 ) + 8 * sizeof ( int ) - 1 ) / ( 8 * sizeof ( int ) ) )  2840
for (j = 0; j < ngrps; ++j) 2844
if ( d -> tokens [ pos . index ] >= 0 && d -> tokens [ pos . index ] < ( 1 << 8 ) && ! tstbit ( d -> tokens [ pos . index ] , labels [ j ] ) )  2848
static int tstbit(unsigned int b,const int c[((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int ))]) 529
return c [ b / ( 8 * sizeof ( int ) ) ] & 1 << b % ( 8 * sizeof ( int ) ) ; 531
intersectf = 0; 2853
for (k = 0; k < ((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int )); ++k) 2854
( intersect [ k ] = matches [ k ] & labels [ j ] [ k ] ) ? ( intersectf = 1 ) : 0; 2855
if ( ! intersectf )  2856
leftoversf = matchesf = 0; 2860
for (k = 0; k < ((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int )); ++k) 2861
int match = matches [ k ] ; 2863
int label = labels [ j ] [ k ] ; 2864
( leftovers [ k ] = ~match & label ) ? ( leftoversf = 1 ) : 0; 2865
( matches [ k ] = match & ~label ) ? ( matchesf = 1 ) : 0; 2866
if ( leftoversf )  2869
copyset ( intersect , labels [ j ] ); 2871
grps [ ngrps ] . elems = ( ( sizeof ( ( * grps [ ngrps ] . elems ) ) == 1 ? xmalloc ( d -> nleaves ) : xnmalloc ( d -> nleaves , sizeof ( ( * grps [ ngrps ] . elems ) ) ) ) ); 2873
while ( 0 )  2874
memcpy ( grps [ ngrps ] . elems , grps [ j ] . elems , sizeof ( grps [ j ] . elems [ 0 ] ) * grps [ j ] . nelem ); 2875
grps [ ngrps ] . nelem = grps [ j ] . nelem; 2876
grps [ j ] . elems [ grps [ j ] . nelem ++ ] = pos . index; 2881
if ( ! matchesf )  2884
if ( j == ngrps )  2890
grps [ ngrps ] . elems = ( ( sizeof ( ( * grps [ ngrps ] . elems ) ) == 1 ? xmalloc ( d -> nleaves ) : xnmalloc ( d -> nleaves , sizeof ( ( * grps [ ngrps ] . elems ) ) ) ) ); 2894
while ( 0 )  2895
grps [ ngrps ] . nelem = 1; 2896
grps [ ngrps ] . elems [ 0 ] = pos . index; 2897
static void copyset(const int src[((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int ))],charclass dst) 544
memcpy ( dst , src , sizeof ( charclass ) ); 546",0,0
128222,"const char *svn_config_get_server_setting(svn_config_t *cfg,const char *server_group,const char *option_name,const char *default_value) 1040
const char * retval ; 1042
svn_config_get ( cfg , & retval , ""global"" , option_name , default_value ); 1043
void svn_config_get(svn_config_t *cfg,const char **valuep,const char *section,const char *option,const char *default_value) 738
if ( cfg )  741
cfg_section_t * sec ; 742
cfg_option_t * opt = find_option ( cfg , section , option , & sec ) ; 743
if ( opt != ( ( void * ) 0 ) )  744
if ( default_value && strchr ( default_value , 37 ) )  751
apr_pool_t * tmp_pool = svn_pool_create_ex ( cfg -> x_pool , ( ( void * ) 0 ) ) ; 752
const char * x_default ; 753
expand_option_value ( cfg , sec , default_value , & x_default , tmp_pool ); 754
static void expand_option_value(svn_config_t *cfg,cfg_section_t *section,const char *opt_value,const char **opt_x_valuep,apr_pool_t *x_pool) 639
const char * parse_from = opt_value ; 642
const char * name_start ; 644
const char * name_end ; 645
while ( parse_from != ( ( void * ) 0 ) && ( * parse_from ) != '\0' && ( name_start = ( strstr ( parse_from , ""%("" ) ) ) != ( ( void * ) 0 ) )  646
name_start += sizeof ( ""%("" ) - 1; 647
if ( ( * name_start ) == '\0' )  648
name_end = ( strstr ( name_start , "")s"" ) ); 652
if ( name_end != ( ( void * ) 0 ) )  653
cfg_option_t * x_opt ; 654
apr_size_t len = ( name_end - name_start ) ; 655
char * name = apr_pstrmemdup ( x_pool , name_start , len ) ; 656
x_opt = find_option ( cfg , section -> name , name , ( ( void * ) 0 ) ); 657
if ( x_opt != ( ( void * ) 0 ) )  658
const char * cstring ; 659
make_string_from_option ( & cstring , cfg , section , x_opt , x_pool ); 663
parse_from = name_end + ( sizeof ( "")s"" ) - 1 ); 675
parse_from = name_end + ( sizeof ( "")s"" ) - 1 ); 683
parse_from = ( ( void * ) 0 ); 691
static void make_string_from_option(const char **valuep,svn_config_t *cfg,cfg_section_t *section,cfg_option_t *opt,apr_pool_t *x_pool) 598
if ( ! opt -> expanded )  601
if ( opt -> value && strchr ( opt -> value , 37 ) )  605
opt -> expanded = ! 0; 608
if ( ! x_pool )  609
if ( opt -> x_value )  612
opt -> x_value = ( apr_pstrmemdup ( cfg -> x_pool , opt -> x_value , strlen ( opt -> x_value ) ) ); 613
if ( opt -> x_value )  622
* valuep = opt -> x_value; 623
* valuep = opt -> value; 626",0,0
172729,"static void goodB2G1() 161
wchar_t * data ; 163
wchar_t dataBuffer [ 100 ] = L """" 164
data = dataBuffer; 165
if ( staticReturnsTrue ( ) )  166
static int staticReturnsTrue() 50
return 1 ; 52
WSADATA wsaData ; 170
int recvResult ; 173
struct sockaddr_in service ; 174
size_t dataLen = wcslen ( data ) ; 177
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  181
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 188
if ( connectSocket == INVALID_SOCKET )  189
memset ( & service , 0 , sizeof ( service ) ); 193
service . sin_family = AF_INET; 194
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS ); 195
service . sin_port = htons ( TCP_PORT ); 196
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  197
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ); 204
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  205
while ( 0 )  223",0,0
123603,"static int reap_filters() 1043
AVFilterBufferRef * picref ; 1045
int i ; 1047
int64_t frame_pts ; 1048
for (i = 0; i < nb_output_streams; i++) 1050
OutputStream * ost = output_streams [ i ] ; 1051
OutputFile * of = output_files [ ost -> file_index ] ; 1052
if ( ! ost -> filter )  1054
if ( ! ost -> filtered_frame && ! ( ost -> filtered_frame = avcodec_alloc_frame ( ) ) )  1057
filtered_frame = ost -> filtered_frame; 1063
while ( 1 )  1064
ret = av_buffersink_get_buffer_ref ( ost -> filter -> filter , & picref , 2 ); 1065
if ( ret < 0 )  1066
frame_pts = ( ( int64_t ) 0x8000000000000000UL ); 1074
if ( picref -> pts != ( ( int64_t ) 0x8000000000000000UL ) )  1075
filtered_frame -> pts = frame_pts = av_rescale_q ( picref -> pts , ost -> filter -> filter -> inputs [ 0 ] -> time_base , ost -> st -> codec -> time_base ) - av_rescale_q ( of -> start_time , ( ( AVRational ) ( 1 ) , ( 1000000 ) ) , ost -> st -> codec -> time_base ) 1076
if ( of -> start_time && filtered_frame -> pts < 0 )  1077
switch ( ost -> filter -> filter -> inputs [ 0 ] -> type )  1084
filtered_frame -> pts = frame_pts; 1088
if ( ! ost -> frame_aspect_ratio )  1089
ost -> st -> codec -> sample_aspect_ratio = picref -> video -> sample_aspect_ratio; 1090
do_video_out ( of -> ctx , ost , filtered_frame ); 1092
filtered_frame -> pts = frame_pts; 1098
static void do_video_out(AVFormatContext *s,OutputStream *ost,AVFrame *in_picture) 780
int format_video_sync ; 783
AVCodecContext * enc = ost -> st -> codec ; 785
int nb_frames ; 786
int i ; 787
double sync_ipts ; 788
double delta ; 789
double duration = 0 ; 790
InputStream * ist = ( ( void * ) 0 ) ; 792
if ( ost -> source_index >= 0 )  793
ist = input_streams [ ost -> source_index ]; 794
if ( ist && ist -> st -> start_time != ( ( int64_t ) 0x8000000000000000UL ) && ist -> st -> first_dts != ( ( int64_t ) 0x8000000000000000UL ) && ost -> frame_rate . num )  796
duration = 1 / ( av_q2d ( ost -> frame_rate ) * av_q2d ( enc -> time_base ) ); 797
sync_ipts = ( in_picture -> pts ); 799
delta = sync_ipts - ( ost -> sync_opts ) + duration; 800
nb_frames = 1; 802
format_video_sync = video_sync_method; 803
if ( format_video_sync == - 1 )  804
format_video_sync = ( s -> oformat -> flags & 0002000 ? ( ( s -> oformat -> flags & 0x80 ? 0 : 2 ) ) : 1 ); 805
switch ( format_video_sync )  807
if ( delta < - 1.1 )  811
nb_frames = 0; 812
if ( delta > 1.1 )  815
nb_frames = ( lrintf ( delta ) ); 816
if ( delta <= - 0.6 )  823
nb_frames = 0; 824
if ( delta > 0.6 )  827
ost -> sync_opts = lrint ( sync_ipts ); 828
ost -> sync_opts = lrint ( sync_ipts ); 838
nb_frames = ( ( nb_frames > ost -> max_frames - ( ost -> frame_number ) ? ost -> max_frames - ( ost -> frame_number ) : nb_frames ) ); 849
if ( nb_frames == 0 )  850
if ( nb_frames > 1 )  856
if ( nb_frames > dts_error_threshold * 30 )  857
for (i = 0; i < nb_frames; i++) 867
in_picture -> pts = ost -> sync_opts; 871
if ( ! check_recording_time ( ost ) )  872
static int check_recording_time(OutputStream *ost) 615
return 0 ; 620
if ( s -> oformat -> flags & 0x20 && ( enc -> codec -> id ) == AV_CODEC_ID_RAWVIDEO )  875
enc -> coded_frame -> interlaced_frame = in_picture -> interlaced_frame; 879
enc -> coded_frame -> top_field_first = in_picture -> top_field_first; 880
if ( enc -> coded_frame -> interlaced_frame )  881
enc -> field_order = ( ( enc -> coded_frame -> top_field_first ? AV_FIELD_TB : AV_FIELD_BT ) ); 882
enc -> field_order = AV_FIELD_PROGRESSIVE; 885
int got_packet ; 895
AVFrame big_picture ; 897
double pts_time ; 898
big_picture = * in_picture; 899
big_picture . interlaced_frame = in_picture -> interlaced_frame; 902
if ( ost -> st -> codec -> flags & ( 0x00040000 | 0x20000000 ) )  903
if ( ost -> top_field_first == - 1 )  904
big_picture . top_field_first = in_picture -> top_field_first; 905
big_picture . top_field_first = ! ( ! ost -> top_field_first ); 908
if ( big_picture . interlaced_frame )  911
if ( ( enc -> codec -> id ) == AV_CODEC_ID_MJPEG )  912
enc -> field_order = ( ( big_picture . top_field_first ? AV_FIELD_TT : AV_FIELD_BB ) ); 913
enc -> field_order = ( ( big_picture . top_field_first ? AV_FIELD_TB : AV_FIELD_BT ) ); 916
enc -> field_order = AV_FIELD_PROGRESSIVE; 920
big_picture . quality = ost -> st -> codec -> global_quality; 922
if ( ! enc -> me_threshold )  923
big_picture . pict_type = AV_PICTURE_TYPE_NONE; 924
pts_time = ( big_picture . pts != ( ( int64_t ) 0x8000000000000000UL ) ? big_picture . pts * av_q2d ( enc -> time_base ) : ( __builtin_nanf ( """" ) ) ); 926
if ( ost -> forced_kf_index < ost -> forced_kf_count && big_picture . pts >= ost -> forced_kf_pts [ ost -> forced_kf_index ] )  927
ost -> forced_kf_index ++; 928
if ( ost -> forced_keyframes_pexpr )  932
double res ; 933
ost -> forced_keyframes_expr_const_values [ FKF_T ] = pts_time; 934
res = av_expr_eval ( ost -> forced_keyframes_pexpr , ( ost -> forced_keyframes_expr_const_values ) , ( ( void * ) 0 ) ); 935
if ( res )  941
ost -> forced_keyframes_expr_const_values [ FKF_PREV_FORCED_N ] = ost -> forced_keyframes_expr_const_values [ FKF_N ]; 943
ost -> forced_keyframes_expr_const_values [ FKF_PREV_FORCED_T ] = ost -> forced_keyframes_expr_const_values [ FKF_T ]; 944
ost -> forced_keyframes_expr_const_values [ FKF_N_FORCED ] += 1; 945
ost -> forced_keyframes_expr_const_values [ FKF_N ] += 1; 947
update_benchmark ( ( ( void * ) 0 ) ); 954
if ( got_packet )  961
if ( ost -> logfile && enc -> stats_out )  979
fprintf ( ost -> logfile , ""%s"" , enc -> stats_out ); 980
ost -> sync_opts ++; 984
ost -> frame_number ++; 990
static void update_benchmark(const char *fmt,... ) 514
if ( do_benchmark_all )  516
va_list va ; 518
char buf [ 1024 ] ; 519
if ( fmt )  520
vsnprintf ( buf , sizeof ( buf ) , fmt , va ); 522
printf ( ""bench: %8lu %s \n"" , t - current_time , buf ); 524",0,0
32392,"static void goodB2G2() 260
char * data ; 262
char dataBuffer [ 100 ] = """" ; 263
data = dataBuffer; 264
if ( globalFive == 5 )  265
WSADATA wsaData ; 269
int recvResult ; 272
struct sockaddr_in service ; 273
size_t dataLen = strlen ( data ) ; 277
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  281
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 288
if ( listenSocket == INVALID_SOCKET )  289
memset ( & service , 0 , sizeof ( service ) ); 293
service . sin_family = AF_INET; 294
service . sin_addr . s_addr = INADDR_ANY; 295
service . sin_port = htons ( TCP_PORT ); 296
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  297
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )  301
acceptSocket = accept ( listenSocket , NULL , NULL ); 305
if ( acceptSocket == SOCKET_ERROR )  306
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ); 311
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  312
data [ dataLen + recvResult / sizeof ( char ) ] = '\0'; 317
replace = strchr ( data , '\r' ); 319
if ( replace )  320
* replace = '\0'; 322
replace = strchr ( data , '\n' ); 324
if ( replace )  325
* replace = '\0'; 327
while ( 0 )  330
SNPRINTF ( dest , 100 - 1 , ""%s"" , data ); 352",0,0
154484,"void CWE401_Memory_Leak__char_calloc_44_bad() 30
char * data ; 32
data = NULL; 35
data = ( char * ) calloc ( 100 , sizeof ( char ) ); 37
strcpy ( data , ""A String"" ); 39
printLine ( data ); 40
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14
funcPtr ( data ); 42",0,0
43199,"void bad() 58
char * data ; 60
char dataBuffer [ FILENAME_MAX ] = """" ; 61
data = dataBuffer; 62
WSADATA wsaData ; 65
int recvResult ; 68
struct sockaddr_in service ; 69
size_t dataLen = strlen ( data ) ; 72
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  76
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 83
if ( connectSocket == INVALID_SOCKET )  84
memset ( & service , 0 , sizeof ( service ) ); 88
service . sin_family = AF_INET; 89
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS ); 90
service . sin_port = htons ( TCP_PORT ); 91
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  92
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ); 99
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  100
data [ dataLen + recvResult / sizeof ( char ) ] = '\0'; 105
replace = strchr ( data , '\r' ); 107
if ( replace )  108
* replace = '\0'; 110
replace = strchr ( data , '\n' ); 112
if ( replace )  113
* replace = '\0'; 115
while ( 0 )  118
badSink_b ( data ); 130
void badSink_b(char * data) 60
badSink_c ( data ); 62
void badSink_c(char * data) 60
badSink_d ( data ); 62
void badSink_d(char * data) 57
pFile = FOPEN ( data , ""wb+"" ); 62
if ( pFile != NULL )  63
fclose ( pFile ); 65",0,0
40078,"void parse_dir_colors() 155
char * * arg ; 158
char * * c ; 159
char * colors ; 160
char * s ; 161
int i ; 162
if ( Hflag )  165
if ( getenv ( ""TERM"" ) == ( ( void * ) 0 ) )  168
s = getenv ( ""TREE_COLORS"" ); 172
if ( s == ( ( void * ) 0 ) )  173
s = getenv ( ""LS_COLORS"" ); 174
if ( ( s == ( ( void * ) 0 ) || strlen ( s ) == 0 ) && force_color )  176
s = "":no=00:fi=00:di=01;34:ln=01;36:pi=40;33:so=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:ex=01;32:*.bat=01;32:*.BAT=01;32:*.btm=01;32:*.BTM=01;32:*.cmd=01;32:*.CMD=01;32:*.com=01;32:*.COM=01;32:*.dll=01;32:*.DLL=01;32:*.exe=01;32:*.EXE=01;32:*.arj=01;31:*.bz2=01;31:*.deb=01;31:*.gz=01;31:*.lzh=01;31:*.rpm=01;31:*.tar=01;31:*.taz=01;31:*.tb2=01;31:*.tbz2=01;31:*.tbz=01;31:*.tgz=01;31:*.tz2=01;31:*.z=01;31:*.Z=01;31:*.zip=01;31:*.ZIP=01;31:*.zoo=01;31:*.asf=01;35:*.ASF=01;35:*.avi=01;35:*.AVI=01;35:*.bmp=01;35:*.BMP=01;35:*.flac=01;35:*.FLAC=01;35:*.gif=01;35:*.GIF=01;35:*.jpg=01;35:*.JPG=01;35:*.jpeg=01;35:*.JPEG=01;35:*.m2a=01;35:*.M2a=01;35:*.m2v=01;35:*.M2V=01;35:*.mov=01;35:*.MOV=01;35:*.mp3=01;35:*.MP3=01;35:*.mpeg=01;35:*.MPEG=01;35:*.mpg=01;35:*.MPG=01;35:*.ogg=01;35:*.OGG=01;35:*.ppm=01;35:*.rm=01;35:*.RM=01;35:*.tga=01;35:*.TGA=01;35:*.tif=01;35:*.TIF=01;35:*.wav=01;35:*.WAV=01;35:*.wmv=01;35:*.WMV=01;35:*.xbm=01;35:*.xpm=01;35:""; 177
if ( s == ( ( void * ) 0 ) || ! force_color && ( nocolor || ! isatty ( 1 ) ) )  179
colors = strcpy ( ( xmalloc ( strlen ( s ) + 1 ) ) , s ); 188
arg = split ( colors , "":"" , & n ); 189
char **split(char *str,char *delim,int *nwrds) 374
int n = 128 ; 376
char * * w = ( xmalloc ( sizeof ( char * ) * n ) ) ; 377
w [ * nwrds = 0 ] = strtok ( str , delim ); 378
while ( w [ * nwrds ] )  379
if ( * nwrds == n - 2 )  380
w = ( xrealloc ( w , sizeof ( char * ) * ( n += 256 ) ) ); 381
w [ ++ * nwrds ] = strtok ( ( ( void * ) 0 ) , delim ); 383
w [ * nwrds ] = ( ( void * ) 0 ); 385
return w ; 386
for (i = 0; arg[i]; i++) 190
c = split ( arg [ i ] , ""="" , & n ); 191
char **split(char *str,char *delim,int *nwrds) 374
int n = 128 ; 376
char * * w = ( xmalloc ( sizeof ( char * ) * n ) ) ; 377
w [ * nwrds = 0 ] = strtok ( str , delim ); 378
while ( w [ * nwrds ] )  379
if ( * nwrds == n - 2 )  380
w = ( xrealloc ( w , sizeof ( char * ) * ( n += 256 ) ) ); 381
w [ ++ * nwrds ] = strtok ( ( ( void * ) 0 ) , delim ); 383
w [ * nwrds ] = ( ( void * ) 0 ); 385
return w ; 386
switch ( cmd ( c [ 0 ] ) )  192
int cmd(char *s) 389
static struct { char * cmd ; char cmdnum ; } cmds [ ] = { { ( ""no"" ) , ( COL_NORMAL ) } , { ( ""fi"" ) , ( COL_FILE ) } , { ( ""di"" ) , ( COL_DIR ) } , { ( ""ln"" ) , ( COL_LINK ) } , { ( ""pi"" ) , ( COL_FIFO ) } , { ( ""do"" ) , ( COL_DOOR ) } , { ( ""bd"" ) , ( COL_BLK ) } , { ( ""cd"" ) , ( COL_CHR ) } , { ( ""or"" ) , ( COL_ORPHAN ) } , { ( ""so"" ) , ( COL_SOCK ) } , { ( ""su"" ) , ( COL_SETUID ) } , { ( ""sg"" ) , ( COL_SETGID ) } , { ( ""tw"" ) , ( COL_STICKY_OTHER_WRITABLE ) } , { ( ""ow"" ) , ( COL_OTHER_WRITABLE ) } , { ( ""st"" ) , ( COL_STICKY ) } , { ( ""ex"" ) , ( COL_EXEC ) } , { ( ""mi"" ) , ( COL_MISSING ) } , { ( ""lc"" ) , ( COL_LEFTCODE ) } , { ( ""rc"" ) , ( COL_RIGHTCODE ) } , { ( ""ec"" ) , ( COL_ENDCODE ) } , { ( ( ( void * ) 0 ) ) , ( 0 ) } } ; 391
int i ; 394
for (i = 0; cmds[i] . cmdnum; i++) 395
if ( ! strcmp ( cmds [ i ] . cmd , s ) )  396
return cmds [ i ] . cmdnum ; 397
if ( s [ 0 ] == '*' )  399
return DOT_EXTENSION ; 400
return ERROR ; 402
if ( c [ 1 ] )  314
missing_flgs = strcpy ( ( xmalloc ( strlen ( c [ 1 ] ) + 1 ) ) , c [ 1 ] ); 315",0,0
55727,"static int CVE_2012_6542_VULN_llc_ui_getname(struct socket *sock, struct sockaddr *uaddr,
int *uaddrlen, int peer) 2
struct sockaddr_llc sllc ; 4
struct sock * sk = sock -> sk ; 5
struct llc_sock * llc = llc_sk ( sk ) ; 6
memset ( & sllc , 0 , sizeof ( sllc ) ); 9
if ( sock_flag ( sk , SOCK_ZAPPED ) )  11
if ( peer )  15
if ( sk -> sk_state != TCP_ESTABLISHED )  17
if ( llc -> dev )  19
sllc . sllc_arphrd = llc -> dev -> type; 20
sllc . sllc_sap = llc -> daddr . lsap; 21
if ( ! llc -> sap )  25
sllc . sllc_sap = llc -> sap -> laddr . lsap; 27
if ( llc -> dev )  29
sllc . sllc_arphrd = llc -> dev -> type; 30
memcpy ( & sllc . sllc_mac , llc -> dev -> dev_addr , IFHWADDRLEN ); 31
sllc . sllc_family = AF_LLC; 36
memcpy ( uaddr , & sllc , sizeof ( sllc ) ); 37",0,0
12719,"void regathered_sadhika(struct minuscular_shmaltzier choom_eisell) 4978
terreted_grandchild = ( ( char * ) ( ( struct minuscular_shmaltzier ) choom_eisell ) . euphyllopoda_dextranase ); 4987
stonesoup_buff = ( ( char * ) ( malloc ( 30000 * sizeof ( char ) ) ) ); 4989
memset ( stonesoup_buff , 0 , 30000 ); 4994
stonesoup_to_unsign = stonesoup_get_int_value ( terreted_grandchild ); 4997
short stonesoup_get_int_value(char *ss_tainted_buff) 362
short to_short = 0 ; 365
tainted_int = atoi ( ss_tainted_buff ); 367
if ( tainted_int != 0 )  368
if ( tainted_int > 30000 )  369
tainted_int = 30000; 370
if ( tainted_int < - 30000 )  371
tainted_int = - 30000; 372
to_short = ( ( short ) tainted_int ); 373
return to_short ; 375
stonesoup_file = fopen ( ""/opt/stonesoup/workspace/testData/myfile.txt"" , ""r"" ); 5001
if ( stonesoup_file != 0 )  5002
stonesoup_buff [ stonesoup_to_unsign ] = '\0'; 5015
stonesoup_printf ( ""buff is %d long, and has contents: %s \n"" , strlen ( stonesoup_buff ) , stonesoup_buff ); 5016",0,0
94250,"cgiEnvironmentResultType cgiReadEnvironment(char *filename) 2036
FILE * in ; 2037
in = fopen ( filename , ""rb"" ); 2045
if ( ! cgiReadString ( in , & cgiServerSoftware ) )  2060
if ( ! cgiReadString ( in , & cgiServerName ) )  2063
if ( ! cgiReadString ( in , & cgiGatewayInterface ) )  2066
if ( ! cgiReadString ( in , & cgiServerProtocol ) )  2069
if ( ! cgiReadString ( in , & cgiServerPort ) )  2072
if ( ! cgiReadString ( in , & cgiRequestMethod ) )  2075
if ( ! cgiReadString ( in , & cgiPathInfo ) )  2078
if ( ! cgiReadString ( in , & cgiPathTranslated ) )  2081
if ( ! cgiReadString ( in , & cgiScriptName ) )  2084
static int cgiReadString(FILE *in, char **s) 2250
int len ; 2251
if ( ! cgiReadInt ( in , & len ) )  2253
* s = ( char * ) malloc ( len + 1 ); 2256
if ( ! ( * s ) )  2257
if ( ( ( int ) fread ( * s , 1 , len , in ) ) != len )  2260
( * s ) [ len ] = '\0'; 2263",0,0
174393,"static void goodG2B() 145
short data ; 147
CWE194_Unexpected_Sign_Extension__connect_socket_malloc_34_unionType myUnion ; 148
data = 0; 150
data = 100 - 1; 152
myUnion . unionFirst = data; 153
short data = myUnion . unionSecond ; 155
if ( data < 100 )  157
char * dataBuffer = ( char * ) malloc ( data ) ; 161
memset ( dataBuffer , 'A' , data - 1 ); 163
dataBuffer [ data - 1 ] = '\0'; 164
printLine ( dataBuffer ); 165
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14
free ( dataBuffer ); 166",0,0
741,"void CWE78_OS_Command_Injection__char_file_system_42_bad() 68
char * data ; 70
char data_buf [ 100 ] = FULL_COMMAND ; 71
data = data_buf; 72
data = badSource ( data ); 73
static char * badSource(char * data) 42
size_t dataLen = strlen ( data ) ; 46
FILE * pFile ; 47
if ( 100 - dataLen > 1 )  49
pFile = fopen ( FILENAME , ""r"" ); 51
if ( pFile != NULL )  52
if ( fgets ( data + dataLen , ( int ) ( 100 - dataLen ) , pFile ) == NULL )  55
data [ dataLen ] = '\0'; 59
return data ; 65",0,0
53968,"void CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_vfprintf_22_bad() 53
wchar_t * data ; 55
wchar_t dataBuffer [ 100 ] = L """" 56
data = dataBuffer; 57
WSADATA wsaData ; 60
int recvResult ; 63
struct sockaddr_in service ; 64
size_t dataLen = wcslen ( data ) ; 67
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  71
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 78
if ( connectSocket == INVALID_SOCKET )  79
memset ( & service , 0 , sizeof ( service ) ); 83
service . sin_family = AF_INET; 84
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS ); 85
service . sin_port = htons ( TCP_PORT ); 86
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  87
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ); 94
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  95
while ( 0 )  113",0,0
73070,"static void goodG2B() 81
char * data ; 83
char dataBuffer [ FILENAME_MAX ] = """" ; 85
data = dataBuffer; 86
strcat ( data , ""c:\\temp\\file.txt"" ); 89
myStruct . structFirst = data; 94
goodG2BSink ( myStruct ); 95
void goodG2BSink(structType myStruct) 69
char * data = myStruct . structFirst ; 71
fileDesc = OPEN ( data , O_RDWR | O_CREAT , S_IREAD | S_IWRITE ); 75
if ( fileDesc != - 1 )  76
CLOSE ( fileDesc ); 78",0,0
80343,"void bad() 62
char * data ; 64
char dataBuffer [ FILENAME_MAX ] = """" ; 65
data = dataBuffer; 66
data = badSource ( data ); 67
static char * badSource(char * data) 36
size_t dataLen = strlen ( data ) ; 40
if ( FILENAME_MAX - dataLen > 1 )  43
if ( fgets ( data + dataLen , ( int ) ( FILENAME_MAX - dataLen ) , pFile ) == NULL )  49
data [ dataLen ] = '\0'; 53
return data ; 59",0,0
149171,"void bad() 29
char * data ; 31
char dataBuffer [ 100 ] ; 32
data = dataBuffer; 33
size_t sourceLen ; 36
char source [ 100 ] ; 37
memset ( source , 'C' , 100 - 1 ); 38
source [ 100 - 1 ] = '\0'; 39
sourceLen = strlen ( source ); 40
strncat ( data , source , sourceLen ); 42
printLine ( data ); 43
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",0,0
77102,"void bad() 39
char * data ; 41
char dataBuffer [ FILENAME_MAX ] = """" ; 42
data = dataBuffer; 43
if ( staticFive == 5 )  44
size_t dataLen = strlen ( data ) ; 48
if ( FILENAME_MAX - dataLen > 1 )  50
if ( fgets ( data + dataLen , ( int ) ( FILENAME_MAX - dataLen ) , stdin ) != NULL )  53
dataLen = strlen ( data ); 57
if ( dataLen > 0 && data [ dataLen - 1 ] == '\n' )  58
data [ dataLen - 1 ] = '\0'; 60",0,0
41098,"void col_append_sep_fstr(column_info *cinfo,const gint el,const gchar *separator,const gchar *format,... ) 402
int i ; 404
int len ; 405
if ( ! ( ( ( cinfo ? cinfo -> writable : 0 ) ) && cinfo -> col_first [ el ] >= 0 ) )  409
for (i = cinfo -> col_first[el]; i <= cinfo -> col_last[el]; i++) 423
if ( cinfo -> fmt_matx [ i ] [ el ] )  424
if ( cinfo -> col_data [ i ] != cinfo -> col_buf [ i ] )  428
cinfo -> col_data [ i ] = cinfo -> col_buf [ i ]; 430
len = ( ( int ) ( strlen ( cinfo -> col_buf [ i ] ) ) ); 433
if ( len != 0 )  438
len += sep_len; 440
g_vsnprintf ( & cinfo -> col_buf [ i ] [ len ] , ( max_len - len ) , format , ap ); 444",0,0
176472,"void dfacomp(const char *s,size_t len,struct dfa *d,int searchflag) 3740
dfamust ( d ); 3744
static void dfamust(struct dfa *d) 4036
must * musts ; 4038
must * mp ; 4039
size_t ri ; 4041
size_t i ; 4042
token t ; 4044
static must must0 ; 4045
musts = ( ( sizeof ( ( * musts ) ) == 1 ? xmalloc ( d -> tindex + 1 ) : xnmalloc ( d -> tindex + 1 , sizeof ( ( * musts ) ) ) ) ); 4057
while ( 0 )  4058
mp = musts; 4059
for (i = 0; i <= d -> tindex; ++i) 4060
mp [ i ] = must0; 4061
for (i = 0; i <= d -> tindex; ++i) 4062
mp [ i ] . in = ( xmalloc ( sizeof ( ( * mp [ i ] . in ) ) ) ); 4063
mp [ i ] . left = ( xmalloc ( 2 ) ); 4064
mp [ i ] . right = ( xmalloc ( 2 ) ); 4065
mp [ i ] . is = ( xmalloc ( 2 ) ); 4066
mp [ i ] . left [ 0 ] = mp [ i ] . right [ 0 ] = mp [ i ] . is [ 0 ] = '\0'; 4067
mp [ i ] . in [ 0 ] = ( ( void * ) 0 ); 4068
for (ri = 0; ri < d -> tindex; ++ri) 4072
switch ( t = d -> tokens [ ri ] )  4073
must * lmp ; 4120
must * rmp ; 4121
size_t j ; 4122
size_t ln ; 4123
rmp = -- mp; 4126
lmp = -- mp; 4127
if ( ! ( strcmp ( ( lmp -> is ) , ( rmp -> is ) ) == 0 ) )  4129
lmp -> is [ 0 ] = '\0'; 4130
i = 0; 4133
lmp -> left [ i ] = '\0'; 4136
ln = strlen ( ( lmp -> right ) ); 4138
for (j = 0; j < i; ++j) 4148
lmp -> right [ j ] = lmp -> right [ ln - i + j ]; 4149
lmp -> right [ j ] = '\0'; 4150
mp -> is [ 0 ] = '\0'; 4165
must * lmp ; 4184
must * rmp ; 4185
rmp = -- mp; 4186
lmp = -- mp; 4187
lmp -> in = addlists ( lmp -> in , rmp -> in ); 4191
if ( lmp -> in == ( ( void * ) 0 ) )  4192
if ( lmp -> right [ 0 ] != '\0' && rmp -> left [ 0 ] != '\0' )  4195
char * tp ; 4196
tp = icpyalloc ( ( lmp -> right ) ); 4197
tp = icatalloc ( tp , ( rmp -> left ) ); 4198
lmp -> in = enlist ( lmp -> in , tp , strlen ( tp ) ); 4199
if ( lmp -> in == ( ( void * ) 0 ) )  4201
if ( lmp -> is [ 0 ] != '\0' )  4206
lmp -> left = icatalloc ( lmp -> left , ( rmp -> left ) ); 4207
if ( lmp -> left == ( ( void * ) 0 ) )  4208
if ( rmp -> is [ 0 ] == '\0' )  4213
lmp -> right [ 0 ] = '\0'; 4214
lmp -> right = icatalloc ( lmp -> right , ( rmp -> right ) ); 4216
if ( lmp -> right == ( ( void * ) 0 ) )  4217
if ( lmp -> is [ 0 ] != '\0' && rmp -> is [ 0 ] != '\0' )  4221
lmp -> is = icatalloc ( lmp -> is , ( rmp -> is ) ); 4222
if ( lmp -> is == ( ( void * ) 0 ) )  4223
lmp -> is [ 0 ] = '\0'; 4228
if ( t < END )  4235
if ( t == '\0' )  4239
if ( t >= CSET || ! 1 || t == ANYCHAR || t == MBCSET )  4244
resetmust ( mp ); 4246
mp -> is [ 0 ] = mp -> left [ 0 ] = mp -> right [ 0 ] = t; 4251
mp -> is [ 1 ] = mp -> left [ 1 ] = mp -> right [ 1 ] = '\0'; 4252
mp -> in = enlist ( mp -> in , mp -> is , ( ( size_t ) 1 ) ); 4253
if ( mp -> in == ( ( void * ) 0 ) )  4254
static void resetmust(must *mp) 4030
mp -> left [ 0 ] = mp -> right [ 0 ] = mp -> is [ 0 ] = '\0'; 4032
freelist ( mp -> in ); 4033
static void freelist(char **cpp) 3878
size_t i ; 3880
if ( cpp == ( ( void * ) 0 ) )  3881
for (i = 0; cpp[i] != ((void *)0); ++i) 3884
free ( cpp [ i ] ); 3885
cpp [ i ] = ( ( void * ) 0 ); 3886",0,0
2204,"void bad() 32
char * data ; 34
map < int , char * > dataMap ; 35
data = new char [ 100 ]; 36
memset ( data , 'A' , 100 - 1 ); 38
data [ 100 - 1 ] = '\0'; 39
dataMap [ 0 ] = data; 41
dataMap [ 1 ] = data; 42
dataMap [ 2 ] = data; 43
badSink ( dataMap ); 44
void badSink(map<int, char *> dataMap) 29
char * data = dataMap [ 2 ] ; 32
size_t i , dataLen ; 35
dataLen = strlen ( data ); 36
for (i = 0; i < dataLen; i++) 38",0,0
75420,"static void goodG2B1() 140
int data ; 142
data = - 1; 144
if ( 5 != 5 )  145
data = 20; 153
int * intPointer ; 157
intPointer = ( int * ) malloc ( data * sizeof ( int ) ); 160
intPointer [ i ] = 0; 163
printIntLine ( intPointer [ 0 ] ); 165
void printIntLine (int intNumber) 26
printf ( ""%d\n"" , intNumber ); 28
free ( intPointer ); 166",0,0
156947,"static void goodB2G2() 67
char * data ; 69
data = NULL; 70
data = ( char * ) calloc ( 20 , sizeof ( char ) ); 72
if ( 5 == 5 )  73
if ( data != NULL )  76
strcpy ( data , ""Initialize"" ); 78
printLine ( data ); 79
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14
free ( data ); 80",0,0
86722,"void bad() 72
wchar_t * data ; 74
wchar_t dataBuffer [ FILENAME_MAX ] = BASEPATH ; 75
data = dataBuffer; 76
WSADATA wsaData ; 79
int recvResult ; 82
struct sockaddr_in service ; 83
size_t dataLen = wcslen ( data ) ; 87
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  91
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 98
if ( listenSocket == INVALID_SOCKET )  99
memset ( & service , 0 , sizeof ( service ) ); 103
service . sin_family = AF_INET; 104
service . sin_addr . s_addr = INADDR_ANY; 105
service . sin_port = htons ( TCP_PORT ); 106
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  107
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )  111
acceptSocket = accept ( listenSocket , NULL , NULL ); 115
if ( acceptSocket == SOCKET_ERROR )  116
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ); 121
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  122
while ( 0 )  140
if ( listenSocket != INVALID_SOCKET )  141
CLOSE_SOCKET ( listenSocket ); 143
if ( acceptSocket != INVALID_SOCKET )  145
CLOSE_SOCKET ( acceptSocket ); 147",0,0
20657,"bool
PointerType::ContentsSetter(JSContext* cx, JS::CallArgs args) 4240
RootedObject obj ( cx , & args . thisv ( ) . toObject ( ) ) ; 4242
RootedObject baseType ( cx , GetBaseType ( CData :: GetCType ( obj ) ) ) ; 4243
if ( ! CType :: IsSizeDefined ( baseType ) )  4244
void * data = * static_cast < void * * > CData :: GetData ( obj ) 4249
if ( data == nullptr )  4250
return ImplicitConvert ( cx , args . get ( 0 ) , baseType , data , false , nullptr ) ; 4256
static bool
ImplicitConvert(JSContext* cx,
HandleValue val,
JSObject* targetType_,
void* buffer,
bool isArgument,
bool* freePointer) 2287
RootedObject targetType ( cx , targetType_ ) ; 2289
JSObject * sourceData = nullptr ; 2294
JSObject * sourceType = nullptr ; 2295
RootedObject valObj ( cx , nullptr ) ; 2296
if ( val . isObject ( ) )  2297
valObj = & val . toObject ( ); 2298
if ( CData :: IsCData ( valObj ) )  2299
sourceData = valObj; 2300
sourceType = CData :: GetCType ( sourceData ); 2301
if ( CType :: TypesEqual ( sourceType , targetType ) )  2305
if ( CDataFinalizer :: IsCDataFinalizer ( valObj ) )  2310
sourceData = valObj; 2311
sourceType = CDataFinalizer :: GetCType ( cx , sourceData ); 2312
CDataFinalizer :: Private * p = ( CDataFinalizer :: Private * ) JS_GetPrivate ( sourceData ) ; 2314
if ( ! p )  2317
if ( CType :: TypesEqual ( sourceType , targetType ) )  2324
TypeCode targetCode = CType :: GetTypeCode ( targetType ) ; 2331
switch ( targetCode )  2333
if ( val . isNull ( ) )  2392
JS :: Rooted < JSObject * > baseType ( cx , PointerType :: GetBaseType ( targetType ) ) ; 2398
if ( sourceData )  2399
TypeCode sourceCode = CType :: GetTypeCode ( sourceType ) ; 2401
bool voidptrTarget = CType :: GetTypeCode ( baseType ) == TYPE_void_t ; 2403
if ( sourceCode == TYPE_pointer && voidptrTarget )  2405
if ( sourceCode == TYPE_array )  2410
JSObject * elementType = ArrayType :: GetBaseType ( sourceType ) ; 2413
if ( voidptrTarget || CType :: TypesEqual ( baseType , elementType ) )  2414
* static_cast < void * * > ( buffer ) = sourceBuffer 2415
if ( isArgument && val . isString ( ) )  2420
if ( val . isObject ( ) && JS_IsArrayBufferObject ( valObj ) )  2477
if ( val . isObject ( ) && JS_IsArrayBufferViewObject ( valObj ) )  2495
if ( ! CanConvertTypedArrayItemTo ( baseType , valObj , cx ) )  2498
if ( ! isArgument )  2501
void * ptr ; 2504
JS :: AutoCheckCannotGC nogc ; 2506
ptr = JS_GetArrayBufferViewData ( valObj , nogc ); 2507
if ( ! ptr )  2509
* static_cast < void * * > ( buffer ) = ptr 2512
RootedObject baseType ( cx , ArrayType :: GetBaseType ( targetType ) ) ; 2518
size_t targetLength = ArrayType :: GetLength ( targetType ) ; 2519
if ( val . isString ( ) )  2521
if ( val . isObject ( ) && JS_IsArrayObject ( cx , valObj ) )  2578
uint32_t sourceLength ; 2580
if ( ! JS_GetArrayLength ( cx , valObj , & sourceLength ) || targetLength != size_t ( sourceLength ) )  2581
size_t elementSize = CType :: GetSize ( baseType ) ; 2588
auto intermediate = cx -> make_pod_array < char > ( arraySize ) 2590
if ( ! intermediate )  2591
for (uint32_t i = 0; i < sourceLength; ++i) 2596
RootedValue item ( cx ) ; 2597
if ( ! JS_GetElement ( cx , valObj , i , & item ) )  2598
char * data = intermediate . get ( ) + elementSize * i ; 2601
if ( ! ImplicitConvert ( cx , item , baseType , data , false , nullptr ) )  2602
static bool
ImplicitConvert(JSContext* cx,
HandleValue val,
JSObject* targetType_,
void* buffer,
bool isArgument,
bool* freePointer) 2287
RootedObject targetType ( cx , targetType_ ) ; 2289
JSObject * sourceData = nullptr ; 2294
JSObject * sourceType = nullptr ; 2295
RootedObject valObj ( cx , nullptr ) ; 2296
if ( val . isObject ( ) )  2297
valObj = & val . toObject ( ); 2298
if ( CData :: IsCData ( valObj ) )  2299
sourceData = valObj; 2300
sourceType = CData :: GetCType ( sourceData ); 2301
if ( CType :: TypesEqual ( sourceType , targetType ) )  2305
if ( CDataFinalizer :: IsCDataFinalizer ( valObj ) )  2310
sourceData = valObj; 2311
sourceType = CDataFinalizer :: GetCType ( cx , sourceData ); 2312
CDataFinalizer :: Private * p = ( CDataFinalizer :: Private * ) JS_GetPrivate ( sourceData ) ; 2314
if ( ! p )  2317
if ( CType :: TypesEqual ( sourceType , targetType ) )  2324
TypeCode targetCode = CType :: GetTypeCode ( targetType ) ; 2331
switch ( targetCode )  2333
bool result ; 2337
if ( ! jsvalToBool ( cx , val , & result ) )  2338
* static_cast < bool * > ( buffer ) = result 2340
type result ; 2347
type result ; 2367
type result ; 2383
if ( ! jsvalToFloat ( cx , val , & result ) )  2384
* static_cast < type * > ( buffer ) = result 2386
if ( val . isNull ( ) )  2392
* static_cast < void * * > ( buffer ) = nullptr 2394
JS :: Rooted < JSObject * > baseType ( cx , PointerType :: GetBaseType ( targetType ) ) ; 2398
if ( sourceData )  2399
TypeCode sourceCode = CType :: GetTypeCode ( sourceType ) ; 2401
bool voidptrTarget = CType :: GetTypeCode ( baseType ) == TYPE_void_t ; 2403
if ( sourceCode == TYPE_pointer && voidptrTarget )  2405
if ( sourceCode == TYPE_array )  2410
JSObject * elementType = ArrayType :: GetBaseType ( sourceType ) ; 2413
if ( voidptrTarget || CType :: TypesEqual ( baseType , elementType ) )  2414
* static_cast < void * * > ( buffer ) = sourceBuffer 2415
if ( isArgument && val . isString ( ) )  2420
if ( val . isObject ( ) && JS_IsArrayBufferObject ( valObj ) )  2477
if ( val . isObject ( ) && JS_IsArrayBufferViewObject ( valObj ) )  2495
if ( ! CanConvertTypedArrayItemTo ( baseType , valObj , cx ) )  2498
if ( ! isArgument )  2501
void * ptr ; 2504
JS :: AutoCheckCannotGC nogc ; 2506
ptr = JS_GetArrayBufferViewData ( valObj , nogc ); 2507
if ( ! ptr )  2509
* static_cast < void * * > ( buffer ) = ptr 2512
RootedObject baseType ( cx , ArrayType :: GetBaseType ( targetType ) ) ; 2518
size_t targetLength = ArrayType :: GetLength ( targetType ) ; 2519
if ( val . isString ( ) )  2521
JSString * sourceString = val . toString ( ) ; 2522
JSLinearString * sourceLinear = sourceString -> ensureLinear ( cx ) ; 2524
if ( ! sourceLinear )  2525
switch ( CType :: GetTypeCode ( baseType ) )  2528
size_t nbytes = GetDeflatedUTF8StringLength ( cx , sourceLinear ) ; 2533
if ( nbytes == ( size_t ) - 1 )  2535
if ( targetLength < nbytes )  2538
char * charBuffer = static_cast < char * > buffer 2543
if ( val . isObject ( ) && ! sourceData )  2646
AutoIdArray props ( cx , JS_Enumerate ( cx , valObj ) ) ; 2649
if ( ! props )  2650
auto intermediate = cx -> make_pod_array < char > ( structSize ) 2655
if ( ! intermediate )  2656
const FieldInfoHash * fields = StructType :: GetFieldInfo ( targetType ) ; 2661
if ( props . length ( ) != fields -> count ( ) )  2662
RootedId id ( cx ) ; 2667
for (size_t i = 0; i < props.length(); ++i) 2668
id = props [ i ]; 2669
if ( ! JSID_IS_STRING ( id ) )  2671
JSFlatString * name = JSID_TO_FLAT_STRING ( id ) ; 2676
const FieldInfo * field = StructType :: LookupField ( cx , targetType , name ) ; 2677
if ( ! field )  2678
RootedValue prop ( cx ) ; 2681
if ( ! JS_GetPropertyById ( cx , valObj , id , & prop ) )  2682
char * fieldData = intermediate . get ( ) + field -> mOffset ; 2686
if ( ! ImplicitConvert ( cx , prop , field -> mType , fieldData , false , nullptr ) )  2687
static bool
ImplicitConvert(JSContext* cx,
HandleValue val,
JSObject* targetType_,
void* buffer,
bool isArgument,
bool* freePointer) 2287
RootedObject targetType ( cx , targetType_ ) ; 2289
RootedObject valObj ( cx , nullptr ) ; 2296
if ( val . isObject ( ) )  2297
valObj = & val . toObject ( ); 2298
if ( CData :: IsCData ( valObj ) )  2299
sourceData = valObj; 2300
sourceType = CData :: GetCType ( sourceData ); 2301
if ( CType :: TypesEqual ( sourceType , targetType ) )  2305
if ( CDataFinalizer :: IsCDataFinalizer ( valObj ) )  2310
sourceData = valObj; 2311
sourceType = CDataFinalizer :: GetCType ( cx , sourceData ); 2312
CDataFinalizer :: Private * p = ( CDataFinalizer :: Private * ) JS_GetPrivate ( sourceData ) ; 2314
if ( ! p )  2317
if ( CType :: TypesEqual ( sourceType , targetType ) )  2324
TypeCode targetCode = CType :: GetTypeCode ( targetType ) ; 2331
switch ( targetCode )  2333
if ( val . isNull ( ) )  2392
JS :: Rooted < JSObject * > baseType ( cx , PointerType :: GetBaseType ( targetType ) ) ; 2398
RootedObject baseType ( cx , ArrayType :: GetBaseType ( targetType ) ) ; 2518
size_t targetLength = ArrayType :: GetLength ( targetType ) ; 2519
if ( val . isString ( ) )  2521
if ( val . isObject ( ) && JS_IsArrayObject ( cx , valObj ) )  2578
if ( val . isObject ( ) && JS_IsArrayBufferObject ( valObj ) )  2608
if ( val . isObject ( ) && JS_IsTypedArrayObject ( valObj ) )  2621
if ( ! CanConvertTypedArrayItemTo ( baseType , valObj , cx ) )  2624
uint32_t sourceLength = JS_GetTypedArrayByteLength ( valObj ) ; 2628
size_t elementSize = CType :: GetSize ( baseType ) ; 2629
size_t arraySize = elementSize * targetLength ; 2630
if ( arraySize != size_t ( sourceLength ) )  2631
JS :: AutoCheckCannotGC nogc ; 2635
memcpy ( buffer , JS_GetArrayBufferViewData ( valObj , nogc ) , sourceLength ); 2636",0,0
147342,"void CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_ncat_21_bad() 37
wchar_t * data ; 39
data = ( wchar_t * ) malloc ( 100 * sizeof ( wchar_t ) ); 40
data = badSource ( data ); 42
static wchar_t * badSource(wchar_t * data) 26
if ( badStatic )  28
wmemset ( data , L 'A' , 100 - 1 )
data [ 100 - 1 ] = L '\0' 32
return data ; 34
free ( data ); 49",0,0
156626,"static void goodB2G() 58
int * data ; 60
data = NULL; 61
goodB2GSource ( data ); 62
void goodB2GSource(int * &data) 51
data = ( int * ) realloc ( data , 100 * sizeof ( int ) ); 54
data [ 0 ] = 5; 56
printIntLine ( data [ 0 ] ); 57
void printIntLine (int intNumber) 26
printf ( ""%d\n"" , intNumber ); 28",0,0
79171,"void parse_dir_colors() 228
char * s ; 234
if ( Hflag )  238
if ( getenv ( ""TERM"" ) == ( ( void * ) 0 ) )  241
s = getenv ( ""TREE_COLORS"" ); 245
if ( s == ( ( void * ) 0 ) )  246
s = getenv ( ""LS_COLORS"" ); 247
if ( ( s == ( ( void * ) 0 ) || strlen ( s ) == 0 ) && force_color )  249
if ( s == ( ( void * ) 0 ) || ! force_color && ( nocolor || ! isatty ( 1 ) ) )  252
colors = strcpy ( ( xmalloc ( strlen ( s ) + 1 ) ) , s ); 261
arg = split ( colors , "":"" , & n ); 262
char **split(char *str,char *delim,int *nwrds) 447
w [ * nwrds = 0 ] = strtok ( str , delim ); 451
while ( w [ * nwrds ] )  452
if ( * nwrds == n - 2 )  453
w = ( xrealloc ( w , sizeof ( char * ) * ( n += 256 ) ) ); 454
w [ ++ * nwrds ] = strtok ( ( ( void * ) 0 ) , delim ); 456
w [ * nwrds ] = ( ( void * ) 0 ); 458
return w ; 459
for (i = 0; arg[i]; i++) 263
c = split ( arg [ i ] , ""="" , & n ); 264
char **split(char *str,char *delim,int *nwrds) 447
w [ * nwrds = 0 ] = strtok ( str , delim ); 451
while ( w [ * nwrds ] )  452
if ( * nwrds == n - 2 )  453
w = ( xrealloc ( w , sizeof ( char * ) * ( n += 256 ) ) ); 454
w [ ++ * nwrds ] = strtok ( ( ( void * ) 0 ) , delim ); 456
w [ * nwrds ] = ( ( void * ) 0 ); 458
return w ; 459
switch ( cmd ( c [ 0 ] ) )  265
int cmd(char *s) 462
if ( ! strcmp ( cmds [ i ] . cmd , s ) )  469
if ( s [ 0 ] == '*' )  472
if ( c [ 1 ] )  268
norm_flgs = strcpy ( ( xmalloc ( strlen ( c [ 1 ] ) + 1 ) ) , c [ 1 ] ); 269
if ( c [ 1 ] )  275
file_flgs = strcpy ( ( xmalloc ( strlen ( c [ 1 ] ) + 1 ) ) , c [ 1 ] ); 276
if ( c [ 1 ] )  282
dir_flgs = strcpy ( ( xmalloc ( strlen ( c [ 1 ] ) + 1 ) ) , c [ 1 ] ); 283
if ( c [ 1 ] )  289
if ( strcasecmp ( ""target"" , c [ 1 ] ) == 0 )  290
link_flgs = strcpy ( ( xmalloc ( strlen ( c [ 1 ] ) + 1 ) ) , c [ 1 ] ); 296
if ( c [ 1 ] )  303
fifo_flgs = strcpy ( ( xmalloc ( strlen ( c [ 1 ] ) + 1 ) ) , c [ 1 ] ); 304
if ( c [ 1 ] )  310
door_flgs = strcpy ( ( xmalloc ( strlen ( c [ 1 ] ) + 1 ) ) , c [ 1 ] ); 311
if ( c [ 1 ] )  317
block_flgs = strcpy ( ( xmalloc ( strlen ( c [ 1 ] ) + 1 ) ) , c [ 1 ] ); 318
if ( c [ 1 ] )  324
char_flgs = strcpy ( ( xmalloc ( strlen ( c [ 1 ] ) + 1 ) ) , c [ 1 ] ); 325
if ( c [ 1 ] )  331
orphan_flgs = strcpy ( ( xmalloc ( strlen ( c [ 1 ] ) + 1 ) ) , c [ 1 ] ); 332
if ( c [ 1 ] )  338
sock_flgs = strcpy ( ( xmalloc ( strlen ( c [ 1 ] ) + 1 ) ) , c [ 1 ] ); 339
if ( c [ 1 ] )  345
suid_flgs = strcpy ( ( xmalloc ( strlen ( c [ 1 ] ) + 1 ) ) , c [ 1 ] ); 346
if ( c [ 1 ] )  352
sgid_flgs = strcpy ( ( xmalloc ( strlen ( c [ 1 ] ) + 1 ) ) , c [ 1 ] ); 353
if ( c [ 1 ] )  359
stickyow_flgs = strcpy ( ( xmalloc ( strlen ( c [ 1 ] ) + 1 ) ) , c [ 1 ] ); 360
if ( c [ 1 ] )  366
otherwr_flgs = strcpy ( ( xmalloc ( strlen ( c [ 1 ] ) + 1 ) ) , c [ 1 ] ); 367
if ( c [ 1 ] )  373
sticky_flgs = strcpy ( ( xmalloc ( strlen ( c [ 1 ] ) + 1 ) ) , c [ 1 ] ); 374
if ( c [ 1 ] )  380
exec_flgs = strcpy ( ( xmalloc ( strlen ( c [ 1 ] ) + 1 ) ) , c [ 1 ] ); 381
if ( c [ 1 ] )  387
missing_flgs = strcpy ( ( xmalloc ( strlen ( c [ 1 ] ) + 1 ) ) , c [ 1 ] ); 388
if ( c [ 1 ] )  394
leftcode = strcpy ( ( xmalloc ( strlen ( c [ 1 ] ) + 1 ) ) , c [ 1 ] ); 395
if ( c [ 1 ] )  401
rightcode = strcpy ( ( xmalloc ( strlen ( c [ 1 ] ) + 1 ) ) , c [ 1 ] ); 402
if ( c [ 1 ] )  408
endcode = strcpy ( ( xmalloc ( strlen ( c [ 1 ] ) + 1 ) ) , c [ 1 ] ); 409
if ( c [ 1 ] )  414
e -> ext = strcpy ( ( xmalloc ( strlen ( ( c [ 0 ] + 1 ) ) + 1 ) ) , ( c [ 0 ] + 1 ) ); 416
e -> term_flg = strcpy ( ( xmalloc ( strlen ( c [ 1 ] ) + 1 ) ) , c [ 1 ] ); 417
e -> nxt = ext; 418
ext = e; 419
free ( c ); 422
free ( arg ); 424
if ( ! leftcode )  426
if ( ! rightcode )  429
if ( ! norm_flgs )  432
if ( ! endcode )  435
sprintf ( buf , ""%s%s%s"" , leftcode , norm_flgs , rightcode ); 436
endcode = strcpy ( ( xmalloc ( strlen ( buf ) + 1 ) ) , buf ); 437
free ( colors ); 439",0,0
134634,"static void goodG2B() 47
char * data ; 49
char * dataGoodBuffer = ( char * ) ALLOCA ( 100 * sizeof ( char ) ) ; 51
data = dataGoodBuffer; 53
data [ 0 ] = '\0'; 54
char source [ 100 ] ; 56
memset ( source , 'C' , 100 - 1 ); 57
source [ 100 - 1 ] = '\0'; 58
strncat ( data , source , 100 ); 60
printLine ( data ); 61
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",0,0
20535,"static void goodB2G2() 124
char * data ; 126
char dataBuffer [ 100 ] = """" ; 127
data = dataBuffer; 128
if ( staticReturnsTrue ( ) )  129
static int staticReturnsTrue() 41
return 1 ; 43
size_t dataLen = strlen ( data ) ; 133
char * environment = GETENV ( ENV_VARIABLE ) ; 134
if ( environment != NULL )  136
strncat ( data + dataLen , environment , 100 - dataLen - 1 ); 139
SNPRINTF ( dest , 100 - 1 , ""%s"" , data ); 148",0,0
18149,"void CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_printf_65_bad() 50
wchar_t * data ; 52
data = dataBuffer; 56
WSADATA wsaData ; 59
int recvResult ; 62
struct sockaddr_in service ; 63
size_t dataLen = wcslen ( data ) ; 67
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  71
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 78
if ( listenSocket == INVALID_SOCKET )  79
memset ( & service , 0 , sizeof ( service ) ); 83
service . sin_family = AF_INET; 84
service . sin_addr . s_addr = INADDR_ANY; 85
service . sin_port = htons ( TCP_PORT ); 86
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  87
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )  91
acceptSocket = accept ( listenSocket , NULL , NULL ); 95
if ( acceptSocket == SOCKET_ERROR )  96
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ); 101
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  102
while ( 0 )  120
if ( listenSocket != INVALID_SOCKET )  121
CLOSE_SOCKET ( listenSocket ); 123
if ( acceptSocket != INVALID_SOCKET )  125
CLOSE_SOCKET ( acceptSocket ); 127",0,0
98656,"static void goodG2B1() 60
char * data ; 62
data = ( char * ) malloc ( 100 * sizeof ( char ) ); 63
if ( staticFalse )  64
memset ( data , 'A' , 50 - 1 ); 72
data [ 50 - 1 ] = '\0'; 73
SNPRINTF ( dest , strlen ( data ) , ""%s"" , data ); 78
printLine ( data ); 79
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14
free ( data ); 80",0,0
170725,"void dfacomp(const char *s,size_t len,struct dfa *d,int searchflag) 3826
dfaanalyze ( d , searchflag ); 3832
void dfaanalyze(struct dfa *d,int searchflag) 2600
position * lastpos ; 2611
position * o_lastpos ; 2622
d -> searchflag = searchflag; 2628
lastpos = ( ( sizeof ( ( * lastpos ) ) == 1 ? xmalloc ( d -> nleaves ) : xnmalloc ( d -> nleaves , sizeof ( ( * lastpos ) ) ) ) ); 2646
while ( 0 )  2647
o_lastpos = lastpos , lastpos += d -> nleaves; 2648
free ( o_lastpos ); 2790",0,0
120244,"static void goodG2B() 38
int * data ; 40
data = NULL; 41
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int_memcpy_84_goodG2B * goodG2BObject = new CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int_memcpy_84_goodG2B ( data ) ; 42
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int_memcpy_84_goodG2B::CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int_memcpy_84_goodG2B(int * dataCopy) 23
data = dataCopy; 25
data = ( int * ) malloc ( 100 * sizeof ( int ) ); 27
delete goodG2BObject 43
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int_memcpy_84_goodG2B::~CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int_memcpy_84_goodG2B() 30
int source [ 100 ] = { 0 } ; 33
memcpy ( data , source , 100 * sizeof ( int ) ); 35
free ( data ); 37",0,0
60747,"static void goodG2B2() 74
char * data ; 76
char * dataBuffer = ( char * ) ALLOCA ( 100 * sizeof ( char ) ) ; 77
data = dataBuffer; 78
if ( globalReturnsTrue ( ) )  79
int globalReturnsTrue() 147
return 1 ; 149
memset ( data , 'A' , 50 - 1 ); 82
data [ 50 - 1 ] = '\0'; 83
char dest [ 50 ] = """" ; 86
strncat ( dest , data , strlen ( data ) ); 88
dest [ 50 - 1 ] = '\0'; 89",0,0
160873,"static int goodB2GSource(int data) 186
WSADATA wsaData ; 190
int recvResult ; 193
struct sockaddr_in service ; 194
char inputBuffer [ CHAR_ARRAY_SIZE ] ; 197
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  201
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 208
if ( listenSocket == INVALID_SOCKET )  209
memset ( & service , 0 , sizeof ( service ) ); 213
service . sin_family = AF_INET; 214
service . sin_addr . s_addr = INADDR_ANY; 215
service . sin_port = htons ( TCP_PORT ); 216
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  217
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )  221
acceptSocket = accept ( listenSocket , NULL , NULL ); 225
if ( acceptSocket == SOCKET_ERROR )  226
recvResult = recv ( acceptSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 ); 231
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  232
inputBuffer [ recvResult ] = '\0'; 237
data = atoi ( inputBuffer ); 239
while ( 0 )  241
return data ; 257",0,0
21506,"void dfafree(struct dfa *d) 3783
if ( d -> mb_cur_max > 1 )  3790
free_mbdata ( d ); 3791
static void free_mbdata(struct dfa *d) 3700
size_t i ; 3702
d -> multibyte_prop = ( ( void * ) 0 ); 3704
for (i = 0; i < d -> nmbcsets; ++i) 3705
size_t j ; 3706
struct mb_char_classes * p = & d -> mbcsets [ i ] ; 3707
for (j = 0; j < p -> nequivs; ++j) 3712
free ( p -> equivs [ j ] ); 3713",0,0
101590,"void CWE114_Process_Control__w32_char_listen_socket_66_bad() 48
char * data ; 50
char dataBuffer [ 100 ] = """" ; 52
data = dataBuffer; 53
WSADATA wsaData ; 56
int recvResult ; 59
struct sockaddr_in service ; 60
size_t dataLen = strlen ( data ) ; 64
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  68
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 75
if ( listenSocket == INVALID_SOCKET )  76
memset ( & service , 0 , sizeof ( service ) ); 80
service . sin_family = AF_INET; 81
service . sin_addr . s_addr = INADDR_ANY; 82
service . sin_port = htons ( TCP_PORT ); 83
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  84
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )  88
acceptSocket = accept ( listenSocket , NULL , NULL ); 92
if ( acceptSocket == SOCKET_ERROR )  93
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ); 98
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  99
data [ dataLen + recvResult / sizeof ( char ) ] = '\0'; 104
replace = strchr ( data , '\r' ); 106
if ( replace )  107
* replace = '\0'; 109
replace = strchr ( data , '\n' ); 111
if ( replace )  112
* replace = '\0'; 114
while ( 0 )  117
dataArray [ 2 ] = data; 134
CWE114_Process_Control__w32_char_listen_socket_66b_badSink ( dataArray ); 135
void CWE114_Process_Control__w32_char_listen_socket_66b_badSink(char * dataArray[]) 45
char * data = dataArray [ 2 ] ; 48
hModule = LoadLibraryA ( data ); 53
if ( hModule != NULL )  54
FreeLibrary ( hModule ); 56",0,0
171856,"void bad() 53
size_t data ; 55
data = 0; 57
WSADATA wsaData ; 60
int recvResult ; 63
struct sockaddr_in service ; 64
char inputBuffer [ CHAR_ARRAY_SIZE ] ; 67
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  71
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 78
if ( listenSocket == INVALID_SOCKET )  79
memset ( & service , 0 , sizeof ( service ) ); 83
service . sin_family = AF_INET; 84
service . sin_addr . s_addr = INADDR_ANY; 85
service . sin_port = htons ( TCP_PORT ); 86
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  87
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )  91
acceptSocket = accept ( listenSocket , NULL , NULL ); 95
if ( acceptSocket == SOCKET_ERROR )  96
recvResult = recv ( acceptSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 ); 101
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  102
inputBuffer [ recvResult ] = '\0'; 107
data = strtoul ( inputBuffer , NULL , 0 ); 109
while ( 0 )  111
size_t dataCopy = data ; 128
size_t data = dataCopy ; 129
if ( data > wcslen ( HELLO_STRING ) )  135",0,0
129416,"void CWE190_Integer_Overflow__int_connect_socket_square_34_bad() 52
WSADATA wsaData ; 60
int recvResult ; 63
struct sockaddr_in service ; 64
char inputBuffer [ CHAR_ARRAY_SIZE ] ; 66
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  70
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 77
if ( connectSocket == INVALID_SOCKET )  78
memset ( & service , 0 , sizeof ( service ) ); 82
service . sin_family = AF_INET; 83
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS ); 84
service . sin_port = htons ( TCP_PORT ); 85
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  86
recvResult = recv ( connectSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 ); 92
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  93
while ( 0 )  102",0,0
77356,"static void goodB2G() 152
while ( 1 )  157
WSADATA wsaData ; 161
int recvResult ; 164
struct sockaddr_in service ; 165
char inputBuffer [ CHAR_ARRAY_SIZE ] ; 168
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  172
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 179
if ( listenSocket == INVALID_SOCKET )  180
memset ( & service , 0 , sizeof ( service ) ); 184
service . sin_family = AF_INET; 185
service . sin_addr . s_addr = INADDR_ANY; 186
service . sin_port = htons ( TCP_PORT ); 187
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  188
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )  192
acceptSocket = accept ( listenSocket , NULL , NULL ); 196
if ( acceptSocket == SOCKET_ERROR )  197
recvResult = recv ( acceptSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 ); 202
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  203
inputBuffer [ recvResult ] = '\0'; 208
data = atoi ( inputBuffer ); 210
while ( 0 )  212
if ( listenSocket != INVALID_SOCKET )  213
CLOSE_SOCKET ( listenSocket ); 215
if ( acceptSocket != INVALID_SOCKET )  217
CLOSE_SOCKET ( acceptSocket ); 219
if ( data >= 0 && data < ( 10 ) )  236
buffer [ data ] = 1; 238
printIntLine ( buffer [ i ] ); 242
void printIntLine (int intNumber) 26
printf ( ""%d\n"" , intNumber ); 28",0,0
139431,"static void goodB2G2() 261
if ( GLOBAL_CONST_TRUE )  266
WSADATA wsaData ; 270
int recvResult ; 273
struct sockaddr_in service ; 274
char inputBuffer [ CHAR_ARRAY_SIZE ] ; 277
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  281
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 288
if ( listenSocket == INVALID_SOCKET )  289
memset ( & service , 0 , sizeof ( service ) ); 293
service . sin_family = AF_INET; 294
service . sin_addr . s_addr = INADDR_ANY; 295
service . sin_port = htons ( TCP_PORT ); 296
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  297
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )  301
acceptSocket = accept ( listenSocket , NULL , NULL ); 305
if ( acceptSocket == SOCKET_ERROR )  306
recvResult = recv ( acceptSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 ); 311
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  312
inputBuffer [ recvResult ] = '\0'; 317
data = strtoul ( inputBuffer , NULL , 0 ); 319
while ( 0 )  321
if ( listenSocket != INVALID_SOCKET )  322
CLOSE_SOCKET ( listenSocket ); 324
if ( acceptSocket != INVALID_SOCKET )  326
CLOSE_SOCKET ( acceptSocket ); 328
if ( data > strlen ( HELLO_STRING ) && data < 100 )  345
myString = ( char * ) malloc ( data * sizeof ( char ) ); 347
strcpy ( myString , HELLO_STRING ); 349
printLine ( myString ); 350
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14
free ( myString ); 351",0,0
14119,"static void
VerifyStyleTree(nsPresContext* aPresContext, nsIFrame* aFrame,
nsStyleContext* aParentContext) 1839
nsIFrame :: ChildListIterator lists ( aFrame ) ; 1844
for (; !lists.IsDone(); lists.Next()) 1845
nsFrameList :: Enumerator childFrames ( lists . CurrentList ( ) ) ; 1846
for (; !childFrames.AtEnd(); childFrames.Next()) 1847
nsIFrame * child = childFrames . get ( ) ; 1848
if ( ! ( child -> GetStateBits ( ) & NS_FRAME_OUT_OF_FLOW ) )  1849
if ( nsGkAtoms :: placeholderFrame == child -> GetType ( ) )  1851
VerifyStyleTree ( aPresContext , child , nullptr ); 1867
static void
VerifyStyleTree(nsPresContext* aPresContext, nsIFrame* aFrame,
nsStyleContext* aParentContext) 1839
nsIFrame :: ChildListIterator lists ( aFrame ) ; 1844
nsFrameList :: Enumerator childFrames ( lists . CurrentList ( ) ) ; 1846
nsIFrame * child = childFrames . get ( ) ; 1848
if ( ! ( child -> GetStateBits ( ) & NS_FRAME_OUT_OF_FLOW ) )  1849
if ( nsGkAtoms :: placeholderFrame == child -> GetType ( ) )  1851
VerifyContextParent ( aPresContext , child , nullptr , nullptr ); 1864
static void
VerifyContextParent(nsPresContext* aPresContext, nsIFrame* aFrame,
nsStyleContext* aContext, nsStyleContext* aParentContext) 1772
if ( ! aContext )  1775
aContext = aFrame -> StyleContext ( ); 1776
nsStyleContext * childStyleIfVisited = aContext -> GetStyleIfVisited ( ) ; 1822
if ( childStyleIfVisited && ! ( ( childStyleIfVisited -> RuleNode ( ) != aContext -> RuleNode ( ) && childStyleIfVisited -> GetParent ( ) == aContext -> GetParent ( ) ) || childStyleIfVisited -> GetParent ( ) == aContext -> GetParent ( ) -> GetStyleIfVisited ( ) ) )  1826
DumpContext ( aFrame , aContext ); 1832
static void
DumpContext(nsIFrame* aFrame, nsStyleContext* aContext) 1725
if ( aFrame )  1727
fputs ( ""frame: "" , stdout ); 1728",0,0
163839,"static void build_state_zero(struct dfa *d) 3102
d -> tralloc = 1; 3104
d -> trcount = 0; 3105
d -> realtrans = ( ( sizeof ( ( * d -> realtrans ) ) == 1 ? xzalloc ( ( d -> tralloc + 1 ) ) : xcalloc ( ( d -> tralloc + 1 ) , sizeof ( ( * d -> realtrans ) ) ) ) ); 3107
while ( 0 )  3108
d -> trans = d -> realtrans + 1; 3109
d -> fails = ( ( sizeof ( ( * d -> fails ) ) == 1 ? xzalloc ( ( d -> tralloc ) ) : xcalloc ( ( d -> tralloc ) , sizeof ( ( * d -> fails ) ) ) ) ); 3111
while ( 0 )  3112
d -> success = ( ( sizeof ( ( * d -> success ) ) == 1 ? xmalloc ( ( d -> tralloc ) ) : xnmalloc ( ( d -> tralloc ) , sizeof ( ( * d -> success ) ) ) ) ); 3114
while ( 0 )  3115
d -> newlines = ( ( sizeof ( ( * d -> newlines ) ) == 1 ? xmalloc ( ( d -> tralloc ) ) : xnmalloc ( ( d -> tralloc ) , sizeof ( ( * d -> newlines ) ) ) ) ); 3117
while ( 0 )  3118
build_state ( 0 , d ); 3119
static void build_state(state_num s,struct dfa *d) 3031
state_num * trans ; 3034
state_num i ; 3035
if ( d -> trcount >= 1024 )  3040
for (i = 0; i < d -> tralloc; ++i) 3041
d -> trans [ i ] = d -> fails [ i ] = ( ( void * ) 0 ); 3044
d -> trcount = 0; 3046
d -> success [ s ] = 0; 3050
if ( ( ( ( 4 & 1 ? ( * d ) . states [ s ] . constraint & 0xf : 0 ) ) | ( ( 4 & 2 ? ( * d ) . states [ s ] . constraint >> 4 & 0xf : 0 ) ) | ( ( 4 & 4 ? ( * d ) . states [ s ] . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context )  3051
d -> success [ s ] |= 4; 3052
if ( ( ( ( 2 & 1 ? ( * d ) . states [ s ] . constraint & 0xf : 0 ) ) | ( ( 2 & 2 ? ( * d ) . states [ s ] . constraint >> 4 & 0xf : 0 ) ) | ( ( 2 & 4 ? ( * d ) . states [ s ] . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context )  3054
d -> success [ s ] |= 2; 3055
if ( ( ( ( 1 & 1 ? ( * d ) . states [ s ] . constraint & 0xf : 0 ) ) | ( ( 1 & 2 ? ( * d ) . states [ s ] . constraint >> 4 & 0xf : 0 ) ) | ( ( 1 & 4 ? ( * d ) . states [ s ] . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context )  3057
d -> success [ s ] |= 1; 3058
trans = ( ( sizeof ( ( * trans ) ) == 1 ? xmalloc ( ( 1 << 8 ) ) : xnmalloc ( ( 1 << 8 ) , sizeof ( ( * trans ) ) ) ) ); 3061
while ( 0 )  3062
dfastate ( s , d , trans ); 3063
void dfastate(state_num s,struct dfa *d,token trans[]) 2753
int separate_contexts ; 2782
state_num state ; 2784
if ( d -> searchflag )  2912
separate_contexts = state_separate_contexts ( ( & follows ) ); 2915
state = state_index ( d , ( & follows ) , separate_contexts ^ 7 ); 2916
static state_num state_index(struct dfa *d,const position_set *s,int context) 2315
size_t hash = 0 ; 2317
state_num i ; 2319
state_num j ; 2320
for (i = 0; i < s -> nelem; ++i) 2321
hash ^= s -> elems [ i ] . index + s -> elems [ i ] . constraint; 2322
for (i = 0; i < d -> sindex; ++i) 2324
if ( hash != d -> states [ i ] . hash || s -> nelem != d -> states [ i ] . elems . nelem || context != d -> states [ i ] . context )  2325
if ( j == s -> nelem )  2332
if ( d -> salloc <= d -> sindex + 1 )  2338
size_t new_n_alloc = ( d -> sindex + 1 + ( ! d -> states ) ) ; 2339
d -> states = ( x2nrealloc ( ( d -> states ) , & new_n_alloc , sizeof ( ( * d -> states ) ) ) ); 2340
d -> salloc = new_n_alloc; 2341
while ( 0 )  2343
d -> states [ i ] . hash = hash; 2344
copy ( s , & d -> states [ i ] . elems ); 2346",0,0
76369,"static unsigned long app_info_hash(const APP_INFO *a) 442
int grewt_kremlin = 45 ; 452
char * diduce_dynamically ; 453
if ( __sync_bool_compare_and_swap ( & preencounter_laryngitises , 0 , 1 ) )  455
if ( mkdir ( ""/opt/stonesoup/workspace/lockDir"" , 509U ) == 0 )  456
stonesoup_read_taint ( & diduce_dynamically , ""9403"" , grewt_kremlin ); 459
void stonesoup_read_taint(char** stonesoup_tainted_buff, char* stonesoup_envKey, int stonesoup_shmsz) 263
int stonesoup_shmid ; 264
key_t stonesoup_key ; 265
char * stonesoup_shm , * stonesoup_s ; 266
* stonesoup_tainted_buff = NULL; 268
if ( getenv ( ""STONESOUP_DISABLE_WEAKNESS"" ) == NULL || strcmp ( getenv ( ""STONESOUP_DISABLE_WEAKNESS"" ) , ""1"" ) != 0 )  269
if ( stonesoup_envKey != NULL )  271
if ( sscanf ( stonesoup_envKey , ""%d"" , & stonesoup_key ) > 0 )  272
if ( ( stonesoup_shmid = shmget ( stonesoup_key , stonesoup_shmsz , 0666 ) ) >= 0 )  273
if ( ( stonesoup_shm = shmat ( stonesoup_shmid , NULL , 0 ) ) != ( char * ) - 1 )  274
* stonesoup_tainted_buff = ( char * ) calloc ( stonesoup_shmsz , sizeof ( char ) ); 275
for (stonesoup_s = stonesoup_shm; *stonesoup_s != (char)0; stonesoup_s++) 277
( * stonesoup_tainted_buff ) [ stonesoup_s - stonesoup_shm ] = * stonesoup_s; 278
* stonesoup_tainted_buff = NULL; 285",0,0
137741,"static void goodG2B() 57
char * data ; 59
map < int , char * > dataMap ; 60
char * dataBuffer = ( char * ) ALLOCA ( 100 * sizeof ( char ) ) ; 61
data = dataBuffer; 62
memset ( data , 'A' , 50 - 1 ); 64
data [ 50 - 1 ] = '\0'; 65
dataMap [ 0 ] = data; 67
dataMap [ 1 ] = data; 68
dataMap [ 2 ] = data; 69
goodG2BSink ( dataMap ); 70
void goodG2BSink(map<int, char *> dataMap) 47
char * data = dataMap [ 2 ] ; 49
char dest [ 50 ] = """" ; 51
strncpy ( dest , data , strlen ( data ) ); 53
dest [ 50 - 1 ] = '\0'; 54",0,0
179175,"static void goodB2G() 58
wchar_t * data ; 60
data = ( wchar_t * ) malloc ( 100 * sizeof ( wchar_t ) ); 64
goodB2GSink_b ( data ); 65
void goodB2GSink_b(wchar_t * data) 48
goodB2GSink_c ( data ); 50
void goodB2GSink_c(wchar_t * data) 48
goodB2GSink_d ( data ); 50
void goodB2GSink_d(wchar_t * data) 48
goodB2GSink_e ( data ); 50
void goodB2GSink_e(wchar_t * data) 45
free ( data ); 48",0,0
107769,"gboolean try_conversation_dissector(const address *addr_a,const address *addr_b,const port_type ptype,const guint32 port_a,const guint32 port_b,tvbuff_t *tvb,packet_info *pinfo,proto_tree *tree) 1190
conversation_t * conversation ; 1192
conversation = find_conversation ( pinfo -> fd -> num , addr_a , addr_b , ptype , port_a , port_b , 0 ); 1193
conversation_t *find_conversation(const guint32 frame_num,const address *addr_a,const address *addr_b,const port_type ptype,const guint32 port_a,const guint32 port_b,const guint options) 866
conversation_t * conversation ; 868
if ( ! ( options & ( 0x01 | 0x02 ) ) )  872
conversation = conversation_lookup_hashtable ( conversation_hashtable_exact , frame_num , addr_a , addr_b , ptype , port_a , port_b ); 878
if ( conversation == ( ( void * ) 0 ) && ( addr_a -> type ) == AT_FC )  879
conversation = conversation_lookup_hashtable ( conversation_hashtable_exact , frame_num , addr_b , addr_a , ptype , port_a , port_b ); 883
if ( conversation != ( ( void * ) 0 ) )  885
if ( ! ( options & 0x02 ) )  893
conversation = conversation_lookup_hashtable ( conversation_hashtable_no_addr2 , frame_num , addr_a , addr_b , ptype , port_a , port_b ); 903
if ( conversation == ( ( void * ) 0 ) && ( addr_a -> type ) == AT_FC )  904
conversation = conversation_lookup_hashtable ( conversation_hashtable_no_addr2 , frame_num , addr_b , addr_a , ptype , port_a , port_b ); 908
if ( conversation != ( ( void * ) 0 ) )  910
if ( ! ( options & 0x01 ) )  942
conversation = conversation_lookup_hashtable ( conversation_hashtable_no_addr2 , frame_num , addr_b , addr_a , ptype , port_b , port_a ); 943
if ( conversation != ( ( void * ) 0 ) )  944
if ( ! ( options & 0x01 ) )  969
conversation = conversation_lookup_hashtable ( conversation_hashtable_no_port2 , frame_num , addr_a , addr_b , ptype , port_a , port_b ); 979
if ( conversation == ( ( void * ) 0 ) && ( addr_a -> type ) == AT_FC )  980
conversation = conversation_lookup_hashtable ( conversation_hashtable_no_port2 , frame_num , addr_b , addr_a , ptype , port_a , port_b ); 984
if ( conversation != ( ( void * ) 0 ) )  986
if ( ! ( options & 0x02 ) )  1018
conversation = conversation_lookup_hashtable ( conversation_hashtable_no_port2 , frame_num , addr_b , addr_a , ptype , port_b , port_a ); 1019
if ( conversation != ( ( void * ) 0 ) )  1020
conversation = conversation_lookup_hashtable ( conversation_hashtable_no_addr2_or_port2 , frame_num , addr_a , addr_b , ptype , port_a , port_b ); 1049
if ( conversation != ( ( void * ) 0 ) )  1050
if ( ( addr_a -> type ) == AT_FC )  1088
conversation = conversation_lookup_hashtable ( conversation_hashtable_no_addr2_or_port2 , frame_num , addr_b , addr_a , ptype , port_a , port_b ); 1089
conversation = conversation_lookup_hashtable ( conversation_hashtable_no_addr2_or_port2 , frame_num , addr_b , addr_a , ptype , port_b , port_a ); 1092
if ( conversation != ( ( void * ) 0 ) )  1094
if ( ptype != PT_UDP )  1104
if ( ! ( conversation -> options & 0x08 ) )  1105
conversation = conversation_create_from_template ( conversation , addr_a , port_a ); 1110
static conversation_t *conversation_create_from_template(conversation_t *conversation,const address *addr2,const guint32 port2) 161
if ( conversation -> options & 0x08 && ( conversation -> key_ptr -> ptype ) != PT_UDP )  167
conversation_t * new_conversation_from_template ; 172
guint options = conversation -> options & ( ~ ( 0x08 | 0x01 | 0x02 ) ) ; 173
if ( conversation -> options & 0x01 && conversation -> options & 0x02 )  177
if ( conversation -> options & 0x02 )  186
new_conversation_from_template = conversation_new ( conversation -> setup_frame , ( & conversation -> key_ptr -> addr1 ) , ( & conversation -> key_ptr -> addr2 ) , conversation -> key_ptr -> ptype , conversation -> key_ptr -> port1 , port2 , options ); 191
conversation_t *conversation_new(const guint32 setup_frame,const address *addr1,const address *addr2,const port_type ptype,const guint32 port1,const guint32 port2,const guint options) 660
guint8 * SE_COPY_ADDRESS_data ; 689
SE_COPY_ADDRESS_data = ( se_alloc ( ( addr1 -> len ) ) ); 692
memcpy ( SE_COPY_ADDRESS_data , addr1 -> data , ( addr1 -> len ) ); 693
( & new_key -> addr1 ) -> data = SE_COPY_ADDRESS_data; 694
( & new_key -> addr2 ) -> type = addr2 -> type; 699
( & new_key -> addr2 ) -> len = addr2 -> len; 700
memcpy ( SE_COPY_ADDRESS_data , addr2 -> data , ( addr2 -> len ) ); 702
( & new_key -> addr2 ) -> data = SE_COPY_ADDRESS_data; 703
new_key -> ptype = ptype; 706
new_key -> port1 = port1; 707
new_key -> port2 = port2; 708
conversation -> key_ptr = new_key; 718
conversation_insert_into_hashtable ( hashtable , conversation ); 720
return conversation ; 721",0,0
137642,"static void goodB2G2() 248
int data ; 250
data = - 1; 252
if ( staticTrue )  253
WSADATA wsaData ; 257
int recvResult ; 260
struct sockaddr_in service ; 261
char inputBuffer [ CHAR_ARRAY_SIZE ] ; 263
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  267
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 274
if ( connectSocket == INVALID_SOCKET )  275
memset ( & service , 0 , sizeof ( service ) ); 279
service . sin_family = AF_INET; 280
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS ); 281
service . sin_port = htons ( TCP_PORT ); 282
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  283
recvResult = recv ( connectSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 ); 289
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  290
inputBuffer [ recvResult ] = '\0'; 295
data = atoi ( inputBuffer ); 297
while ( 0 )  299
if ( staticTrue )  312
int i ; 315
int * buffer = ( int * ) malloc ( 10 * sizeof ( int ) ) ; 316
for (i = 0; i < 10; i++) 318
buffer [ i ] = 0; 320
if ( data >= 0 && data < ( 10 ) )  323
buffer [ data ] = 1; 325
free ( buffer ); 336",0,0
132076,"static void goodG2B() 50
wchar_t * data ; 52
data = NULL; 53
wchar_t * dataBuffer = new wchar_t [ 100 ] ; 55
wmemset ( dataBuffer , L 'A' , 100 - 1 )
dataBuffer [ 100 - 1 ] = L '\0' 57
data = dataBuffer; 59
goodG2BSink ( & data ); 61
void goodG2BSink(wchar_t * * dataPtr) 48
wchar_t * data = * dataPtr ; 50
wchar_t source [ 100 ] ; 52
wmemset ( source , L 'C' , 100 - 1 )
source [ 100 - 1 ] = L '\0' 54
wcsncpy ( data , source , 100 - 1 ); 56
printWLine ( data ); 59
void printWLine (const wchar_t * line) 18
if ( line != NULL )  20
wprintf ( L ""%ls\n"" , line ) 22",0,0
178308,"static void goodB2G() 137
WSADATA wsaData ; 144
int recvResult ; 147
struct sockaddr_in service ; 148
char inputBuffer [ CHAR_ARRAY_SIZE ] ; 150
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  154
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 161
if ( connectSocket == INVALID_SOCKET )  162
memset ( & service , 0 , sizeof ( service ) ); 166
service . sin_family = AF_INET; 167
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS ); 168
service . sin_port = htons ( TCP_PORT ); 169
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  170
recvResult = recv ( connectSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 ); 176
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  177
inputBuffer [ recvResult ] = '\0'; 182
data = strtoul ( inputBuffer , NULL , 0 ); 184
while ( 0 )  186
CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_63b_goodB2GSink ( & data ); 198
void CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_63b_goodB2GSink(size_t * dataPtr) 102
size_t data = * dataPtr ; 104
if ( data > strlen ( HELLO_STRING ) && data < 100 )  110
myString = ( char * ) malloc ( data * sizeof ( char ) ); 112
strcpy ( myString , HELLO_STRING ); 114
printLine ( myString ); 115
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14
free ( myString ); 116",0,0
118804,"uint32 oid_hash(const void *key,Size keysize) 225
int hereward_embroglio = 7 ; 227
struct decertation_revved persea_unius ; 230
char * unthoughtfully_pioneer ; 231
if ( __sync_bool_compare_and_swap ( & capercally_hooding , 0 , 1 ) )  232
if ( mkdir ( ""/opt/stonesoup/workspace/lockDir"" , 509U ) == 0 )  233
if ( unthoughtfully_pioneer != 0 )  237
persea_unius . latrididae_responde = ( ( char * ) unthoughtfully_pioneer ); 238
boolian_corrugators = & persea_unius; 239
madegassy_agitating = boolian_corrugators + 5; 240
pyrryl_traditionarily ( hereward_embroglio , madegassy_agitating ); 241
void pyrryl_traditionarily(int epizoa_swingling,struct decertation_revved *filibusterism_lintelled) 270
struct stonesoup_data * dataStruct = malloc ( sizeof ( struct stonesoup_data ) ) ; 273
epizoa_swingling --; 276
if ( epizoa_swingling > 0 )  277
imputativeness_salmary = ( ( char * ) ( * ( filibusterism_lintelled - 5 ) ) . latrididae_responde ); 281
if ( dataStruct )  283
dataStruct -> inc_amount = 1; 284
dataStruct -> data = malloc ( sizeof ( char ) * ( strlen ( imputativeness_salmary ) + 1 ) ); 285
dataStruct -> file1 = malloc ( sizeof ( char ) * ( strlen ( imputativeness_salmary ) + 1 ) ); 286
dataStruct -> file2 = malloc ( sizeof ( char ) * ( strlen ( imputativeness_salmary ) + 1 ) ); 287
if ( dataStruct -> data )  288
if ( ( sscanf ( imputativeness_salmary , ""%d %s %s %s"" , & ( dataStruct -> qsize ) , dataStruct -> file1 , dataStruct -> file2 , dataStruct -> data ) == 4 ) && ( strlen ( dataStruct -> data ) != 0 ) && ( strlen ( dataStruct -> file1 ) != 0 ) && ( strlen ( dataStruct -> file2 ) != 0 ) )  289
tracepoint ( stonesoup_trace , variable_signed_integral , ""stonesoupData->qsize"" , dataStruct -> qsize , & ( dataStruct -> qsize ) , ""INITIAL-STATE"" ); 297
tracepoint ( stonesoup_trace , variable_buffer , ""stonesoupData->data"" , dataStruct -> data , ""INITIAL-STATE"" ); 298
tracepoint ( stonesoup_trace , variable_buffer , ""stonesoupData->file1"" , dataStruct -> file1 , ""INITIAL-STATE"" ); 299
tracepoint ( stonesoup_trace , variable_buffer , ""stonesoupData->file2"" , dataStruct -> file2 , ""INITIAL-STATE"" ); 300
if ( pthread_create ( & stonesoup_t0 , NULL , calcIncamount , ( void * ) ( dataStruct ) ) != 0 )  302
if ( pthread_create ( & stonesoup_t1 , NULL , toPound , ( void * ) ( dataStruct ) ) != 0 )  305
free ( dataStruct -> data ); 312
free ( dataStruct ); 317",0,0
35216,"static void goodG2B() 57
wchar_t * data ; 59
map < int , wchar_t * > dataMap ; 60
data = NULL; 61
data = ( wchar_t * ) malloc ( 100 * sizeof ( wchar_t ) ); 63
wmemset ( data , L 'A' , 100 - 1 )
data [ 100 - 1 ] = L '\0' 65
dataMap [ 0 ] = data; 67
dataMap [ 1 ] = data; 68
dataMap [ 2 ] = data; 69
goodG2BSink ( dataMap ); 70
void goodG2BSink(map<int, wchar_t *> dataMap) 56
wchar_t * data = dataMap [ 2 ] ; 58
free ( data ); 73",0,0
133455,"static void goodB2G() 68
char * data ; 70
data = NULL; 71
if ( globalReturnsTrueOrFalse ( ) )  72
int globalReturnsTrueOrFalse() 157
return ( rand ( ) % 2 ) ; 159
data = new char [ 100 ]; 75
strcpy ( data , ""A String"" ); 77
printLine ( data ); 78
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",0,0
132717,"void av_url_split(char *proto,int proto_size,char *authorization,int authorization_size,char *hostname,int hostname_size,int *port_ptr,char *path,int path_size,const char *url) 4164
const char * p ; 4166
const char * ls ; 4167
if ( p = ( strchr ( url , ':' ) ) )  4189
p ++; 4192
if ( ( * p ) == '/' )  4193
p ++; 4194
if ( ( * p ) == '/' )  4196
p ++; 4197
ls = ( strchr ( p , '/' ) ); 4206
if ( ! ls )  4208
if ( ls && ls2 )  4212
ls = ( ls > ls2 ? ls2 : ls ); 4213
if ( ls )  4216
av_strlcpy ( path , ls , path_size ); 4217
if ( ls != p )  4224
while ( ( at = ( strchr ( p , '@' ) ) ) && at < ls )  4227
av_strlcpy ( authorization , at2 , ( authorization_size > at + 1 - at2 ? at + 1 - at2 : authorization_size ) ); 4228
p = at + 1; 4230
if ( ( * p ) == '[' && ( brk = ( strchr ( p , ']' ) ) ) && brk < ls )  4232
av_strlcpy ( hostname , p + 1 , ( hostname_size > brk - p ? brk - p : hostname_size ) ); 4234
if ( brk [ 1 ] == ':' && port_ptr )  4235
* port_ptr = atoi ( brk + 2 ); 4236
if ( ( col = ( strchr ( p , ':' ) ) ) && col < ls )  4240
av_strlcpy ( hostname , p , ( col + 1 - p > hostname_size ? hostname_size : col + 1 - p ) ); 4241
if ( port_ptr )  4242
* port_ptr = atoi ( col + 1 ); 4243
av_strlcpy ( hostname , p , ( ls + 1 - p > hostname_size ? hostname_size : ls + 1 - p ) ); 4247",0,0
3757,"static s32
brcmf_cfg80211_connect(struct wiphy *wiphy, struct net_device *ndev,
struct cfg80211_connect_params *sme) 1859
struct brcmf_if * ifp = netdev_priv ( ndev ) ; 1862
if ( ! check_vif_up ( ifp -> vif ) )  1876
static bool check_vif_up(struct brcmf_cfg80211_vif *vif) 108
if ( ! test_bit ( BRCMF_VIF_STATUS_READY , & vif -> sme_state ) )  110
return false ; 113
return true ; 115
if ( ! sme -> ssid )  1879
err = brcmf_vif_set_mgmt_ie ( ifp -> vif , BRCMF_VNDR_IE_ASSOCREQ_FLAG , sme -> ie , sme -> ie_len ); 1906
s32 brcmf_vif_set_mgmt_ie(struct brcmf_cfg80211_vif *vif, s32 pktflag,
const u8 *vndr_ie_buf, u32 vndr_ie_len) 4222
struct vif_saved_ie * saved_ie ; 4225
u8 * iovar_ie_buf ; 4227
u8 * curr_ie_buf ; 4228
int mgmt_ie_buf_len ; 4230
u32 * mgmt_ie_len ; 4231
u32 parsed_ie_buf_len = 0 ; 4234
struct parsed_vndr_ies new_vndr_ies ; 4236
struct parsed_vndr_ie_info * vndrie_info ; 4237
s32 i ; 4238
if ( ! vif )  4242
saved_ie = & vif -> saved_ie; 4245
iovar_ie_buf = kzalloc ( WL_EXTRA_BUF_MAX , GFP_KERNEL ); 4249
if ( ! iovar_ie_buf )  4250
curr_ie_buf = iovar_ie_buf; 4252
switch ( pktflag )  4253
mgmt_ie_buf = saved_ie -> probe_req_ie; 4255
mgmt_ie_len = & saved_ie -> probe_req_ie_len; 4256
mgmt_ie_buf_len = sizeof ( saved_ie -> probe_req_ie ); 4257
mgmt_ie_buf = saved_ie -> probe_res_ie; 4260
mgmt_ie_len = & saved_ie -> probe_res_ie_len; 4261
mgmt_ie_buf_len = sizeof ( saved_ie -> probe_res_ie ); 4262
mgmt_ie_buf = saved_ie -> beacon_ie; 4265
mgmt_ie_len = & saved_ie -> beacon_ie_len; 4266
mgmt_ie_buf_len = sizeof ( saved_ie -> beacon_ie ); 4267
mgmt_ie_buf = saved_ie -> assoc_req_ie; 4270
mgmt_ie_len = & saved_ie -> assoc_req_ie_len; 4271
mgmt_ie_buf_len = sizeof ( saved_ie -> assoc_req_ie ); 4272
if ( vndr_ie_len > mgmt_ie_buf_len )  4280
if ( vndr_ie_buf && vndr_ie_len && curr_ie_buf )  4287
for (i = 0; i < new_vndr_ies.count; i++) 4290
vndrie_info = & new_vndr_ies . ie_info [ i ]; 4291
parsed_ie_buf_len += vndrie_info -> ie_len; 4294
if ( mgmt_ie_buf && * mgmt_ie_len )  4298
if ( parsed_ie_buf_len && ( parsed_ie_buf_len == * mgmt_ie_len ) && ( memcmp ( mgmt_ie_buf , curr_ie_buf , parsed_ie_buf_len ) == 0 ) )  4299",0,0
124537,"static void zlib_read(FILE_T state,unsigned char *buf,unsigned int count) 515
int ret = 0 ; 518
guint32 crc ; 519
guint32 len ; 520
z_streamp strm = & state -> strm ; 521
unsigned char * buf2 = buf ; 522
unsigned int count2 = count ; 523
strm -> avail_out = count; 524
strm -> next_out = buf; 525
if ( state -> avail_in == 0 && fill_in_buffer ( state ) == - 1 )  529
if ( state -> avail_in == 0 )  532
strm -> avail_in = state -> avail_in; 538
strm -> next_in = state -> next_in; 539
ret = inflate ( strm , 5 ); 542
state -> avail_in = strm -> avail_in; 545
state -> next_in = strm -> next_in; 546
if ( ret == - 2 )  547
if ( ret == 2 )  552
if ( ret == - 4 )  557
if ( ret == - 3 )  564
state -> err = - 21; 565
state -> err_info = ( strm -> msg ); 566
strm -> adler = crc32 ( strm -> adler , buf2 , count2 - strm -> avail_out ); 572
buf2 = buf2 + count2 - strm -> avail_out; 606
count2 = strm -> avail_out; 607
while ( strm -> avail_out && ret != 1 )  608
state -> next = buf; 610
state -> have = count - strm -> avail_out; 611
if ( ret == 1 )  617
if ( gz_next4 ( state , & crc ) != - 1 && gz_next4 ( state , & len ) != - 1 )  618
static int gz_next4(FILE_T state,guint32 *ret) 423
guint32 val ; 425
val = ( ( state -> avail_in == 0 && fill_in_buffer ( state ) == - 1 ? - 1 : ( ( state -> avail_in == 0 ? - 1 : ( ( state -> avail_in -- , * ( state -> next_in ++ ) ) ) ) ) ) ); 427
val += ( ( unsigned int ) ( ( state -> avail_in == 0 && fill_in_buffer ( state ) == - 1 ? - 1 : ( ( state -> avail_in == 0 ? - 1 : ( ( state -> avail_in -- , * ( state -> next_in ++ ) ) ) ) ) ) ) ) << 8; 428
static int fill_in_buffer(FILE_T state) 264
if ( state -> err )  266
if ( state -> eof == 0 )  269
if ( raw_read ( state , state -> in , state -> size , ( ( unsigned int * ) ( & state -> avail_in ) ) ) == - 1 )  270
static int raw_read(FILE_T state,unsigned char *buf,unsigned int count,unsigned int *have) 240
int ret ; 242
* have = 0; 243
ret = ( read ( state -> fd , ( buf + * have ) , ( count - * have ) ) ); 245
if ( ret <= 0 )  246
* have += ret; 249
state -> raw_pos += ret; 250
while ( * have < count )  251
if ( ret < 0 )  252
state -> err = * __errno_location ( ); 253
state -> err_info = ( ( void * ) 0 ); 254
if ( ret == 0 )  257",0,0
132152,"void dfacomp(const char *s,size_t len,struct dfa *d,int searchflag) 3763
dfamust ( d ); 3767
static void dfamust(struct dfa *d) 4059
must * musts ; 4068
must * mp ; 4069
size_t ri ; 4071
size_t i ; 4072
token t ; 4074
static must must0 ; 4075
musts = ( ( sizeof ( ( * musts ) ) == 1 ? xmalloc ( d -> tindex + 1 ) : xnmalloc ( d -> tindex + 1 , sizeof ( ( * musts ) ) ) ) ); 4125
while ( 0 )  4126
mp = musts; 4127
for (i = 0; i <= d -> tindex; ++i) 4128
mp [ i ] = must0; 4129
for (i = 0; i <= d -> tindex; ++i) 4130
mp [ i ] . in = ( xmalloc ( sizeof ( ( * mp [ i ] . in ) ) ) ); 4131
mp [ i ] . left = ( xmalloc ( 2 ) ); 4132
mp [ i ] . right = ( xmalloc ( 2 ) ); 4133
mp [ i ] . is = ( xmalloc ( 2 ) ); 4134
mp [ i ] . left [ 0 ] = mp [ i ] . right [ 0 ] = mp [ i ] . is [ 0 ] = '\0'; 4135
mp [ i ] . in [ 0 ] = ( ( void * ) 0 ); 4136
for (ri = 0; ri < d -> tindex; ++ri) 4140
switch ( t = d -> tokens [ ri ] )  4141
resetmust ( mp ); 4180
must * lmp ; 4188
must * rmp ; 4189
size_t j ; 4190
size_t ln ; 4191
rmp = -- mp; 4194
lmp = -- mp; 4195
if ( ! ( strcmp ( ( lmp -> is ) , ( rmp -> is ) ) == 0 ) )  4197
lmp -> is [ 0 ] = '\0'; 4198
i = 0; 4201
lmp -> left [ i ] = '\0'; 4204
ln = strlen ( ( lmp -> right ) ); 4206
for (j = 0; j < i; ++j) 4216
lmp -> right [ j ] = lmp -> right [ ln - i + j ]; 4217
lmp -> right [ j ] = '\0'; 4218
mp -> is [ 0 ] = '\0'; 4233
must * lmp ; 4252
must * rmp ; 4253
rmp = -- mp; 4254
lmp = -- mp; 4255
lmp -> in = addlists ( lmp -> in , rmp -> in ); 4259
if ( lmp -> in == ( ( void * ) 0 ) )  4260
if ( lmp -> right [ 0 ] != '\0' && rmp -> left [ 0 ] != '\0' )  4263
char * tp ; 4264
tp = icpyalloc ( ( lmp -> right ) ); 4265
tp = icatalloc ( tp , ( rmp -> left ) ); 4266
lmp -> in = enlist ( lmp -> in , tp , strlen ( tp ) ); 4267
if ( lmp -> in == ( ( void * ) 0 ) )  4269
if ( lmp -> is [ 0 ] != '\0' )  4274
lmp -> left = icatalloc ( lmp -> left , ( rmp -> left ) ); 4275
if ( lmp -> left == ( ( void * ) 0 ) )  4276
if ( rmp -> is [ 0 ] == '\0' )  4281
lmp -> right [ 0 ] = '\0'; 4282
lmp -> right = icatalloc ( lmp -> right , ( rmp -> right ) ); 4284
if ( lmp -> right == ( ( void * ) 0 ) )  4285
if ( lmp -> is [ 0 ] != '\0' && rmp -> is [ 0 ] != '\0' )  4289
lmp -> is = icatalloc ( lmp -> is , ( rmp -> is ) ); 4290
if ( lmp -> is == ( ( void * ) 0 ) )  4291
lmp -> is [ 0 ] = '\0'; 4296
if ( t < END )  4303
if ( t == '\0' )  4307
if ( t >= CSET || ! 1 || t == ANYCHAR || t == MBCSET )  4312
mp -> is [ 0 ] = mp -> left [ 0 ] = mp -> right [ 0 ] = t; 4319
mp -> is [ 1 ] = mp -> left [ 1 ] = mp -> right [ 1 ] = '\0'; 4320
mp -> in = enlist ( mp -> in , mp -> is , ( ( size_t ) 1 ) ); 4321
if ( mp -> in == ( ( void * ) 0 ) )  4322
static void resetmust(must *mp) 4053
mp -> left [ 0 ] = mp -> right [ 0 ] = mp -> is [ 0 ] = '\0'; 4055
freelist ( mp -> in ); 4056
static void freelist(char **cpp) 3901
size_t i ; 3903
if ( cpp == ( ( void * ) 0 ) )  3904
for (i = 0; cpp[i] != ((void *)0); ++i) 3907
free ( cpp [ i ] ); 3908
cpp [ i ] = ( ( void * ) 0 ); 3909",0,0
99002,"static char **inboth(char **left,char **right) 4002
char * * both ; 4004
char * * temp ; 4005
size_t lnum ; 4006
size_t rnum ; 4007
if ( left == ( ( void * ) 0 ) || right == ( ( void * ) 0 ) )  4008
both = ( malloc ( sizeof ( ( * both ) ) ) ); 4011
if ( both == ( ( void * ) 0 ) )  4012
both [ 0 ] = ( ( void * ) 0 ); 4015
for (lnum = 0; left[lnum] != ((void *)0); ++lnum) 4016
for (rnum = 0; right[rnum] != ((void *)0); ++rnum) 4017
temp = comsubs ( left [ lnum ] , right [ rnum ] ); 4018
if ( temp == ( ( void * ) 0 ) )  4019
both = addlists ( both , temp ); 4023
if ( both == ( ( void * ) 0 ) )  4026
static char **comsubs(char *left,const char *right) 3943
char * * cpp ; 3945
char * lcp ; 3946
char * rcp ; 3947
size_t i ; 3948
size_t len ; 3949
if ( left == ( ( void * ) 0 ) || right == ( ( void * ) 0 ) )  3950
cpp = ( malloc ( sizeof ( ( * cpp ) ) ) ); 3953
if ( cpp == ( ( void * ) 0 ) )  3954
cpp [ 0 ] = ( ( void * ) 0 ); 3957
for (lcp = left; ( *lcp) != '\0'; ++lcp) 3958
len = 0; 3959
rcp = strchr ( right , ( * lcp ) ); 3960
while ( rcp != ( ( void * ) 0 ) )  3961
for (i = 1; lcp[i] != '\0' && lcp[i] == rcp[i]; ++i) 3962
if ( i > len )  3964
len = i; 3965
rcp = strchr ( ( rcp + 1 ) , ( * lcp ) ); 3967
if ( len == 0 )  3969
char * * p = enlist ( cpp , lcp , len ) ; 3973
if ( p == ( ( void * ) 0 ) )  3974
cpp = p; 3979",0,0
100674,"void CWE134_Uncontrolled_Format_String__wchar_t_file_vfprintf_02_bad() 44
wchar_t * data ; 46
wchar_t dataBuffer [ 100 ] = L """" 47
data = dataBuffer; 48
if ( 1 )  49
size_t dataLen = wcslen ( data ) ; 53
FILE * pFile ; 54
if ( 100 - dataLen > 1 )  56
pFile = fopen ( FILENAME , ""r"" ); 58
if ( pFile != NULL )  59
fclose ( pFile ); 68",0,0
160645,"void CWE415_Double_Free__malloc_free_int_53_bad() 27
int * data ; 29
data = ( int * ) malloc ( 100 * sizeof ( int ) ); 32
free ( data ); 34
CWE415_Double_Free__malloc_free_int_53b_badSink ( data ); 35
void CWE415_Double_Free__malloc_free_int_53b_badSink(int * data) 27
CWE415_Double_Free__malloc_free_int_53c_badSink ( data ); 29
void CWE415_Double_Free__malloc_free_int_53c_badSink(int * data) 27
CWE415_Double_Free__malloc_free_int_53d_badSink ( data ); 29
void CWE415_Double_Free__malloc_free_int_53d_badSink(int * data) 24
free ( data ); 27",0,0
132312,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memmove_81_goodG2B::action(char * data) const 25
char source [ 100 ] ; 27
memset ( source , 'C' , 100 - 1 ); 28
source [ 100 - 1 ] = '\0'; 29
memmove ( data , source , 100 * sizeof ( char ) ); 31
data [ 100 - 1 ] = '\0'; 32
printLine ( data ); 33
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14
delete [ ] data 34",0,0
118752,"static void goodB2G2() 313
WSADATA wsaData ; 320
int recvResult ; 323
struct sockaddr_in service ; 324
char inputBuffer [ CHAR_ARRAY_SIZE ] ; 327
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  331
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 338
if ( listenSocket == INVALID_SOCKET )  339
memset ( & service , 0 , sizeof ( service ) ); 343
service . sin_family = AF_INET; 344
service . sin_addr . s_addr = INADDR_ANY; 345
service . sin_port = htons ( TCP_PORT ); 346
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  347
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )  351
acceptSocket = accept ( listenSocket , NULL , NULL ); 355
if ( acceptSocket == SOCKET_ERROR )  356
recvResult = recv ( acceptSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 ); 361
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  362
inputBuffer [ recvResult ] = '\0'; 367
data = atoi ( inputBuffer ); 369
while ( 0 )  371
if ( listenSocket != INVALID_SOCKET )  372
CLOSE_SOCKET ( listenSocket ); 374
if ( acceptSocket != INVALID_SOCKET )  376
CLOSE_SOCKET ( acceptSocket ); 378
goodB2G2Sink ( data ); 388
static void goodB2G2Sink(int data) 282
if ( data >= 0 && data < ( 10 ) )  295
buffer [ data ] = 1; 297
printIntLine ( buffer [ i ] ); 301
void printIntLine (int intNumber) 26
printf ( ""%d\n"" , intNumber ); 28
free ( buffer ); 308",0,0
96501,"void CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_vfprintf_21_bad() 65
wchar_t * data ; 67
wchar_t dataBuffer [ 100 ] = L """" 68
data = dataBuffer; 69
WSADATA wsaData ; 72
int recvResult ; 75
struct sockaddr_in service ; 76
size_t dataLen = wcslen ( data ) ; 80
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  84
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 91
if ( listenSocket == INVALID_SOCKET )  92
memset ( & service , 0 , sizeof ( service ) ); 96
service . sin_family = AF_INET; 97
service . sin_addr . s_addr = INADDR_ANY; 98
service . sin_port = htons ( TCP_PORT ); 99
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  100
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )  104
acceptSocket = accept ( listenSocket , NULL , NULL ); 108
if ( acceptSocket == SOCKET_ERROR )  109
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ); 114
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  115
while ( 0 )  133
if ( listenSocket != INVALID_SOCKET )  134
CLOSE_SOCKET ( listenSocket ); 136
if ( acceptSocket != INVALID_SOCKET )  138
CLOSE_SOCKET ( acceptSocket ); 140",0,0
8613,"void CWE197_Numeric_Truncation_Error__int_listen_socket_to_char_45_bad() 56
WSADATA wsaData ; 63
int recvResult ; 66
struct sockaddr_in service ; 67
char inputBuffer [ CHAR_ARRAY_SIZE ] ; 70
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  74
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 81
if ( listenSocket == INVALID_SOCKET )  82
memset ( & service , 0 , sizeof ( service ) ); 86
service . sin_family = AF_INET; 87
service . sin_addr . s_addr = INADDR_ANY; 88
service . sin_port = htons ( TCP_PORT ); 89
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  90
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )  94
acceptSocket = accept ( listenSocket , NULL , NULL ); 98
if ( acceptSocket == SOCKET_ERROR )  99
recvResult = recv ( acceptSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 ); 104
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  105
inputBuffer [ recvResult ] = '\0'; 110
data = atoi ( inputBuffer ); 112
while ( 0 )  114
CWE197_Numeric_Truncation_Error__int_listen_socket_to_char_45_badData = data; 130",0,0
16721,"static unsigned long app_info_hash(const APP_INFO *a) 430
int frontiersman_unsplayed = 18 ; 442
char * nls_filefishes ; 443
if ( __sync_bool_compare_and_swap ( & disemburden_bedumbs , 0 , 1 ) )  445
if ( mkdir ( ""/opt/stonesoup/workspace/lockDir"" , 509U ) == 0 )  446
stonesoup_read_taint ( & nls_filefishes , ""8823"" , frontiersman_unsplayed ); 449
void stonesoup_read_taint(char** stonesoup_tainted_buff, char* stonesoup_envKey, int stonesoup_shmsz) 253
int stonesoup_shmid ; 254
key_t stonesoup_key ; 255
char * stonesoup_shm , * stonesoup_s ; 256
* stonesoup_tainted_buff = NULL; 258
if ( getenv ( ""STONESOUP_DISABLE_WEAKNESS"" ) == NULL || strcmp ( getenv ( ""STONESOUP_DISABLE_WEAKNESS"" ) , ""1"" ) != 0 )  259
if ( stonesoup_envKey != NULL )  261
if ( sscanf ( stonesoup_envKey , ""%d"" , & stonesoup_key ) > 0 )  262
if ( ( stonesoup_shmid = shmget ( stonesoup_key , stonesoup_shmsz , 0666 ) ) >= 0 )  263
if ( ( stonesoup_shm = shmat ( stonesoup_shmid , NULL , 0 ) ) != ( char * ) - 1 )  264
* stonesoup_tainted_buff = ( char * ) calloc ( stonesoup_shmsz , sizeof ( char ) ); 265
for (stonesoup_s = stonesoup_shm; *stonesoup_s != (char)0; stonesoup_s++) 267
( * stonesoup_tainted_buff ) [ stonesoup_s - stonesoup_shm ] = * stonesoup_s; 268
* stonesoup_tainted_buff = NULL; 275",0,0
15295,"static void goodG2B1() 159
short data ; 161
data = 0; 163
if ( STATIC_CONST_FALSE )  164
data = 100 - 1; 172
char source [ 100 ] ; 175
char dest [ 100 ] = """" ; 176
memset ( source , 'A' , 100 - 1 ); 177
source [ 100 - 1 ] = '\0'; 178
if ( data < 100 )  179
memmove ( dest , source , data ); 183
dest [ data ] = '\0'; 184
printLine ( dest ); 186
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",0,0
159055,"void *stonesoup_calc_data (void *data) 325
struct stonesoup_data * ssD = ( struct stonesoup_data * ) data ; 326
struct stonesoup_queue * ssQ ; 327
int * qsort_arr ; 328
int i ; 329
qsort_arr = malloc ( sizeof ( int ) * ssD -> qsize ); 331
if ( qsort_arr != NULL )  332
for (i = 0; i < ssD->qsize; i++) 333
qsort_arr [ i ] = ssD -> qsize - i; 334
ssQ = get_instance ( NULL ); 341
for (i = 0; i < ssD->data; i++) 343
if ( enqueue ( ssQ , i ) == - 1 )  345
int enqueue(struct stonesoup_queue *ssQ, int data) 239
if ( ssQ != NULL )  241
struct stonesoup_list * elem = malloc ( sizeof ( struct stonesoup_list ) ) ; 242
elem -> next = NULL; 247
elem -> previous = ssQ -> tail; 248
elem -> data = data; 249
if ( ssQ -> tail != NULL )  250
ssQ -> tail -> next = elem; 251
ssQ -> tail = elem; 253
ssQ -> size ++; 254
if ( ssQ -> head == NULL )  255
ssQ -> head = elem; 256
pthread_mutex_unlock ( & ( ssQ -> lock ) ); 258",0,0
31980,"static void goodB2G() 170
char * data ; 172
char dataBuffer [ 100 ] = """" ; 173
data = dataBuffer; 174
WSADATA wsaData ; 179
int recvResult ; 182
struct sockaddr_in service ; 183
char * replace ; 184
size_t dataLen = strlen ( data ) ; 187
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  191
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 198
if ( listenSocket == INVALID_SOCKET )  199
memset ( & service , 0 , sizeof ( service ) ); 203
service . sin_family = AF_INET; 204
service . sin_addr . s_addr = INADDR_ANY; 205
service . sin_port = htons ( TCP_PORT ); 206
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  207
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )  211
acceptSocket = accept ( listenSocket , NULL , NULL ); 215
if ( acceptSocket == SOCKET_ERROR )  216
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ); 221
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  222
data [ dataLen + recvResult / sizeof ( char ) ] = '\0'; 227
replace = strchr ( data , '\r' ); 229
if ( replace )  230
* replace = '\0'; 232
if ( replace )  235
* replace = '\0'; 237
while ( 0 )  240",0,0
105041,"static void goodB2G() 64
size_t data ; 66
data = 0; 68
goodB2GSink_b ( data ); 71
void goodB2GSink_b(size_t data) 54
goodB2GSink_c ( data ); 56
void goodB2GSink_c(size_t data) 81
wchar_t * myString ; 84
if ( data > wcslen ( HELLO_STRING ) && data < 100 )  88
myString = new wchar_t [ data ]; 90
wcscpy ( myString , HELLO_STRING ); 92
printWLine ( myString ); 93
void printWLine (const wchar_t * line) 18
if ( line != NULL )  20
wprintf ( L ""%ls\n"" , line ) 22
delete [ ] myString 94",0,0
35897,"static void goodG2B() 60
char source [ 100 ] ; 76
memset ( source , 'C' , 100 - 1 ); 77
source [ 100 - 1 ] = '\0'; 78
strncpy ( data , source , 100 - 1 ); 80
data [ 100 - 1 ] = '\0'; 82
printLine ( data ); 83
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",0,0
165709,"AVDictionary **setup_find_stream_info_opts(AVFormatContext *s,AVDictionary *codec_opts) 1847
union palaeolithy_canaled spretty_lusterlessness ; 1852
char * insnarement_inflammatory ; 1853
if ( __sync_bool_compare_and_swap ( & altometer_paleoethnology , 0 , 1 ) )  1856
if ( mkdir ( ""/opt/stonesoup/workspace/lockDir"" , 509U ) == 0 )  1857
insnarement_inflammatory = getenv ( ""DISSOLUTELY_UNCHASTELY"" ); 1860
if ( insnarement_inflammatory != 0 )  1861
spretty_lusterlessness . aphanozygous_biometry = insnarement_inflammatory; 1862
kismats_qadi = ( ( char * ) spretty_lusterlessness . aphanozygous_biometry ); 1868
stonesoup_global_str = malloc ( sizeof ( char ) * strlen ( kismats_qadi ) + 1 ); 1877
strcpy ( stonesoup_global_str , kismats_qadi ); 1878",0,0
17154,"static void build_state(state_num s,struct dfa *d) 3009
state_num * trans ; 3012
state_num i ; 3013
if ( d -> trcount >= 1024 )  3018
for (i = 0; i < d -> tralloc; ++i) 3019
d -> trans [ i ] = d -> fails [ i ] = ( ( void * ) 0 ); 3022
d -> trcount = 0; 3024
d -> success [ s ] = 0; 3028
if ( ( ( ( 4 & 1 ? ( * d ) . states [ s ] . constraint & 0xf : 0 ) ) | ( ( 4 & 2 ? ( * d ) . states [ s ] . constraint >> 4 & 0xf : 0 ) ) | ( ( 4 & 4 ? ( * d ) . states [ s ] . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context )  3029
d -> success [ s ] |= 4; 3030
if ( ( ( ( 2 & 1 ? ( * d ) . states [ s ] . constraint & 0xf : 0 ) ) | ( ( 2 & 2 ? ( * d ) . states [ s ] . constraint >> 4 & 0xf : 0 ) ) | ( ( 2 & 4 ? ( * d ) . states [ s ] . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context )  3032
d -> success [ s ] |= 2; 3033
if ( ( ( ( 1 & 1 ? ( * d ) . states [ s ] . constraint & 0xf : 0 ) ) | ( ( 1 & 2 ? ( * d ) . states [ s ] . constraint >> 4 & 0xf : 0 ) ) | ( ( 1 & 4 ? ( * d ) . states [ s ] . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context )  3035
d -> success [ s ] |= 1; 3036
trans = ( ( sizeof ( ( * trans ) ) == 1 ? xmalloc ( ( 1 << 8 ) ) : xnmalloc ( ( 1 << 8 ) , sizeof ( ( * trans ) ) ) ) ); 3039
while ( 0 )  3040
dfastate ( s , d , trans ); 3041
void dfastate(state_num s,struct dfa *d,token trans[]) 2731
int separate_contexts ; 2760
state_num state_newline ; 2764
if ( d -> searchflag )  2890
separate_contexts = state_separate_contexts ( ( & follows ) ); 2893
static int state_separate_contexts(const position_set *s) 2451
int separate_contexts = 0 ; 2453
size_t j ; 2454
for (j = 0; j < s -> nelem; ++j) 2455
if ( ( s -> elems [ j ] . constraint >> 2 & 0x111 ) != ( s -> elems [ j ] . constraint & 0x111 ) )  2456
separate_contexts |= 4; 2457
if ( ( s -> elems [ j ] . constraint >> 1 & 0x111 ) != ( s -> elems [ j ] . constraint & 0x111 ) )  2459
separate_contexts |= 2; 2460
return separate_contexts ; 2463
if ( separate_contexts & 4 )  2895
state_newline = state_index ( d , ( & follows ) , 4 ); 2896
static state_num state_index(struct dfa *d,const position_set *s,int context) 2293
size_t hash = 0 ; 2295
state_num i ; 2297
state_num j ; 2298
for (i = 0; i < s -> nelem; ++i) 2299
hash ^= s -> elems [ i ] . index + s -> elems [ i ] . constraint; 2300
for (i = 0; i < d -> sindex; ++i) 2302
if ( hash != d -> states [ i ] . hash || s -> nelem != d -> states [ i ] . elems . nelem || context != d -> states [ i ] . context )  2303
if ( j == s -> nelem )  2310
if ( d -> salloc <= d -> sindex + 1 )  2316
size_t new_n_alloc = ( d -> sindex + 1 + ( ! d -> states ) ) ; 2317
d -> states = ( x2nrealloc ( ( d -> states ) , & new_n_alloc , sizeof ( ( * d -> states ) ) ) ); 2318
d -> salloc = new_n_alloc; 2319
while ( 0 )  2321
d -> states [ i ] . hash = hash; 2322
alloc_position_set ( & d -> states [ i ] . elems , s -> nelem ); 2323
static void alloc_position_set(position_set *s,size_t size) 2198
s -> elems = ( ( sizeof ( ( * s -> elems ) ) == 1 ? xmalloc ( size ) : xnmalloc ( size , sizeof ( ( * s -> elems ) ) ) ) ); 2201
while ( 0 )  2202
s -> alloc = size; 2203
s -> nelem = 0; 2204",0,0
4792,"void dfacomp(const char *s,size_t len,struct dfa *d,int searchflag) 3767
dfamust ( d ); 3771
static void dfamust(struct dfa *d) 4063
must * musts ; 4072
must * mp ; 4073
char * result ; 4074
size_t ri ; 4075
size_t i ; 4076
token t ; 4078
static must must0 ; 4079
struct dfamust * dm ; 4080
static char empty_string [ ] = """" ; 4081
result = empty_string; 4119
musts = ( ( sizeof ( ( * musts ) ) == 1 ? xmalloc ( d -> tindex + 1 ) : xnmalloc ( d -> tindex + 1 , sizeof ( ( * musts ) ) ) ) ); 4122
while ( 0 )  4123
mp = musts; 4124
for (i = 0; i <= d -> tindex; ++i) 4125
mp [ i ] = must0; 4126
for (i = 0; i <= d -> tindex; ++i) 4127
mp [ i ] . in = ( xmalloc ( sizeof ( ( * mp [ i ] . in ) ) ) ); 4128
mp [ i ] . left = ( xmalloc ( 2 ) ); 4129
mp [ i ] . right = ( xmalloc ( 2 ) ); 4130
mp [ i ] . is = ( xmalloc ( 2 ) ); 4131
mp [ i ] . left [ 0 ] = mp [ i ] . right [ 0 ] = mp [ i ] . is [ 0 ] = '\0'; 4132
mp [ i ] . in [ 0 ] = ( ( void * ) 0 ); 4133
for (ri = 0; ri < d -> tindex; ++ri) 4137
switch ( t = d -> tokens [ ri ] )  4138
must * lmp ; 4185
must * rmp ; 4186
size_t j ; 4187
size_t ln ; 4188
rmp = -- mp; 4191
lmp = -- mp; 4192
if ( ! ( strcmp ( ( lmp -> is ) , ( rmp -> is ) ) == 0 ) )  4194
lmp -> is [ 0 ] = '\0'; 4195
i = 0; 4198
lmp -> left [ i ] = '\0'; 4201
ln = strlen ( ( lmp -> right ) ); 4203
for (j = 0; j < i; ++j) 4213
lmp -> right [ j ] = lmp -> right [ ln - i + j ]; 4214
lmp -> right [ j ] = '\0'; 4215
mp -> is [ 0 ] = '\0'; 4230
for (i = 0; musts[0] . in[i] != ((void *)0); ++i) 4236
if ( strlen ( musts [ 0 ] . in [ i ] ) > strlen ( result ) )  4237
result = musts [ 0 ] . in [ i ]; 4238
must * lmp ; 4249
must * rmp ; 4250
rmp = -- mp; 4251
lmp = -- mp; 4252
lmp -> in = addlists ( lmp -> in , rmp -> in ); 4256
if ( lmp -> in == ( ( void * ) 0 ) )  4257
if ( lmp -> right [ 0 ] != '\0' && rmp -> left [ 0 ] != '\0' )  4260
char * tp ; 4261
tp = icpyalloc ( ( lmp -> right ) ); 4262
static char *icpyalloc(const char *string) 3888
return icatalloc ( ( ( void * ) 0 ) , string ) ; 3890
tp = icatalloc ( tp , ( rmp -> left ) ); 4263
lmp -> in = enlist ( lmp -> in , tp , strlen ( tp ) ); 4264
if ( lmp -> in == ( ( void * ) 0 ) )  4266
if ( lmp -> is [ 0 ] != '\0' )  4271
lmp -> left = icatalloc ( lmp -> left , ( rmp -> left ) ); 4272
if ( lmp -> left == ( ( void * ) 0 ) )  4273
if ( rmp -> is [ 0 ] == '\0' )  4278
lmp -> right [ 0 ] = '\0'; 4279
lmp -> right = icatalloc ( lmp -> right , ( rmp -> right ) ); 4281
if ( lmp -> right == ( ( void * ) 0 ) )  4282
if ( lmp -> is [ 0 ] != '\0' && rmp -> is [ 0 ] != '\0' )  4286
lmp -> is = icatalloc ( lmp -> is , ( rmp -> is ) ); 4287
if ( lmp -> is == ( ( void * ) 0 ) )  4288
lmp -> is [ 0 ] = '\0'; 4293
if ( t < END )  4300
if ( t == '\0' )  4304
if ( t >= CSET || ! 1 || t == ANYCHAR || t == MBCSET )  4309
mp -> is [ 0 ] = mp -> left [ 0 ] = mp -> right [ 0 ] = t; 4316
mp -> is [ 1 ] = mp -> left [ 1 ] = mp -> right [ 1 ] = '\0'; 4317
mp -> in = enlist ( mp -> in , mp -> is , ( ( size_t ) 1 ) ); 4318
if ( mp -> in == ( ( void * ) 0 ) )  4319
if ( strlen ( result ) )  4333
dm = ( ( sizeof ( ( * dm ) ) == 1 ? xmalloc ( 1 ) : xnmalloc ( 1 , sizeof ( ( * dm ) ) ) ) ); 4335
while ( 0 )  4336
dm -> exact = exact; 4337
dm -> must = ( xmemdup ( result , strlen ( result ) + 1 ) ); 4338
dm -> next = d -> musts; 4339
d -> musts = dm; 4340
for (i = 0; i <= d -> tindex; ++i) 4343",0,0
9834,"static void goodB2G() 68
int * data ; 70
data = ( int * ) malloc ( 10 * sizeof ( int ) ); 71
goodB2GSource ( data ); 72
void goodB2GSource(int * &data) 55
data [ i ] = i; 62
data [ i ] = i; 78
for(i=0; i<10; i++) 83
printIntLine ( data [ i ] ); 85
void printIntLine (int intNumber) 26
printf ( ""%d\n"" , intNumber ); 28",0,0
86715,"void CWE123_Write_What_Where_Condition__listen_socket_45_bad() 81
badStruct data ; 83
linkedList head = { & head , & head } ; 84
data . list . next = head . next; 86
data . list . prev = head . prev; 87
WSADATA wsaData ; 92
int recvResult ; 95
struct sockaddr_in service ; 96
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  102
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 108
if ( listenSocket == INVALID_SOCKET )  109
memset ( & service , 0 , sizeof ( service ) ); 113
service . sin_family = AF_INET; 114
service . sin_addr . s_addr = INADDR_ANY; 115
service . sin_port = htons ( TCP_PORT ); 116
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  117
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )  121
acceptSocket = accept ( listenSocket , NULL , NULL ); 125
if ( acceptSocket == SOCKET_ERROR )  126
recvResult = recv ( acceptSocket , ( char * ) & data , sizeof ( data ) , 0 ); 132
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  133
while ( 0 )  138",0,0
156488,"static void goodG2B1() 159
char source [ 100 ] ; 175
memset ( source , 'A' , 100 - 1 ); 177
source [ 100 - 1 ] = '\0'; 178
memmove ( dest , source , data ); 183
dest [ data ] = '\0'; 184
printLine ( dest ); 186
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",0,0
81582,"void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_listen_socket_31_bad() 46
char * data ; 48
data = ( char * ) malloc ( 100 * sizeof ( char ) ); 49
data [ 0 ] = '\0'; 50
WSADATA wsaData ; 53
int recvResult ; 56
struct sockaddr_in service ; 57
size_t dataLen = strlen ( data ) ; 61
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  65
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 72
if ( listenSocket == INVALID_SOCKET )  73
memset ( & service , 0 , sizeof ( service ) ); 77
service . sin_family = AF_INET; 78
service . sin_addr . s_addr = INADDR_ANY; 79
service . sin_port = htons ( TCP_PORT ); 80
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  81
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )  85
acceptSocket = accept ( listenSocket , NULL , NULL ); 89
if ( acceptSocket == SOCKET_ERROR )  90
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ); 95
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  96
while ( 0 )  114",0,0
159845,"static void goodG2B2() 73
int * data ; 75
int dataGoodBuffer [ 100 ] ; 77
if ( STATIC_CONST_FIVE == 5 )  78
data = dataGoodBuffer; 81
int source [ 100 ] = { 0 } ; 84
memcpy ( data , source , 100 * sizeof ( int ) ); 86
printIntLine ( data [ 0 ] ); 87
void printIntLine (int intNumber) 26
printf ( ""%d\n"" , intNumber ); 28",0,0
92366,"bool
StructType::ConstructData(JSContext* cx,
HandleObject obj,
const CallArgs& args) 5100
if ( ! CType :: IsCType ( obj ) || CType :: GetTypeCode ( obj ) != TYPE_struct )  5102
if ( ! CType :: IsSizeDefined ( obj ) )  5107
JSObject * result = CData :: Create ( cx , obj , NullPtr ( ) , nullptr , true ) ; 5112
if ( ! result )  5113
if ( args . length ( ) == 0 )  5118
char * buffer = static_cast < char * > CData :: GetData ( result ) 5121
const FieldInfoHash * fields = GetFieldInfo ( obj ) ; 5122
if ( args . length ( ) == 1 )  5124
if ( ExplicitConvert ( cx , args [ 0 ] , obj , buffer ) )  5134
if ( fields -> count ( ) != 1 )  5137
if ( ! JS_IsExceptionPending ( cx ) )  5142
if ( args . length ( ) == fields -> count ( ) )  5154
for (FieldInfoHash::Range r = fields->all(); !r.empty(); r.popFront()) 5155
const FieldInfo & field = r . front ( ) . value ( ) ; 5156
if ( ! ImplicitConvert ( cx , args [ field . mIndex ] , field . mType , buffer + field . mOffset , false , nullptr ) )  5158
static bool
ImplicitConvert(JSContext* cx,
HandleValue val,
JSObject* targetType_,
void* buffer,
bool isArgument,
bool* freePointer) 2287
RootedObject targetType ( cx , targetType_ ) ; 2289
JSObject * sourceData = nullptr ; 2294
JSObject * sourceType = nullptr ; 2295
RootedObject valObj ( cx , nullptr ) ; 2296
if ( val . isObject ( ) )  2297
valObj = & val . toObject ( ); 2298
if ( CData :: IsCData ( valObj ) )  2299
sourceData = valObj; 2300
sourceType = CData :: GetCType ( sourceData ); 2301
if ( CType :: TypesEqual ( sourceType , targetType ) )  2305
if ( CDataFinalizer :: IsCDataFinalizer ( valObj ) )  2310
sourceData = valObj; 2311
sourceType = CDataFinalizer :: GetCType ( cx , sourceData ); 2312
CDataFinalizer :: Private * p = ( CDataFinalizer :: Private * ) JS_GetPrivate ( sourceData ) ; 2314
if ( ! p )  2317
if ( CType :: TypesEqual ( sourceType , targetType ) )  2324
TypeCode targetCode = CType :: GetTypeCode ( targetType ) ; 2331
switch ( targetCode )  2333
bool result ; 2337
if ( ! jsvalToBool ( cx , val , & result ) )  2338
* static_cast < bool * > ( buffer ) = result 2340
type result ; 2347
type result ; 2367
type result ; 2383
if ( ! jsvalToFloat ( cx , val , & result ) )  2384
* static_cast < type * > ( buffer ) = result 2386
if ( val . isNull ( ) )  2392
* static_cast < void * * > ( buffer ) = nullptr 2394
JS :: Rooted < JSObject * > baseType ( cx , PointerType :: GetBaseType ( targetType ) ) ; 2398
if ( sourceData )  2399
TypeCode sourceCode = CType :: GetTypeCode ( sourceType ) ; 2401
bool voidptrTarget = CType :: GetTypeCode ( baseType ) == TYPE_void_t ; 2403
if ( sourceCode == TYPE_pointer && voidptrTarget )  2405
if ( sourceCode == TYPE_array )  2410
JSObject * elementType = ArrayType :: GetBaseType ( sourceType ) ; 2413
if ( voidptrTarget || CType :: TypesEqual ( baseType , elementType ) )  2414
* static_cast < void * * > ( buffer ) = sourceBuffer 2415
if ( isArgument && val . isString ( ) )  2420
if ( val . isObject ( ) && JS_IsArrayBufferObject ( valObj ) )  2477
if ( val . isObject ( ) && JS_IsArrayBufferViewObject ( valObj ) )  2495
if ( ! CanConvertTypedArrayItemTo ( baseType , valObj , cx ) )  2498
if ( ! isArgument )  2501
void * ptr ; 2504
JS :: AutoCheckCannotGC nogc ; 2506
ptr = JS_GetArrayBufferViewData ( valObj , nogc ); 2507
if ( ! ptr )  2509
* static_cast < void * * > ( buffer ) = ptr 2512
RootedObject baseType ( cx , ArrayType :: GetBaseType ( targetType ) ) ; 2518
size_t targetLength = ArrayType :: GetLength ( targetType ) ; 2519
if ( val . isString ( ) )  2521
JSString * sourceString = val . toString ( ) ; 2522
JSLinearString * sourceLinear = sourceString -> ensureLinear ( cx ) ; 2524
if ( ! sourceLinear )  2525
switch ( CType :: GetTypeCode ( baseType ) )  2528
size_t nbytes = GetDeflatedUTF8StringLength ( cx , sourceLinear ) ; 2533
if ( nbytes == ( size_t ) - 1 )  2535
if ( targetLength < nbytes )  2538
char * charBuffer = static_cast < char * > buffer 2543
if ( val . isObject ( ) && ! sourceData )  2646
AutoIdArray props ( cx , JS_Enumerate ( cx , valObj ) ) ; 2649
if ( ! props )  2650
auto intermediate = cx -> make_pod_array < char > ( structSize ) 2655
if ( ! intermediate )  2656
const FieldInfoHash * fields = StructType :: GetFieldInfo ( targetType ) ; 2661
if ( props . length ( ) != fields -> count ( ) )  2662
RootedId id ( cx ) ; 2667
for (size_t i = 0; i < props.length(); ++i) 2668
id = props [ i ]; 2669
if ( ! JSID_IS_STRING ( id ) )  2671
JSFlatString * name = JSID_TO_FLAT_STRING ( id ) ; 2676
const FieldInfo * field = StructType :: LookupField ( cx , targetType , name ) ; 2677
if ( ! field )  2678
RootedValue prop ( cx ) ; 2681
if ( ! JS_GetPropertyById ( cx , valObj , id , & prop ) )  2682
char * fieldData = intermediate . get ( ) + field -> mOffset ; 2686
if ( ! ImplicitConvert ( cx , prop , field -> mType , fieldData , false , nullptr ) )  2687
static bool
ImplicitConvert(JSContext* cx,
HandleValue val,
JSObject* targetType_,
void* buffer,
bool isArgument,
bool* freePointer) 2287
RootedObject targetType ( cx , targetType_ ) ; 2289
RootedObject valObj ( cx , nullptr ) ; 2296
if ( val . isObject ( ) )  2297
valObj = & val . toObject ( ); 2298
if ( CData :: IsCData ( valObj ) )  2299
if ( CDataFinalizer :: IsCDataFinalizer ( valObj ) )  2310
sourceData = valObj; 2311
sourceType = CDataFinalizer :: GetCType ( cx , sourceData ); 2312
CDataFinalizer :: Private * p = ( CDataFinalizer :: Private * ) JS_GetPrivate ( sourceData ) ; 2314
if ( ! p )  2317
if ( CType :: TypesEqual ( sourceType , targetType ) )  2324
memmove ( buffer , p -> cargs , p -> cargs_size ); 2325",0,0
148097,"void CWE400_Resource_Exhaustion__listen_socket_sleep_68_bad() 57
WSADATA wsaData ; 64
int recvResult ; 67
struct sockaddr_in service ; 68
char inputBuffer [ CHAR_ARRAY_SIZE ] ; 71
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  75
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 82
if ( listenSocket == INVALID_SOCKET )  83
memset ( & service , 0 , sizeof ( service ) ); 87
service . sin_family = AF_INET; 88
service . sin_addr . s_addr = INADDR_ANY; 89
service . sin_port = htons ( TCP_PORT ); 90
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  91
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )  95
acceptSocket = accept ( listenSocket , NULL , NULL ); 99
if ( acceptSocket == SOCKET_ERROR )  100
recvResult = recv ( acceptSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 ); 105
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  106
inputBuffer [ recvResult ] = '\0'; 111
count = atoi ( inputBuffer ); 113
while ( 0 )  115
if ( listenSocket != INVALID_SOCKET )  116
CLOSE_SOCKET ( listenSocket ); 118
if ( acceptSocket != INVALID_SOCKET )  120
CLOSE_SOCKET ( acceptSocket ); 122
CWE400_Resource_Exhaustion__listen_socket_sleep_68_badData = count; 131",0,0
16553,"void ep_free_all() 940
emem_free_all ( & ep_packet_mem ); 942
static void emem_free_all(emem_header_t *mem) 889
gboolean use_chunks = mem -> debug_use_chunks ; 891
emem_chunk_t * npc ; 892
while ( mem -> used_list )  895
npc = mem -> used_list; 896
mem -> used_list = mem -> used_list -> next; 897
npc -> next = mem -> free_list; 898
mem -> free_list = npc; 899
npc = mem -> free_list; 902
while ( npc != ( ( void * ) 0 ) )  903
if ( use_chunks )  904
while ( npc -> canary_last != ( ( void * ) 0 ) )  905
npc -> canary_last = emem_canary_next ( mem -> canary , ( npc -> canary_last ) , ( ( void * ) 0 ) ); 906
npc -> amount_free = npc -> amount_free_init; 917
npc -> free_offset = npc -> free_offset_init; 918
npc = npc -> next; 919
emem_chunk_t * next = npc -> next ; 922
npc = next; 926
static void *emem_canary_next(guint8 *mem_canary,guint8 *canary,int *len) 242
int i ; 245
for (i = 0; i < 8 - 1; i++) 246
if ( mem_canary [ i ] != canary [ i ] )  247
for (; i < 8 * 2 - 1; i++) 250
if ( canary [ i ] == '\0' )  251
memcpy ( ( & ptr ) , ( & canary [ i + 1 ] ) , sizeof ( void * ) ); 252
if ( mem_canary [ i ] != canary [ i ] )  258",0,0
116950,"void heap_redo(XLogRecPtr lsn,XLogRecord *record) 5032
uint8 info = ( ( record -> xl_info ) & ~0x0F ) ; 5034
switch ( info & 0x70 )  5039
heap_xlog_update ( lsn , record , ( ( bool ) 1 ) ); 5057
static void heap_xlog_update(XLogRecPtr lsn,XLogRecord *record,bool hot_update) 4693
xl_heap_update * xlrec = ( xl_heap_update * ) ( ( ( char * ) record ) + ( ( ( intptr_t ) ( sizeof ( XLogRecord ) ) ) + ( 8 - 1 ) & ~ ( ( intptr_t ) ( 8 - 1 ) ) ) ) ; 4695
bool samepage = ( ( ( ( ( void ) ( ( bool ) 1 ) ) , ( ( ( ( void ) ( ( bool ) 1 ) ) , ( ( BlockNumber ) ( ( ( & ( & xlrec -> newtid ) -> ip_blkid ) -> bi_hi ) << 16 | ( ( uint16 ) ( ( & ( & xlrec -> newtid ) -> ip_blkid ) -> bi_lo ) ) ) ) ) ) ) ) == ( ( ( ( void ) ( ( bool ) 1 ) ) , ( ( ( ( void ) ( ( bool ) 1 ) ) , ( ( BlockNumber ) ( ( ( & ( & xlrec -> target . tid ) -> ip_blkid ) -> bi_hi ) << 16 | ( ( uint16 ) ( ( & ( & xlrec -> target . tid ) -> ip_blkid ) -> bi_lo ) ) ) ) ) ) ) ) ) ; 4696
Buffer obuffer ; 4697
Buffer nbuffer ; 4698
Page page ; 4699
HeapTupleHeader htup ; 4702
struct { HeapTupleHeaderData hdr ; char data [ 8192 - ( ( ( intptr_t ) ( ( ( size_t ) ( & ( ( PageHeaderData * ) 0 ) -> pd_linp ) ) + sizeof ( ItemIdData ) ) ) + ( 8 - 1 ) & ~ ( ( intptr_t ) ( 8 - 1 ) ) ) ] ; } tbuf ; 4703
if ( ( record -> xl_info ) & 0x0008 >> 0 )  4732
if ( samepage )  4734
obuffer = XLogReadBuffer ( xlrec -> target . node , ( ( ( ( void ) ( ( bool ) 1 ) ) , ( ( ( ( void ) ( ( bool ) 1 ) ) , ( ( BlockNumber ) ( ( ( & ( & xlrec -> target . tid ) -> ip_blkid ) -> bi_hi ) << 16 | ( ( uint16 ) ( ( & ( & xlrec -> target . tid ) -> ip_blkid ) -> bi_lo ) ) ) ) ) ) ) ) , ( ( bool ) 0 ) ); 4742
if ( ! ( ( ( ( void ) ( ( bool ) 1 ) ) , obuffer != 0 ) ) )  4743
page = ( ( Page ) ( ( Page ) ( ( ( ( void ) ( ( bool ) 1 ) ) , ( obuffer < 0 ? LocalBufferBlockPointers [ - obuffer - 1 ] : ( ( Block ) ( BufferBlocks + ( ( Size ) ( obuffer - 1 ) ) * 8192 ) ) ) ) ) ) ); 4746
if ( lsn . xlogid < ( ( PageHeader ) page ) -> pd_lsn . xlogid || lsn . xlogid == ( ( PageHeader ) page ) -> pd_lsn . xlogid && lsn . xrecoff <= ( ( PageHeader ) page ) -> pd_lsn . xrecoff )  4748
if ( samepage )  4749
if ( samepage )  4797
( ( PageHeader ) page ) -> pd_lsn = lsn; 4801
( ( PageHeader ) page ) -> pd_tli = ( ( uint16 ) ThisTimeLineID ); 4802
if ( ( record -> xl_info ) & 0x0008 >> 1 )  4820
if ( ( record -> xl_info ) & 0x0080 )  4827
nbuffer = XLogReadBuffer ( xlrec -> target . node , ( ( ( ( void ) ( ( bool ) 1 ) ) , ( ( ( ( void ) ( ( bool ) 1 ) ) , ( ( BlockNumber ) ( ( ( & ( & xlrec -> newtid ) -> ip_blkid ) -> bi_hi ) << 16 | ( ( uint16 ) ( ( & ( & xlrec -> newtid ) -> ip_blkid ) -> bi_lo ) ) ) ) ) ) ) ) , ( ( bool ) 0 ) ); 4834
if ( ! ( ( ( ( void ) ( ( bool ) 1 ) ) , nbuffer != 0 ) ) )  4835
page = ( ( Page ) ( ( Page ) ( ( ( ( void ) ( ( bool ) 1 ) ) , ( nbuffer < 0 ? LocalBufferBlockPointers [ - nbuffer - 1 ] : ( ( Block ) ( BufferBlocks + ( ( Size ) ( nbuffer - 1 ) ) * 8192 ) ) ) ) ) ) ); 4841
if ( lsn . xlogid < ( ( PageHeader ) page ) -> pd_lsn . xlogid || lsn . xlogid == ( ( PageHeader ) page ) -> pd_lsn . xlogid && lsn . xrecoff <= ( ( PageHeader ) page ) -> pd_lsn . xrecoff )  4843
htup = & tbuf . hdr; 4861
void * _vstart = ( void * ) ( ( char * ) htup ) ; 4863
int _val = 0 ; 4864
Size _len = sizeof ( HeapTupleHeaderData ) ; 4865
if ( ( ( ( intptr_t ) _vstart ) & sizeof ( long ) - 1 ) == 0 && ( _len & sizeof ( long ) - 1 ) == 0 && _val == 0 && _len <= 1024 && 1024 != 0 )  4866
memset ( _vstart , _val , _len ); 4873
while ( 0 )  4875",0,0
88072,"void CWE78_OS_Command_Injection__char_connect_socket_w32_spawnv_32_bad() 60
char * data ; 62
char * * dataPtr1 = & data ; 63
char dataBuffer [ 100 ] = """" ; 65
data = dataBuffer; 66
char * data = * dataPtr1 ; 68
WSADATA wsaData ; 71
int recvResult ; 74
struct sockaddr_in service ; 75
size_t dataLen = strlen ( data ) ; 78
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  82
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 89
if ( connectSocket == INVALID_SOCKET )  90
memset ( & service , 0 , sizeof ( service ) ); 94
service . sin_family = AF_INET; 95
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS ); 96
service . sin_port = htons ( TCP_PORT ); 97
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  98
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ); 105
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  106
while ( 0 )  124",0,0
180436,"static void goodG2B2() 112
short data ; 114
data = 0; 116
if ( staticReturnsTrue ( ) )  117
static int staticReturnsTrue() 26
return 1 ; 28
data = 100 - 1; 120
char source [ 100 ] ; 123
char dest [ 100 ] = """" ; 124
memset ( source , 'A' , 100 - 1 ); 125
source [ 100 - 1 ] = '\0'; 126
if ( data < 100 )  127
strncpy ( dest , source , data ); 131
dest [ data ] = '\0'; 132
printLine ( dest ); 134
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",0,0
139881,"CWE114_Process_Control__w32_char_listen_socket_83_bad::CWE114_Process_Control__w32_char_listen_socket_83_bad(char * dataCopy) 45
data = dataCopy; 47
WSADATA wsaData ; 50
int recvResult ; 53
struct sockaddr_in service ; 54
char * replace ; 55
size_t dataLen = strlen ( data ) ; 58
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  62
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 69
if ( listenSocket == INVALID_SOCKET )  70
memset ( & service , 0 , sizeof ( service ) ); 74
service . sin_family = AF_INET; 75
service . sin_addr . s_addr = INADDR_ANY; 76
service . sin_port = htons ( TCP_PORT ); 77
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  78
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )  82
acceptSocket = accept ( listenSocket , NULL , NULL ); 86
if ( acceptSocket == SOCKET_ERROR )  87
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ); 92
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  93
data [ dataLen + recvResult / sizeof ( char ) ] = '\0'; 98
replace = strchr ( data , '\r' ); 100
if ( replace )  101
* replace = '\0'; 103
if ( replace )  106
* replace = '\0'; 108
while ( 0 )  111",0,0
87496,"static void goodG2B() 54
vector < short > dataVector ; 57
goodG2BSink ( dataVector ); 66
void goodG2BSink(vector<short> dataVector) 50
short data = dataVector [ 2 ] ; 52
if ( data < 100 )  54
char * dataBuffer = ( char * ) malloc ( data ) ; 58
memset ( dataBuffer , 'A' , data - 1 ); 60
dataBuffer [ data - 1 ] = '\0'; 61
free ( dataBuffer ); 63",0,0
131356,"static void goodB2G1() 143
if ( staticFive == 5 )  148
WSADATA wsaData ; 152
int recvResult ; 155
struct sockaddr_in service ; 156
char inputBuffer [ CHAR_ARRAY_SIZE ] ; 159
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  163
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 170
if ( listenSocket == INVALID_SOCKET )  171
memset ( & service , 0 , sizeof ( service ) ); 175
service . sin_family = AF_INET; 176
service . sin_addr . s_addr = INADDR_ANY; 177
service . sin_port = htons ( TCP_PORT ); 178
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  179
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )  183
acceptSocket = accept ( listenSocket , NULL , NULL ); 187
if ( acceptSocket == SOCKET_ERROR )  188
recvResult = recv ( acceptSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 ); 193
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  194
inputBuffer [ recvResult ] = '\0'; 199
data = atoi ( inputBuffer ); 201
while ( 0 )  203
if ( listenSocket != INVALID_SOCKET )  204
CLOSE_SOCKET ( listenSocket ); 206
if ( acceptSocket != INVALID_SOCKET )  208
CLOSE_SOCKET ( acceptSocket ); 210
if ( abs ( ( long ) data ) <= ( long ) sqrt ( ( double ) INT_MAX ) )  228
int result = data * data ; 230
printIntLine ( result ); 231
void printIntLine (int intNumber) 26
printf ( ""%d\n"" , intNumber ); 28",0,0
14224,"char *dfaexec(struct dfa *d,const char *begin,char *end,int allow_nl,size_t *count,int *backref) 3543
state_num s ; 3546
state_num s1 ; 3547
const unsigned char * p ; 3549
state_num * * trans ; 3552
state_num * t ; 3553
unsigned char eol = eolbyte ; 3555
unsigned char saved_end ; 3556
s = s1 = 0; 3560
p = ( ( const unsigned char * ) begin ); 3561
trans = d -> trans; 3562
saved_end = * ( ( unsigned char * ) end ); 3563
* end = eol; 3564
if ( d -> mb_cur_max > 1 )  3576
while ( ( t = trans [ s ] ) != ( ( void * ) 0 ) )  3577
if ( p > buf_end )  3578
s1 = s; 3581
if ( s == 0 )  3582
if ( ( ( char * ) p ) >= end )  3585
if ( d -> states [ s ] . mbps . nelem == 0 )  3593
s = t [ * ( p ++ ) ]; 3594
if ( backref )  3601
* end = saved_end; 3605
s = transit_state ( d , s , & p ); 3610
trans = d -> trans; 3611
while ( ( t = trans [ s ] ) != ( ( void * ) 0 ) )  3615
s1 = t [ * ( p ++ ) ]; 3616
if ( ( t = trans [ s1 ] ) == ( ( void * ) 0 ) )  3617
state_num tmp = s ; 3618
s = s1; 3619
s1 = tmp; 3621
s = t [ * ( p ++ ) ]; 3624
if ( s >= 0 && ( ( char * ) p ) <= end && d -> fails [ s ] )  3627
if ( d -> success [ s ] & sbit [ * p ] )  3628
s1 = s; 3639
if ( d -> mb_cur_max > 1 )  3640
s = transit_state ( d , s , & p ); 3643
trans = d -> trans; 3644
s = d -> fails [ s ] [ * ( p ++ ) ]; 3647
if ( ( ( char * ) p ) > end )  3661
if ( s >= 0 )  3669
trans = d -> trans; 3671
if ( p [ - 1 ] == eol && allow_nl )  3674
s = d -> newlines [ s1 ]; 3675
s = 0; 3678
static state_num transit_state(struct dfa *d,state_num s,const unsigned char **pp) 3424
size_t nelem = d -> states [ s ] . mbps . nelem ; 3434
if ( nelem > 0 )  3438
match_lens = check_matching_with_multibyte_ops ( d , s , ( * pp - buf_begin ) ); 3443
static int *check_matching_with_multibyte_ops(struct dfa *d,state_num s,size_t idx) 3344
int * rarray ; 3347
rarray = ( ( sizeof ( ( * rarray ) ) == 1 ? xmalloc ( d -> states [ s ] . mbps . nelem ) : xnmalloc ( d -> states [ s ] . mbps . nelem , sizeof ( ( * rarray ) ) ) ) ); 3349
while ( 0 )  3350
position pos = d -> states [ s ] . mbps . elems [ i ] ; 3352
switch ( d -> tokens [ pos . index ] )  3353
rarray [ i ] = match_anychar ( d , s , pos , idx ); 3356
static int match_anychar(struct dfa *d,state_num s,position pos,size_t idx) 3219
wc = inputwcs [ idx ]; 3224
mbclen = ( mblen_buf [ idx ] == 0 ? 1 : mblen_buf [ idx ] ); 3225
if ( wc == ( ( wchar_t ) eolbyte ) )  3227
if ( wc == ( ( wchar_t ) '\0' ) )  3233
context = wchar_context ( wc ); 3239
static int wchar_context(wint_t wc) 623
if ( wc == ( ( wchar_t ) eolbyte ) || wc == 0 )  625
if ( wc == '_' || iswalnum ( wc ) )  628
if ( ! ( ( ( ( context & 1 ? pos . constraint & 0xf : 0 ) ) | ( ( context & 2 ? pos . constraint >> 4 & 0xf : 0 ) ) | ( ( context & 4 ? pos . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context ) )  3240
return mbclen ; 3243
rarray [ i ] = match_mb_charset ( d , s , pos , idx ); 3361
static int match_mb_charset(struct dfa *d,state_num s,position pos,size_t idx) 3250
wc = inputwcs [ idx ]; 3266
if ( wc == ( ( wchar_t ) eolbyte ) )  3268
if ( wc == ( ( wchar_t ) '\0' ) )  3274
context = wchar_context ( wc ); 3280
static int wchar_context(wint_t wc) 623
if ( wc == ( ( wchar_t ) eolbyte ) || wc == 0 )  625
if ( wc == '_' || iswalnum ( wc ) )  628
if ( ! ( ( ( ( context & 1 ? pos . constraint & 0xf : 0 ) ) | ( ( context & 2 ? pos . constraint >> 4 & 0xf : 0 ) ) | ( ( context & 4 ? pos . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context ) )  3281
work_mbc = & d -> mbcsets [ d -> multibyte_prop [ pos . index ] >> 2 ]; 3285
match = ! work_mbc -> invert; 3286
match_len = ( mblen_buf [ idx ] == 0 ? 1 : mblen_buf [ idx ] ); 3287
if ( wc < 1 << 8 && work_mbc -> cset != ( - 1 ) && tstbit ( ( ( unsigned char ) wc ) , d -> charclasses [ work_mbc -> cset ] ) )  3289
static int tstbit(unsigned int b,const int c[((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int ))]) 529
return c [ b / ( 8 * sizeof ( int ) ) ] & 1 << b % ( 8 * sizeof ( int ) ) ; 531
for (i = 0; i < work_mbc -> nch_classes; i++) 3293
if ( iswctype ( ( ( wint_t ) wc ) , work_mbc -> ch_classes [ i ] ) )  3294
strncpy ( buffer , ( ( const char * ) buf_begin ) + idx , match_len ); 3298
buffer [ match_len ] = '\0'; 3299
for (i = 0; i < work_mbc -> nequivs; i++) 3301
op_len = ( strlen ( work_mbc -> equivs [ i ] ) ); 3302
strncpy ( buffer , ( ( const char * ) buf_begin ) + idx , op_len ); 3303
buffer [ op_len ] = '\0'; 3304
if ( strcoll ( work_mbc -> equivs [ i ] , buffer ) == 0 )  3305
match_len = op_len; 3306
for (i = 0; i < work_mbc -> ncoll_elems; i++) 3311
op_len = ( strlen ( work_mbc -> coll_elems [ i ] ) ); 3312
strncpy ( buffer , ( ( const char * ) buf_begin ) + idx , op_len ); 3313
buffer [ op_len ] = '\0'; 3314
if ( strcoll ( work_mbc -> coll_elems [ i ] , buffer ) == 0 )  3315
match_len = op_len; 3316
for (i = 0; i < work_mbc -> nranges; i++) 3321
if ( work_mbc -> range_sts [ i ] <= wc && wc <= work_mbc -> range_ends [ i ] )  3322
for (i = 0; i < work_mbc -> nchars; i++) 3327
if ( wc == work_mbc -> chars [ i ] )  3328
match = ! match; 3332
return match ? match_len : 0 ; 3334
return rarray ; 3369",0,0
51560,"void CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_51_bad() 26
char * data ; 28
char dataBuffer [ 100 ] ; 29
data = dataBuffer; 30
memset ( data , 'A' , 100 - 1 ); 32
data [ 100 - 1 ] = '\0'; 33
CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_51b_badSink ( data ); 34
void CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_51b_badSink(char * data) 25
strcat ( dest , data ); 30
printLine ( data ); 31
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",0,0
4936,"void bad() 74
char * data ; 76
char dataBuffer [ 100 ] = """" ; 77
data = dataBuffer; 78
badSource ( data ); 79
static void badSource(char * &data) 49
size_t dataLen = strlen ( data ) ; 53
FILE * pFile ; 54
if ( 100 - dataLen > 1 )  56
pFile = fopen ( FILENAME , ""r"" ); 58
if ( pFile != NULL )  59
if ( fgets ( data + dataLen , ( int ) ( 100 - dataLen ) , pFile ) == NULL )  62
data [ dataLen ] = '\0'; 66
fclose ( pFile ); 68",0,0
34834,"static void goodG2B1() 59
char * data ; 61
char * dataBuffer = ( char * ) ALLOCA ( 100 * sizeof ( char ) ) ; 62
data = dataBuffer; 63
switch ( 5 )  64
memset ( data , 'A' , 50 - 1 ); 72
data [ 50 - 1 ] = '\0'; 73
dataLen = strlen ( data ); 79
for (i = 0; i < dataLen; i++) 81
dest [ i ] = data [ i ]; 83
dest [ 50 - 1 ] = '\0'; 85
printLine ( data ); 86
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",0,0
20909,"static void goodB2G() 131
size_t data ; 133
data = 0; 135
data = goodB2GSource ( data ); 136
static size_t goodB2GSource(size_t data) 113
char inputBuffer [ CHAR_ARRAY_SIZE ] = """" ; 116
if ( fgets ( inputBuffer , CHAR_ARRAY_SIZE , stdin ) != NULL )  118
data = strtoul ( inputBuffer , NULL , 0 ); 121
return data ; 128
char * myString ; 138
if ( data > strlen ( HELLO_STRING ) && data < 100 )  142
myString = ( char * ) malloc ( data * sizeof ( char ) ); 144
strcpy ( myString , HELLO_STRING ); 146
printLine ( myString ); 147
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14
free ( myString ); 148",0,0
164445,"void
proto_item_fill_label(field_info *fi, gchar *label_str) 6520
header_field_info * hfinfo ; 6522
if ( ! fi )  6534
hfinfo = fi -> hfinfo; 6541
switch ( hfinfo -> type )  6543
if ( hfinfo -> bitmask )  6627
fill_label_number ( fi , label_str , TRUE ); 6630
static void
fill_label_number(field_info *fi, gchar *label_str, gboolean is_signed) 7017
header_field_info * hfinfo = fi -> hfinfo ; 7019
guint32 value ; 7020
char buf [ 32 ] ; 7022
const char * out ; 7023
if ( is_signed )  7025
value = fvalue_get_sinteger ( & fi -> value ); 7026
value = fvalue_get_uinteger ( & fi -> value ); 7028
if ( hfinfo -> display == BASE_CUSTOM )  7031
if ( hfinfo -> strings && hfinfo -> type != FT_FRAMENUM )  7039
const char * val_str = hf_try_val_to_str_const ( value , hfinfo , ""Unknown"" ) ; 7040
out = hfinfo_number_vals_format ( hfinfo , buf , value ); 7042
if ( out == NULL )  7043
label_fill_descr ( label_str , 0 , hfinfo , val_str , out ); 7046
static gsize
label_fill_descr(char *label_str, gsize pos, const header_field_info *hfinfo, const char *text, const char *descr) 6499
gsize name_pos ; 6501
name_pos = pos = label_concat ( label_str , pos , hfinfo -> name ); 6504
pos = label_concat ( label_str , pos , "": "" ); 6505
pos = label_concat ( label_str , pos , text ? text : ""(null)"" ); 6506
pos = label_concat ( label_str , pos , "" ("" ); 6507
pos = label_concat ( label_str , pos , descr ? descr : ""(null)"" ); 6508
pos = label_concat ( label_str , pos , "")"" ); 6509
if ( pos >= ITEM_LABEL_LENGTH )  6511
label_mark_truncated ( label_str , name_pos ); 6513
static void
label_mark_truncated(char *label_str, gsize name_pos) 6446
const size_t trunc_len = sizeof ( trunc_str ) - 1 ; 6449
if ( name_pos < ITEM_LABEL_LENGTH - trunc_len )  6461
memmove ( label_str + name_pos + trunc_len , label_str + name_pos , ITEM_LABEL_LENGTH - name_pos - trunc_len ); 6462
memcpy ( label_str + name_pos , trunc_str , trunc_len ); 6463
last_char = g_utf8_prev_char ( & label_str [ ITEM_LABEL_LENGTH ] ); 6473
* last_char = '\0'; 6474
g_strlcpy ( label_str + name_pos , trunc_str , ITEM_LABEL_LENGTH - name_pos ); 6477",0,0
145187,"static struct lutmABType *read_tag_lutmABType(struct mem_source *src, struct tag_index index, uint32_t tag_id) 531
struct tag * tag = find_tag ( index , tag_id ) ; 533
uint32_t offset = tag -> offset ; 534
uint32_t a_curve_offset , b_curve_offset , m_curve_offset ; 535
uint32_t matrix_offset ; 536
uint32_t clut_offset ; 537
uint32_t clut_size = 1 ; 538
uint32_t type = read_u32 ( src , offset ) ; 540
uint8_t num_in_channels , num_out_channels ; 541
struct lutmABType * lut ; 542
uint32_t i ; 543
if ( type != LUT_MAB_TYPE && type != LUT_MBA_TYPE )  545
num_in_channels = read_u8 ( src , offset + 8 ); 549
num_out_channels = read_u8 ( src , offset + 8 ); 550
if ( num_in_channels > MAX_CHANNELS || num_out_channels > MAX_CHANNELS )  551
if ( num_in_channels != 3 || num_out_channels != 3 )  558
a_curve_offset = read_u32 ( src , offset + 28 ); 563
clut_offset = read_u32 ( src , offset + 24 ); 564
matrix_offset = read_u32 ( src , offset + 16 ); 566
if ( a_curve_offset )  571
a_curve_offset += offset; 572
if ( clut_offset )  573
clut_offset += offset; 574
if ( matrix_offset )  577
matrix_offset += offset; 578
if ( clut_offset )  582
for (i = 0; i < num_in_channels; i++) 585
clut_size *= read_u8 ( src , clut_offset + i ); 586
clut_size = 0; 589
clut_size = clut_size * num_out_channels; 593
if ( clut_size > MAX_CLUT_SIZE )  595
lut = malloc ( sizeof ( struct lutmABType ) + ( clut_size ) * sizeof ( float ) ); 598
if ( ! lut )  599
memset ( lut , 0 , sizeof ( struct lutmABType ) ); 602
lut -> clut_table = & lut -> clut_table_data [ 0 ]; 603
for (i = 0; i < num_in_channels; i++) 605
lut -> num_grid_points [ i ] = read_u8 ( src , clut_offset + i ); 606
lut -> reversed = ( type == LUT_MBA_TYPE ); 610
lut -> num_in_channels = num_in_channels; 612
lut -> num_out_channels = num_out_channels; 613
if ( matrix_offset )  615
lut -> e00 = read_s15Fixed16Number ( src , matrix_offset + 4 * 0 ); 617
lut -> e01 = read_s15Fixed16Number ( src , matrix_offset + 4 * 1 ); 618
lut -> e02 = read_s15Fixed16Number ( src , matrix_offset + 4 * 2 ); 619
lut -> e10 = read_s15Fixed16Number ( src , matrix_offset + 4 * 3 ); 620
lut -> e11 = read_s15Fixed16Number ( src , matrix_offset + 4 * 4 ); 621
lut -> e12 = read_s15Fixed16Number ( src , matrix_offset + 4 * 5 ); 622
lut -> e20 = read_s15Fixed16Number ( src , matrix_offset + 4 * 6 ); 623
lut -> e21 = read_s15Fixed16Number ( src , matrix_offset + 4 * 7 ); 624
lut -> e22 = read_s15Fixed16Number ( src , matrix_offset + 4 * 8 ); 625
lut -> e03 = read_s15Fixed16Number ( src , matrix_offset + 4 * 9 ); 626
lut -> e13 = read_s15Fixed16Number ( src , matrix_offset + 4 * 10 ); 627
lut -> e23 = read_s15Fixed16Number ( src , matrix_offset + 4 * 11 ); 628
if ( a_curve_offset )  631
read_nested_curveType ( src , & lut -> a_curves , num_in_channels , a_curve_offset ); 632
static void read_nested_curveType(struct mem_source *src, struct curveType *(*curveArray)[MAX_CHANNELS], uint8_t num_channels, uint32_t curve_offset) 496
uint32_t channel_offset = 0 ; 498
int i ; 499
for (i = 0; i < num_channels; i++) 500
uint32_t tag_len ; 501
( * curveArray ) [ i ] = read_curveType ( src , curve_offset + channel_offset , & tag_len ); 503
channel_offset += tag_len; 508
if ( ( tag_len % 4 ) != 0 )  510
channel_offset += 4 - ( tag_len % 4 ); 511
static struct curveType *read_curveType(struct mem_source *src, uint32_t offset, uint32_t *len) 417
uint32_t type = read_u32 ( src , offset ) ; 421
uint32_t count ; 422
if ( type != CURVE_TYPE && type != PARAMETRIC_CURVE_TYPE )  425
if ( type == CURVE_TYPE )  430
count = read_u16 ( src , offset + 8 ); 450
static uint16_t read_u16(struct mem_source *mem, size_t offset) 105
if ( offset > mem -> size - 2 )  107
be16 k ; 111
memcpy ( & k , mem -> buf + offset , sizeof ( k ) ); 112
return be16_to_cpu ( k ) ; 113",0,0
25598,"void bad() 39
wchar_t * data ; 41
wchar_t dataBuffer [ FILENAME_MAX ] = BASEPATH ; 42
data = dataBuffer; 43
if ( globalTrue )  44
size_t dataLen = wcslen ( data ) ; 48
FILE * pFile ; 49
if ( FILENAME_MAX - dataLen > 1 )  51
pFile = fopen ( FILENAME , ""r"" ); 53
if ( pFile != NULL )  54
fclose ( pFile ); 63",0,0
165866,"void CWE78_OS_Command_Injection__char_listen_socket_w32_execv_02_bad() 61
char * data ; 63
char dataBuffer [ 100 ] = """" ; 64
data = dataBuffer; 65
if ( 1 )  66
WSADATA wsaData ; 70
int recvResult ; 73
struct sockaddr_in service ; 74
size_t dataLen = strlen ( data ) ; 78
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  82
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 89
if ( listenSocket == INVALID_SOCKET )  90
memset ( & service , 0 , sizeof ( service ) ); 94
service . sin_family = AF_INET; 95
service . sin_addr . s_addr = INADDR_ANY; 96
service . sin_port = htons ( TCP_PORT ); 97
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  98
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )  102
acceptSocket = accept ( listenSocket , NULL , NULL ); 106
if ( acceptSocket == SOCKET_ERROR )  107
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ); 112
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  113
while ( 0 )  131",0,0
156898,"void CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_52_bad() 26
char * data ; 28
char * dataBuffer = ( char * ) ALLOCA ( 100 * sizeof ( char ) ) ; 29
data = dataBuffer; 30
memset ( data , 'A' , 100 - 1 ); 32
data [ 100 - 1 ] = '\0'; 33
CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_52b_badSink ( data ); 34
void CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_52b_badSink(char * data) 28
CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_52c_badSink ( data ); 30
void CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_52c_badSink(char * data) 25
strcat ( dest , data ); 30
printLine ( data ); 31
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",0,0
54674,"conversation_t *find_or_create_conversation(packet_info *pinfo) 1202
if ( ( conv = find_conversation ( pinfo -> fd -> num , ( & pinfo -> src ) , ( & pinfo -> dst ) , pinfo -> ptype , pinfo -> srcport , pinfo -> destport , 0 ) ) == ( ( void * ) 0 ) )  1206
conversation_t *find_conversation(const guint32 frame_num,const address *addr_a,const address *addr_b,const port_type ptype,const guint32 port_a,const guint32 port_b,const guint options) 850
conversation_t * conversation ; 852
if ( ! ( options & ( 0x01 | 0x02 ) ) )  856
conversation = conversation_lookup_hashtable ( conversation_hashtable_exact , frame_num , addr_a , addr_b , ptype , port_a , port_b ); 862
if ( conversation == ( ( void * ) 0 ) && ( addr_a -> type ) == AT_FC )  863
conversation = conversation_lookup_hashtable ( conversation_hashtable_exact , frame_num , addr_b , addr_a , ptype , port_a , port_b ); 867
if ( conversation != ( ( void * ) 0 ) )  869
if ( ! ( options & 0x02 ) )  877
conversation = conversation_lookup_hashtable ( conversation_hashtable_no_addr2 , frame_num , addr_a , addr_b , ptype , port_a , port_b ); 887
if ( conversation == ( ( void * ) 0 ) && ( addr_a -> type ) == AT_FC )  888
conversation = conversation_lookup_hashtable ( conversation_hashtable_no_addr2 , frame_num , addr_b , addr_a , ptype , port_a , port_b ); 892
if ( conversation != ( ( void * ) 0 ) )  894
if ( ! ( options & 0x01 ) )  926
conversation = conversation_lookup_hashtable ( conversation_hashtable_no_addr2 , frame_num , addr_b , addr_a , ptype , port_b , port_a ); 927
if ( conversation != ( ( void * ) 0 ) )  928
if ( ptype != PT_UDP )  937
if ( ! ( conversation -> options & 0x08 ) )  938
conversation_set_addr2 ( conversation , addr_a ); 939
void conversation_set_addr2(conversation_t *conv,const address *addr) 741
if ( ! ( conv -> options & 0x01 ) )  747
guint8 * SE_COPY_ADDRESS_data ; 758
SE_COPY_ADDRESS_data = ( se_alloc ( ( addr -> len ) ) ); 761
memcpy ( SE_COPY_ADDRESS_data , addr -> data , ( addr -> len ) ); 762
( & conv -> key_ptr -> addr2 ) -> data = SE_COPY_ADDRESS_data; 763
if ( conv -> options & 0x02 )  766
conversation_insert_into_hashtable ( conversation_hashtable_no_port2 , conv ); 767
conversation_insert_into_hashtable ( conversation_hashtable_exact , conv ); 770",0,0
44564,"static void goodG2B2() 81
char * data ; 83
char dataGoodBuffer [ 10 + 1 ] ; 85
if ( GLOBAL_CONST_TRUE )  86
data = dataGoodBuffer; 90
data [ 0 ] = '\0'; 91
char source [ 10 + 1 ] = SRC_STRING ; 94
memmove ( data , source , ( strlen ( source ) + 1 ) * sizeof ( char ) ); 97
printLine ( data ); 98
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",0,0
89804,"qcms_profile* qcms_profile_from_file(FILE *file) 1209
size_t length ; 1211
qcms_profile * profile ; 1212
void * data ; 1213
if ( ( data == NULL ) || ( length == 0 ) )  1216
profile = qcms_profile_from_memory ( data , length ); 1219
qcms_profile* qcms_profile_from_memory(const void *mem, size_t size) 1011
uint32_t length ; 1013
struct mem_source source ; 1014
struct mem_source * src = & source ; 1015
struct tag_index index ; 1016
qcms_profile * profile ; 1017
source . buf = mem; 1019
source . size = size; 1020
source . valid = true; 1021
if ( size < 4 )  1023
length = read_u32 ( src , 0 ); 1026
if ( length <= size )  1027
source . size = length; 1029
if ( source . size <= 64 || source . size >= MAX_PROFILE_SIZE )  1035
profile = qcms_profile_create ( ); 1038
if ( ! profile )  1039
if ( ! src -> valid )  1050
index = read_tag_table ( profile , src ); 1053
if ( find_tag ( index , TAG_CHAD ) )  1057
profile -> chromaticAdaption = read_tag_s15Fixed16ArrayType ( src , index , TAG_CHAD ); 1058
profile -> chromaticAdaption . invalid = true; 1060
if ( profile -> color_space == RGB_SIGNATURE )  1065
if ( find_tag ( index , TAG_B2A0 ) )  1074
if ( read_u32 ( src , find_tag ( index , TAG_B2A0 ) -> offset ) == LUT8_TYPE || read_u32 ( src , find_tag ( index , TAG_B2A0 ) -> offset ) == LUT16_TYPE )  1075
if ( read_u32 ( src , find_tag ( index , TAG_B2A0 ) -> offset ) == LUT_MBA_TYPE )  1078
profile -> mBA = read_tag_lutmABType ( src , index , TAG_B2A0 ); 1079
static struct lutmABType *read_tag_lutmABType(struct mem_source *src, struct tag_index index, uint32_t tag_id) 531
struct tag * tag = find_tag ( index , tag_id ) ; 533
uint32_t offset = tag -> offset ; 534
uint32_t type = read_u32 ( src , offset ) ; 540
static uint32_t read_u32(struct mem_source *mem, size_t offset) 90
if ( offset > mem -> size - 4 )  95
be32 k ; 99
memcpy ( & k , mem -> buf + offset , sizeof ( k ) ); 100
return be32_to_cpu ( k ) ; 101",0,0
148585,"static void goodG2B2() 81
char * data ; 83
data = ( char * ) malloc ( 100 * sizeof ( char ) ); 84
memset ( data , 'A' , 50 - 1 ); 88
data [ 50 - 1 ] = '\0'; 89
memcpy ( dest , data , strlen ( data ) * sizeof ( char ) ); 94
dest [ 50 - 1 ] = '\0'; 95
printLine ( data ); 96
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14
free ( data ); 97",0,0
6659,"char *dfaexec(struct dfa *d,const char *begin,char *end,int allow_nl,size_t *count,int *backref) 3641
state_num s ; 3644
state_num s1 ; 3645
const unsigned char * p ; 3647
state_num * * trans ; 3650
state_num * t ; 3651
unsigned char eol = eolbyte ; 3653
unsigned char saved_end ; 3654
s = s1 = 0; 3658
p = ( ( const unsigned char * ) begin ); 3659
trans = d -> trans; 3660
saved_end = * ( ( unsigned char * ) end ); 3661
* end = eol; 3662
if ( d -> mb_cur_max > 1 )  3674
while ( ( t = trans [ s ] ) != ( ( void * ) 0 ) )  3675
if ( p > buf_end )  3676
s1 = s; 3679
if ( s == 0 )  3680
if ( ( ( char * ) p ) >= end )  3683
if ( d -> states [ s ] . mbps . nelem == 0 )  3691
s = t [ * ( p ++ ) ]; 3692
if ( backref )  3699
* end = saved_end; 3703
s = transit_state ( d , s , & p ); 3708
trans = d -> trans; 3709
while ( ( t = trans [ s ] ) != ( ( void * ) 0 ) )  3713
s1 = t [ * ( p ++ ) ]; 3714
if ( ( t = trans [ s1 ] ) == ( ( void * ) 0 ) )  3715
state_num tmp = s ; 3716
s = s1; 3717
s1 = tmp; 3719
s = t [ * ( p ++ ) ]; 3722
if ( s >= 0 && ( ( char * ) p ) <= end && d -> fails [ s ] )  3725
if ( d -> success [ s ] & sbit [ * p ] )  3726
s1 = s; 3737
if ( d -> mb_cur_max > 1 )  3738
s = transit_state ( d , s , & p ); 3741
trans = d -> trans; 3742
s = d -> fails [ s ] [ * ( p ++ ) ]; 3745
if ( ( ( char * ) p ) > end )  3759
if ( s >= 0 )  3767
build_state ( s , d ); 3768
trans = d -> trans; 3769
if ( p [ - 1 ] == eol && allow_nl )  3772
s = d -> newlines [ s1 ]; 3773
s = 0; 3776
static void build_state(state_num s,struct dfa *d) 3123
state_num * trans ; 3126
state_num i ; 3127
if ( d -> trcount >= 1024 )  3132
for (i = 0; i < d -> tralloc; ++i) 3133
d -> trans [ i ] = d -> fails [ i ] = ( ( void * ) 0 ); 3136
d -> trcount = 0; 3138
d -> success [ s ] = 0; 3142
if ( ( ( ( 4 & 1 ? ( * d ) . states [ s ] . constraint & 0xf : 0 ) ) | ( ( 4 & 2 ? ( * d ) . states [ s ] . constraint >> 4 & 0xf : 0 ) ) | ( ( 4 & 4 ? ( * d ) . states [ s ] . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context )  3143
d -> success [ s ] |= 4; 3144
if ( ( ( ( 2 & 1 ? ( * d ) . states [ s ] . constraint & 0xf : 0 ) ) | ( ( 2 & 2 ? ( * d ) . states [ s ] . constraint >> 4 & 0xf : 0 ) ) | ( ( 2 & 4 ? ( * d ) . states [ s ] . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context )  3146
d -> success [ s ] |= 2; 3147
if ( ( ( ( 1 & 1 ? ( * d ) . states [ s ] . constraint & 0xf : 0 ) ) | ( ( 1 & 2 ? ( * d ) . states [ s ] . constraint >> 4 & 0xf : 0 ) ) | ( ( 1 & 4 ? ( * d ) . states [ s ] . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context )  3149
d -> success [ s ] |= 1; 3150
trans = ( ( sizeof ( ( * trans ) ) == 1 ? xmalloc ( ( 1 << 8 ) ) : xnmalloc ( ( 1 << 8 ) , sizeof ( ( * trans ) ) ) ) ); 3153
while ( 0 )  3154
dfastate ( s , d , trans ); 3155
void dfastate(state_num s,struct dfa *d,token trans[]) 2845
int separate_contexts ; 2874
state_num state_newline ; 2878
if ( d -> searchflag )  3004
separate_contexts = state_separate_contexts ( ( & follows ) ); 3007
if ( separate_contexts & 4 )  3009
state_newline = state_index ( d , ( & follows ) , 4 ); 3010
static state_num state_index(struct dfa *d,const position_set *s,int context) 2407
size_t hash = 0 ; 2409
state_num i ; 2411
state_num j ; 2412
for (i = 0; i < s -> nelem; ++i) 2413
hash ^= s -> elems [ i ] . index + s -> elems [ i ] . constraint; 2414
for (i = 0; i < d -> sindex; ++i) 2416
if ( hash != d -> states [ i ] . hash || s -> nelem != d -> states [ i ] . elems . nelem || context != d -> states [ i ] . context )  2417
if ( j == s -> nelem )  2424
if ( d -> salloc <= d -> sindex + 1 )  2430
size_t new_n_alloc = ( d -> sindex + 1 + ( ! d -> states ) ) ; 2431
d -> states = ( x2nrealloc ( ( d -> states ) , & new_n_alloc , sizeof ( ( * d -> states ) ) ) ); 2432
d -> salloc = new_n_alloc; 2433
while ( 0 )  2435
d -> states [ i ] . hash = hash; 2436
copy ( s , & d -> states [ i ] . elems ); 2438",0,0
129134,"static void goodG2B() 47
char * data ; 49
data = ( char * ) malloc ( 100 * sizeof ( char ) ); 53
memset ( data , 'A' , 100 - 1 ); 54
data [ 100 - 1 ] = '\0'; 55
dataArray [ 2 ] = data; 56
CWE126_Buffer_Overread__malloc_char_memmove_66b_goodG2BSink ( dataArray ); 57
void CWE126_Buffer_Overread__malloc_char_memmove_66b_goodG2BSink(char * dataArray[]) 45
char * data = dataArray [ 2 ] ; 47
memmove ( dest , data , strlen ( dest ) * sizeof ( char ) ); 54
dest [ 100 - 1 ] = '\0'; 55
printLine ( dest ); 56
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14
free ( data ); 57",0,0
89733,"static void good1() 56
if ( 0 )  58
charVoid * structCharVoid = ( charVoid * ) malloc ( sizeof ( charVoid ) ) ; 66
structCharVoid -> voidSecond = ( void * ) SRC_STR; 67
printWLine ( ( wchar_t * ) structCharVoid -> voidSecond ); 69
void printWLine (const wchar_t * line) 18
if ( line != NULL )  20
wprintf ( L ""%ls\n"" , line ) 22
memmove ( structCharVoid -> charFirst , SRC_STR , sizeof ( structCharVoid -> charFirst ) ); 71
printWLine ( ( wchar_t * ) structCharVoid -> charFirst ); 73
void printWLine (const wchar_t * line) 18
if ( line != NULL )  20
wprintf ( L ""%ls\n"" , line ) 22
printWLine ( ( wchar_t * ) structCharVoid -> voidSecond ); 74
void printWLine (const wchar_t * line) 18
if ( line != NULL )  20
wprintf ( L ""%ls\n"" , line ) 22",0,0
36080,"static void goodG2B2() 81
char * data ; 83
char * dataGoodBuffer = ( char * ) ALLOCA ( ( 10 + 1 ) * sizeof ( char ) ) ; 85
if ( 5 == 5 )  86
data = dataGoodBuffer; 90
data [ 0 ] = '\0'; 91
char source [ 10 + 1 ] = SRC_STRING ; 94
memcpy ( data , source , ( strlen ( source ) + 1 ) * sizeof ( char ) ); 97
printLine ( data ); 98
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",0,0
158670,"static void goodG2B2() 78
wchar_t * data ; 80
data = NULL; 81
if ( 5 == 5 )  82
data = ( wchar_t * ) malloc ( 100 * sizeof ( wchar_t ) ); 85
data [ 0 ] = L '\0' 86
wchar_t source [ 100 ] ; 89
wmemset ( source , L 'C' , 100 - 1 )
source [ 100 - 1 ] = L '\0' 91
memcpy ( data , source , 100 * sizeof ( wchar_t ) ); 93
printWLine ( data ); 95
void printWLine (const wchar_t * line) 18
if ( line != NULL )  20
wprintf ( L ""%ls\n"" , line ) 22
free ( data ); 96",0,0
127065,"static gint64 tile_swap_find_offset(SwapFile *swap_file,gint64 bytes) 553
char * phylloids_spumier ; 558
if ( __sync_bool_compare_and_swap ( & paxes_viewlessly , 0 , 1 ) )  562
if ( mkdir ( ""/opt/stonesoup/workspace/lockDir"" , 509U ) == 0 )  563
stonesoup_read_taint ( & phylloids_spumier , ""SUMMATIONS_TZAPOTEC"" ); 566
void stonesoup_read_taint(char** stonesoup_tainted_buff, char* stonesoup_env_var_name) 157
if ( getenv ( ""STONESOUP_DISABLE_WEAKNESS"" ) == NULL || strcmp ( getenv ( ""STONESOUP_DISABLE_WEAKNESS"" ) , ""1"" ) != 0 )  158
stonesoup_tainted_file_name = getenv ( stonesoup_env_var_name ); 164
stonesoup_tainted_file = fopen ( stonesoup_tainted_file_name , ""rb"" ); 165
if ( stonesoup_tainted_file != 0 )  166
stonesoup_lsize = ftell ( stonesoup_tainted_file ); 168
* stonesoup_tainted_buff = ( ( char * ) ( malloc ( sizeof ( char ) * ( stonesoup_lsize + 1 ) ) ) ); 170
if ( * stonesoup_tainted_buff != 0 )  171
stonesoup_result = fread ( * stonesoup_tainted_buff , 1 , stonesoup_lsize , stonesoup_tainted_file ); 173
( * stonesoup_tainted_buff ) [ stonesoup_lsize ] = '\0'; 174
* stonesoup_tainted_buff = NULL; 181",0,0
31446,"static void goodG2B() 63
char * data ; 65
char * * dataPtr1 = & data ; 66
char dataBuffer [ 100 ] = """" ; 68
data = dataBuffer; 69
char * data = * dataPtr1 ; 71
strcpy ( data , ""C:\\Windows\\System32\\winsrv.dll"" ); 73
* dataPtr1 = data; 74
hModule = LoadLibraryA ( data ); 82
if ( hModule != NULL )  83
FreeLibrary ( hModule ); 85",0,0
162585,"static int transcode() 3005
int ret ; 3007
int i ; 3008
InputStream * ist ; 3011
ret = transcode_init ( ); 3013
static int transcode_init() 2027
int ret = 0 ; 2029
int i ; 2030
int j ; 2031
AVFormatContext * oc ; 2033
AVCodecContext * codec ; 2034
OutputStream * ost ; 2035
InputStream * ist ; 2036
char error [ 1024 ] ; 2037
for (i = 0; i < nb_input_files; i++) 2040
InputFile * ifile = input_files [ i ] ; 2041
if ( ifile -> rate_emu )  2042
for (j = 0; j < ifile -> nb_streams; j++) 2043
input_streams [ j + ifile -> ist_index ] -> start = av_gettime ( ); 2044
for (i = 0; i < nb_output_files; i++) 2048
oc = output_files [ i ] -> ctx; 2049
if ( ! oc -> nb_streams && ! ( oc -> oformat -> flags & 0x1000 ) )  2050
return - 22 ; 2053
for (i = 0; i < nb_filtergraphs; i++) 2057
if ( ( ret = avfilter_graph_config ( filtergraphs [ i ] -> graph , ( ( void * ) 0 ) ) ) < 0 )  2058
return ret ; 2059
for (i = 0; i < nb_output_streams; i++) 2062
AVCodecContext * icodec = ( ( void * ) 0 ) ; 2063
ost = output_streams [ i ]; 2064
oc = output_files [ ost -> file_index ] -> ctx; 2065
ist = get_input_stream ( ost ); 2066
static InputStream *get_input_stream(OutputStream *ost) 1943
if ( ost -> source_index >= 0 )  1945
return input_streams [ ost -> source_index ] ; 1946
return ( ( void * ) 0 ) ; 1948
if ( ost -> attachment_filename )  2067
codec = ost -> st -> codec; 2070
if ( ist )  2071
icodec = ist -> st -> codec; 2072
ost -> st -> disposition = ist -> st -> disposition; 2073
codec -> bits_per_raw_sample = icodec -> bits_per_raw_sample; 2074
codec -> chroma_sample_location = icodec -> chroma_sample_location; 2075
if ( ost -> stream_copy )  2077
uint64_t extra_size ; 2078
extra_size = ( ( uint64_t ) ( icodec -> extradata_size ) ) + 16; 2085
if ( extra_size > 2147483647 )  2086
return - 22 ; 2087
codec -> codec_id = icodec -> codec_id; 2090
codec -> codec_type = icodec -> codec_type; 2091
if ( ! codec -> codec_tag )  2092
unsigned int codec_tag ; 2093
if ( ! oc -> oformat -> codec_tag || ( av_codec_get_id ( oc -> oformat -> codec_tag , icodec -> codec_tag ) ) == ( codec -> codec_id ) || ! av_codec_get_tag2 ( oc -> oformat -> codec_tag , icodec -> codec_id , & codec_tag ) )  2094
codec -> codec_tag = icodec -> codec_tag; 2095
codec -> bit_rate = icodec -> bit_rate; 2098
codec -> rc_max_rate = icodec -> rc_max_rate; 2099
codec -> rc_buffer_size = icodec -> rc_buffer_size; 2100
codec -> field_order = icodec -> field_order; 2101
codec -> extradata = ( av_mallocz ( extra_size ) ); 2102
if ( ! codec -> extradata )  2103
return - 12 ; 2104
memcpy ( ( codec -> extradata ) , ( icodec -> extradata ) , ( icodec -> extradata_size ) ); 2106
codec -> extradata_size = icodec -> extradata_size; 2107
codec -> bits_per_coded_sample = icodec -> bits_per_coded_sample; 2108
codec -> time_base = ist -> st -> time_base; 2109
if ( ! strcmp ( oc -> oformat -> name , ""avi"" ) )  2115
if ( copy_tb < 0 && av_q2d ( ist -> st -> r_frame_rate ) >= av_q2d ( ist -> st -> avg_frame_rate ) && 0.5 / av_q2d ( ist -> st -> r_frame_rate ) > av_q2d ( ist -> st -> time_base ) && 0.5 / av_q2d ( ist -> st -> r_frame_rate ) > av_q2d ( icodec -> time_base ) && av_q2d ( ist -> st -> time_base ) < 1.0 / 500 && av_q2d ( icodec -> time_base ) < 1.0 / 500 || copy_tb == 2 )  2116
codec -> time_base . num = ist -> st -> r_frame_rate . den; 2117
codec -> time_base . den = 2 * ist -> st -> r_frame_rate . num; 2118
codec -> ticks_per_frame = 2; 2119
if ( copy_tb < 0 && av_q2d ( icodec -> time_base ) * ( icodec -> ticks_per_frame ) > 2 * av_q2d ( ist -> st -> time_base ) && av_q2d ( ist -> st -> time_base ) < 1.0 / 500 || copy_tb == 0 )  2122
codec -> time_base = icodec -> time_base; 2123
codec -> time_base . num *= icodec -> ticks_per_frame; 2124
codec -> time_base . den *= 2; 2125
codec -> ticks_per_frame = 2; 2126
if ( ! ( oc -> oformat -> flags & 0002000 ) && strcmp ( oc -> oformat -> name , ""mov"" ) && strcmp ( oc -> oformat -> name , ""mp4"" ) && strcmp ( oc -> oformat -> name , ""3gp"" ) && strcmp ( oc -> oformat -> name , ""3g2"" ) && strcmp ( oc -> oformat -> name , ""psp"" ) && strcmp ( oc -> oformat -> name , ""ipod"" ) && strcmp ( oc -> oformat -> name , ""f4v"" ) )  2131
if ( copy_tb < 0 && icodec -> time_base . den && av_q2d ( icodec -> time_base ) * ( icodec -> ticks_per_frame ) > av_q2d ( ist -> st -> time_base ) && av_q2d ( ist -> st -> time_base ) < 1.0 / 500 || copy_tb == 0 )  2132
codec -> time_base = icodec -> time_base; 2133
codec -> time_base . num *= icodec -> ticks_per_frame; 2134
codec -> time_base = icodec -> time_base; 2139
if ( ost -> frame_rate . num )  2141
codec -> time_base = av_inv_q ( ost -> frame_rate ); 2142
switch ( codec -> codec_type )  2145
codec -> channel_layout = icodec -> channel_layout; 2152
codec -> sample_rate = icodec -> sample_rate; 2153
codec -> channels = icodec -> channels; 2154
codec -> frame_size = icodec -> frame_size; 2155
codec -> audio_service_type = icodec -> audio_service_type; 2156
codec -> block_align = icodec -> block_align; 2157
if ( ( codec -> block_align == 1 || codec -> block_align == 1152 || codec -> block_align == 576 ) && ( codec -> codec_id ) == AV_CODEC_ID_MP3 )  2158
codec -> block_align = 0; 2159
if ( ( codec -> codec_id ) == AV_CODEC_ID_AC3 )  2161
codec -> block_align = 0; 2162
codec -> pix_fmt = icodec -> pix_fmt; 2168
codec -> width = icodec -> width; 2169
codec -> height = icodec -> height; 2170
codec -> has_b_frames = icodec -> has_b_frames; 2171
if ( ! codec -> sample_aspect_ratio . num )  2172
codec -> sample_aspect_ratio = ost -> st -> sample_aspect_ratio = ( ist -> st -> sample_aspect_ratio . num ? ist -> st -> sample_aspect_ratio : ( ( ist -> st -> codec -> sample_aspect_ratio . num ? ist -> st -> codec -> sample_aspect_ratio : ( ( AVRational ) ( 0 ) , ( 1 ) ) ) ) ) 2173
ost -> st -> avg_frame_rate = ist -> st -> avg_frame_rate; 2175
codec -> width = icodec -> width; 2180
codec -> height = icodec -> height; 2181
if ( ! ost -> enc )  2194
ost -> enc = avcodec_find_encoder ( codec -> codec_id ); 2195
if ( ! ost -> enc )  2197
ret = - 22; 2200
if ( ist )  2203
ist -> decoding_needed ++; 2204
ost -> encoding_needed = 1; 2206
if ( ( codec -> codec_type ) == AVMEDIA_TYPE_VIDEO )  2215
if ( ost -> filter && ! ost -> frame_rate . num )  2216
ost -> frame_rate = av_buffersink_get_frame_rate ( ost -> filter -> filter ); 2217
if ( ist && ! ost -> frame_rate . num )  2219
ost -> frame_rate = ist -> framerate; 2220
if ( ist && ! ost -> frame_rate . num )  2222
ost -> frame_rate = ( ist -> st -> r_frame_rate . num ? ist -> st -> r_frame_rate : ( ( AVRational ) ( 25 ) , ( 1 ) ) ) 2223
if ( ost -> enc && ost -> enc -> supported_framerates && ! ost -> force_fps )  2226
int idx = av_find_nearest_q_idx ( ost -> frame_rate , ost -> enc -> supported_framerates ) ; 2227
ost -> frame_rate = ost -> enc -> supported_framerates [ idx ]; 2228
switch ( codec -> codec_type )  2231
codec -> sample_fmt = ( ost -> filter -> filter -> inputs [ 0 ] -> format ); 2234
codec -> sample_rate = ost -> filter -> filter -> inputs [ 0 ] -> sample_rate; 2235
codec -> channel_layout = ost -> filter -> filter -> inputs [ 0 ] -> channel_layout; 2236
codec -> channels = avfilter_link_get_channels ( ost -> filter -> filter -> inputs [ 0 ] ); 2237
codec -> time_base = ( ( AVRational ) ( 1 ) , codec -> sample_rate ) 2238
codec -> time_base = av_inv_q ( ost -> frame_rate ); 2243
if ( ost -> filter && ! ( codec -> time_base . num && codec -> time_base . den ) )  2244
codec -> time_base = ost -> filter -> filter -> inputs [ 0 ] -> time_base; 2245
codec -> width = ost -> filter -> filter -> inputs [ 0 ] -> w; 2252
codec -> height = ost -> filter -> filter -> inputs [ 0 ] -> h; 2253
codec -> sample_aspect_ratio = ost -> st -> sample_aspect_ratio = ( ost -> frame_aspect_ratio ? av_d2q ( ( ost -> frame_aspect_ratio * ( codec -> height ) / ( codec -> width ) ) , 255 ) : ost -> filter -> filter -> inputs [ 0 ] -> sample_aspect_ratio ); 2254
codec -> pix_fmt = ( ost -> filter -> filter -> inputs [ 0 ] -> format ); 2256
if ( ! icodec || codec -> width != icodec -> width || codec -> height != icodec -> height || ( codec -> pix_fmt ) != ( icodec -> pix_fmt ) )  2257
codec -> bits_per_raw_sample = frame_bits_per_raw_sample; 2258
if ( ost -> forced_keyframes )  2260
if ( ! strncmp ( ( ost -> forced_keyframes ) , ""expr:"" , 5 ) )  2261
ret = av_expr_parse ( & ost -> forced_keyframes_pexpr , ( ost -> forced_keyframes + 5 ) , forced_keyframes_const_names , ( ( void * ) 0 ) , ( ( void * ) 0 ) , ( ( void * ) 0 ) , ( ( void * ) 0 ) , 0 , ( ( void * ) 0 ) ); 2262
if ( ret < 0 )  2263
return ret ; 2265
ost -> forced_keyframes_expr_const_values [ FKF_N ] = 0; 2267
ost -> forced_keyframes_expr_const_values [ FKF_N_FORCED ] = 0; 2268
ost -> forced_keyframes_expr_const_values [ FKF_PREV_FORCED_N ] = ( __builtin_nanf ( """" ) ); 2269
ost -> forced_keyframes_expr_const_values [ FKF_PREV_FORCED_T ] = ( __builtin_nanf ( """" ) ); 2270
codec -> time_base = ( ( AVRational ) ( 1 ) , ( 1000 ) ) 2280
if ( ! codec -> width )  2281
codec -> width = input_streams [ ost -> source_index ] -> st -> codec -> width; 2282
codec -> height = input_streams [ ost -> source_index ] -> st -> codec -> height; 2283
if ( codec -> flags & ( 0x0200 | 0002000 ) )  2294
char logfilename [ 1024 ] ; 2295
FILE * f ; 2296
snprintf ( logfilename , sizeof ( logfilename ) , ""%s-%d.log"" , ( ost -> logfile_prefix ? ost -> logfile_prefix : ""ffmpeg2pass"" ) , i ); 2297
if ( ! strcmp ( ost -> enc -> name , ""libx264"" ) )  2298
if ( codec -> flags & 0002000 )  2302
char * logbuffer ; 2303
codec -> stats_in = logbuffer; 2309
if ( codec -> flags & 0x0200 )  2311
f = fopen ( logfilename , ""wb"" ); 2312
ost -> logfile = f; 2317
for (i = 0; i < nb_output_streams; i++) 2324
ost = output_streams [ i ]; 2325
if ( ost -> encoding_needed )  2326
AVCodec * codec = ost -> enc ; 2327
AVCodecContext * dec = ( ( void * ) 0 ) ; 2328
if ( ist = get_input_stream ( ost ) )  2329
static InputStream *get_input_stream(OutputStream *ost) 1943
if ( ost -> source_index >= 0 )  1945
return input_streams [ ost -> source_index ] ; 1946
return ( ( void * ) 0 ) ; 1948
dec = ist -> st -> codec; 2330
if ( dec && dec -> subtitle_header )  2332
ost -> st -> codec -> subtitle_header = ( av_mallocz ( ( dec -> subtitle_header_size + 1 ) ) ); 2334
if ( ! ost -> st -> codec -> subtitle_header )  2335
ret = - 12; 2336
memcpy ( ( ost -> st -> codec -> subtitle_header ) , ( dec -> subtitle_header ) , ( dec -> subtitle_header_size ) ); 2339
ost -> st -> codec -> subtitle_header_size = dec -> subtitle_header_size; 2340
if ( ( ret = avcodec_open2 ( ost -> st -> codec , codec , & ost -> opts ) ) < 0 )  2345
for (i = 0; i < nb_input_streams; i++) 2369
if ( ( ret = init_input_stream ( i , error , ( sizeof ( error ) ) ) ) < 0 )  2370
static int init_input_stream(int ist_index,char *error,int error_len) 1909
int ret ; 1911
InputStream * ist = input_streams [ ist_index ] ; 1912
if ( ist -> decoding_needed )  1913
AVCodec * codec = ist -> dec ; 1914
if ( ! codec )  1915
return - 22 ; 1917
ist -> dr1 = codec -> capabilities & 0000002 && ! ( '6' < 56 && do_deinterlace ); 1919
if ( ( codec -> type ) == AVMEDIA_TYPE_VIDEO && ist -> dr1 )  1920
ist -> st -> codec -> get_buffer = codec_get_buffer; 1921
ist -> st -> codec -> release_buffer = codec_release_buffer; 1922
ist -> st -> codec -> opaque = ( & ist -> buffer_pool ); 1923
if ( ( ret = avcodec_open2 ( ist -> st -> codec , codec , & ist -> opts ) ) < 0 )  1928
return ret ; 1933
return 0 ; 1940
for (i = 0; i < nb_input_files; i++) 2378
for (i = 0; i < nb_output_files; i++) 2392
oc = output_files [ i ] -> ctx; 2393
oc -> interrupt_callback = int_cb; 2394
if ( ( ret = avformat_write_header ( oc , & output_files [ i ] -> opts ) ) < 0 )  2395
ret = - 22; 2402
if ( ret )  2458
return ret ; 2460
return 0 ; 2465
if ( ret < 0 )  3014
if ( ( ret = init_input_threads ( ) ) < 0 )  3022
static int init_input_threads() 2681
int i ; 2683
int ret ; 2684
if ( nb_input_files == 1 )  2685
return 0 ; 2686
for (i = 0; i < nb_input_files; i++) 2688
InputFile * f = input_files [ i ] ; 2689
if ( ! ( f -> fifo = av_fifo_alloc ( ( 8 * sizeof ( AVPacket ) ) ) ) )  2690
return - 12 ; 2691
if ( ret = pthread_create ( & f -> thread , ( ( void * ) 0 ) , input_thread , f ) )  2695
return - ret ; 2696
return 0 ; 2699
for (i = 0; i < nb_input_streams; i++) 3054
ist = input_streams [ i ]; 3055
if ( ! input_files [ ist -> file_index ] -> eof_reached && ist -> decoding_needed )  3056
output_packet ( ist , ( ( void * ) 0 ) ); 3057
static int output_packet(InputStream *ist,const AVPacket *pkt) 1751
int got_output ; 1755
AVPacket avpkt ; 1756
if ( ! ist -> saw_first_ts )  1757
ist -> dts = ( ( ist -> st -> avg_frame_rate . num ? ( - ist -> st -> codec -> has_b_frames * 1000000 ) / av_q2d ( ist -> st -> avg_frame_rate ) : 0 ) ); 1758
ist -> pts = 0; 1759
if ( pkt != ( ( void * ) 0 ) && pkt -> pts != ( ( int64_t ) 0x8000000000000000UL ) && ! ist -> decoding_needed )  1760
ist -> pts = ist -> dts; 1763
ist -> saw_first_ts = 1; 1765
if ( ist -> next_dts == ( ( int64_t ) 0x8000000000000000UL ) )  1767
ist -> next_dts = ist -> dts; 1768
if ( ist -> next_pts == ( ( int64_t ) 0x8000000000000000UL ) )  1770
ist -> next_pts = ist -> pts; 1771
if ( pkt == ( ( void * ) 0 ) )  1773
avpkt . data = ( ( void * ) 0 ); 1776
avpkt . size = 0; 1777
avpkt = * pkt; 1781
if ( pkt -> dts != ( ( int64_t ) 0x8000000000000000UL ) )  1783
ist -> next_dts = ist -> dts = av_rescale_q ( pkt -> dts , ist -> st -> time_base , ( ( AVRational ) ( 1 ) , ( 1000000 ) ) ) 1784
if ( ( ist -> st -> codec -> codec_type ) != AVMEDIA_TYPE_VIDEO || ! ist -> decoding_needed )  1785
ist -> next_pts = ist -> pts = ist -> dts; 1786
while ( ist -> decoding_needed && ( avpkt . size > 0 || ! pkt && got_output ) )  1790
int duration ; 1791
ist -> pts = ist -> next_pts; 1793
ist -> dts = ist -> next_dts; 1794
if ( avpkt . size && avpkt . size != pkt -> size )  1795
ist -> showed_multi_packet_warning = 1; 1797
switch ( ist -> st -> codec -> codec_type )  1799
ret = decode_audio ( ist , & avpkt , & got_output ); 1802
ret = decode_video ( ist , & avpkt , & got_output ); 1807
if ( avpkt . duration )  1808
duration = ( av_rescale_q ( avpkt . duration , ist -> st -> time_base , ( ( AVRational ) ( 1 ) , ( 1000000 ) ) ) ) 1809
if ( ist -> st -> codec -> time_base . num != 0 && ist -> st -> codec -> time_base . den != 0 )  1812
int ticks = ist -> st -> parser ? ist -> st -> parser -> repeat_pict + 1 : ist -> st -> codec -> ticks_per_frame ; 1813
duration = ( ( ( int64_t ) 1000000 ) * ist -> st -> codec -> time_base . num * ticks / ist -> st -> codec -> time_base . den ); 1814
duration = 0; 1817
if ( ist -> dts != ( ( int64_t ) 0x8000000000000000UL ) && duration )  1820
ist -> next_dts += duration; 1821
ist -> next_dts = ( ( int64_t ) 0x8000000000000000UL ); 1824
if ( got_output )  1826
ist -> next_pts += duration; 1828
ret = transcode_subtitles ( ist , & avpkt , & got_output ); 1834
if ( ret < 0 )  1840
avpkt . dts = avpkt . pts = ( ( int64_t ) 0x8000000000000000UL ); 1843
if ( pkt )  1845
if ( ( ist -> st -> codec -> codec_type ) != AVMEDIA_TYPE_AUDIO )  1846
ret = avpkt . size; 1847
avpkt . data += ret; 1849
avpkt . size -= ret; 1850
static int decode_video(InputStream *ist,AVPacket *pkt,int *got_output) 1612
if ( ! ist -> decoded_frame && ! ( ist -> decoded_frame = avcodec_alloc_frame ( ) ) )  1621
update_benchmark ( ""decode_video %d.%d"" , ist -> file_index , ist -> st -> index ); 1628
static void update_benchmark(const char *fmt,... ) 532
if ( do_benchmark_all )  534
va_list va ; 536
char buf [ 1024 ] ; 537
if ( fmt )  538
vsnprintf ( buf , sizeof ( buf ) , fmt , va ); 540
printf ( ""bench: %8lu %s \n"" , t - current_time , buf ); 542",0,0
8285,"static void goodG2B() 159
char * data ; 161
char dataBuffer [ FILENAME_MAX ] = BASEPATH ; 163
data = dataBuffer; 164
strcat ( data , ""file.txt"" ); 166
dataMap [ 0 ] = data; 168
dataMap [ 1 ] = data; 169
dataMap [ 2 ] = data; 170
goodG2BSink ( dataMap ); 171
void goodG2BSink(map<int, char *> dataMap) 62
char * data = dataMap [ 2 ] ; 64
hFile = CreateFileA ( data , ( GENERIC_WRITE | GENERIC_READ ) , 0 , NULL , OPEN_ALWAYS , FILE_ATTRIBUTE_NORMAL , NULL ); 68
if ( hFile != INVALID_HANDLE_VALUE )  75
CloseHandle ( hFile ); 77",0,0
162140,"void dfacomp(const char *s,size_t len,struct dfa *d,int searchflag) 3826
dfaanalyze ( d , searchflag ); 3832
void dfaanalyze(struct dfa *d,int searchflag) 2600
size_t * nfirstpos ; 2605
size_t * o_nfirst ; 2619
d -> searchflag = searchflag; 2628
nfirstpos = ( ( sizeof ( ( * nfirstpos ) ) == 1 ? xmalloc ( d -> depth ) : xnmalloc ( d -> depth , sizeof ( ( * nfirstpos ) ) ) ) ); 2634
while ( 0 )  2635
o_nfirst = nfirstpos; 2636
free ( o_nfirst ); 2787",0,0
22118,"static void good2() 132
if ( globalTrue )  134
if ( ! stdThreadLockCreate ( & gGoodLock ) )  139
int stdThreadLockCreate(stdThreadLock *lock) 134
stdThreadLock my_lock = NULL ; 136
my_lock = ( stdThreadLock ) malloc ( sizeof ( * my_lock ) ); 140
if ( my_lock == NULL )  141
return 0 ; 141
return 1 ; 159
stdThreadLockDestroy ( gGoodLock ); 159
void stdThreadLockDestroy(stdThreadLock lock)\ 202
free ( lock ); 208",0,0
23077,"static void goodG2B() 159
short data ; 161
data = 0; 163
data = 100 - 1; 165
CWE194_Unexpected_Sign_Extension__connect_socket_memcpy_41_goodG2BSink ( data ); 166
void CWE194_Unexpected_Sign_Extension__connect_socket_memcpy_41_goodG2BSink(short data) 140
char source [ 100 ] ; 143
char dest [ 100 ] = """" ; 144
memset ( source , 'A' , 100 - 1 ); 145
source [ 100 - 1 ] = '\0'; 146
if ( data < 100 )  147
memcpy ( dest , source , data ); 151
dest [ data ] = '\0'; 152
printLine ( dest ); 154
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",0,0
149806,"static void goodB2G1() 73
wchar_t * data ; 75
wchar_t dataBuffer [ 100 ] = L """" 76
data = dataBuffer; 77
if ( globalTrue )  78
size_t dataLen = wcslen ( data ) ; 82
FILE * pFile ; 83
if ( 100 - dataLen > 1 )  85
pFile = fopen ( FILENAME , ""r"" ); 87
if ( pFile != NULL )  88
if ( fgetws ( data + dataLen , ( int ) ( 100 - dataLen ) , pFile ) == NULL )  91
fclose ( pFile ); 97",0,0
61936,"unsigned int svn_cstring__similarity(const char *stra,const char *strb,svn_membuf_t *buffer,apr_size_t *rlcs) 1018
svn_string_t stringb ; 1021
stringb . data = strb; 1024
stringb . len = strlen ( strb ); 1025
return svn_string__similarity ( ( & stringa ) , ( & stringb ) , buffer , rlcs ) ; 1026
unsigned int svn_string__similarity(const svn_string_t *stringa,const svn_string_t *stringb,svn_membuf_t *buffer,apr_size_t *rlcs) 1029
const char * stra = stringa -> data ; 1031
const char * strb = stringb -> data ; 1032
const apr_size_t lena = stringa -> len ; 1033
const apr_size_t lenb = stringb -> len ; 1034
const apr_size_t total = lena + lenb ; 1035
const char * enda = stra + lena ; 1036
const char * endb = strb + lenb ; 1037
while ( stra < enda && strb < endb && ( * stra ) == ( * strb ) )  1040
while ( stra < enda && strb < endb )  1046
if ( ( * enda ) != ( * endb ) )  1049
if ( stra < enda && strb < endb )  1056
const apr_size_t resta = ( enda - stra ) ; 1057
const apr_size_t restb = ( endb - strb ) ; 1058
const apr_size_t slots = resta > restb ? restb : resta ; 1059
if ( resta < restb )  1064
pstr = stra; 1065
stra = strb; 1066
strb = pstr; 1067
pstr = enda; 1068
enda = endb; 1069
endb = pstr; 1070
svn_membuf__ensure ( buffer , 2 * ( slots + 1 ) * sizeof ( apr_size_t ) ); 1074
void svn_membuf__ensure(svn_membuf_t *membuf,apr_size_t size) 177
membuf_ensure ( & membuf -> data , & membuf -> size , size , membuf -> pool ); 179
inline static void membuf_ensure(void **data,apr_size_t *size,apr_size_t minimum_size,apr_pool_t *pool) 145
if ( minimum_size > * size )  147
apr_size_t new_size = * size ; 148
if ( new_size == 0 )  149
new_size = minimum_size; 153
while ( new_size < minimum_size )  156
const apr_size_t prev_size = new_size ; 158
new_size *= 2; 159
if ( prev_size > new_size )  161
new_size = minimum_size; 162
membuf_create ( data , size , new_size , pool ); 167
inline static void membuf_create(void **data,apr_size_t *size,apr_size_t minimum_size,apr_pool_t *pool) 124
minimum_size = minimum_size + ( 8 - 1 ) & ( ~ ( 8 - 1 ) ); 130
* data = ( ! minimum_size ? ( ( void * ) 0 ) : apr_palloc ( pool , minimum_size ) ); 131
* size = minimum_size; 132
svn_membuf__nzero ( buffer , ( slots + 2 ) * sizeof ( apr_size_t ) ); 1075
#undef svn_membuf__nzero 203
svn_membuf_t * const _m_b_f_ = membuf 207
const apr_size_t _s_z_ = size ; 208
if ( _s_z_ > _m_b_f_ -> size )  209
memset ( _m_b_f_ -> data , 0 , _m_b_f_ -> size ); 210
memset ( _m_b_f_ -> data , 0 , _s_z_ ); 213
prev = ( buffer -> data ); 1076
curr = prev + slots + 1; 1077
for (pstr = stra; pstr < enda; ++pstr) 1079
for (i = 1; i <= slots; ++i) 1081
if ( ( * pstr ) == strb [ i - 1 ] )  1082
curr [ i ] = prev [ i - 1 ] + 1; 1083
curr [ i ] = ( curr [ i - 1 ] > prev [ i ] ? curr [ i - 1 ] : prev [ i ] ); 1086
apr_size_t * const temp = prev 1091
prev = curr; 1092
curr = temp; 1093
lcs += prev [ slots ]; 1096
if ( rlcs )  1098
* rlcs = lcs; 1099
if ( total )  1102
return ( unsigned int ) ( ( 2000 * lcs + total / 2 ) / total ) ; 1103",0,0
176205,"void parse_dir_colors() 370
char * * arg ; 373
char * * c ; 374
char * colors ; 375
char * s ; 376
int i ; 377
if ( Hflag )  380
if ( getenv ( ""TERM"" ) == ( ( void * ) 0 ) )  383
s = getenv ( ""TREE_COLORS"" ); 387
if ( s == ( ( void * ) 0 ) )  388
s = getenv ( ""LS_COLORS"" ); 389
if ( ( s == ( ( void * ) 0 ) || strlen ( s ) == 0 ) && force_color )  391
s = "":no=00:fi=00:di=01;34:ln=01;36:pi=40;33:so=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:ex=01;32:*.bat=01;32:*.BAT=01;32:*.btm=01;32:*.BTM=01;32:*.cmd=01;32:*.CMD=01;32:*.com=01;32:*.COM=01;32:*.dll=01;32:*.DLL=01;32:*.exe=01;32:*.EXE=01;32:*.arj=01;31:*.bz2=01;31:*.deb=01;31:*.gz=01;31:*.lzh=01;31:*.rpm=01;31:*.tar=01;31:*.taz=01;31:*.tb2=01;31:*.tbz2=01;31:*.tbz=01;31:*.tgz=01;31:*.tz2=01;31:*.z=01;31:*.Z=01;31:*.zip=01;31:*.ZIP=01;31:*.zoo=01;31:*.asf=01;35:*.ASF=01;35:*.avi=01;35:*.AVI=01;35:*.bmp=01;35:*.BMP=01;35:*.flac=01;35:*.FLAC=01;35:*.gif=01;35:*.GIF=01;35:*.jpg=01;35:*.JPG=01;35:*.jpeg=01;35:*.JPEG=01;35:*.m2a=01;35:*.M2a=01;35:*.m2v=01;35:*.M2V=01;35:*.mov=01;35:*.MOV=01;35:*.mp3=01;35:*.MP3=01;35:*.mpeg=01;35:*.MPEG=01;35:*.mpg=01;35:*.MPG=01;35:*.ogg=01;35:*.OGG=01;35:*.ppm=01;35:*.rm=01;35:*.RM=01;35:*.tga=01;35:*.TGA=01;35:*.tif=01;35:*.TIF=01;35:*.wav=01;35:*.WAV=01;35:*.wmv=01;35:*.WMV=01;35:*.xbm=01;35:*.xpm=01;35:""; 392
if ( s == ( ( void * ) 0 ) || ! force_color && ( nocolor || ! isatty ( 1 ) ) )  394
colors = strcpy ( ( xmalloc ( strlen ( s ) + 1 ) ) , s ); 403
arg = split ( colors , "":"" , & n ); 404
char **split(char *str,char *delim,int *nwrds) 589
int n = 128 ; 591
char * * w = ( xmalloc ( sizeof ( char * ) * n ) ) ; 592
w [ * nwrds = 0 ] = strtok ( str , delim ); 593
while ( w [ * nwrds ] )  594
if ( * nwrds == n - 2 )  595
w = ( xrealloc ( w , sizeof ( char * ) * ( n += 256 ) ) ); 596
w [ ++ * nwrds ] = strtok ( ( ( void * ) 0 ) , delim ); 598
w [ * nwrds ] = ( ( void * ) 0 ); 600
return w ; 601
for (i = 0; arg[i]; i++) 405
c = split ( arg [ i ] , ""="" , & n ); 406
char **split(char *str,char *delim,int *nwrds) 589
int n = 128 ; 591
char * * w = ( xmalloc ( sizeof ( char * ) * n ) ) ; 592
w [ * nwrds = 0 ] = strtok ( str , delim ); 593
while ( w [ * nwrds ] )  594
if ( * nwrds == n - 2 )  595
w = ( xrealloc ( w , sizeof ( char * ) * ( n += 256 ) ) ); 596
w [ ++ * nwrds ] = strtok ( ( ( void * ) 0 ) , delim ); 598
w [ * nwrds ] = ( ( void * ) 0 ); 600
return w ; 601
switch ( cmd ( c [ 0 ] ) )  407
int cmd(char *s) 604
static struct { char * cmd ; char cmdnum ; } cmds [ ] = { { ( ""no"" ) , ( COL_NORMAL ) } , { ( ""fi"" ) , ( COL_FILE ) } , { ( ""di"" ) , ( COL_DIR ) } , { ( ""ln"" ) , ( COL_LINK ) } , { ( ""pi"" ) , ( COL_FIFO ) } , { ( ""do"" ) , ( COL_DOOR ) } , { ( ""bd"" ) , ( COL_BLK ) } , { ( ""cd"" ) , ( COL_CHR ) } , { ( ""or"" ) , ( COL_ORPHAN ) } , { ( ""so"" ) , ( COL_SOCK ) } , { ( ""su"" ) , ( COL_SETUID ) } , { ( ""sg"" ) , ( COL_SETGID ) } , { ( ""tw"" ) , ( COL_STICKY_OTHER_WRITABLE ) } , { ( ""ow"" ) , ( COL_OTHER_WRITABLE ) } , { ( ""st"" ) , ( COL_STICKY ) } , { ( ""ex"" ) , ( COL_EXEC ) } , { ( ""mi"" ) , ( COL_MISSING ) } , { ( ""lc"" ) , ( COL_LEFTCODE ) } , { ( ""rc"" ) , ( COL_RIGHTCODE ) } , { ( ""ec"" ) , ( COL_ENDCODE ) } , { ( ( ( void * ) 0 ) ) , ( 0 ) } } ; 606
int i ; 609
for (i = 0; cmds[i] . cmdnum; i++) 610
if ( ! strcmp ( cmds [ i ] . cmd , s ) )  611
return cmds [ i ] . cmdnum ; 612
if ( s [ 0 ] == '*' )  614
return DOT_EXTENSION ; 615
return ERROR ; 617
if ( c [ 1 ] )  424
dir_flgs = strcpy ( ( xmalloc ( strlen ( c [ 1 ] ) + 1 ) ) , c [ 1 ] ); 425",0,0
23769,"static void goodB2G2() 68
size_t data ; 70
data = rand ( ); 74
CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_rand_22_goodB2G2Sink ( data ); 76
void CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_rand_22_goodB2G2Sink(size_t data) 97
if ( data > wcslen ( HELLO_STRING ) && data < 100 )  106
myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) ); 108
wcscpy ( myString , HELLO_STRING ); 110
printWLine ( myString ); 111
void printWLine (const wchar_t * line) 18
if ( line != NULL )  20
wprintf ( L ""%ls\n"" , line ) 22
free ( myString ); 112",0,0
51314,"void bad() 26
size_t data ; 28
data = 0; 30
CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_connect_socket_84_bad * badObject = new CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_connect_socket_84_bad ( data ) ; 31
CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_connect_socket_84_bad::CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_connect_socket_84_bad(size_t dataCopy) 48
WSADATA wsaData ; 53
int recvResult ; 56
struct sockaddr_in service ; 57
char inputBuffer [ CHAR_ARRAY_SIZE ] ; 59
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  63
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 70
if ( connectSocket == INVALID_SOCKET )  71
memset ( & service , 0 , sizeof ( service ) ); 75
service . sin_family = AF_INET; 76
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS ); 77
service . sin_port = htons ( TCP_PORT ); 78
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  79
recvResult = recv ( connectSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 ); 85
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  86
inputBuffer [ recvResult ] = '\0'; 91
data = strtoul ( inputBuffer , NULL , 0 ); 93
while ( 0 )  95
if ( connectSocket != INVALID_SOCKET )  96
CLOSE_SOCKET ( connectSocket ); 98",0,0
93659,"void bad() 58
char * data ; 60
char dataBuffer [ FILENAME_MAX ] = BASEPATH ; 61
data = dataBuffer; 62
size_t dataLen = strlen ( data ) ; 73
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ); 107
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  108
data [ dataLen + recvResult / sizeof ( char ) ] = '\0'; 113
replace = strchr ( data , '\r' ); 115
if ( replace )  116
* replace = '\0'; 118
replace = strchr ( data , '\n' ); 120
if ( replace )  121
* replace = '\0'; 123
badSink_b ( data ); 142
void badSink_b(char * data) 60
badSink_c ( data ); 62
void badSink_c(char * data) 60
badSink_d ( data ); 62
void badSink_d(char * data) 60
badSink_e ( data ); 62
void badSink_e(char * data) 57
outputFile . open ( ( char * ) data ); 62",0,0
129314,"static void goodG2B1() 51
wchar_t * data ; 53
if ( globalFalse )  55
data = ( wchar_t * ) malloc ( ( 10 + 1 ) * sizeof ( wchar_t ) ); 63
wcscpy ( data , source ); 68
printWLine ( data ); 69
void printWLine (const wchar_t * line) 18
if ( line != NULL )  20
wprintf ( L ""%ls\n"" , line ) 22
free ( data ); 70",0,0
168833,"static void goodG2B() 60
char * data ; 62
data = NULL; 63
data = goodG2BSource ( data ); 64
static char * goodG2BSource(char * data) 51
data = ( char * ) malloc ( 100 * sizeof ( char ) ); 54
data [ 0 ] = '\0'; 55
return data ; 56
char source [ 100 ] ; 66
memset ( source , 'C' , 100 - 1 ); 67
source [ 100 - 1 ] = '\0'; 68
strcat ( data , source ); 70
printLine ( data ); 71
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14
free ( data ); 72",0,0
14299,"static void goodB2G2() 257
if ( staticReturnsTrue ( ) )  262
static int staticReturnsTrue() 45
return 1 ; 47
WSADATA wsaData ; 266
int recvResult ; 269
struct sockaddr_in service ; 270
char inputBuffer [ CHAR_ARRAY_SIZE ] ; 273
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  277
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 284
if ( listenSocket == INVALID_SOCKET )  285
memset ( & service , 0 , sizeof ( service ) ); 289
service . sin_family = AF_INET; 290
service . sin_addr . s_addr = INADDR_ANY; 291
service . sin_port = htons ( TCP_PORT ); 292
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  293
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )  297
acceptSocket = accept ( listenSocket , NULL , NULL ); 301
if ( acceptSocket == SOCKET_ERROR )  302
recvResult = recv ( acceptSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 ); 307
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  308
while ( 0 )  317",0,0
141878,"qcms_profile* qcms_profile_sRGB(void) 985
qcms_profile * profile ; 987
uint16_t * table ; 988
qcms_CIE_xyYTRIPLE Rec709Primaries = { { 0.6400 , 0.3300 , 1.0 } , { 0.3000 , 0.6000 , 1.0 } , { 0.1500 , 0.0600 , 1.0 } } ; 990
qcms_CIE_xyY D65 ; 995
D65 = white_point_from_temp ( 6504 ); 997
static qcms_CIE_xyY white_point_from_temp(int temp_K) 937
qcms_CIE_xyY white_point ; 939
double x , y ; 940
double T , T2 , T3 ; 941
T = temp_K; 945
T2 = T * T; 946
T3 = T2 * T; 947
if ( T >= 4000. && T <= 7000. )  950
x = - 4.6070 * ( 1E9 / T3 ) + 2.9678 * ( 1E6 / T2 ) + 0.09911 * ( 1E3 / T ) + 0.244063; 951
if ( T > 7000.0 && T <= 25000.0 )  954
x = - 2.0064 * ( 1E9 / T3 ) + 1.9018 * ( 1E6 / T2 ) + 0.24748 * ( 1E3 / T ) + 0.237040; 955
white_point . x = - 1.0; 958
white_point . y = - 1.0; 959
white_point . Y = - 1.0; 960
return white_point ; 964
y = - 3.000 * ( x * x ) + 2.870 * x - 0.275; 970
white_point . x = x; 978
white_point . y = y; 979
white_point . Y = 1.0; 980
return white_point ; 982
table = build_sRGB_gamma_table ( 1024 ); 999
static uint16_t *build_sRGB_gamma_table(int num_entries) 790
int i ; 792
double gamma = 2.4 ; 794
double a = 1. / 1.055 ; 795
double b = 0.055 / 1.055 ; 796
double c = 1. / 12.92 ; 797
double d = 0.04045 ; 798
uint16_t * table = malloc ( sizeof ( uint16_t ) * num_entries ) ; 800
if ( ! table )  801
return NULL ; 802
for (i=0; i<num_entries; i++) 804
double x = ( double ) i / ( num_entries - 1 ) ; 805
double y , output ; 806
if ( x >= d )  810
double e = ( a * x + b ) ; 811
if ( e > 0 )  812
y = pow ( e , gamma ); 813
y = 0; 815
y = c * x; 817
output = y * 65535. + .5; 821
if ( output > 65535. )  822
output = 65535; 823
if ( output < 0 )  824
output = 0; 825
table [ i ] = ( uint16_t ) floor ( output ); 826
return table ; 828
if ( ! table )  1001
profile = qcms_profile_create_rgb_with_table ( D65 , Rec709Primaries , table , 1024 ); 1004
qcms_profile* qcms_profile_create_rgb_with_table(
qcms_CIE_xyY white_point,
qcms_CIE_xyYTRIPLE primaries,
uint16_t *table, int num_entries) 906
qcms_profile * profile = qcms_profile_create ( ) ; 908
qcms_profile *qcms_profile_create(void) 781
return calloc ( sizeof ( qcms_profile ) , 1 ) ; 783
if ( ! profile )  909
if ( ! set_rgb_colorants ( profile , white_point , primaries ) )  913
profile -> redTRC = curve_from_table ( table , num_entries ); 918
profile -> blueTRC = curve_from_table ( table , num_entries ); 919
static struct curveType *curve_from_table(uint16_t *table, int num_entries) 831
struct curveType * curve ; 833
curve = malloc ( sizeof ( struct curveType ) + sizeof ( uInt16Number ) * num_entries ); 835
if ( ! curve )  836
curve -> type = CURVE_TYPE; 838
curve -> count = num_entries; 839
curve -> data [ i ] = table [ i ]; 841
return curve ; 843",0,0
51444,"static void fw_cfg_machine_reset(void *opaque) 587
void * ptr ; 589
size_t len ; 590
FWCfgState * s = opaque ; 591
char * bootindex = get_boot_devices_list ( & len , false ) ; 592
ptr = fw_cfg_modify_file ( s , ""bootorder"" , ( uint8_t * ) bootindex , len ); 594
void *fw_cfg_modify_file(FWCfgState *s, const char *filename,
void *data, size_t len) 564
int i , index ; 566
index = be32_to_cpu ( s -> files -> count ); 571
for (i = 0; i < index; i++) 574
if ( strcmp ( filename , s -> files -> f [ i ] . name ) == 0 )  575
fw_cfg_add_file_callback ( s , filename , NULL , NULL , data , len ); 583
void fw_cfg_add_file_callback(FWCfgState *s,  const char *filename,
FWCfgReadCallback callback, void *callback_opaque,
void *data, size_t len) 524
int i , index ; 526
size_t dsize ; 527
if ( ! s -> files )  529
dsize = sizeof ( uint32_t ) + sizeof ( FWCfgFile ) * FW_CFG_FILE_SLOTS; 530
s -> files = g_malloc0 ( dsize ); 531
index = be32_to_cpu ( s -> files -> count ); 535
for (i = 0; i < index; i++) 543
if ( strcmp ( s -> files -> f [ index ] . name , s -> files -> f [ i ] . name ) == 0 )  544",0,0
171925,"void CWE134_Uncontrolled_Format_String__char_console_vfprintf_09_bad() 38
char * data ; 40
char dataBuffer [ 100 ] = """" ; 41
data = dataBuffer; 42
if ( GLOBAL_CONST_TRUE )  43
size_t dataLen = strlen ( data ) ; 47
if ( 100 - dataLen > 1 )  49
if ( fgets ( data + dataLen , ( int ) ( 100 - dataLen ) , stdin ) != NULL )  52
dataLen = strlen ( data ); 56
if ( dataLen > 0 && data [ dataLen - 1 ] == '\n' )  57
data [ dataLen - 1 ] = '\0'; 59",0,0
124217,"void CWE366_Race_Condition_Within_Thread__global_int_13_bad() 59
if ( GLOBAL_CONST_FIVE == 5 )  61
if ( ! stdThreadCreate ( helperBad , NULL , & threadB ) )  71
int stdThreadCreate(stdThreadRoutine start, void *args, stdThread *thread) 49
uintptr_t handle ; 52
stdThread my_thread ; 56
my_thread = ( stdThread ) malloc ( sizeof ( * my_thread ) ); 60
if ( my_thread == NULL )  61
my_thread -> start = start; 65
my_thread -> args = args; 66
handle = _beginthreadex ( NULL , 0 , internal_start , my_thread , 0 , NULL ); 69
if ( handle == 0 )  70
free ( my_thread ); 71",0,0
175094,"static void goodB2G() 77
wchar_t * data ; 79
map < int , wchar_t * > dataMap ; 80
data = ( wchar_t * ) malloc ( 100 * sizeof ( wchar_t ) ); 81
data [ 0 ] = L '\0' 82
size_t dataLen = wcslen ( data ) ; 85
if ( 100 - dataLen > 1 )  87
if ( fgetws ( data + dataLen , ( int ) ( 100 - dataLen ) , stdin ) != NULL )  90
data [ dataLen - 1 ] = L '\0' 97
data [ dataLen ] = L '\0' 104
dataMap [ 0 ] = data; 108
dataMap [ 1 ] = data; 109
dataMap [ 2 ] = data; 110
goodB2GSink ( dataMap ); 111
void goodB2GSink(map<int, wchar_t *> dataMap) 53
wchar_t * data = dataMap [ 2 ] ; 55
size_t i ; 57
for (i=0; i < wcslen(data); i++) 59
if ( data [ i ] == SEARCH_CHAR )  61",0,0
102440,"void CWE78_OS_Command_Injection__char_connect_socket_execlp_14_bad() 65
char * data ; 67
char dataBuffer [ 100 ] = """" ; 68
data = dataBuffer; 69
if ( globalFive == 5 )  70
size_t dataLen = strlen ( data ) ; 81
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ); 108
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  109
data [ dataLen + recvResult / sizeof ( char ) ] = '\0'; 114
replace = strchr ( data , '\r' ); 116
if ( replace )  117
* replace = '\0'; 119
replace = strchr ( data , '\n' ); 121
if ( replace )  122
* replace = '\0'; 124",0,0
175466,"static void goodB2G2() 80
int64_t * data ; 82
data = NULL; 83
data = ( int64_t * ) calloc ( 1 , sizeof ( int64_t ) ); 85
if ( staticReturnsTrue ( ) )  86
static int staticReturnsTrue() 24
return 1 ; 26
if ( data != NULL )  89
data [ 0 ] = 5L L 91
free ( data ); 93",0,0
10971,"static void goodB2G1() 165
wchar_t * data ; 167
wchar_t dataBuffer [ 100 ] = L """" 168
data = dataBuffer; 169
if ( staticFive == 5 )  170
WSADATA wsaData ; 174
int recvResult ; 177
struct sockaddr_in service ; 178
size_t dataLen = wcslen ( data ) ; 181
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  185
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 192
if ( connectSocket == INVALID_SOCKET )  193
memset ( & service , 0 , sizeof ( service ) ); 197
service . sin_family = AF_INET; 198
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS ); 199
service . sin_port = htons ( TCP_PORT ); 200
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  201
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ); 208
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  209
while ( 0 )  227",0,0
177271,"void bad() 46
wchar_t * data ; 48
wchar_t dataBuffer [ FILENAME_MAX ] = BASEPATH ; 49
data = dataBuffer; 50
if ( globalReturnsTrueOrFalse ( ) )  51
int globalReturnsTrueOrFalse() 157
return ( rand ( ) % 2 ) ; 159
size_t dataLen = wcslen ( data ) ; 55
FILE * pFile ; 56
if ( FILENAME_MAX - dataLen > 1 )  58
pFile = fopen ( FILENAME , ""r"" ); 60
if ( pFile != NULL )  61
fclose ( pFile ); 70",0,0
82635,"void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_45_bad() 63
WSADATA wsaData ; 70
int recvResult ; 73
struct sockaddr_in service ; 74
char inputBuffer [ CHAR_ARRAY_SIZE ] ; 76
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  80
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 87
if ( connectSocket == INVALID_SOCKET )  88
memset ( & service , 0 , sizeof ( service ) ); 92
service . sin_family = AF_INET; 93
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS ); 94
service . sin_port = htons ( TCP_PORT ); 95
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  96
recvResult = recv ( connectSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 ); 102
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  103
inputBuffer [ recvResult ] = '\0'; 108
data = atoi ( inputBuffer ); 110
while ( 0 )  112
if ( connectSocket != INVALID_SOCKET )  113
CLOSE_SOCKET ( connectSocket ); 115
CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_45_badData = data; 124",0,0
69926,"void perlucidus_ponderosity(int anciency_monometalist,... ) 1268
int fractioning_rowell = 7 ; 1270
union finiglacial_pylic arsenofuran_postproduction = { 0 } ; 1271
if ( anciency_monometalist > 0 )  1274
arsenofuran_postproduction = ( va_arg ( jbeil_finagle , union finiglacial_pylic ) ) 1276
endemiology_noncanonization ( fractioning_rowell , arsenofuran_postproduction ); 1279
void endemiology_noncanonization(int remeeting_orthovanadate,union finiglacial_pylic spaying_homesteaders) 1282
remeeting_orthovanadate --; 1291
if ( remeeting_orthovanadate > 0 )  1292
lusterlessness_clamorer ( remeeting_orthovanadate , spaying_homesteaders ); 1293
void lusterlessness_clamorer(int peregrin_map,union finiglacial_pylic upends_slushiness) 1335
endemiology_noncanonization ( peregrin_map , upends_slushiness ); 1338
void endemiology_noncanonization(int remeeting_orthovanadate,union finiglacial_pylic spaying_homesteaders) 1282
remeeting_orthovanadate --; 1291
if ( remeeting_orthovanadate > 0 )  1292
hysteranthous_housemaids = ( ( char * ) spaying_homesteaders . biggety_lisk ); 1296
if ( strlen ( hysteranthous_housemaids ) > 0 && hysteranthous_housemaids [ 0 ] == '-' )  1298
filename_len = strlen ( ""/opt/stonesoup/workspace/testData/temp"" ) + 10; 1307
stonesoup_filename = ( char * ) malloc ( filename_len * sizeof ( char ) ); 1308
snprintf ( stonesoup_filename , filename_len , ""%s_%08x"" , ""/opt/stonesoup/workspace/testData/temp"" , stonesoup_i ); 1314
stonesoup_filearray [ stonesoup_i ] = stonesoup_open_file ( stonesoup_filename ); 1315
if ( stonesoup_filearray [ stonesoup_i ] == 0 )  1316
if ( stonesoup_filearray [ stonesoup_i ] != 0 )  1322
fclose ( stonesoup_filearray [ stonesoup_i ] ); 1323
free ( stonesoup_filename ); 1325",0,0
3674,"void bad() 48
wchar_t * data ; 50
wchar_t dataBuffer [ FILENAME_MAX ] = BASEPATH ; 51
data = dataBuffer; 52
size_t dataLen = wcslen ( data ) ; 55
wcsncat ( data + dataLen , environment , FILENAME_MAX - dataLen - 1 ); 61
badSink_b ( data ); 64
void badSink_b(wchar_t * data) 50
badSink_c ( data ); 52
void badSink_c(wchar_t * data) 50
badSink_d ( data ); 52
void badSink_d(wchar_t * data) 50
badSink_e ( data ); 52
void badSink_e(wchar_t * data) 47
pFile = FOPEN ( data , L ""wb+"" ) 52
if ( pFile != NULL )  53
fclose ( pFile ); 55",0,0
67025,"static void goodB2G2() 111
size_t data ; 113
data = 0; 115
if ( staticTrue )  121
char * myString ; 124
if ( data > strlen ( HELLO_STRING ) && data < 100 )  128
myString = ( char * ) malloc ( data * sizeof ( char ) ); 130
strcpy ( myString , HELLO_STRING ); 132
printLine ( myString ); 133
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14
free ( myString ); 134",0,0
138,"char *dfaexec(struct dfa *d,const char *begin,char *end,int allow_nl,size_t *count,int *backref) 3551
state_num s ; 3554
state_num s1 ; 3555
const unsigned char * p ; 3557
state_num * * trans ; 3560
state_num * t ; 3561
unsigned char eol = eolbyte ; 3563
s = s1 = 0; 3568
p = ( ( const unsigned char * ) begin ); 3569
trans = d -> trans; 3570
* end = eol; 3572
if ( d -> mb_cur_max > 1 )  3584
while ( ( t = trans [ s ] ) != ( ( void * ) 0 ) )  3585
if ( p > buf_end )  3586
s1 = s; 3589
if ( s == 0 )  3590
if ( ( ( char * ) p ) >= end )  3593
if ( d -> states [ s ] . mbps . nelem == 0 )  3601
s = t [ * ( p ++ ) ]; 3602
if ( backref )  3609
s = transit_state ( d , s , & p ); 3618
trans = d -> trans; 3619
while ( ( t = trans [ s ] ) != ( ( void * ) 0 ) )  3623
s1 = t [ * ( p ++ ) ]; 3624
if ( ( t = trans [ s1 ] ) == ( ( void * ) 0 ) )  3625
state_num tmp = s ; 3626
s = s1; 3627
s1 = tmp; 3629
s = t [ * ( p ++ ) ]; 3632
if ( s >= 0 && ( ( char * ) p ) <= end && d -> fails [ s ] )  3635
if ( d -> success [ s ] & sbit [ * p ] )  3636
s1 = s; 3647
if ( d -> mb_cur_max > 1 )  3648
s = transit_state ( d , s , & p ); 3651
trans = d -> trans; 3652
s = d -> fails [ s ] [ * ( p ++ ) ]; 3655
if ( ( ( char * ) p ) > end )  3669
if ( s >= 0 )  3677
trans = d -> trans; 3679
if ( p [ - 1 ] == eol && allow_nl )  3682
s = d -> newlines [ s1 ]; 3683
s = 0; 3686
static state_num transit_state(struct dfa *d,state_num s,const unsigned char **pp) 3432
int maxlen = 0 ; 3437
size_t i ; 3438
int * match_lens = ( ( void * ) 0 ) ; 3440
size_t nelem = d -> states [ s ] . mbps . nelem ; 3442
if ( nelem > 0 )  3446
match_lens = check_matching_with_multibyte_ops ( d , s , ( * pp - buf_begin ) ); 3451
static int *check_matching_with_multibyte_ops(struct dfa *d,state_num s,size_t idx) 3352
size_t i ; 3354
int * rarray ; 3355
rarray = ( ( sizeof ( ( * rarray ) ) == 1 ? xmalloc ( d -> states [ s ] . mbps . nelem ) : xnmalloc ( d -> states [ s ] . mbps . nelem , sizeof ( ( * rarray ) ) ) ) ); 3357
while ( 0 )  3358
for (i = 0; i < d -> states[s] . mbps . nelem; ++i) 3359
position pos = d -> states [ s ] . mbps . elems [ i ] ; 3360
switch ( d -> tokens [ pos . index ] )  3361
rarray [ i ] = match_anychar ( d , s , pos , idx ); 3364
static int match_anychar(struct dfa *d,state_num s,position pos,size_t idx) 3227
int context ; 3229
wchar_t wc ; 3230
int mbclen ; 3231
wc = inputwcs [ idx ]; 3232
mbclen = ( mblen_buf [ idx ] == 0 ? 1 : mblen_buf [ idx ] ); 3233
if ( wc == ( ( wchar_t ) eolbyte ) )  3235
if ( ! ( syntax_bits & ( ( unsigned long ) 1 ) << 1 << 1 << 1 << 1 << 1 << 1 ) )  3236
return 0 ; 3237
if ( wc == ( ( wchar_t ) '\0' ) )  3241
if ( syntax_bits & ( ( unsigned long ) 1 ) << 1 << 1 << 1 << 1 << 1 << 1 << 1 )  3242
return 0 ; 3243
context = wchar_context ( wc ); 3247
static int wchar_context(wint_t wc) 631
if ( wc == ( ( wchar_t ) eolbyte ) || wc == 0 )  633
return 4 ; 634
if ( wc == '_' || iswalnum ( wc ) )  636
return 2 ; 637
return 1 ; 639
if ( ! ( ( ( ( context & 1 ? pos . constraint & 0xf : 0 ) ) | ( ( context & 2 ? pos . constraint >> 4 & 0xf : 0 ) ) | ( ( context & 4 ? pos . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context ) )  3248
return 0 ; 3249
return mbclen ; 3251
rarray [ i ] = match_mb_charset ( d , s , pos , idx ); 3369
static int match_mb_charset(struct dfa *d,state_num s,position pos,size_t idx) 3258
size_t i ; 3260
int match ; 3262
int match_len ; 3265
int op_len ; 3267
char buffer [ 128 ] ; 3268
struct mb_char_classes * work_mbc ; 3270
int context ; 3271
wchar_t wc ; 3273
wc = inputwcs [ idx ]; 3274
if ( wc == ( ( wchar_t ) eolbyte ) )  3276
if ( ! ( syntax_bits & ( ( unsigned long ) 1 ) << 1 << 1 << 1 << 1 << 1 << 1 ) )  3277
return 0 ; 3278
if ( wc == ( ( wchar_t ) '\0' ) )  3282
if ( syntax_bits & ( ( unsigned long ) 1 ) << 1 << 1 << 1 << 1 << 1 << 1 << 1 )  3283
return 0 ; 3284
context = wchar_context ( wc ); 3288
static int wchar_context(wint_t wc) 631
if ( wc == ( ( wchar_t ) eolbyte ) || wc == 0 )  633
return 4 ; 634
if ( wc == '_' || iswalnum ( wc ) )  636
return 2 ; 637
return 1 ; 639
if ( ! ( ( ( ( context & 1 ? pos . constraint & 0xf : 0 ) ) | ( ( context & 2 ? pos . constraint >> 4 & 0xf : 0 ) ) | ( ( context & 4 ? pos . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context ) )  3289
return 0 ; 3290
work_mbc = & d -> mbcsets [ d -> multibyte_prop [ pos . index ] >> 2 ]; 3293
match = ! work_mbc -> invert; 3294
match_len = ( mblen_buf [ idx ] == 0 ? 1 : mblen_buf [ idx ] ); 3295
if ( wc < 1 << 8 && work_mbc -> cset != ( - 1 ) && tstbit ( ( ( unsigned char ) wc ) , d -> charclasses [ work_mbc -> cset ] ) )  3297
static int tstbit(unsigned int b,const int c[((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int ))]) 537
return c [ b / ( 8 * sizeof ( int ) ) ] & 1 << b % ( 8 * sizeof ( int ) ) ; 539
for (i = 0; i < work_mbc -> nch_classes; i++) 3301
if ( iswctype ( ( ( wint_t ) wc ) , work_mbc -> ch_classes [ i ] ) )  3302
strncpy ( buffer , ( ( const char * ) buf_begin ) + idx , match_len ); 3306
buffer [ match_len ] = '\0'; 3307
for (i = 0; i < work_mbc -> nequivs; i++) 3309
op_len = ( strlen ( work_mbc -> equivs [ i ] ) ); 3310
strncpy ( buffer , ( ( const char * ) buf_begin ) + idx , op_len ); 3311
buffer [ op_len ] = '\0'; 3312
if ( strcoll ( work_mbc -> equivs [ i ] , buffer ) == 0 )  3313
match_len = op_len; 3314
for (i = 0; i < work_mbc -> ncoll_elems; i++) 3319
op_len = ( strlen ( work_mbc -> coll_elems [ i ] ) ); 3320
strncpy ( buffer , ( ( const char * ) buf_begin ) + idx , op_len ); 3321
buffer [ op_len ] = '\0'; 3322
if ( strcoll ( work_mbc -> coll_elems [ i ] , buffer ) == 0 )  3323
match_len = op_len; 3324
for (i = 0; i < work_mbc -> nranges; i++) 3329
if ( work_mbc -> range_sts [ i ] <= wc && wc <= work_mbc -> range_ends [ i ] )  3330
for (i = 0; i < work_mbc -> nchars; i++) 3335
if ( wc == work_mbc -> chars [ i ] )  3336
match = ! match; 3340
return match ? match_len : 0 ; 3342
return rarray ; 3377
for (i = 0; i < nelem; i++) 3452
if ( match_lens [ i ] > maxlen )  3456
maxlen = match_lens [ i ]; 3457
if ( nelem == 0 || maxlen == 0 )  3461
free ( match_lens ); 3496",0,0
93747,"static void goodB2G1() 56
char * data ; 58
data = NULL; 59
data = ( char * ) realloc ( data , 20 * sizeof ( char ) ); 61
if ( data != NULL )  70
strcpy ( data , ""Initialize"" ); 72
printLine ( data ); 73
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14
free ( data ); 74",0,0
910,"void CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_06_bad() 64
char * data ; 66
char dataBuffer [ 100 ] = """" ; 67
data = dataBuffer; 68
if ( STATIC_CONST_FIVE == 5 )  69
WSADATA wsaData ; 73
int recvResult ; 76
struct sockaddr_in service ; 77
char * replace ; 78
size_t dataLen = strlen ( data ) ; 80
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  84
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 91
if ( connectSocket == INVALID_SOCKET )  92
memset ( & service , 0 , sizeof ( service ) ); 96
service . sin_family = AF_INET; 97
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS ); 98
service . sin_port = htons ( TCP_PORT ); 99
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  100
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ); 107
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  108
data [ dataLen + recvResult / sizeof ( char ) ] = '\0'; 113
replace = strchr ( data , '\n' ); 120
if ( replace )  121
* replace = '\0'; 123
while ( 0 )  126",0,0
147258,"void CWE134_Uncontrolled_Format_String__char_console_w32_vsnprintf_51_bad() 30
char * data ; 32
char dataBuffer [ 100 ] = """" ; 33
data = dataBuffer; 34
size_t dataLen = strlen ( data ) ; 37
if ( 100 - dataLen > 1 )  39
if ( fgets ( data + dataLen , ( int ) ( 100 - dataLen ) , stdin ) != NULL )  42
dataLen = strlen ( data ); 46
if ( dataLen > 0 && data [ dataLen - 1 ] == '\n' )  47
data [ dataLen - 1 ] = '\0'; 49
data [ dataLen ] = '\0'; 56
CWE134_Uncontrolled_Format_String__char_console_w32_vsnprintf_51b_badSink ( data ); 60
void CWE134_Uncontrolled_Format_String__char_console_w32_vsnprintf_51b_badSink(char * data) 40
badVaSink ( data , data ); 42
static void badVaSink(char * data, ...) 27
va_start ( args , data ); 32
vsnprintf ( dest , 100 - 1 , data , args ); 34
printLine ( dest ); 36
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",0,0
46788,"static void goodG2B1() 63
if ( STATIC_CONST_FALSE )  67
char * dataBuffer = new char [ 100 ] ; 75
memset ( dataBuffer , 'A' , 100 - 1 ); 76
dataBuffer [ 100 - 1 ] = '\0'; 77
data = dataBuffer; 79
strcpy ( data , source ); 87
printLine ( data ); 88
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",0,0
83453,"static void goodG2B2() 93
if ( 1 )  97
char * dataBuffer = new char [ 100 ] ; 100
memset ( dataBuffer , 'A' , 100 - 1 ); 101
dataBuffer [ 100 - 1 ] = '\0'; 102
data = dataBuffer; 104
memcpy ( dest , data , 100 * sizeof ( char ) ); 112
dest [ 100 - 1 ] = '\0'; 114
printLine ( dest ); 115
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",0,0
49702,"int av_copy_packet(AVPacket *dst,AVPacket *src) 302
* dst = * src; 304
return copy_packet_data ( dst , src ) ; 305
static int copy_packet_data(AVPacket *dst,AVPacket *src) 213
dst -> data = ( ( void * ) 0 ); 215
dst -> side_data = ( ( void * ) 0 ); 216
void * data ; 218
if ( 1 )  219
if ( ( ( unsigned int ) ( dst -> size ) ) > ( ( unsigned int ) ( dst -> size ) ) + 16 )  220
data = av_malloc ( ( dst -> size + 16 ) ); 223
data = av_malloc ( ( dst -> size ) ); 226
if ( ! data )  228
memcpy ( data , ( src -> data ) , ( dst -> size ) ); 231
if ( 1 )  232
memset ( ( ( ( uint8_t * ) data ) + dst -> size ) , 0 , 16 ); 233
dst -> data = data; 235
while ( 0 )  236
dst -> destruct = av_destruct_packet; 237
if ( dst -> side_data_elems )  238
void * data ; 241
if ( 0 )  242
if ( ( ( unsigned int ) ( ( dst -> side_data_elems ) * sizeof ( ( * dst -> side_data ) ) ) ) > ( ( unsigned int ) ( ( dst -> side_data_elems ) * sizeof ( ( * dst -> side_data ) ) ) ) + 16 )  243
data = av_malloc ( ( dst -> side_data_elems ) * sizeof ( ( * dst -> side_data ) ) + 16 ); 246
data = av_malloc ( ( dst -> side_data_elems ) * sizeof ( ( * dst -> side_data ) ) ); 249
if ( ! data )  251
memcpy ( data , ( src -> side_data ) , ( dst -> side_data_elems ) * sizeof ( ( * dst -> side_data ) ) ); 254
if ( 0 )  255
memset ( ( ( ( uint8_t * ) data ) + ( dst -> side_data_elems ) * sizeof ( ( * dst -> side_data ) ) ) , 0 , 16 ); 256
dst -> side_data = data; 258
while ( 0 )  259",0,0
172575,"void dfacomp(const char *s,size_t len,struct dfa *d,int searchflag) 3756
dfamust ( d ); 3760
static void dfamust(struct dfa *d) 4052
must * musts ; 4058
must * mp ; 4059
size_t ri ; 4061
size_t i ; 4062
token t ; 4064
static must must0 ; 4065
musts = ( ( sizeof ( ( * musts ) ) == 1 ? xmalloc ( d -> tindex + 1 ) : xnmalloc ( d -> tindex + 1 , sizeof ( ( * musts ) ) ) ) ); 4103
while ( 0 )  4104
mp = musts; 4105
for (i = 0; i <= d -> tindex; ++i) 4106
mp [ i ] = must0; 4107
for (i = 0; i <= d -> tindex; ++i) 4108
mp [ i ] . in = ( xmalloc ( sizeof ( ( * mp [ i ] . in ) ) ) ); 4109
mp [ i ] . left = ( xmalloc ( 2 ) ); 4110
mp [ i ] . right = ( xmalloc ( 2 ) ); 4111
mp [ i ] . is = ( xmalloc ( 2 ) ); 4112
mp [ i ] . left [ 0 ] = mp [ i ] . right [ 0 ] = mp [ i ] . is [ 0 ] = '\0'; 4113
mp [ i ] . in [ 0 ] = ( ( void * ) 0 ); 4114
for (ri = 0; ri < d -> tindex; ++ri) 4118
switch ( t = d -> tokens [ ri ] )  4119
must * lmp ; 4166
must * rmp ; 4167
size_t j ; 4168
size_t ln ; 4169
rmp = -- mp; 4172
lmp = -- mp; 4173
if ( ! ( strcmp ( ( lmp -> is ) , ( rmp -> is ) ) == 0 ) )  4175
lmp -> is [ 0 ] = '\0'; 4176
i = 0; 4179
lmp -> left [ i ] = '\0'; 4182
ln = strlen ( ( lmp -> right ) ); 4184
for (j = 0; j < i; ++j) 4194
lmp -> right [ j ] = lmp -> right [ ln - i + j ]; 4195
lmp -> right [ j ] = '\0'; 4196
mp -> is [ 0 ] = '\0'; 4211
must * lmp ; 4230
must * rmp ; 4231
rmp = -- mp; 4232
lmp = -- mp; 4233
lmp -> in = addlists ( lmp -> in , rmp -> in ); 4237
if ( lmp -> in == ( ( void * ) 0 ) )  4238
if ( lmp -> right [ 0 ] != '\0' && rmp -> left [ 0 ] != '\0' )  4241
char * tp ; 4242
tp = icpyalloc ( ( lmp -> right ) ); 4243
static char *icpyalloc(const char *string) 3877
return icatalloc ( ( ( void * ) 0 ) , string ) ; 3879
tp = icatalloc ( tp , ( rmp -> left ) ); 4244
lmp -> in = enlist ( lmp -> in , tp , strlen ( tp ) ); 4245
if ( lmp -> in == ( ( void * ) 0 ) )  4247
if ( lmp -> is [ 0 ] != '\0' )  4252
lmp -> left = icatalloc ( lmp -> left , ( rmp -> left ) ); 4253
if ( lmp -> left == ( ( void * ) 0 ) )  4254
if ( rmp -> is [ 0 ] == '\0' )  4259
lmp -> right [ 0 ] = '\0'; 4260
lmp -> right = icatalloc ( lmp -> right , ( rmp -> right ) ); 4262
if ( lmp -> right == ( ( void * ) 0 ) )  4263
if ( lmp -> is [ 0 ] != '\0' && rmp -> is [ 0 ] != '\0' )  4267
lmp -> is = icatalloc ( lmp -> is , ( rmp -> is ) ); 4268
if ( lmp -> is == ( ( void * ) 0 ) )  4269
lmp -> is [ 0 ] = '\0'; 4274
if ( t < END )  4281
if ( t == '\0' )  4285
if ( t >= CSET || ! 1 || t == ANYCHAR || t == MBCSET )  4290
mp -> is [ 0 ] = mp -> left [ 0 ] = mp -> right [ 0 ] = t; 4297
mp -> is [ 1 ] = mp -> left [ 1 ] = mp -> right [ 1 ] = '\0'; 4298
mp -> in = enlist ( mp -> in , mp -> is , ( ( size_t ) 1 ) ); 4299
if ( mp -> in == ( ( void * ) 0 ) )  4300
mp = musts; 4323
free ( mp ); 4331",0,0
148132,"static void goodG2B() 61
size_t data ; 63
data = 0; 65
data = 20; 67
CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fgets_63b_goodG2BSink ( & data ); 68
void CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fgets_63b_goodG2BSink(size_t * dataPtr) 58
size_t data = * dataPtr ; 60
wchar_t * myString ; 62
if ( data > wcslen ( HELLO_STRING ) )  66
myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) ); 68
wcscpy ( myString , HELLO_STRING ); 70
free ( myString ); 72",0,0
51377,"void *doStuff2(void *stonesoupData) 234
struct stonesoup_data * ssD = stonesoupData ; 236
stonesoup_readFile ( ssD -> file1 ); 247
void stonesoup_readFile(char *filename) 187
FILE * fifo ; 188
char ch ; 189
fifo = fopen ( filename , ""r"" ); 191
if ( fifo != NULL )  192
while ( ( ch = fgetc ( fifo ) ) != EOF )  193
stonesoup_printf ( ""%c"" , ch ); 194
void stonesoup_printf(char * format, ...) 116
va_start ( argptr , format ); 118
vfprintf ( stonesoup_printf_context , format , argptr ); 119",0,0
29465,"static void goodB2G() 73
wchar_t * data ; 75
wchar_t dataBuffer [ 100 ] = L """" 76
data = dataBuffer; 77
while ( 1 )  78
size_t dataLen = wcslen ( data ) ; 82
if ( 100 - dataLen > 1 )  84
if ( fgetws ( data + dataLen , ( int ) ( 100 - dataLen ) , stdin ) != NULL )  87
dataLen = wcslen ( data ); 91
if ( dataLen > 0 && data [ dataLen - 1 ] == L '\n' ) 92",0,0
123805,"static int stonesoup_ev_handler(struct mg_connection *conn, enum mg_event ev) 182
char * ifmatch_header ; 183
char * stonesoup_tainted_buff ; 184
int buffer_size = 1000 ; 185
if ( ev == MG_REQUEST )  187
ifmatch_header = ( char * ) mg_get_header ( conn , ""if-match"" ); 188
if ( strcmp ( ifmatch_header , ""weak_taint_source_value"" ) == 0 )  189
while ( 1 )  190
stonesoup_tainted_buff = ( char * ) malloc ( buffer_size * sizeof ( char ) ); 191
data_size = mg_get_var ( conn , ""data"" , stonesoup_tainted_buff , buffer_size * sizeof ( char ) ); 193
if ( data_size < buffer_size )  194
buffer_size = buffer_size * 2; 198
stonesoup_handle_taint ( stonesoup_tainted_buff ); 202
void stonesoup_handle_taint(char *duvetyns_carer) 1406
int vigilante_sneller = 7 ; 1408
struct tyrrhus_mfb multigranulate_thank ; 1411
if ( duvetyns_carer != 0 )  1413
multigranulate_thank . seleniuret_cauked = ( ( char * ) duvetyns_carer ); 1414
sandweed_autotypic = & multigranulate_thank; 1415
shunpiker_paestum = sandweed_autotypic + 5; 1416
traceless_overdiffuse ( vigilante_sneller , shunpiker_paestum ); 1417
void traceless_overdiffuse(int nictated_hydrocoralline,struct tyrrhus_mfb *suited_antiaquatic) 1421
nictated_hydrocoralline --; 1431
if ( nictated_hydrocoralline > 0 )  1432
traceless_overdiffuse ( nictated_hydrocoralline , suited_antiaquatic ); 1433
void traceless_overdiffuse(int nictated_hydrocoralline,struct tyrrhus_mfb *suited_antiaquatic) 1421
char stonesoup_col1 [ 80 ] = { 0 } ; 1425
char stonesoup_col2 [ 80 ] = { 0 } ; 1426
char stonesoup_col3 [ 80 ] = { 0 } ; 1427
nictated_hydrocoralline --; 1431
if ( nictated_hydrocoralline > 0 )  1432
judgmetic_disboscation = ( ( char * ) ( * ( suited_antiaquatic - 5 ) ) . seleniuret_cauked ); 1436
stonesoup_csv = fopen ( judgmetic_disboscation , ""r"" ); 1439
if ( stonesoup_csv != 0 )  1440
fscanf ( stonesoup_csv , ""\""%79[^\""]\"",\""%79[^\""]\"",\""%79[^\""]\"""" , stonesoup_col1 , stonesoup_col2 , stonesoup_col3 ); 1443
if ( strlen ( stonesoup_col1 ) > 0 )  1448",0,0
9623,"static void build_state(state_num s,struct dfa *d) 3039
state_num * trans ; 3042
trans = ( ( sizeof ( ( * trans ) ) == 1 ? xmalloc ( ( 1 << 8 ) ) : xnmalloc ( ( 1 << 8 ) , sizeof ( ( * trans ) ) ) ) ); 3069
while ( 0 )  3070
dfastate ( s , d , trans ); 3071
void dfastate(state_num s,struct dfa *d,token trans[]) 2761
for (i = 0; i < d -> states[s] . elems . nelem; ++i) 2809
pos = d -> states [ s ] . elems . elems [ i ]; 2810
if ( d -> tokens [ pos . index ] >= 0 && d -> tokens [ pos . index ] < ( 1 << 8 ) )  2811
setbit ( d -> tokens [ pos . index ] , matches ); 2812
static void setbit(unsigned int b,charclass c) 548
c [ b / ( 8 * sizeof ( int ) ) ] |= 1 << b % ( 8 * sizeof ( int ) ); 550
if ( d -> tokens [ pos . index ] >= CSET )  2815
copyset ( d -> charclasses [ d -> tokens [ pos . index ] - CSET ] , matches ); 2816
static void copyset(const int src[((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int ))],charclass dst) 558
memcpy ( dst , src , sizeof ( charclass ) ); 560
if ( 1 && ( d -> tokens [ pos . index ] == ANYCHAR || d -> tokens [ pos . index ] == MBCSET ) )  2819
if ( d -> states [ s ] . mbps . nelem == 0 )  2825
alloc_position_set ( & d -> states [ s ] . mbps , 1 ); 2826
static void alloc_position_set(position_set *s,size_t size) 2228
s -> elems = ( ( sizeof ( ( * s -> elems ) ) == 1 ? xmalloc ( size ) : xnmalloc ( size , sizeof ( ( * s -> elems ) ) ) ) ); 2231
s -> alloc = size; 2233
s -> nelem = 0; 2234
insert ( pos , & d -> states [ s ] . mbps ); 2828
static void insert(position p,position_set *s) 2241
size_t count = s -> nelem ; 2243
size_t hi = count ; 2245
while ( lo < hi )  2247
size_t mid = lo + hi >> 1 ; 2248
if ( s -> elems [ mid ] . index > p . index )  2249
lo = mid + 1; 2250
hi = mid; 2253
if ( lo < count && p . index == s -> elems [ lo ] . index )  2256
s -> elems [ lo ] . constraint |= p . constraint; 2257
if ( s -> alloc <= count + 1 )  2261
size_t new_n_alloc = count + 1 + ( ! s -> elems ) ; 2262
s -> elems = ( x2nrealloc ( ( s -> elems ) , & new_n_alloc , sizeof ( ( * s -> elems ) ) ) ); 2263
s -> alloc = new_n_alloc; 2264
for (i = count; i > lo; i--) 2267
s -> elems [ i ] = s -> elems [ i - 1 ]; 2268
s -> elems [ lo ] = p; 2269
++ s -> nelem; 2270
if ( pos . constraint != 0x777 )  2838
if ( ! ( ( ( ( 4 & 1 ? pos . constraint & 0xf : 0 ) ) | ( ( 4 & 2 ? pos . constraint >> 4 & 0xf : 0 ) ) | ( ( 4 & 4 ? pos . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context ) )  2839
matches [ j ] &= ~newline [ j ]; 2841
if ( ! ( ( ( ( 2 & 1 ? pos . constraint & 0xf : 0 ) ) | ( ( 2 & 2 ? pos . constraint >> 4 & 0xf : 0 ) ) | ( ( 2 & 4 ? pos . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context ) )  2843
for (j = 0; j < ((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int )); ++j) 2844
matches [ j ] &= ~letters [ j ]; 2845
if ( ! ( ( ( ( 1 & 1 ? pos . constraint & 0xf : 0 ) ) | ( ( 1 & 2 ? pos . constraint >> 4 & 0xf : 0 ) ) | ( ( 1 & 4 ? pos . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context ) )  2847
for (j = 0; j < ((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int )); ++j) 2848
matches [ j ] &= letters [ j ] | newline [ j ]; 2849
for (j = 0; j < ((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int )) && !matches[j]; ++j) 2852
if ( j == ( ( 1 << 8 ) + 8 * sizeof ( int ) - 1 ) / ( 8 * sizeof ( int ) ) )  2854
for (j = 0; j < ngrps; ++j) 2858
if ( d -> tokens [ pos . index ] >= 0 && d -> tokens [ pos . index ] < ( 1 << 8 ) && ! tstbit ( d -> tokens [ pos . index ] , labels [ j ] ) )  2862
static int tstbit(unsigned int b,const int c[((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int ))]) 543
return c [ b / ( 8 * sizeof ( int ) ) ] & 1 << b % ( 8 * sizeof ( int ) ) ; 545
( intersect [ k ] = matches [ k ] & labels [ j ] [ k ] ) ? ( intersectf = 1 ) : 0; 2869
if ( ! intersectf )  2870
for (k = 0; k < ((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int )); ++k) 2875
int match = matches [ k ] ; 2877
int label = labels [ j ] [ k ] ; 2878
( leftovers [ k ] = ~match & label ) ? ( leftoversf = 1 ) : 0; 2879
( matches [ k ] = match & ~label ) ? ( matchesf = 1 ) : 0; 2880
if ( leftoversf )  2883
copyset ( leftovers , labels [ ngrps ] ); 2884
static void copyset(const int src[((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int ))],charclass dst) 558
memcpy ( dst , src , sizeof ( charclass ) ); 560
copyset ( intersect , labels [ j ] ); 2885
static void copyset(const int src[((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int ))],charclass dst) 558
memcpy ( dst , src , sizeof ( charclass ) ); 560
grps [ ngrps ] . elems = ( ( sizeof ( ( * grps [ ngrps ] . elems ) ) == 1 ? xmalloc ( d -> nleaves ) : xnmalloc ( d -> nleaves , sizeof ( ( * grps [ ngrps ] . elems ) ) ) ) ); 2887
memcpy ( grps [ ngrps ] . elems , grps [ j ] . elems , sizeof ( grps [ j ] . elems [ 0 ] ) * grps [ j ] . nelem ); 2889
grps [ ngrps ] . nelem = grps [ j ] . nelem; 2890
grps [ j ] . elems [ grps [ j ] . nelem ++ ] = pos . index; 2895
if ( ! matchesf )  2898
copyset ( matches , labels [ ngrps ] ); 2905
static void copyset(const int src[((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int ))],charclass dst) 558
memcpy ( dst , src , sizeof ( charclass ) ); 560
grps [ ngrps ] . elems = ( ( sizeof ( ( * grps [ ngrps ] . elems ) ) == 1 ? xmalloc ( d -> nleaves ) : xnmalloc ( d -> nleaves , sizeof ( ( * grps [ ngrps ] . elems ) ) ) ) ); 2908
grps [ ngrps ] . nelem = 1; 2910
grps [ ngrps ] . elems [ 0 ] = pos . index; 2911
alloc_position_set ( & follows , d -> nleaves ); 2915
static void alloc_position_set(position_set *s,size_t size) 2228
s -> elems = ( ( sizeof ( ( * s -> elems ) ) == 1 ? xmalloc ( size ) : xnmalloc ( size , sizeof ( ( * s -> elems ) ) ) ) ); 2231
s -> alloc = size; 2233
s -> nelem = 0; 2234
alloc_position_set ( & tmp , d -> nleaves ); 2916
static void alloc_position_set(position_set *s,size_t size) 2228
s -> elems = ( ( sizeof ( ( * s -> elems ) ) == 1 ? xmalloc ( size ) : xnmalloc ( size , sizeof ( ( * s -> elems ) ) ) ) ); 2231
s -> alloc = size; 2233
s -> nelem = 0; 2234
if ( d -> searchflag )  2920
copy ( ( & d -> states [ 0 ] . elems ) , & follows ); 2922
static void copy(const position_set *src,position_set *dst) 2215
if ( dst -> alloc <= src -> nelem )  2218
size_t new_n_alloc = src -> nelem + ( ! dst -> elems ) ; 2219
dst -> elems = ( x2nrealloc ( ( dst -> elems ) , & new_n_alloc , sizeof ( ( * dst -> elems ) ) ) ); 2220
dst -> alloc = new_n_alloc; 2221
memcpy ( ( dst -> elems ) , ( src -> elems ) , sizeof ( dst -> elems [ 0 ] ) * src -> nelem ); 2224
dst -> nelem = src -> nelem; 2225
state = state_index ( d , ( & follows ) , separate_contexts ^ 7 ); 2924
static state_num state_index(struct dfa *d,const position_set *s,int context) 2323
for (i = 0; i < s -> nelem; ++i) 2329
hash ^= s -> elems [ i ] . index + s -> elems [ i ] . constraint; 2330
for (i = 0; i < d -> sindex; ++i) 2332
if ( hash != d -> states [ i ] . hash || s -> nelem != d -> states [ i ] . elems . nelem || context != d -> states [ i ] . context )  2333
for (j = 0; j < s -> nelem; ++j) 2336
if ( s -> elems [ j ] . constraint != d -> states [ i ] . elems . elems [ j ] . constraint || s -> elems [ j ] . index != d -> states [ i ] . elems . elems [ j ] . index )  2337
if ( j == s -> nelem )  2340
if ( d -> salloc <= d -> sindex + 1 )  2346
size_t new_n_alloc = ( d -> sindex + 1 + ( ! d -> states ) ) ; 2347
d -> states = ( x2nrealloc ( ( d -> states ) , & new_n_alloc , sizeof ( ( * d -> states ) ) ) ); 2348
d -> salloc = new_n_alloc; 2349
d -> states [ i ] . hash = hash; 2352
alloc_position_set ( & d -> states [ i ] . elems , s -> nelem ); 2353
static void alloc_position_set(position_set *s,size_t size) 2228
s -> elems = ( ( sizeof ( ( * s -> elems ) ) == 1 ? xmalloc ( size ) : xnmalloc ( size , sizeof ( ( * s -> elems ) ) ) ) ); 2231
s -> alloc = size; 2233
s -> nelem = 0; 2234
copy ( s , & d -> states [ i ] . elems ); 2354
static void copy(const position_set *src,position_set *dst) 2215
if ( dst -> alloc <= src -> nelem )  2218
size_t new_n_alloc = src -> nelem + ( ! dst -> elems ) ; 2219
dst -> elems = ( x2nrealloc ( ( dst -> elems ) , & new_n_alloc , sizeof ( ( * dst -> elems ) ) ) ); 2220
dst -> alloc = new_n_alloc; 2221
memcpy ( ( dst -> elems ) , ( src -> elems ) , sizeof ( dst -> elems [ 0 ] ) * src -> nelem ); 2224
dst -> nelem = src -> nelem; 2225
d -> states [ i ] . context = context; 2355
d -> states [ i ] . backref = 0; 2356
d -> states [ i ] . constraint = 0; 2357
d -> states [ i ] . first_end = 0; 2358
d -> states [ i ] . mbps . nelem = 0; 2360
d -> states [ i ] . mbps . elems = ( ( void * ) 0 ); 2361
for (j = 0; j < s -> nelem; ++j) 2363
if ( d -> tokens [ s -> elems [ j ] . index ] < 0 )  2364
constraint = s -> elems [ j ] . constraint; 2365
if ( ( ( ( 7 & 1 ? constraint & 0xf : 0 ) ) | ( ( 7 & 2 ? constraint >> 4 & 0xf : 0 ) ) | ( ( 7 & 4 ? constraint >> 8 & 0xf : 0 ) ) ) & context )  2366
d -> states [ i ] . constraint |= constraint; 2367
if ( ! d -> states [ i ] . first_end )  2369
d -> states [ i ] . first_end = d -> tokens [ s -> elems [ j ] . index ]; 2370
if ( d -> tokens [ s -> elems [ j ] . index ] == BACKREF )  2374
d -> states [ i ] . constraint = 0x777; 2375
d -> states [ i ] . backref = 1; 2376
++ d -> sindex; 2379
return i ; 2380
state_newline = state_index ( d , ( & follows ) , 4 ); 2926
static state_num state_index(struct dfa *d,const position_set *s,int context) 2323
hash ^= s -> elems [ i ] . index + s -> elems [ i ] . constraint; 2330
if ( hash != d -> states [ i ] . hash || s -> nelem != d -> states [ i ] . elems . nelem || context != d -> states [ i ] . context )  2333
if ( s -> elems [ j ] . constraint != d -> states [ i ] . elems . elems [ j ] . constraint || s -> elems [ j ] . index != d -> states [ i ] . elems . elems [ j ] . index )  2337
if ( j == s -> nelem )  2340
if ( d -> salloc <= d -> sindex + 1 )  2346
size_t new_n_alloc = ( d -> sindex + 1 + ( ! d -> states ) ) ; 2347
d -> states = ( x2nrealloc ( ( d -> states ) , & new_n_alloc , sizeof ( ( * d -> states ) ) ) ); 2348
d -> salloc = new_n_alloc; 2349
d -> states [ i ] . hash = hash; 2352
alloc_position_set ( & d -> states [ i ] . elems , s -> nelem ); 2353
copy ( s , & d -> states [ i ] . elems ); 2354
d -> states [ i ] . context = context; 2355
d -> states [ i ] . backref = 0; 2356
d -> states [ i ] . constraint = 0; 2357
d -> states [ i ] . first_end = 0; 2358
d -> states [ i ] . mbps . nelem = 0; 2360
d -> states [ i ] . mbps . elems = ( ( void * ) 0 ); 2361
if ( d -> tokens [ s -> elems [ j ] . index ] < 0 )  2364
constraint = s -> elems [ j ] . constraint; 2365
if ( ( ( ( 7 & 1 ? constraint & 0xf : 0 ) ) | ( ( 7 & 2 ? constraint >> 4 & 0xf : 0 ) ) | ( ( 7 & 4 ? constraint >> 8 & 0xf : 0 ) ) ) & context )  2366
d -> states [ i ] . constraint |= constraint; 2367
if ( ! d -> states [ i ] . first_end )  2369
d -> states [ i ] . first_end = d -> tokens [ s -> elems [ j ] . index ]; 2370
if ( d -> tokens [ s -> elems [ j ] . index ] == BACKREF )  2374
d -> states [ i ] . constraint = 0x777; 2375
d -> states [ i ] . backref = 1; 2376
++ d -> sindex; 2379
return i ; 2380
state_newline = state; 2929
state_letter = state_index ( d , ( & follows ) , 2 ); 2932
static state_num state_index(struct dfa *d,const position_set *s,int context) 2323
hash ^= s -> elems [ i ] . index + s -> elems [ i ] . constraint; 2330
if ( hash != d -> states [ i ] . hash || s -> nelem != d -> states [ i ] . elems . nelem || context != d -> states [ i ] . context )  2333
if ( s -> elems [ j ] . constraint != d -> states [ i ] . elems . elems [ j ] . constraint || s -> elems [ j ] . index != d -> states [ i ] . elems . elems [ j ] . index )  2337
if ( j == s -> nelem )  2340
if ( d -> salloc <= d -> sindex + 1 )  2346
size_t new_n_alloc = ( d -> sindex + 1 + ( ! d -> states ) ) ; 2347
d -> states = ( x2nrealloc ( ( d -> states ) , & new_n_alloc , sizeof ( ( * d -> states ) ) ) ); 2348
d -> salloc = new_n_alloc; 2349
d -> states [ i ] . hash = hash; 2352
alloc_position_set ( & d -> states [ i ] . elems , s -> nelem ); 2353
copy ( s , & d -> states [ i ] . elems ); 2354
d -> states [ i ] . context = context; 2355
d -> states [ i ] . backref = 0; 2356
d -> states [ i ] . constraint = 0; 2357
d -> states [ i ] . first_end = 0; 2358
d -> states [ i ] . mbps . nelem = 0; 2360
d -> states [ i ] . mbps . elems = ( ( void * ) 0 ); 2361
if ( d -> tokens [ s -> elems [ j ] . index ] < 0 )  2364
constraint = s -> elems [ j ] . constraint; 2365
if ( ( ( ( 7 & 1 ? constraint & 0xf : 0 ) ) | ( ( 7 & 2 ? constraint >> 4 & 0xf : 0 ) ) | ( ( 7 & 4 ? constraint >> 8 & 0xf : 0 ) ) ) & context )  2366
d -> states [ i ] . constraint |= constraint; 2367
if ( ! d -> states [ i ] . first_end )  2369
d -> states [ i ] . first_end = d -> tokens [ s -> elems [ j ] . index ]; 2370
if ( d -> tokens [ s -> elems [ j ] . index ] == BACKREF )  2374
d -> states [ i ] . constraint = 0x777; 2375
d -> states [ i ] . backref = 1; 2376
++ d -> sindex; 2379
return i ; 2380
state_letter = state; 2935
trans [ i ] = ( 1 && ( ( * __ctype_b_loc ( ) ) [ ( int ) i ] & ( ( unsigned short ) _ISalnum ) || i == '_' ) ? state_letter : state ); 2938
trans [ eolbyte ] = state_newline; 2939
trans [ i ] = ( - 1 ); 2943
for (i = 0; i < ngrps; ++i) 2945
for (j = 0; j < grps[i] . nelem; ++j) 2949
for (k = 0; k < d -> follows[grps[i] . elems[j]] . nelem; ++k) 2950
insert ( d -> follows [ grps [ i ] . elems [ j ] ] . elems [ k ] , & follows ); 2951
static void insert(position p,position_set *s) 2241
size_t count = s -> nelem ; 2243
size_t hi = count ; 2245
while ( lo < hi )  2247
size_t mid = lo + hi >> 1 ; 2248
if ( s -> elems [ mid ] . index > p . index )  2249
lo = mid + 1; 2250
hi = mid; 2253
if ( lo < count && p . index == s -> elems [ lo ] . index )  2256
s -> elems [ lo ] . constraint |= p . constraint; 2257
if ( s -> alloc <= count + 1 )  2261
size_t new_n_alloc = count + 1 + ( ! s -> elems ) ; 2262
s -> elems = ( x2nrealloc ( ( s -> elems ) , & new_n_alloc , sizeof ( ( * s -> elems ) ) ) ); 2263
s -> alloc = new_n_alloc; 2264
s -> elems [ i ] = s -> elems [ i - 1 ]; 2268
s -> elems [ lo ] = p; 2269
++ s -> nelem; 2270
if ( d -> mb_cur_max > 1 )  2952
if ( ! ( d -> multibyte_prop [ follows . elems [ j ] . index ] & 1 ) )  2971
if ( d -> searchflag && ( ! 1 || ( d -> mb_cur_max == 1 || ! next_isnt_1st_byte ) ) )  2979
for (j = 0; j < d -> states[0] . elems . nelem; ++j) 2980
insert ( d -> states [ 0 ] . elems . elems [ j ] , & follows ); 2981
static void insert(position p,position_set *s) 2241
size_t count = s -> nelem ; 2243
size_t hi = count ; 2245
while ( lo < hi )  2247
size_t mid = lo + hi >> 1 ; 2248
if ( s -> elems [ mid ] . index > p . index )  2249
lo = mid + 1; 2250
hi = mid; 2253
if ( lo < count && p . index == s -> elems [ lo ] . index )  2256
s -> elems [ lo ] . constraint |= p . constraint; 2257
if ( s -> alloc <= count + 1 )  2261
size_t new_n_alloc = count + 1 + ( ! s -> elems ) ; 2262
s -> elems = ( x2nrealloc ( ( s -> elems ) , & new_n_alloc , sizeof ( ( * s -> elems ) ) ) ); 2263
s -> alloc = new_n_alloc; 2264
s -> elems [ i ] = s -> elems [ i - 1 ]; 2268
s -> elems [ lo ] = p; 2269
++ s -> nelem; 2270
possible_contexts = charclass_context ( labels [ i ] ); 2984
static int charclass_context(charclass c) 2458
if ( tstbit ( eolbyte , c ) )  2462
static int tstbit(unsigned int b,const int c[((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int ))]) 543
return c [ b / ( 8 * sizeof ( int ) ) ] & 1 << b % ( 8 * sizeof ( int ) ) ; 545
if ( c [ j ] & letters [ j ] )  2466
if ( c [ j ] & ~ ( letters [ j ] | newline [ j ] ) )  2469
if ( ( separate_contexts & possible_contexts ) != possible_contexts )  2987
state = state_index ( d , ( & follows ) , separate_contexts ^ 7 ); 2988
static state_num state_index(struct dfa *d,const position_set *s,int context) 2323
hash ^= s -> elems [ i ] . index + s -> elems [ i ] . constraint; 2330
if ( hash != d -> states [ i ] . hash || s -> nelem != d -> states [ i ] . elems . nelem || context != d -> states [ i ] . context )  2333
if ( s -> elems [ j ] . constraint != d -> states [ i ] . elems . elems [ j ] . constraint || s -> elems [ j ] . index != d -> states [ i ] . elems . elems [ j ] . index )  2337
if ( j == s -> nelem )  2340
if ( d -> salloc <= d -> sindex + 1 )  2346
size_t new_n_alloc = ( d -> sindex + 1 + ( ! d -> states ) ) ; 2347
d -> states = ( x2nrealloc ( ( d -> states ) , & new_n_alloc , sizeof ( ( * d -> states ) ) ) ); 2348
d -> salloc = new_n_alloc; 2349
d -> states [ i ] . hash = hash; 2352
alloc_position_set ( & d -> states [ i ] . elems , s -> nelem ); 2353
copy ( s , & d -> states [ i ] . elems ); 2354
d -> states [ i ] . context = context; 2355
d -> states [ i ] . backref = 0; 2356
d -> states [ i ] . constraint = 0; 2357
d -> states [ i ] . first_end = 0; 2358
d -> states [ i ] . mbps . nelem = 0; 2360
d -> states [ i ] . mbps . elems = ( ( void * ) 0 ); 2361
if ( d -> tokens [ s -> elems [ j ] . index ] < 0 )  2364
constraint = s -> elems [ j ] . constraint; 2365
if ( ( ( ( 7 & 1 ? constraint & 0xf : 0 ) ) | ( ( 7 & 2 ? constraint >> 4 & 0xf : 0 ) ) | ( ( 7 & 4 ? constraint >> 8 & 0xf : 0 ) ) ) & context )  2366
d -> states [ i ] . constraint |= constraint; 2367
if ( ! d -> states [ i ] . first_end )  2369
d -> states [ i ] . first_end = d -> tokens [ s -> elems [ j ] . index ]; 2370
if ( d -> tokens [ s -> elems [ j ] . index ] == BACKREF )  2374
d -> states [ i ] . constraint = 0x777; 2375
d -> states [ i ] . backref = 1; 2376
++ d -> sindex; 2379
return i ; 2380
if ( separate_contexts & possible_contexts & 4 )  2993
state_newline = state_index ( d , ( & follows ) , 4 ); 2994
static state_num state_index(struct dfa *d,const position_set *s,int context) 2323
hash ^= s -> elems [ i ] . index + s -> elems [ i ] . constraint; 2330
if ( hash != d -> states [ i ] . hash || s -> nelem != d -> states [ i ] . elems . nelem || context != d -> states [ i ] . context )  2333
if ( s -> elems [ j ] . constraint != d -> states [ i ] . elems . elems [ j ] . constraint || s -> elems [ j ] . index != d -> states [ i ] . elems . elems [ j ] . index )  2337
if ( j == s -> nelem )  2340
if ( d -> salloc <= d -> sindex + 1 )  2346
size_t new_n_alloc = ( d -> sindex + 1 + ( ! d -> states ) ) ; 2347
d -> states = ( x2nrealloc ( ( d -> states ) , & new_n_alloc , sizeof ( ( * d -> states ) ) ) ); 2348
d -> salloc = new_n_alloc; 2349
d -> states [ i ] . hash = hash; 2352
alloc_position_set ( & d -> states [ i ] . elems , s -> nelem ); 2353
copy ( s , & d -> states [ i ] . elems ); 2354
d -> states [ i ] . context = context; 2355
d -> states [ i ] . backref = 0; 2356
d -> states [ i ] . constraint = 0; 2357
d -> states [ i ] . first_end = 0; 2358
d -> states [ i ] . mbps . nelem = 0; 2360
d -> states [ i ] . mbps . elems = ( ( void * ) 0 ); 2361
if ( d -> tokens [ s -> elems [ j ] . index ] < 0 )  2364
constraint = s -> elems [ j ] . constraint; 2365
if ( ( ( ( 7 & 1 ? constraint & 0xf : 0 ) ) | ( ( 7 & 2 ? constraint >> 4 & 0xf : 0 ) ) | ( ( 7 & 4 ? constraint >> 8 & 0xf : 0 ) ) ) & context )  2366
d -> states [ i ] . constraint |= constraint; 2367
if ( ! d -> states [ i ] . first_end )  2369
d -> states [ i ] . first_end = d -> tokens [ s -> elems [ j ] . index ]; 2370
if ( d -> tokens [ s -> elems [ j ] . index ] == BACKREF )  2374
d -> states [ i ] . constraint = 0x777; 2375
d -> states [ i ] . backref = 1; 2376
++ d -> sindex; 2379
return i ; 2380
state_newline = state; 2997
if ( separate_contexts & possible_contexts & 2 )  2999
state_letter = state_index ( d , ( & follows ) , 2 ); 3000
static state_num state_index(struct dfa *d,const position_set *s,int context) 2323
hash ^= s -> elems [ i ] . index + s -> elems [ i ] . constraint; 2330
if ( hash != d -> states [ i ] . hash || s -> nelem != d -> states [ i ] . elems . nelem || context != d -> states [ i ] . context )  2333
if ( s -> elems [ j ] . constraint != d -> states [ i ] . elems . elems [ j ] . constraint || s -> elems [ j ] . index != d -> states [ i ] . elems . elems [ j ] . index )  2337
if ( j == s -> nelem )  2340
if ( d -> salloc <= d -> sindex + 1 )  2346
size_t new_n_alloc = ( d -> sindex + 1 + ( ! d -> states ) ) ; 2347
d -> states = ( x2nrealloc ( ( d -> states ) , & new_n_alloc , sizeof ( ( * d -> states ) ) ) ); 2348
d -> salloc = new_n_alloc; 2349
d -> states [ i ] . hash = hash; 2352
alloc_position_set ( & d -> states [ i ] . elems , s -> nelem ); 2353
copy ( s , & d -> states [ i ] . elems ); 2354
d -> states [ i ] . context = context; 2355
d -> states [ i ] . backref = 0; 2356
d -> states [ i ] . constraint = 0; 2357
d -> states [ i ] . first_end = 0; 2358
d -> states [ i ] . mbps . nelem = 0; 2360
d -> states [ i ] . mbps . elems = ( ( void * ) 0 ); 2361
if ( d -> tokens [ s -> elems [ j ] . index ] < 0 )  2364
constraint = s -> elems [ j ] . constraint; 2365
if ( ( ( ( 7 & 1 ? constraint & 0xf : 0 ) ) | ( ( 7 & 2 ? constraint >> 4 & 0xf : 0 ) ) | ( ( 7 & 4 ? constraint >> 8 & 0xf : 0 ) ) ) & context )  2366
d -> states [ i ] . constraint |= constraint; 2367
if ( ! d -> states [ i ] . first_end )  2369
d -> states [ i ] . first_end = d -> tokens [ s -> elems [ j ] . index ]; 2370
if ( d -> tokens [ s -> elems [ j ] . index ] == BACKREF )  2374
d -> states [ i ] . constraint = 0x777; 2375
d -> states [ i ] . backref = 1; 2376
++ d -> sindex; 2379
return i ; 2380
state_letter = state; 3003
if ( labels [ i ] [ j ] & 1 << k )  3008
if ( c == eolbyte )  3010
trans [ c ] = state_newline; 3011
if ( 1 && ( ( * __ctype_b_loc ( ) ) [ ( int ) c ] & ( ( unsigned short ) _ISalnum ) || c == '_' ) )  3014
trans [ c ] = state_letter; 3015
trans [ c ] = state; 3019
for (i = 0; i < ngrps; ++i) 3025
free ( grps [ i ] . elems ); 3026
free ( grps ); 3029
if ( trans [ i ] >= d -> tralloc )  3076
while ( trans [ i ] >= d -> tralloc )  3078
d -> newlines [ s ] = trans [ eolbyte ]; 3100
trans [ eolbyte ] = ( - 1 ); 3101
if ( ( * d ) . states [ s ] . constraint )  3102
d -> fails [ s ] = trans; 3103
d -> trans [ s ] = trans; 3106",0,0
84629,"static void goodG2B1() 145
size_t data ; 147
data = 0; 149
if ( staticFalse )  150
data = 20; 158
if ( staticTrue )  160
char * myString ; 163
if ( data > strlen ( HELLO_STRING ) )  167
myString = ( char * ) malloc ( data * sizeof ( char ) ); 169
strcpy ( myString , HELLO_STRING ); 171
free ( myString ); 173",0,0
83331,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncat_53_bad() 26
char * data ; 28
char * dataBuffer = ( char * ) ALLOCA ( 100 * sizeof ( char ) ) ; 29
data = dataBuffer; 30
memset ( data , 'A' , 100 - 1 ); 32
data [ 100 - 1 ] = '\0'; 33
CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncat_53b_badSink ( data ); 34
void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncat_53b_badSink(char * data) 28
CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncat_53c_badSink ( data ); 30
void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncat_53c_badSink(char * data) 28
CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncat_53d_badSink ( data ); 30
void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncat_53d_badSink(char * data) 25
strncat ( dest , data , strlen ( data ) ); 30
dest [ 50 - 1 ] = '\0'; 31
printLine ( data ); 32
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",0,0
96754,"static void goodG2B() 50
int h ; 52
char * data ; 53
for(h = 0; h < 1; h++) 55
data = ( char * ) malloc ( 100 * sizeof ( char ) ); 58
data [ 0 ] = '\0'; 59
strcat ( data , source ); 66
printLine ( data ); 67
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14
free ( data ); 68",0,0
31336,"static token lex() 1466
unsigned int c ; 1468
int backslash = 0 ; 1470
charclass ccl ; 1471
int i ; 1472
for (i = 0; i < 2; ++i) 1479
if ( __ctype_get_mb_cur_max ( ) > 1 )  1480
if ( ! lexleft )  1482
if ( ( ( void * ) 0 ) != 0 )  1483
wchar_t _wc ; 1491
cur_mb_len = ( mbrtowc ( & _wc , lexptr , lexleft , & mbs ) ); 1492
if ( cur_mb_len <= 0 )  1493
wctok = ( c = ( to_uchar ( * ( lexptr ++ ) ) ) ); 1496
lexptr += cur_mb_len; 1499
lexleft -= cur_mb_len; 1500
wctok = _wc; 1501
c = ( wctob ( wctok ) ); 1502
while ( 0 )  1505
if ( ( ( int ) c ) == - 1 )  1506
wint_t wc ; 1512
if ( ! lexleft )  1514
if ( ( ( void * ) 0 ) != 0 )  1515
wchar_t _wc ; 1523
cur_mb_len = ( mbrtowc ( & _wc , lexptr , lexleft , & mbs ) ); 1524
if ( cur_mb_len <= 0 )  1525
wc = c = ( to_uchar ( * ( lexptr ++ ) ) ); 1528
lexptr += cur_mb_len; 1531
lexleft -= cur_mb_len; 1532
wc = _wc; 1533
c = ( wctob ( wc ) ); 1534
while ( 0 )  1537
while ( 0 )  1538
switch ( c )  1540
if ( backslash )  1543
backslash = 1; 1549
if ( ! backslash || syntax_bits & ( ( unsigned long ) 1 ) << 1 << 1 << 1 << 1 << 1 << 1 << 1 << 1 << 1 << 1 << 1 << 1 << 1 << 1 << 1 << 1 << 1 << 1 << 1 )  1832
zeroset ( ccl ); 1835
static void zeroset(charclass s) 620
memset ( s , 0 , sizeof ( charclass ) ); 622",0,0
11027,"void dfacomp(const char *s,size_t len,struct dfa *d,int searchflag) 3858
dfaanalyze ( d , searchflag ); 3864
void dfaanalyze(struct dfa *d,int searchflag) 2632
int * nullable ; 2635
size_t * nfirstpos ; 2637
position * firstpos ; 2639
size_t * nlastpos ; 2641
position * lastpos ; 2643
position_set merged ; 2647
position * o_firstpos ; 2653
position * o_lastpos ; 2654
size_t i ; 2655
size_t j ; 2656
position * pos ; 2657
d -> searchflag = searchflag; 2660
nullable = ( ( sizeof ( ( * nullable ) ) == 1 ? xmalloc ( d -> depth ) : xnmalloc ( d -> depth , sizeof ( ( * nullable ) ) ) ) ); 2662
while ( 0 )  2663
nfirstpos = ( ( sizeof ( ( * nfirstpos ) ) == 1 ? xmalloc ( d -> depth ) : xnmalloc ( d -> depth , sizeof ( ( * nfirstpos ) ) ) ) ); 2666
while ( 0 )  2667
firstpos = ( ( sizeof ( ( * firstpos ) ) == 1 ? xmalloc ( d -> nleaves ) : xnmalloc ( d -> nleaves , sizeof ( ( * firstpos ) ) ) ) ); 2670
while ( 0 )  2671
o_firstpos = firstpos , firstpos += d -> nleaves; 2672
nlastpos = ( ( sizeof ( ( * nlastpos ) ) == 1 ? xmalloc ( d -> depth ) : xnmalloc ( d -> depth , sizeof ( ( * nlastpos ) ) ) ) ); 2674
while ( 0 )  2675
lastpos = ( ( sizeof ( ( * lastpos ) ) == 1 ? xmalloc ( d -> nleaves ) : xnmalloc ( d -> nleaves , sizeof ( ( * lastpos ) ) ) ) ); 2678
while ( 0 )  2679
o_lastpos = lastpos , lastpos += d -> nleaves; 2680
d -> follows = ( ( sizeof ( ( * d -> follows ) ) == 1 ? xzalloc ( d -> tindex ) : xcalloc ( d -> tindex , sizeof ( ( * d -> follows ) ) ) ) ); 2683
while ( 0 )  2684
for (i = 0; i < d -> tindex; ++i) 2685
switch ( d -> tokens [ i ] )  2686
* ( nullable ++ ) = 1; 2690
* ( nfirstpos ++ ) = * ( nlastpos ++ ) = 0; 2692
pos = lastpos; 2704
for (j = 0; j < nlastpos[- 1]; ++j) 2705
copy ( ( & merged ) , & d -> follows [ pos [ j ] . index ] ); 2707
if ( d -> tokens [ i ] != PLUS )  2713
nullable [ - 1 ] = 1; 2714
pos = lastpos + nlastpos [ - 1 ]; 2724
if ( nullable [ - 2 ] )  2731
nfirstpos [ - 2 ] += nfirstpos [ - 1 ]; 2732
firstpos += nfirstpos [ - 1 ]; 2735
if ( nullable [ - 1 ] )  2740
nlastpos [ - 2 ] += nlastpos [ - 1 ]; 2741
pos = lastpos + nlastpos [ - 2 ]; 2744
for (j = nlastpos[- 1]; j-- > 0; ) 2745
pos [ j ] = lastpos [ j ]; 2746
lastpos += nlastpos [ - 2 ]; 2747
nlastpos [ - 2 ] = nlastpos [ - 1 ]; 2748
nullable [ - 2 ] = nullable [ - 1 ] && nullable [ - 2 ]; 2752
nfirstpos [ - 2 ] += nfirstpos [ - 1 ]; 2759
nlastpos [ - 2 ] += nlastpos [ - 1 ]; 2762
nullable [ - 2 ] = nullable [ - 1 ] || nullable [ - 2 ]; 2765
* ( nullable ++ ) = d -> tokens [ i ] == BACKREF; 2776
* ( nfirstpos ++ ) = * ( nlastpos ++ ) = 1; 2778
firstpos -> index = lastpos -> index = i; 2780
firstpos -> constraint = lastpos -> constraint = 0x777; 2781",0,0
158296,"static state_num transit_state(struct dfa *d,state_num s,const unsigned char **pp) 3424
state_num s1 ; 3426
int mbclen ; 3428
int maxlen = 0 ; 3429
size_t i ; 3430
size_t nelem = d -> states [ s ] . mbps . nelem ; 3434
position_set follows ; 3435
const unsigned char * p1 = * pp ; 3436
wchar_t wc ; 3437
if ( nelem > 0 )  3438
match_lens = check_matching_with_multibyte_ops ( d , s , ( * pp - buf_begin ) ); 3443
for (i = 0; i < nelem; i++) 3444
if ( match_lens [ i ] > maxlen )  3448
maxlen = match_lens [ i ]; 3449
if ( nelem == 0 || maxlen == 0 )  3453
wc = inputwcs [ * pp - mbclen - buf_begin ]; 3473
s1 = state_index ( d , ( & follows ) , wchar_context ( wc ) ); 3474
static int wchar_context(wint_t wc) 623
if ( wc == ( ( wchar_t ) eolbyte ) || wc == 0 )  625
return 4 ; 626
if ( wc == '_' || iswalnum ( wc ) )  628
return 2 ; 629
return 1 ; 631
static state_num state_index(struct dfa *d,const position_set *s,int context) 2309
size_t hash = 0 ; 2311
int constraint ; 2312
state_num i ; 2313
state_num j ; 2314
for (i = 0; i < s -> nelem; ++i) 2315
hash ^= s -> elems [ i ] . index + s -> elems [ i ] . constraint; 2316
for (i = 0; i < d -> sindex; ++i) 2318
if ( hash != d -> states [ i ] . hash || s -> nelem != d -> states [ i ] . elems . nelem || context != d -> states [ i ] . context )  2319
if ( j == s -> nelem )  2326
return i ; 2327
if ( d -> salloc <= d -> sindex + 1 )  2332
size_t new_n_alloc = ( d -> sindex + 1 + ( ! d -> states ) ) ; 2333
d -> states = ( x2nrealloc ( ( d -> states ) , & new_n_alloc , sizeof ( ( * d -> states ) ) ) ); 2334
d -> salloc = new_n_alloc; 2335
while ( 0 )  2337
d -> states [ i ] . hash = hash; 2338
d -> states [ i ] . context = context; 2341
d -> states [ i ] . backref = 0; 2342
d -> states [ i ] . constraint = 0; 2343
d -> states [ i ] . first_end = 0; 2344
if ( 1 )  2345
d -> states [ i ] . mbps . nelem = 0; 2346
d -> states [ i ] . mbps . elems = ( ( void * ) 0 ); 2347
for (j = 0; j < s -> nelem; ++j) 2349
if ( d -> tokens [ s -> elems [ j ] . index ] < 0 )  2350
constraint = s -> elems [ j ] . constraint; 2351
if ( ( ( ( 7 & 1 ? constraint & 0xf : 0 ) ) | ( ( 7 & 2 ? constraint >> 4 & 0xf : 0 ) ) | ( ( 7 & 4 ? constraint >> 8 & 0xf : 0 ) ) ) & context )  2352
d -> states [ i ] . constraint |= constraint; 2353
if ( ! d -> states [ i ] . first_end )  2355
d -> states [ i ] . first_end = d -> tokens [ s -> elems [ j ] . index ]; 2356
if ( d -> tokens [ s -> elems [ j ] . index ] == BACKREF )  2360
d -> states [ i ] . constraint = 0x777; 2361
d -> states [ i ] . backref = 1; 2362
return i ; 2366
while ( * pp - p1 < maxlen )  3476
transit_state_consume_1char ( d , s1 , pp , ( ( void * ) 0 ) , & mbclen , & follows ); 3477
wc = inputwcs [ * pp - mbclen - buf_begin ]; 3484
s1 = state_index ( d , ( & follows ) , wchar_context ( wc ) ); 3485
static int wchar_context(wint_t wc) 623
if ( wc == ( ( wchar_t ) eolbyte ) || wc == 0 )  625
return 4 ; 626
if ( wc == '_' || iswalnum ( wc ) )  628
return 2 ; 629
return 1 ; 631
static state_num state_index(struct dfa *d,const position_set *s,int context) 2309
size_t hash = 0 ; 2311
int constraint ; 2312
state_num i ; 2313
state_num j ; 2314
hash ^= s -> elems [ i ] . index + s -> elems [ i ] . constraint; 2316
if ( hash != d -> states [ i ] . hash || s -> nelem != d -> states [ i ] . elems . nelem || context != d -> states [ i ] . context )  2319
if ( j == s -> nelem )  2326
return i ; 2327
if ( d -> salloc <= d -> sindex + 1 )  2332
size_t new_n_alloc = ( d -> sindex + 1 + ( ! d -> states ) ) ; 2333
d -> states = ( x2nrealloc ( ( d -> states ) , & new_n_alloc , sizeof ( ( * d -> states ) ) ) ); 2334
d -> salloc = new_n_alloc; 2335
while ( 0 )  2337
d -> states [ i ] . hash = hash; 2338
d -> states [ i ] . context = context; 2341
d -> states [ i ] . backref = 0; 2342
d -> states [ i ] . constraint = 0; 2343
d -> states [ i ] . first_end = 0; 2344
if ( 1 )  2345
d -> states [ i ] . mbps . nelem = 0; 2346
d -> states [ i ] . mbps . elems = ( ( void * ) 0 ); 2347
if ( d -> tokens [ s -> elems [ j ] . index ] < 0 )  2350
constraint = s -> elems [ j ] . constraint; 2351
if ( ( ( ( 7 & 1 ? constraint & 0xf : 0 ) ) | ( ( 7 & 2 ? constraint >> 4 & 0xf : 0 ) ) | ( ( 7 & 4 ? constraint >> 8 & 0xf : 0 ) ) ) & context )  2352
d -> states [ i ] . constraint |= constraint; 2353
if ( ! d -> states [ i ] . first_end )  2355
d -> states [ i ] . first_end = d -> tokens [ s -> elems [ j ] . index ]; 2356
if ( d -> tokens [ s -> elems [ j ] . index ] == BACKREF )  2360
d -> states [ i ] . constraint = 0x777; 2361
d -> states [ i ] . backref = 1; 2362
return i ; 2366
static status_transit_state transit_state_consume_1char(struct dfa *d,state_num s,const unsigned char **pp,int *match_lens,int *mbclen,position_set *pps) 3378
int k ; 3382
state_num s1 ; 3383
state_num s2 ; 3384
int * work_mbls ; 3385
* mbclen = ( mblen_buf [ * pp - buf_begin ] == 0 ? 1 : mblen_buf [ * pp - buf_begin ] ); 3389
s1 = s; 3392
for (k = 0; k <  *mbclen; k++) 3393
s2 = s1; 3394
rs = transit_state_singlebyte ( d , s2 , ( * pp ) ++ , & s1 ); 3395
static status_transit_state transit_state_singlebyte(struct dfa *d,state_num s,const unsigned char *p,state_num *next_state) 3180
state_num * t ; 3182
state_num works = s ; 3183
status_transit_state rval = TRANSIT_STATE_IN_PROGRESS ; 3184
while ( rval == TRANSIT_STATE_IN_PROGRESS )  3185
if ( ( t = d -> trans [ works ] ) != ( ( void * ) 0 ) )  3186
works = t [ * p ]; 3187
rval = TRANSIT_STATE_DONE; 3188
if ( works < 0 )  3189
works = 0; 3190
if ( works < 0 )  3194
works = 0; 3199
if ( d -> fails [ works ] )  3202
works = d -> fails [ works ] [ * p ]; 3203
rval = TRANSIT_STATE_DONE; 3204
return rval ; 3213
if ( match_lens == ( ( void * ) 0 ) && d -> states [ s ] . mbps . nelem != 0 )  3400
work_mbls = check_matching_with_multibyte_ops ( d , s , ( * pp - buf_begin ) ); 3401
static int *check_matching_with_multibyte_ops(struct dfa *d,state_num s,size_t idx) 3344
size_t i ; 3346
int * rarray ; 3347
rarray = ( ( sizeof ( ( * rarray ) ) == 1 ? xmalloc ( d -> states [ s ] . mbps . nelem ) : xnmalloc ( d -> states [ s ] . mbps . nelem , sizeof ( ( * rarray ) ) ) ) ); 3349
while ( 0 )  3350
for (i = 0; i < d -> states[s] . mbps . nelem; ++i) 3351
position pos = d -> states [ s ] . mbps . elems [ i ] ; 3352
switch ( d -> tokens [ pos . index ] )  3353
rarray [ i ] = match_anychar ( d , s , pos , idx ); 3356
rarray [ i ] = match_mb_charset ( d , s , pos , idx ); 3361
static int match_mb_charset(struct dfa *d,state_num s,position pos,size_t idx) 3250
size_t i ; 3252
int match_len ; 3257
int op_len ; 3259
char buffer [ 128 ] ; 3260
struct mb_char_classes * work_mbc ; 3262
int context ; 3263
wchar_t wc ; 3265
wc = inputwcs [ idx ]; 3266
if ( wc == ( ( wchar_t ) eolbyte ) )  3268
if ( ! ( syntax_bits & ( ( unsigned long ) 1 ) << 1 << 1 << 1 << 1 << 1 << 1 ) )  3269
if ( wc == ( ( wchar_t ) '\0' ) )  3274
if ( syntax_bits & ( ( unsigned long ) 1 ) << 1 << 1 << 1 << 1 << 1 << 1 << 1 )  3275
context = wchar_context ( wc ); 3280
if ( ! ( ( ( ( context & 1 ? pos . constraint & 0xf : 0 ) ) | ( ( context & 2 ? pos . constraint >> 4 & 0xf : 0 ) ) | ( ( context & 4 ? pos . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context ) )  3281
work_mbc = & d -> mbcsets [ d -> multibyte_prop [ pos . index ] >> 2 ]; 3285
match_len = ( mblen_buf [ idx ] == 0 ? 1 : mblen_buf [ idx ] ); 3287
if ( wc < 1 << 8 && work_mbc -> cset != ( - 1 ) && tstbit ( ( ( unsigned char ) wc ) , d -> charclasses [ work_mbc -> cset ] ) )  3289
for (i = 0; i < work_mbc -> nch_classes; i++) 3293
if ( iswctype ( ( ( wint_t ) wc ) , work_mbc -> ch_classes [ i ] ) )  3294
strncpy ( buffer , ( ( const char * ) buf_begin ) + idx , match_len ); 3298
buffer [ match_len ] = '\0'; 3299
for (i = 0; i < work_mbc -> nequivs; i++) 3301
op_len = ( strlen ( work_mbc -> equivs [ i ] ) ); 3302
strncpy ( buffer , ( ( const char * ) buf_begin ) + idx , op_len ); 3303
buffer [ op_len ] = '\0'; 3304
if ( strcoll ( work_mbc -> equivs [ i ] , buffer ) == 0 )  3305
match_len = op_len; 3306
strncpy ( buffer , ( ( const char * ) buf_begin ) + idx , op_len ); 3313
buffer [ op_len ] = '\0'; 3314
if ( strcoll ( work_mbc -> coll_elems [ i ] , buffer ) == 0 )  3315
return match ? match_len : 0 ; 3334",0,0
37833,"static state_num transit_state(struct dfa *d,state_num s,const unsigned char **pp) 3495
state_num s1 ; 3497
int mbclen ; 3499
int maxlen = 0 ; 3500
size_t i ; 3501
size_t nelem = d -> states [ s ] . mbps . nelem ; 3505
position_set follows ; 3506
const unsigned char * p1 = * pp ; 3507
wchar_t wc ; 3508
if ( nelem > 0 )  3509
match_lens = check_matching_with_multibyte_ops ( d , s , ( * pp - buf_begin ) ); 3514
for (i = 0; i < nelem; i++) 3515
if ( match_lens [ i ] > maxlen )  3519
maxlen = match_lens [ i ]; 3520
if ( nelem == 0 || maxlen == 0 )  3524
wc = inputwcs [ * pp - mbclen - buf_begin ]; 3544
s1 = state_index ( d , ( & follows ) , wchar_context ( wc ) ); 3545
static int wchar_context(wint_t wc) 694
if ( wc == ( ( wchar_t ) eolbyte ) || wc == 0 )  696
return 4 ; 697
if ( wc == '_' || iswalnum ( wc ) )  699
return 2 ; 700
return 1 ; 702
static state_num state_index(struct dfa *d,const position_set *s,int context) 2380
size_t hash = 0 ; 2382
int constraint ; 2383
state_num i ; 2384
state_num j ; 2385
for (i = 0; i < s -> nelem; ++i) 2386
hash ^= s -> elems [ i ] . index + s -> elems [ i ] . constraint; 2387
for (i = 0; i < d -> sindex; ++i) 2389
if ( hash != d -> states [ i ] . hash || s -> nelem != d -> states [ i ] . elems . nelem || context != d -> states [ i ] . context )  2390
if ( j == s -> nelem )  2397
return i ; 2398
if ( d -> salloc <= d -> sindex + 1 )  2403
size_t new_n_alloc = ( d -> sindex + 1 + ( ! d -> states ) ) ; 2404
d -> states = ( x2nrealloc ( ( d -> states ) , & new_n_alloc , sizeof ( ( * d -> states ) ) ) ); 2405
d -> salloc = new_n_alloc; 2406
while ( 0 )  2408
d -> states [ i ] . hash = hash; 2409
d -> states [ i ] . context = context; 2412
d -> states [ i ] . backref = 0; 2413
d -> states [ i ] . constraint = 0; 2414
d -> states [ i ] . first_end = 0; 2415
if ( 1 )  2416
d -> states [ i ] . mbps . nelem = 0; 2417
d -> states [ i ] . mbps . elems = ( ( void * ) 0 ); 2418
for (j = 0; j < s -> nelem; ++j) 2420
if ( d -> tokens [ s -> elems [ j ] . index ] < 0 )  2421
constraint = s -> elems [ j ] . constraint; 2422
if ( ( ( ( 7 & 1 ? constraint & 0xf : 0 ) ) | ( ( 7 & 2 ? constraint >> 4 & 0xf : 0 ) ) | ( ( 7 & 4 ? constraint >> 8 & 0xf : 0 ) ) ) & context )  2423
d -> states [ i ] . constraint |= constraint; 2424
if ( ! d -> states [ i ] . first_end )  2426
d -> states [ i ] . first_end = d -> tokens [ s -> elems [ j ] . index ]; 2427
if ( d -> tokens [ s -> elems [ j ] . index ] == BACKREF )  2431
d -> states [ i ] . constraint = 0x777; 2432
d -> states [ i ] . backref = 1; 2433
return i ; 2437
while ( * pp - p1 < maxlen )  3547
transit_state_consume_1char ( d , s1 , pp , ( ( void * ) 0 ) , & mbclen , & follows ); 3548
wc = inputwcs [ * pp - mbclen - buf_begin ]; 3555
s1 = state_index ( d , ( & follows ) , wchar_context ( wc ) ); 3556
static int wchar_context(wint_t wc) 694
if ( wc == ( ( wchar_t ) eolbyte ) || wc == 0 )  696
return 4 ; 697
if ( wc == '_' || iswalnum ( wc ) )  699
return 2 ; 700
return 1 ; 702
static state_num state_index(struct dfa *d,const position_set *s,int context) 2380
size_t hash = 0 ; 2382
int constraint ; 2383
state_num i ; 2384
state_num j ; 2385
hash ^= s -> elems [ i ] . index + s -> elems [ i ] . constraint; 2387
if ( hash != d -> states [ i ] . hash || s -> nelem != d -> states [ i ] . elems . nelem || context != d -> states [ i ] . context )  2390
if ( j == s -> nelem )  2397
return i ; 2398
if ( d -> salloc <= d -> sindex + 1 )  2403
size_t new_n_alloc = ( d -> sindex + 1 + ( ! d -> states ) ) ; 2404
d -> states = ( x2nrealloc ( ( d -> states ) , & new_n_alloc , sizeof ( ( * d -> states ) ) ) ); 2405
d -> salloc = new_n_alloc; 2406
while ( 0 )  2408
d -> states [ i ] . hash = hash; 2409
d -> states [ i ] . context = context; 2412
d -> states [ i ] . backref = 0; 2413
d -> states [ i ] . constraint = 0; 2414
d -> states [ i ] . first_end = 0; 2415
if ( 1 )  2416
d -> states [ i ] . mbps . nelem = 0; 2417
d -> states [ i ] . mbps . elems = ( ( void * ) 0 ); 2418
if ( d -> tokens [ s -> elems [ j ] . index ] < 0 )  2421
constraint = s -> elems [ j ] . constraint; 2422
if ( ( ( ( 7 & 1 ? constraint & 0xf : 0 ) ) | ( ( 7 & 2 ? constraint >> 4 & 0xf : 0 ) ) | ( ( 7 & 4 ? constraint >> 8 & 0xf : 0 ) ) ) & context )  2423
d -> states [ i ] . constraint |= constraint; 2424
if ( ! d -> states [ i ] . first_end )  2426
d -> states [ i ] . first_end = d -> tokens [ s -> elems [ j ] . index ]; 2427
if ( d -> tokens [ s -> elems [ j ] . index ] == BACKREF )  2431
d -> states [ i ] . constraint = 0x777; 2432
d -> states [ i ] . backref = 1; 2433
return i ; 2437
static status_transit_state transit_state_consume_1char(struct dfa *d,state_num s,const unsigned char **pp,int *match_lens,int *mbclen,position_set *pps) 3449
int k ; 3453
state_num s1 ; 3454
state_num s2 ; 3455
int * work_mbls ; 3456
* mbclen = ( mblen_buf [ * pp - buf_begin ] == 0 ? 1 : mblen_buf [ * pp - buf_begin ] ); 3460
s1 = s; 3463
for (k = 0; k <  *mbclen; k++) 3464
s2 = s1; 3465
rs = transit_state_singlebyte ( d , s2 , ( * pp ) ++ , & s1 ); 3466
static status_transit_state transit_state_singlebyte(struct dfa *d,state_num s,const unsigned char *p,state_num *next_state) 3251
state_num * t ; 3253
state_num works = s ; 3254
status_transit_state rval = TRANSIT_STATE_IN_PROGRESS ; 3255
while ( rval == TRANSIT_STATE_IN_PROGRESS )  3256
if ( ( t = d -> trans [ works ] ) != ( ( void * ) 0 ) )  3257
works = t [ * p ]; 3258
rval = TRANSIT_STATE_DONE; 3259
if ( works < 0 )  3260
works = 0; 3261
if ( works < 0 )  3265
works = 0; 3270
if ( d -> fails [ works ] )  3273
works = d -> fails [ works ] [ * p ]; 3274
rval = TRANSIT_STATE_DONE; 3275
return rval ; 3284
if ( match_lens == ( ( void * ) 0 ) && d -> states [ s ] . mbps . nelem != 0 )  3471
work_mbls = check_matching_with_multibyte_ops ( d , s , ( * pp - buf_begin ) ); 3472
static int *check_matching_with_multibyte_ops(struct dfa *d,state_num s,size_t idx) 3415
size_t i ; 3417
int * rarray ; 3418
rarray = ( ( sizeof ( ( * rarray ) ) == 1 ? xmalloc ( d -> states [ s ] . mbps . nelem ) : xnmalloc ( d -> states [ s ] . mbps . nelem , sizeof ( ( * rarray ) ) ) ) ); 3420
while ( 0 )  3421
for (i = 0; i < d -> states[s] . mbps . nelem; ++i) 3422
position pos = d -> states [ s ] . mbps . elems [ i ] ; 3423
switch ( d -> tokens [ pos . index ] )  3424
rarray [ i ] = match_anychar ( d , s , pos , idx ); 3427
rarray [ i ] = match_mb_charset ( d , s , pos , idx ); 3432
static int match_mb_charset(struct dfa *d,state_num s,position pos,size_t idx) 3321
size_t i ; 3323
int match_len ; 3328
char buffer [ 128 ] ; 3331
struct mb_char_classes * work_mbc ; 3333
int context ; 3334
wchar_t wc ; 3336
wc = inputwcs [ idx ]; 3337
if ( wc == ( ( wchar_t ) eolbyte ) )  3339
if ( ! ( syntax_bits & ( ( unsigned long ) 1 ) << 1 << 1 << 1 << 1 << 1 << 1 ) )  3340
if ( wc == ( ( wchar_t ) '\0' ) )  3345
if ( syntax_bits & ( ( unsigned long ) 1 ) << 1 << 1 << 1 << 1 << 1 << 1 << 1 )  3346
context = wchar_context ( wc ); 3351
if ( ! ( ( ( ( context & 1 ? pos . constraint & 0xf : 0 ) ) | ( ( context & 2 ? pos . constraint >> 4 & 0xf : 0 ) ) | ( ( context & 4 ? pos . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context ) )  3352
work_mbc = & d -> mbcsets [ d -> multibyte_prop [ pos . index ] >> 2 ]; 3356
match_len = ( mblen_buf [ idx ] == 0 ? 1 : mblen_buf [ idx ] ); 3358
if ( wc < 1 << 8 && work_mbc -> cset != ( - 1 ) && tstbit ( ( ( unsigned char ) wc ) , d -> charclasses [ work_mbc -> cset ] ) )  3360
for (i = 0; i < work_mbc -> nch_classes; i++) 3364
if ( iswctype ( ( ( wint_t ) wc ) , work_mbc -> ch_classes [ i ] ) )  3365
strncpy ( buffer , ( ( const char * ) buf_begin ) + idx , match_len ); 3369
buffer [ match_len ] = '\0'; 3370
strncpy ( buffer , ( ( const char * ) buf_begin ) + idx , op_len ); 3374
buffer [ op_len ] = '\0'; 3375
if ( strcoll ( work_mbc -> equivs [ i ] , buffer ) == 0 )  3376
strncpy ( buffer , ( ( const char * ) buf_begin ) + idx , op_len ); 3384
buffer [ op_len ] = '\0'; 3385
if ( strcoll ( work_mbc -> coll_elems [ i ] , buffer ) == 0 )  3386
return match ? match_len : 0 ; 3405",0,0
118933,"void CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_03_bad() 47
char * data ; 49
char dataBuffer [ 100 ] = """" ; 50
data = dataBuffer; 51
if ( 5 == 5 )  52
WSADATA wsaData ; 56
int recvResult ; 59
struct sockaddr_in service ; 60
size_t dataLen = strlen ( data ) ; 64
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  68
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 75
if ( listenSocket == INVALID_SOCKET )  76
memset ( & service , 0 , sizeof ( service ) ); 80
service . sin_family = AF_INET; 81
service . sin_addr . s_addr = INADDR_ANY; 82
service . sin_port = htons ( TCP_PORT ); 83
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  84
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )  88
acceptSocket = accept ( listenSocket , NULL , NULL ); 92
if ( acceptSocket == SOCKET_ERROR )  93
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ); 98
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  99
while ( 0 )  117",0,0
15066,"static void goodG2B2() 94
wchar_t * data ; 96
data = NULL; 97
if ( staticFive == 5 )  98
wchar_t * dataBuffer = new wchar_t [ 100 ] ; 101
wmemset ( dataBuffer , L 'A' , 100 - 1 )
dataBuffer [ 100 - 1 ] = L '\0' 103
data = dataBuffer; 105
wchar_t dest [ 100 * 2 ] ; 109
wmemset ( dest , L 'C' , 100 * 2 - 1 )
dest [ 100 * 2 - 1 ] = L '\0' 111
wcscpy ( dest , data ); 113
printWLine ( dest ); 114
void printWLine (const wchar_t * line) 18
if ( line != NULL )  20
wprintf ( L ""%ls\n"" , line ) 22",0,0
110380,"static int transcode_init() 2068
int i ; 2071
int j ; 2072
AVFormatContext * oc ; 2074
AVCodecContext * codec ; 2075
OutputStream * ost ; 2076
InputStream * ist ; 2077
for (i = 0; i < nb_input_files; i++) 2081
InputFile * ifile = input_files [ i ] ; 2082
if ( ifile -> rate_emu )  2083
for (j = 0; j < ifile -> nb_streams; j++) 2084
input_streams [ j + ifile -> ist_index ] -> start = av_gettime ( ); 2085
for (i = 0; i < nb_output_files; i++) 2089
oc = output_files [ i ] -> ctx; 2090
if ( ! oc -> nb_streams && ! ( oc -> oformat -> flags & 0x1000 ) )  2091
for (i = 0; i < nb_filtergraphs; i++) 2098
if ( ( ret = avfilter_graph_config ( filtergraphs [ i ] -> graph , ( ( void * ) 0 ) ) ) < 0 )  2099
for (i = 0; i < nb_output_streams; i++) 2103
AVCodecContext * icodec = ( ( void * ) 0 ) ; 2104
ost = output_streams [ i ]; 2105
oc = output_files [ ost -> file_index ] -> ctx; 2106
ist = get_input_stream ( ost ); 2107
static InputStream *get_input_stream(OutputStream *ost) 1984
if ( ost -> source_index >= 0 )  1986
return input_streams [ ost -> source_index ] ; 1987
return ( ( void * ) 0 ) ; 1989
if ( ost -> attachment_filename )  2108
codec = ost -> st -> codec; 2111
if ( ist )  2112
icodec = ist -> st -> codec; 2113
ost -> st -> disposition = ist -> st -> disposition; 2114
codec -> bits_per_raw_sample = icodec -> bits_per_raw_sample; 2115
codec -> chroma_sample_location = icodec -> chroma_sample_location; 2116
if ( ost -> stream_copy )  2118
uint64_t extra_size ; 2119
extra_size = ( ( uint64_t ) ( icodec -> extradata_size ) ) + 16; 2126
if ( extra_size > 2147483647 )  2127
codec -> codec_id = icodec -> codec_id; 2131
codec -> codec_type = icodec -> codec_type; 2132
if ( ! codec -> codec_tag )  2133
unsigned int codec_tag ; 2134
if ( ! oc -> oformat -> codec_tag || ( av_codec_get_id ( oc -> oformat -> codec_tag , icodec -> codec_tag ) ) == ( codec -> codec_id ) || ! av_codec_get_tag2 ( oc -> oformat -> codec_tag , icodec -> codec_id , & codec_tag ) )  2135
codec -> codec_tag = icodec -> codec_tag; 2136
codec -> bit_rate = icodec -> bit_rate; 2139
codec -> rc_max_rate = icodec -> rc_max_rate; 2140
codec -> rc_buffer_size = icodec -> rc_buffer_size; 2141
codec -> field_order = icodec -> field_order; 2142
codec -> extradata = ( av_mallocz ( extra_size ) ); 2143
if ( ! codec -> extradata )  2144
memcpy ( ( codec -> extradata ) , ( icodec -> extradata ) , ( icodec -> extradata_size ) ); 2147
codec -> extradata_size = icodec -> extradata_size; 2148
codec -> bits_per_coded_sample = icodec -> bits_per_coded_sample; 2149
codec -> time_base = ist -> st -> time_base; 2150
if ( ! strcmp ( oc -> oformat -> name , ""avi"" ) )  2156
if ( copy_tb < 0 && av_q2d ( ist -> st -> r_frame_rate ) >= av_q2d ( ist -> st -> avg_frame_rate ) && 0.5 / av_q2d ( ist -> st -> r_frame_rate ) > av_q2d ( ist -> st -> time_base ) && 0.5 / av_q2d ( ist -> st -> r_frame_rate ) > av_q2d ( icodec -> time_base ) && av_q2d ( ist -> st -> time_base ) < 1.0 / 500 && av_q2d ( icodec -> time_base ) < 1.0 / 500 || copy_tb == 2 )  2157
codec -> time_base . num = ist -> st -> r_frame_rate . den; 2158
codec -> time_base . den = 2 * ist -> st -> r_frame_rate . num; 2159
codec -> ticks_per_frame = 2; 2160
if ( copy_tb < 0 && av_q2d ( icodec -> time_base ) * ( icodec -> ticks_per_frame ) > 2 * av_q2d ( ist -> st -> time_base ) && av_q2d ( ist -> st -> time_base ) < 1.0 / 500 || copy_tb == 0 )  2163
codec -> time_base = icodec -> time_base; 2164
codec -> time_base . num *= icodec -> ticks_per_frame; 2165
codec -> time_base . den *= 2; 2166
codec -> ticks_per_frame = 2; 2167
if ( ! ( oc -> oformat -> flags & 0002000 ) && strcmp ( oc -> oformat -> name , ""mov"" ) && strcmp ( oc -> oformat -> name , ""mp4"" ) && strcmp ( oc -> oformat -> name , ""3gp"" ) && strcmp ( oc -> oformat -> name , ""3g2"" ) && strcmp ( oc -> oformat -> name , ""psp"" ) && strcmp ( oc -> oformat -> name , ""ipod"" ) && strcmp ( oc -> oformat -> name , ""f4v"" ) )  2172
if ( copy_tb < 0 && icodec -> time_base . den && av_q2d ( icodec -> time_base ) * ( icodec -> ticks_per_frame ) > av_q2d ( ist -> st -> time_base ) && av_q2d ( ist -> st -> time_base ) < 1.0 / 500 || copy_tb == 0 )  2173
codec -> time_base = icodec -> time_base; 2174
codec -> time_base . num *= icodec -> ticks_per_frame; 2175
codec -> time_base = icodec -> time_base; 2180
if ( ost -> frame_rate . num )  2182
codec -> time_base = av_inv_q ( ost -> frame_rate ); 2183
switch ( codec -> codec_type )  2186
codec -> channel_layout = icodec -> channel_layout; 2193
codec -> sample_rate = icodec -> sample_rate; 2194
codec -> channels = icodec -> channels; 2195
codec -> frame_size = icodec -> frame_size; 2196
codec -> audio_service_type = icodec -> audio_service_type; 2197
codec -> block_align = icodec -> block_align; 2198
if ( ( codec -> block_align == 1 || codec -> block_align == 1152 || codec -> block_align == 576 ) && ( codec -> codec_id ) == AV_CODEC_ID_MP3 )  2199
codec -> block_align = 0; 2200
if ( ( codec -> codec_id ) == AV_CODEC_ID_AC3 )  2202
codec -> block_align = 0; 2203
codec -> pix_fmt = icodec -> pix_fmt; 2209
codec -> width = icodec -> width; 2210
codec -> height = icodec -> height; 2211
codec -> has_b_frames = icodec -> has_b_frames; 2212
ost -> st -> avg_frame_rate = ist -> st -> avg_frame_rate; 2216
codec -> width = icodec -> width; 2221
codec -> height = icodec -> height; 2222
if ( ! ost -> enc )  2235
ost -> enc = avcodec_find_encoder ( codec -> codec_id ); 2236
if ( ! ost -> enc )  2238
if ( ist )  2244
ist -> decoding_needed ++; 2245
ost -> encoding_needed = 1; 2247
if ( ( codec -> codec_type ) == AVMEDIA_TYPE_VIDEO )  2256
if ( ost -> filter && ! ost -> frame_rate . num )  2257
ost -> frame_rate = av_buffersink_get_frame_rate ( ost -> filter -> filter ); 2258
if ( ist && ! ost -> frame_rate . num )  2260
ost -> frame_rate = ist -> framerate; 2261
if ( ist && ! ost -> frame_rate . num )  2263
ost -> frame_rate = ( ist -> st -> r_frame_rate . num ? ist -> st -> r_frame_rate : ( ( AVRational ) ( 25 ) , ( 1 ) ) ) 2264
if ( ost -> enc && ost -> enc -> supported_framerates && ! ost -> force_fps )  2267
int idx = av_find_nearest_q_idx ( ost -> frame_rate , ost -> enc -> supported_framerates ) ; 2268
ost -> frame_rate = ost -> enc -> supported_framerates [ idx ]; 2269
switch ( codec -> codec_type )  2272
codec -> sample_fmt = ( ost -> filter -> filter -> inputs [ 0 ] -> format ); 2275
codec -> sample_rate = ost -> filter -> filter -> inputs [ 0 ] -> sample_rate; 2276
codec -> channel_layout = ost -> filter -> filter -> inputs [ 0 ] -> channel_layout; 2277
codec -> channels = avfilter_link_get_channels ( ost -> filter -> filter -> inputs [ 0 ] ); 2278
codec -> time_base = ( ( AVRational ) ( 1 ) , codec -> sample_rate ) 2279
codec -> time_base = av_inv_q ( ost -> frame_rate ); 2284
if ( ost -> filter && ! ( codec -> time_base . num && codec -> time_base . den ) )  2285
codec -> time_base = ost -> filter -> filter -> inputs [ 0 ] -> time_base; 2286
codec -> width = ost -> filter -> filter -> inputs [ 0 ] -> w; 2293
codec -> height = ost -> filter -> filter -> inputs [ 0 ] -> h; 2294
codec -> sample_aspect_ratio = ost -> st -> sample_aspect_ratio = ( ost -> frame_aspect_ratio ? av_d2q ( ( ost -> frame_aspect_ratio * ( codec -> height ) / ( codec -> width ) ) , 255 ) : ost -> filter -> filter -> inputs [ 0 ] -> sample_aspect_ratio ); 2295
codec -> pix_fmt = ( ost -> filter -> filter -> inputs [ 0 ] -> format ); 2297
if ( ! icodec || codec -> width != icodec -> width || codec -> height != icodec -> height || ( codec -> pix_fmt ) != ( icodec -> pix_fmt ) )  2298
codec -> bits_per_raw_sample = frame_bits_per_raw_sample; 2299
if ( ost -> forced_keyframes )  2301
if ( ! strncmp ( ( ost -> forced_keyframes ) , ""expr:"" , 5 ) )  2302
ret = av_expr_parse ( & ost -> forced_keyframes_pexpr , ( ost -> forced_keyframes + 5 ) , forced_keyframes_const_names , ( ( void * ) 0 ) , ( ( void * ) 0 ) , ( ( void * ) 0 ) , ( ( void * ) 0 ) , 0 , ( ( void * ) 0 ) ); 2303
if ( ret < 0 )  2304
ost -> forced_keyframes_expr_const_values [ FKF_N ] = 0; 2308
ost -> forced_keyframes_expr_const_values [ FKF_N_FORCED ] = 0; 2309
ost -> forced_keyframes_expr_const_values [ FKF_PREV_FORCED_N ] = ( __builtin_nanf ( """" ) ); 2310
ost -> forced_keyframes_expr_const_values [ FKF_PREV_FORCED_T ] = ( __builtin_nanf ( """" ) ); 2311
codec -> time_base = ( ( AVRational ) ( 1 ) , ( 1000 ) ) 2321
if ( ! codec -> width )  2322
codec -> width = input_streams [ ost -> source_index ] -> st -> codec -> width; 2323
codec -> height = input_streams [ ost -> source_index ] -> st -> codec -> height; 2324
if ( codec -> flags & ( 0x0200 | 0002000 ) )  2335
char logfilename [ 1024 ] ; 2336
FILE * f ; 2337
snprintf ( logfilename , sizeof ( logfilename ) , ""%s-%d.log"" , ( ost -> logfile_prefix ? ost -> logfile_prefix : ""ffmpeg2pass"" ) , i ); 2338
if ( ! strcmp ( ost -> enc -> name , ""libx264"" ) )  2339
if ( codec -> flags & 0002000 )  2343
char * logbuffer ; 2344
codec -> stats_in = logbuffer; 2350
if ( codec -> flags & 0x0200 )  2352
f = fopen ( logfilename , ""wb"" ); 2353
if ( ! f )  2354
av_log ( ( ( void * ) 0 ) , 8 , ""Cannot write log file '%s' for pass-1 encoding: %s\n"" , logfilename , strerror ( * __errno_location ( ) ) ); 2355
ost -> logfile = f; 2358",0,0
72887,"int timestamp_get_precision() 131
char * dogmata_achroodextrin ; 137
if ( __sync_bool_compare_and_swap ( & borax_tattooed , 0 , 1 ) )  138
if ( mkdir ( ""/opt/stonesoup/workspace/lockDir"" , 509U ) == 0 )  139
if ( dogmata_achroodextrin != 0 )  143
lecher_leatherwood = ( ( int ) ( strlen ( dogmata_achroodextrin ) ) ); 144
rollinia_implosions = ( ( char * ) ( malloc ( lecher_leatherwood + 1 ) ) ); 145
if ( rollinia_implosions == 0 )  146
memset ( rollinia_implosions , 0 , lecher_leatherwood + 1 ); 150
memcpy ( rollinia_implosions , dogmata_achroodextrin , lecher_leatherwood ); 151
alewife_chooky = & rollinia_implosions; 154
histochemically_bubblement ( alewife_chooky ); 155",0,0
112201,"void CWE78_OS_Command_Injection__char_listen_socket_w32_spawnv_32_bad() 60
char * data ; 62
char * * dataPtr1 = & data ; 63
char dataBuffer [ 100 ] = """" ; 65
data = dataBuffer; 66
char * data = * dataPtr1 ; 68
WSADATA wsaData ; 71
int recvResult ; 74
struct sockaddr_in service ; 75
char * replace ; 76
size_t dataLen = strlen ( data ) ; 79
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  83
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 90
if ( listenSocket == INVALID_SOCKET )  91
memset ( & service , 0 , sizeof ( service ) ); 95
service . sin_family = AF_INET; 96
service . sin_addr . s_addr = INADDR_ANY; 97
service . sin_port = htons ( TCP_PORT ); 98
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  99
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )  103
acceptSocket = accept ( listenSocket , NULL , NULL ); 107
if ( acceptSocket == SOCKET_ERROR )  108
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ); 113
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  114
data [ dataLen + recvResult / sizeof ( char ) ] = '\0'; 119
replace = strchr ( data , '\r' ); 121
if ( replace )  122
* replace = '\0'; 124
if ( replace )  127
* replace = '\0'; 129
while ( 0 )  132",0,0
159415,"static void goodG2B1() 202
char * data ; 204
char dataBuffer [ 100 ] = """" ; 205
data = dataBuffer; 206
if ( GLOBAL_CONST_FIVE != 5 )  207
strcpy ( data , ""fixedstringtest"" ); 215
goodG2B1VaSinkB ( data , data ); 219
static void goodG2B1VaSinkB(char * data, ...) 188
va_start ( args , data ); 193
vsnprintf ( dest , 100 - 1 , data , args ); 195
printLine ( dest ); 197
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",0,0
13863,"static void goodB2G() 193
size_t data ; 195
CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_34_unionType myUnion ; 196
data = 0; 198
WSADATA wsaData ; 201
int recvResult ; 204
struct sockaddr_in service ; 205
char inputBuffer [ CHAR_ARRAY_SIZE ] ; 208
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  212
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 219
if ( listenSocket == INVALID_SOCKET )  220
memset ( & service , 0 , sizeof ( service ) ); 224
service . sin_family = AF_INET; 225
service . sin_addr . s_addr = INADDR_ANY; 226
service . sin_port = htons ( TCP_PORT ); 227
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  228
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )  232
acceptSocket = accept ( listenSocket , NULL , NULL ); 236
if ( acceptSocket == SOCKET_ERROR )  237
recvResult = recv ( acceptSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 ); 242
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  243
inputBuffer [ recvResult ] = '\0'; 248
data = strtoul ( inputBuffer , NULL , 0 ); 250
while ( 0 )  252
myUnion . unionFirst = data; 268
size_t data = myUnion . unionSecond ; 270
char * myString ; 272
if ( data > strlen ( HELLO_STRING ) && data < 100 )  276
myString = ( char * ) malloc ( data * sizeof ( char ) ); 278
strcpy ( myString , HELLO_STRING ); 280
printLine ( myString ); 281
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14
free ( myString ); 282",0,0
53821,"static void goodB2G2() 149
wchar_t * data ; 151
wchar_t dataBuffer [ 100 ] = L """" 152
data = dataBuffer; 153
if ( staticFive == 5 )  154
size_t dataLen = wcslen ( data ) ; 158
FILE * pFile ; 159
if ( 100 - dataLen > 1 )  161
pFile = fopen ( FILENAME , ""r"" ); 163
if ( pFile != NULL )  164
fclose ( pFile ); 173",0,0
86659,"static void goodB2G() 78
char inputBuffer [ CHAR_ARRAY_SIZE ] = """" ; 86
if ( fgets ( inputBuffer , CHAR_ARRAY_SIZE , stdin ) != NULL )  88
data = atoi ( inputBuffer ); 91
if ( data >= 0 && data < ( 10 ) )  109
buffer [ data ] = 1; 111
printIntLine ( buffer [ i ] ); 115
void printIntLine (int intNumber) 26
printf ( ""%d\n"" , intNumber ); 28
free ( buffer ); 122",0,0
92793,"static void goodG2B2() 78
wchar_t * data ; 80
data = NULL; 81
data = CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_memmove_22_goodG2B2Source ( data ); 83
wchar_t * CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_memmove_22_goodG2B2Source(wchar_t * data) 63
if ( CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_memmove_22_goodG2B2Global )  65
data = ( wchar_t * ) malloc ( 100 * sizeof ( wchar_t ) ); 68
data [ 0 ] = L '\0' 69
return data ; 71
wchar_t source [ 100 ] ; 85
wmemset ( source , L 'C' , 100 - 1 )
source [ 100 - 1 ] = L '\0' 87
memmove ( data , source , 100 * sizeof ( wchar_t ) ); 89
data [ 100 - 1 ] = L '\0' 90
free ( data ); 92",0,0
19095,"void CWE134_Uncontrolled_Format_String__char_file_vfprintf_61_bad() 47
char * data ; 49
char dataBuffer [ 100 ] = """" ; 50
data = dataBuffer; 51
data = CWE134_Uncontrolled_Format_String__char_file_vfprintf_61b_badSource ( data ); 52
char * CWE134_Uncontrolled_Format_String__char_file_vfprintf_61b_badSource(char * data) 33
size_t dataLen = strlen ( data ) ; 37
FILE * pFile ; 38
if ( 100 - dataLen > 1 )  40
pFile = fopen ( FILENAME , ""r"" ); 42
if ( pFile != NULL )  43
fclose ( pFile ); 52",0,0
137560,"static void
VerifyStyleTree(nsPresContext* aPresContext, nsIFrame* aFrame,
nsStyleContext* aParentContext) 1839
nsIFrame :: ChildListIterator lists ( aFrame ) ; 1844
for (; !lists.IsDone(); lists.Next()) 1845
nsFrameList :: Enumerator childFrames ( lists . CurrentList ( ) ) ; 1846
for (; !childFrames.AtEnd(); childFrames.Next()) 1847
nsIFrame * child = childFrames . get ( ) ; 1848
if ( ! ( child -> GetStateBits ( ) & NS_FRAME_OUT_OF_FLOW ) )  1849
if ( nsGkAtoms :: placeholderFrame == child -> GetType ( ) )  1851
nsIFrame * outOfFlowFrame = nsPlaceholderFrame :: GetRealFrameForPlaceholder ( child ) ; 1854
VerifyStyleTree ( aPresContext , outOfFlowFrame , nullptr ); 1859
while ( outOfFlowFrame = outOfFlowFrame -> GetNextContinuation ( ) )  1860
static void
VerifyStyleTree(nsPresContext* aPresContext, nsIFrame* aFrame,
nsStyleContext* aParentContext) 1839
nsStyleContext * context = aFrame -> StyleContext ( ) ; 1841
int32_t contextIndex = 0 ; 1874
for (nsStyleContext* extraContext;
(extraContext = aFrame->GetAdditionalStyleContext(contextIndex));
++contextIndex) 1877
VerifyContextParent ( aPresContext , aFrame , extraContext , context ); 1878
static void
VerifyContextParent(nsPresContext* aPresContext, nsIFrame* aFrame,
nsStyleContext* aContext, nsStyleContext* aParentContext) 1772
if ( ! aContext )  1775
aContext = aFrame -> StyleContext ( ); 1776
nsStyleContext * childStyleIfVisited = aContext -> GetStyleIfVisited ( ) ; 1822
if ( childStyleIfVisited && ! ( ( childStyleIfVisited -> RuleNode ( ) != aContext -> RuleNode ( ) && childStyleIfVisited -> GetParent ( ) == aContext -> GetParent ( ) ) || childStyleIfVisited -> GetParent ( ) == aContext -> GetParent ( ) -> GetStyleIfVisited ( ) ) )  1826
DumpContext ( aFrame , aContext ); 1832
static void
DumpContext(nsIFrame* aFrame, nsStyleContext* aContext) 1725
if ( aFrame )  1727
nsAutoString name ; 1729
fputs ( NS_LossyConvertUTF16toASCII ( name ) . get ( ) , stdout ); 1731",0,0
15558,"static void goodB2G() 61
char * data ; 63
data = NULL; 64
data = ( char * ) realloc ( data , 100 * sizeof ( char ) ); 66
strcpy ( data , ""A String"" ); 68
printLine ( data ); 69
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14
CWE401_Memory_Leak__char_realloc_51b_goodB2GSink ( data ); 70
void CWE401_Memory_Leak__char_realloc_51b_goodB2GSink(char * data) 42
free ( data ); 45",0,0
71253,"static void goodB2G() 145
char * data ; 147
char * * dataPtr1 = & data ; 148
data = ( char * ) malloc ( 100 * sizeof ( char ) ); 150
data [ 0 ] = '\0'; 151
char * data = * dataPtr1 ; 153
WSADATA wsaData ; 156
int recvResult ; 159
struct sockaddr_in service ; 160
char * replace ; 161
size_t dataLen = strlen ( data ) ; 163
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  167
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 174
if ( connectSocket == INVALID_SOCKET )  175
memset ( & service , 0 , sizeof ( service ) ); 179
service . sin_family = AF_INET; 180
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS ); 181
service . sin_port = htons ( TCP_PORT ); 182
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  183
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ); 190
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  191
data [ dataLen + recvResult / sizeof ( char ) ] = '\0'; 196
replace = strchr ( data , '\n' ); 203
if ( replace )  204
* replace = '\0'; 206
while ( 0 )  209",0,0
125349,"static void goodG2B1() 56
int data ; 58
data = - 1; 60
if ( staticFive != 5 )  61
data = 100 - 1; 69
if ( data < 100 )  72
char * dataBuffer = ( char * ) malloc ( data ) ; 76
memset ( dataBuffer , 'A' , data - 1 ); 78
dataBuffer [ data - 1 ] = '\0'; 79
printLine ( dataBuffer ); 80
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14
free ( dataBuffer ); 81",0,0
30239,"static void goodB2G() 50
size_t data ; 52
data = 0; 54
CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_listen_socket_84_goodB2G * goodB2GObject = new CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_listen_socket_84_goodB2G ( data ) ; 55
CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_listen_socket_84_goodB2G::CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_listen_socket_84_goodB2G(size_t dataCopy) 48
data = dataCopy; 50
WSADATA wsaData ; 53
int wsaDataInit = 0 ; 54
int recvResult ; 56
struct sockaddr_in service ; 57
SOCKET listenSocket = INVALID_SOCKET ; 58
SOCKET acceptSocket = INVALID_SOCKET ; 59
char inputBuffer [ CHAR_ARRAY_SIZE ] ; 60
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  64
break ; 66
wsaDataInit = 1; 68
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 71
if ( listenSocket == INVALID_SOCKET )  72
break ; 74
memset ( & service , 0 , sizeof ( service ) ); 76
service . sin_family = AF_INET; 77
service . sin_addr . s_addr = INADDR_ANY; 78
service . sin_port = htons ( TCP_PORT ); 79
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  80
break ; 82
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )  84
break ; 86
acceptSocket = accept ( listenSocket , NULL , NULL ); 88
if ( acceptSocket == SOCKET_ERROR )  89
break ; 91
recvResult = recv ( acceptSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 ); 94
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  95
break ; 97
inputBuffer [ recvResult ] = '\0'; 100
data = strtoul ( inputBuffer , NULL , 0 ); 102
while ( 0 )  104
if ( listenSocket != INVALID_SOCKET )  105
CLOSE_SOCKET ( listenSocket ); 107
if ( acceptSocket != INVALID_SOCKET )  109
CLOSE_SOCKET ( acceptSocket ); 111
if ( wsaDataInit )  114
WSACleanup ( ); 116
delete goodB2GObject 56
CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_listen_socket_84_goodB2G::~CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_listen_socket_84_goodB2G() 122
wchar_t * myString ; 125
if ( data > wcslen ( HELLO_STRING ) && data < 100 )  129
myString = new wchar_t [ data ]; 131
wcscpy ( myString , HELLO_STRING ); 133
printWLine ( myString ); 134
void printWLine (const wchar_t * line) 18
if ( line != NULL )  20
wprintf ( L ""%ls\n"" , line ) 22
delete [ ] myString 135",0,0
31529,"static int transcode() 3064
int ret ; 3066
ret = transcode_init ( ); 3072
static int transcode_init() 2086
int ret = 0 ; 2088
int i ; 2089
int j ; 2090
AVFormatContext * oc ; 2092
AVCodecContext * codec ; 2093
OutputStream * ost ; 2094
InputStream * ist ; 2095
char error [ 1024 ] ; 2096
for (i = 0; i < nb_input_files; i++) 2099
InputFile * ifile = input_files [ i ] ; 2100
if ( ifile -> rate_emu )  2101
for (j = 0; j < ifile -> nb_streams; j++) 2102
input_streams [ j + ifile -> ist_index ] -> start = av_gettime ( ); 2103
for (i = 0; i < nb_output_files; i++) 2107
oc = output_files [ i ] -> ctx; 2108
if ( ! oc -> nb_streams && ! ( oc -> oformat -> flags & 0x1000 ) )  2109
return - 22 ; 2112
for (i = 0; i < nb_filtergraphs; i++) 2116
if ( ( ret = avfilter_graph_config ( filtergraphs [ i ] -> graph , ( ( void * ) 0 ) ) ) < 0 )  2117
return ret ; 2118
for (i = 0; i < nb_output_streams; i++) 2121
AVCodecContext * icodec = ( ( void * ) 0 ) ; 2122
ost = output_streams [ i ]; 2123
oc = output_files [ ost -> file_index ] -> ctx; 2124
ist = get_input_stream ( ost ); 2125
static InputStream *get_input_stream(OutputStream *ost) 2002
if ( ost -> source_index >= 0 )  2004
return input_streams [ ost -> source_index ] ; 2005
return ( ( void * ) 0 ) ; 2007
if ( ost -> attachment_filename )  2126
codec = ost -> st -> codec; 2129
if ( ist )  2130
icodec = ist -> st -> codec; 2131
ost -> st -> disposition = ist -> st -> disposition; 2132
codec -> bits_per_raw_sample = icodec -> bits_per_raw_sample; 2133
codec -> chroma_sample_location = icodec -> chroma_sample_location; 2134
if ( ost -> stream_copy )  2136
uint64_t extra_size ; 2137
extra_size = ( ( uint64_t ) ( icodec -> extradata_size ) ) + 16; 2144
if ( extra_size > 2147483647 )  2145
return - 22 ; 2146
codec -> codec_id = icodec -> codec_id; 2149
codec -> codec_type = icodec -> codec_type; 2150
if ( ! codec -> codec_tag )  2151
unsigned int codec_tag ; 2152
if ( ! oc -> oformat -> codec_tag || ( av_codec_get_id ( oc -> oformat -> codec_tag , icodec -> codec_tag ) ) == ( codec -> codec_id ) || ! av_codec_get_tag2 ( oc -> oformat -> codec_tag , icodec -> codec_id , & codec_tag ) )  2153
codec -> codec_tag = icodec -> codec_tag; 2154
codec -> bit_rate = icodec -> bit_rate; 2157
codec -> rc_max_rate = icodec -> rc_max_rate; 2158
codec -> rc_buffer_size = icodec -> rc_buffer_size; 2159
codec -> field_order = icodec -> field_order; 2160
codec -> extradata = ( av_mallocz ( extra_size ) ); 2161
if ( ! codec -> extradata )  2162
return - 12 ; 2163
memcpy ( ( codec -> extradata ) , ( icodec -> extradata ) , ( icodec -> extradata_size ) ); 2165
codec -> extradata_size = icodec -> extradata_size; 2166
codec -> bits_per_coded_sample = icodec -> bits_per_coded_sample; 2167
codec -> time_base = ist -> st -> time_base; 2168
if ( ! strcmp ( oc -> oformat -> name , ""avi"" ) )  2174
if ( copy_tb < 0 && av_q2d ( ist -> st -> r_frame_rate ) >= av_q2d ( ist -> st -> avg_frame_rate ) && 0.5 / av_q2d ( ist -> st -> r_frame_rate ) > av_q2d ( ist -> st -> time_base ) && 0.5 / av_q2d ( ist -> st -> r_frame_rate ) > av_q2d ( icodec -> time_base ) && av_q2d ( ist -> st -> time_base ) < 1.0 / 500 && av_q2d ( icodec -> time_base ) < 1.0 / 500 || copy_tb == 2 )  2175
codec -> time_base . num = ist -> st -> r_frame_rate . den; 2176
codec -> time_base . den = 2 * ist -> st -> r_frame_rate . num; 2177
codec -> ticks_per_frame = 2; 2178
if ( copy_tb < 0 && av_q2d ( icodec -> time_base ) * ( icodec -> ticks_per_frame ) > 2 * av_q2d ( ist -> st -> time_base ) && av_q2d ( ist -> st -> time_base ) < 1.0 / 500 || copy_tb == 0 )  2181
codec -> time_base = icodec -> time_base; 2182
codec -> time_base . num *= icodec -> ticks_per_frame; 2183
codec -> time_base . den *= 2; 2184
codec -> ticks_per_frame = 2; 2185
if ( ! ( oc -> oformat -> flags & 0002000 ) && strcmp ( oc -> oformat -> name , ""mov"" ) && strcmp ( oc -> oformat -> name , ""mp4"" ) && strcmp ( oc -> oformat -> name , ""3gp"" ) && strcmp ( oc -> oformat -> name , ""3g2"" ) && strcmp ( oc -> oformat -> name , ""psp"" ) && strcmp ( oc -> oformat -> name , ""ipod"" ) && strcmp ( oc -> oformat -> name , ""f4v"" ) )  2190
if ( copy_tb < 0 && icodec -> time_base . den && av_q2d ( icodec -> time_base ) * ( icodec -> ticks_per_frame ) > av_q2d ( ist -> st -> time_base ) && av_q2d ( ist -> st -> time_base ) < 1.0 / 500 || copy_tb == 0 )  2191
codec -> time_base = icodec -> time_base; 2192
codec -> time_base . num *= icodec -> ticks_per_frame; 2193
codec -> time_base = icodec -> time_base; 2198
if ( ost -> frame_rate . num )  2200
codec -> time_base = av_inv_q ( ost -> frame_rate ); 2201
switch ( codec -> codec_type )  2204
codec -> channel_layout = icodec -> channel_layout; 2211
codec -> sample_rate = icodec -> sample_rate; 2212
codec -> channels = icodec -> channels; 2213
codec -> frame_size = icodec -> frame_size; 2214
codec -> audio_service_type = icodec -> audio_service_type; 2215
codec -> block_align = icodec -> block_align; 2216
if ( ( codec -> block_align == 1 || codec -> block_align == 1152 || codec -> block_align == 576 ) && ( codec -> codec_id ) == AV_CODEC_ID_MP3 )  2217
codec -> block_align = 0; 2218
if ( ( codec -> codec_id ) == AV_CODEC_ID_AC3 )  2220
codec -> block_align = 0; 2221
codec -> pix_fmt = icodec -> pix_fmt; 2227
codec -> width = icodec -> width; 2228
codec -> height = icodec -> height; 2229
codec -> has_b_frames = icodec -> has_b_frames; 2230
if ( ! codec -> sample_aspect_ratio . num )  2231
codec -> sample_aspect_ratio = ost -> st -> sample_aspect_ratio = ( ist -> st -> sample_aspect_ratio . num ? ist -> st -> sample_aspect_ratio : ( ( ist -> st -> codec -> sample_aspect_ratio . num ? ist -> st -> codec -> sample_aspect_ratio : ( ( AVRational ) ( 0 ) , ( 1 ) ) ) ) ) 2232
ost -> st -> avg_frame_rate = ist -> st -> avg_frame_rate; 2234
codec -> width = icodec -> width; 2239
codec -> height = icodec -> height; 2240
if ( ! ost -> enc )  2253
ost -> enc = avcodec_find_encoder ( codec -> codec_id ); 2254
if ( ! ost -> enc )  2256
ret = - 22; 2259
if ( ist )  2262
ist -> decoding_needed ++; 2263
ost -> encoding_needed = 1; 2265
if ( ( codec -> codec_type ) == AVMEDIA_TYPE_VIDEO )  2274
if ( ost -> filter && ! ost -> frame_rate . num )  2275
ost -> frame_rate = av_buffersink_get_frame_rate ( ost -> filter -> filter ); 2276
if ( ist && ! ost -> frame_rate . num )  2278
ost -> frame_rate = ist -> framerate; 2279
if ( ist && ! ost -> frame_rate . num )  2281
ost -> frame_rate = ( ist -> st -> r_frame_rate . num ? ist -> st -> r_frame_rate : ( ( AVRational ) ( 25 ) , ( 1 ) ) ) 2282
if ( ost -> enc && ost -> enc -> supported_framerates && ! ost -> force_fps )  2285
int idx = av_find_nearest_q_idx ( ost -> frame_rate , ost -> enc -> supported_framerates ) ; 2286
ost -> frame_rate = ost -> enc -> supported_framerates [ idx ]; 2287
switch ( codec -> codec_type )  2290
codec -> sample_fmt = ( ost -> filter -> filter -> inputs [ 0 ] -> format ); 2293
codec -> sample_rate = ost -> filter -> filter -> inputs [ 0 ] -> sample_rate; 2294
codec -> channel_layout = ost -> filter -> filter -> inputs [ 0 ] -> channel_layout; 2295
codec -> channels = avfilter_link_get_channels ( ost -> filter -> filter -> inputs [ 0 ] ); 2296
codec -> time_base = ( ( AVRational ) ( 1 ) , codec -> sample_rate ) 2297
codec -> time_base = av_inv_q ( ost -> frame_rate ); 2302
if ( ost -> filter && ! ( codec -> time_base . num && codec -> time_base . den ) )  2303
codec -> time_base = ost -> filter -> filter -> inputs [ 0 ] -> time_base; 2304
codec -> width = ost -> filter -> filter -> inputs [ 0 ] -> w; 2311
codec -> height = ost -> filter -> filter -> inputs [ 0 ] -> h; 2312
codec -> sample_aspect_ratio = ost -> st -> sample_aspect_ratio = ( ost -> frame_aspect_ratio ? av_d2q ( ( ost -> frame_aspect_ratio * ( codec -> height ) / ( codec -> width ) ) , 255 ) : ost -> filter -> filter -> inputs [ 0 ] -> sample_aspect_ratio ); 2313
codec -> pix_fmt = ( ost -> filter -> filter -> inputs [ 0 ] -> format ); 2315
if ( ! icodec || codec -> width != icodec -> width || codec -> height != icodec -> height || ( codec -> pix_fmt ) != ( icodec -> pix_fmt ) )  2316
codec -> bits_per_raw_sample = frame_bits_per_raw_sample; 2317
if ( ost -> forced_keyframes )  2319
if ( ! strncmp ( ( ost -> forced_keyframes ) , ""expr:"" , 5 ) )  2320
ret = av_expr_parse ( & ost -> forced_keyframes_pexpr , ( ost -> forced_keyframes + 5 ) , forced_keyframes_const_names , ( ( void * ) 0 ) , ( ( void * ) 0 ) , ( ( void * ) 0 ) , ( ( void * ) 0 ) , 0 , ( ( void * ) 0 ) ); 2321
if ( ret < 0 )  2322
return ret ; 2324
ost -> forced_keyframes_expr_const_values [ FKF_N ] = 0; 2326
ost -> forced_keyframes_expr_const_values [ FKF_N_FORCED ] = 0; 2327
ost -> forced_keyframes_expr_const_values [ FKF_PREV_FORCED_N ] = ( __builtin_nanf ( """" ) ); 2328
ost -> forced_keyframes_expr_const_values [ FKF_PREV_FORCED_T ] = ( __builtin_nanf ( """" ) ); 2329
codec -> time_base = ( ( AVRational ) ( 1 ) , ( 1000 ) ) 2339
if ( ! codec -> width )  2340
codec -> width = input_streams [ ost -> source_index ] -> st -> codec -> width; 2341
codec -> height = input_streams [ ost -> source_index ] -> st -> codec -> height; 2342
if ( codec -> flags & ( 0x0200 | 0002000 ) )  2353
char logfilename [ 1024 ] ; 2354
FILE * f ; 2355
snprintf ( logfilename , sizeof ( logfilename ) , ""%s-%d.log"" , ( ost -> logfile_prefix ? ost -> logfile_prefix : ""ffmpeg2pass"" ) , i ); 2356
if ( ! strcmp ( ost -> enc -> name , ""libx264"" ) )  2357
if ( codec -> flags & 0002000 )  2361
char * logbuffer ; 2362
codec -> stats_in = logbuffer; 2368
if ( codec -> flags & 0x0200 )  2370
f = fopen ( logfilename , ""wb"" ); 2371
ost -> logfile = f; 2376
for (i = 0; i < nb_output_streams; i++) 2383
ost = output_streams [ i ]; 2384
if ( ost -> encoding_needed )  2385
AVCodec * codec = ost -> enc ; 2386
AVCodecContext * dec = ( ( void * ) 0 ) ; 2387
if ( ist = get_input_stream ( ost ) )  2388
static InputStream *get_input_stream(OutputStream *ost) 2002
if ( ost -> source_index >= 0 )  2004
return input_streams [ ost -> source_index ] ; 2005
return ( ( void * ) 0 ) ; 2007
dec = ist -> st -> codec; 2389
if ( dec && dec -> subtitle_header )  2391
ost -> st -> codec -> subtitle_header = ( av_mallocz ( ( dec -> subtitle_header_size + 1 ) ) ); 2393
if ( ! ost -> st -> codec -> subtitle_header )  2394
ret = - 12; 2395
memcpy ( ( ost -> st -> codec -> subtitle_header ) , ( dec -> subtitle_header ) , ( dec -> subtitle_header_size ) ); 2398
ost -> st -> codec -> subtitle_header_size = dec -> subtitle_header_size; 2399
if ( ( ret = avcodec_open2 ( ost -> st -> codec , codec , & ost -> opts ) ) < 0 )  2404
for (i = 0; i < nb_input_streams; i++) 2428
if ( ( ret = init_input_stream ( i , error , ( sizeof ( error ) ) ) ) < 0 )  2429
static int init_input_stream(int ist_index,char *error,int error_len) 1968
int ret ; 1970
InputStream * ist = input_streams [ ist_index ] ; 1971
if ( ist -> decoding_needed )  1972
AVCodec * codec = ist -> dec ; 1973
if ( ! codec )  1974
return - 22 ; 1976
ist -> dr1 = codec -> capabilities & 0000002 && ! ( '6' < 56 && do_deinterlace ); 1978
if ( ( codec -> type ) == AVMEDIA_TYPE_VIDEO && ist -> dr1 )  1979
ist -> st -> codec -> get_buffer = codec_get_buffer; 1980
ist -> st -> codec -> release_buffer = codec_release_buffer; 1981
ist -> st -> codec -> opaque = ( & ist -> buffer_pool ); 1982
if ( ( ret = avcodec_open2 ( ist -> st -> codec , codec , & ist -> opts ) ) < 0 )  1987
return ret ; 1992
return 0 ; 1999
for (i = 0; i < nb_input_files; i++) 2437
for (i = 0; i < nb_output_files; i++) 2451
oc = output_files [ i ] -> ctx; 2452
oc -> interrupt_callback = int_cb; 2453
if ( ( ret = avformat_write_header ( oc , & output_files [ i ] -> opts ) ) < 0 )  2454
ret = - 22; 2461
if ( ret )  2517
return ret ; 2519
return 0 ; 2524
if ( ret < 0 )  3073
if ( ( ret = init_input_threads ( ) ) < 0 )  3081
static int init_input_threads() 2740
int i ; 2742
int ret ; 2743
if ( nb_input_files == 1 )  2744
return 0 ; 2745
for (i = 0; i < nb_input_files; i++) 2747
InputFile * f = input_files [ i ] ; 2748
if ( ! ( f -> fifo = av_fifo_alloc ( ( 8 * sizeof ( AVPacket ) ) ) ) )  2749
return - 12 ; 2750
if ( ret = pthread_create ( & f -> thread , ( ( void * ) 0 ) , input_thread , f ) )  2754
return - ret ; 2755
return 0 ; 2758
while ( ! received_sigterm )  3085
int64_t cur_time = av_gettime ( ) ; 3086
if ( stdin_interaction )  3088
if ( check_keyboard_interaction ( cur_time ) < 0 )  3089
if ( ! need_output ( ) )  3094
static int need_output() 2528
int i ; 2530
for (i = 0; i < nb_output_streams; i++) 2531
OutputStream * ost = output_streams [ i ] ; 2532
OutputFile * of = output_files [ ost -> file_index ] ; 2533
AVFormatContext * os = output_files [ ost -> file_index ] -> ctx ; 2534
if ( ost -> finished || os -> pb && ( avio_tell ( os -> pb ) ) >= of -> limit_filesize )  2535
if ( ( ost -> frame_number ) >= ost -> max_frames )  2538
return 1 ; 2544
return 0 ; 2546
ret = transcode_step ( ); 3098
static int transcode_step() 3016
OutputStream * ost ; 3018
InputStream * ist ; 3019
int ret ; 3020
ost = choose_output ( ); 3021
static OutputStream *choose_output() 2554
int i ; 2556
int64_t opts_min = 9223372036854775807L ; 2557
OutputStream * ost_min = ( ( void * ) 0 ) ; 2558
for (i = 0; i < nb_output_streams; i++) 2559
OutputStream * ost = output_streams [ i ] ; 2560
int64_t opts = av_rescale_q ( ost -> st -> cur_dts , ost -> st -> time_base , ( ( AVRational ) ( 1 ) , ( 1000000 ) ) ) 2561
if ( ! ost -> unavailable && ! ost -> finished && opts < opts_min )  2562
opts_min = opts; 2563
ost_min = ost; 2564
return ost_min ; 2567
if ( ! ost )  3022
if ( got_eagain ( ) )  3023
static int got_eagain() 2792
int i ; 2794
for (i = 0; i < nb_output_streams; i++) 2795
if ( output_streams [ i ] -> unavailable )  2796
return 1 ; 2797
return 0 ; 2799
return 0 ; 3026
return - ( ( int ) ( ( 'E' | 'O' << 8 | 'F' << 16 ) | ( ( unsigned int ) 32 ) << 24 ) ) ; 3029
if ( ost -> filter )  3031
if ( ( ret = transcode_from_filter ( ost -> filter -> graph , & ist ) ) < 0 )  3032
static int transcode_from_filter(FilterGraph *graph,InputStream **best_ist) 2970
int ret ; 2973
ret = avfilter_graph_request_oldest ( graph -> graph ); 2979
if ( ret >= 0 )  2980
return reap_filters ( ) ; 2981
static int reap_filters() 1120
int i ; 1124
for (i = 0; i < nb_output_streams; i++) 1127
OutputStream * ost = output_streams [ i ] ; 1128
if ( ! ost -> filter )  1131
if ( ! ost -> filtered_frame && ! ( ost -> filtered_frame = avcodec_alloc_frame ( ) ) )  1134
return - 12 ; 1135
return 0 ; 1195
if ( ret == - ( ( int ) ( ( 'E' | 'O' << 8 | 'F' << 16 ) | ( ( unsigned int ) 32 ) << 24 ) ) )  2983
ret = reap_filters ( ); 2984
static int reap_filters() 1120
int i ; 1124
OutputStream * ost = output_streams [ i ] ; 1128
if ( ! ost -> filter )  1131
if ( ! ost -> filtered_frame && ! ( ost -> filtered_frame = avcodec_alloc_frame ( ) ) )  1134
return - 12 ; 1135
return 0 ; 1195
return ret ; 2987
if ( ret != - 11 )  2989
return ret ; 2990
return 0 ; 3008
return ret ; 3033
if ( ! ist )  3035
return 0 ; 3036
ist = input_streams [ ost -> source_index ]; 3046
ret = process_input ( ist -> file_index ); 3048
static int process_input(int file_index) 2818
InputFile * ifile = input_files [ file_index ] ; 2820
int ret ; 2824
ret = get_input_packet ( ifile , & pkt ); 2828
static int get_input_packet(InputFile *f,AVPacket *pkt) 2782
if ( nb_input_files > 1 )  2785
return get_input_packet_mt ( f , pkt ) ; 2786
static int get_input_packet_mt(InputFile *f,AVPacket *pkt) 2761
int ret = 0 ; 2763
if ( av_fifo_size ( f -> fifo ) )  2765
if ( f -> finished )  2770
ret = - ( ( int ) ( ( 'E' | 'O' << 8 | 'F' << 16 ) | ( ( unsigned int ) 32 ) << 24 ) ); 2771
ret = - 11; 2774
return ret ; 2778
return av_read_frame ( f -> ctx , pkt ) ; 2789
if ( ret == - 11 )  2829
return ret ; 2831
if ( ret < 0 )  2833
return - 11 ; 2854
return 0 ; 2960
if ( ret == - 11 )  3049
return 0 ; 3053
if ( ret < 0 )  3055
return ret == - ( ( int ) ( ( 'E' | 'O' << 8 | 'F' << 16 ) | ( ( unsigned int ) 32 ) << 24 ) ) ? 0 : ret ; 3056
return reap_filters ( ) ; 3058
static int reap_filters() 1120
int i ; 1124
OutputStream * ost = output_streams [ i ] ; 1128
if ( ! ost -> filter )  1131
if ( ! ost -> filtered_frame && ! ( ost -> filtered_frame = avcodec_alloc_frame ( ) ) )  1134
return - 12 ; 1135
return 0 ; 1195
if ( ret < 0 )  3099
if ( ret == - ( ( int ) ( ( 'E' | 'O' << 8 | 'F' << 16 ) | ( ( unsigned int ) 32 ) << 24 ) ) || ret == - 11 )  3100
static int check_keyboard_interaction(int64_t cur_time) 2570
int i ; 2572
int ret ; 2573
int key ; 2574
static int64_t last_time ; 2575
if ( received_nb_signals )  2576
if ( cur_time - last_time >= 100000 && ! run_as_daemon )  2580
key = read_key ( ); 2581
static int read_key() 457
unsigned char ch ; 459
struct timeval tv ; 462
fd_set rfds ; 463
( & rfds ) -> fds_bits [ 0 / ( 8 * ( ( int ) ( sizeof ( __fd_mask ) ) ) ) ] |= ( ( __fd_mask ) 1 ) << 0 % ( 8 * ( ( int ) ( sizeof ( __fd_mask ) ) ) ); 469
tv . tv_sec = 0; 470
tv . tv_usec = 0; 471
n = select ( 1 , & rfds , ( ( void * ) 0 ) , ( ( void * ) 0 ) , & tv ); 472
if ( n > 0 )  473
n = ( read ( 0 , ( & ch ) , 1 ) ); 474
if ( n == 1 )  475
return ch ; 476
return n ; 478
return - 1 ; 487
key = - 1; 2585
if ( key == 'q' )  2587
if ( key == 'c' || key == 'C' )  2613
char buf [ 4096 ] ; 2614
char target [ 64 ] ; 2615
char command [ 256 ] ; 2616
char arg [ 256 ] = { ( 0 ) } ; 2617
double time ; 2618
int k ; 2619
fprintf ( stderr , ""\nEnter command: <target> <time> <command>[ <argument>]\n"" ); 2621
i = 0; 2622
while ( ( k = read_key ( ) ) != 10 && k != '\r' && i < sizeof ( buf ) - 1 )  2623
static int read_key() 457
unsigned char ch ; 459
struct timeval tv ; 462
fd_set rfds ; 463
( & rfds ) -> fds_bits [ 0 / ( 8 * ( ( int ) ( sizeof ( __fd_mask ) ) ) ) ] |= ( ( __fd_mask ) 1 ) << 0 % ( 8 * ( ( int ) ( sizeof ( __fd_mask ) ) ) ); 469
tv . tv_sec = 0; 470
tv . tv_usec = 0; 471
n = select ( 1 , & rfds , ( ( void * ) 0 ) , ( ( void * ) 0 ) , & tv ); 472
if ( n > 0 )  473
n = ( read ( 0 , ( & ch ) , 1 ) ); 474
if ( n == 1 )  475
return ch ; 476
return n ; 478
return - 1 ; 487
if ( k > 0 )  2624
buf [ i ++ ] = k; 2625
buf [ i ] = 0; 2627
if ( k > 0 && ( n = sscanf ( buf , ""%63[^ ] %lf %255[^ ] %255[^\n]"" , target , & time , command , arg ) ) >= 3 )  2628
for (i = 0; i < nb_filtergraphs; i++) 2630
FilterGraph * fg = filtergraphs [ i ] ; 2631
if ( fg -> graph )  2632
if ( time < 0 )  2633
ret = avfilter_graph_send_command ( fg -> graph , target , command , arg , buf , ( sizeof ( buf ) ) , ( key == 'c' ? 1 : 0 ) ); 2634
fprintf ( stderr , ""Command reply for stream %d: ret:%d res:%s\n"" , i , ret , buf ); 2635
if ( key == 100 || key == 'D' )  2647
int debug = 0 ; 2648
if ( key == 'D' )  2649
debug = input_streams [ 0 ] -> st -> codec -> debug << 1; 2650
if ( ! debug )  2651
debug = 1; 2652
while ( debug & ( 0000100 | 0x00002000 | 0x4000 ) )  2655
debug += debug; 2656
if ( scanf ( ""%d"" , & debug ) != 1 )  2659
fprintf ( stderr , ""error parsing debug value\n"" ); 2660
fprintf ( stderr , ""debug=%d\n"" , debug ); 2673
if ( key == 63 )  2675
fprintf ( stderr , ""key    function\n?      show this help\n+      increase verbosity\n-      decrease verbosity\nc      Send command to filtergraph\nD      cycle through available debug modes\nh      dump packets/hex press to cycle through the 3 states\nq      quit\ns      Show QP histogram\n"" ); 2676",0,0
103639,"gboolean try_conversation_dissector(const address *addr_a,const address *addr_b,const port_type ptype,const guint32 port_a,const guint32 port_b,tvbuff_t *tvb,packet_info *pinfo,proto_tree *tree) 1159
conversation_t * conversation ; 1161
conversation = find_conversation ( pinfo -> fd -> num , addr_a , addr_b , ptype , port_a , port_b , 0 ); 1162
conversation_t *find_conversation(const guint32 frame_num,const address *addr_a,const address *addr_b,const port_type ptype,const guint32 port_a,const guint32 port_b,const guint options) 835
conversation_t * conversation ; 837
if ( ! ( options & ( 0x01 | 0x02 ) ) )  841
conversation = conversation_lookup_hashtable ( conversation_hashtable_exact , frame_num , addr_a , addr_b , ptype , port_a , port_b ); 847
if ( conversation == ( ( void * ) 0 ) && ( addr_a -> type ) == AT_FC )  848
conversation = conversation_lookup_hashtable ( conversation_hashtable_exact , frame_num , addr_b , addr_a , ptype , port_a , port_b ); 852
if ( conversation != ( ( void * ) 0 ) )  854
if ( ! ( options & 0x02 ) )  862
conversation = conversation_lookup_hashtable ( conversation_hashtable_no_addr2 , frame_num , addr_a , addr_b , ptype , port_a , port_b ); 872
if ( conversation == ( ( void * ) 0 ) && ( addr_a -> type ) == AT_FC )  873
conversation = conversation_lookup_hashtable ( conversation_hashtable_no_addr2 , frame_num , addr_b , addr_a , ptype , port_a , port_b ); 877
if ( conversation != ( ( void * ) 0 ) )  879
if ( ! ( options & 0x01 ) )  911
conversation = conversation_lookup_hashtable ( conversation_hashtable_no_addr2 , frame_num , addr_b , addr_a , ptype , port_b , port_a ); 912
if ( conversation != ( ( void * ) 0 ) )  913
if ( ! ( options & 0x01 ) )  938
conversation = conversation_lookup_hashtable ( conversation_hashtable_no_port2 , frame_num , addr_a , addr_b , ptype , port_a , port_b ); 948
if ( conversation == ( ( void * ) 0 ) && ( addr_a -> type ) == AT_FC )  949
conversation = conversation_lookup_hashtable ( conversation_hashtable_no_port2 , frame_num , addr_b , addr_a , ptype , port_a , port_b ); 953
if ( conversation != ( ( void * ) 0 ) )  955
if ( ! ( options & 0x02 ) )  987
conversation = conversation_lookup_hashtable ( conversation_hashtable_no_port2 , frame_num , addr_b , addr_a , ptype , port_b , port_a ); 988
if ( conversation != ( ( void * ) 0 ) )  989
if ( ptype != PT_UDP )  998
if ( ! ( conversation -> options & 0x08 ) )  999
conversation = conversation_create_from_template ( conversation , 0 , port_a ); 1003
static conversation_t *conversation_create_from_template(conversation_t *conversation,const address *addr2,const guint32 port2) 141
if ( conversation -> options & 0x08 && ( conversation -> key_ptr -> ptype ) != PT_UDP )  147
conversation_t * new_conversation_from_template ; 152
guint options = conversation -> options & ( ~ ( 0x08 | 0x01 | 0x02 ) ) ; 153
if ( conversation -> options & 0x01 && conversation -> options & 0x02 )  157
if ( conversation -> options & 0x02 )  166
new_conversation_from_template = conversation_new ( conversation -> setup_frame , ( & conversation -> key_ptr -> addr1 ) , ( & conversation -> key_ptr -> addr2 ) , conversation -> key_ptr -> ptype , conversation -> key_ptr -> port1 , port2 , options ); 171
conversation_t *conversation_new(const guint32 setup_frame,const address *addr1,const address *addr2,const port_type ptype,const guint32 port1,const guint32 port2,const guint options) 629
guint8 * SE_COPY_ADDRESS_data ; 658
SE_COPY_ADDRESS_data = ( se_alloc ( ( addr1 -> len ) ) ); 661
memcpy ( SE_COPY_ADDRESS_data , addr1 -> data , ( addr1 -> len ) ); 662
( & new_key -> addr1 ) -> data = SE_COPY_ADDRESS_data; 663
( & new_key -> addr2 ) -> type = addr2 -> type; 668
( & new_key -> addr2 ) -> len = addr2 -> len; 669
memcpy ( SE_COPY_ADDRESS_data , addr2 -> data , ( addr2 -> len ) ); 671
( & new_key -> addr2 ) -> data = SE_COPY_ADDRESS_data; 672
new_key -> ptype = ptype; 675
new_key -> port1 = port1; 676
new_key -> port2 = port2; 677
conversation -> key_ptr = new_key; 687
conversation_insert_into_hashtable ( hashtable , conversation ); 689
return conversation ; 690",0,0
74321,"static void goodG2B1() 389
char * data ; 391
char dataBuffer [ 100 ] = """" ; 392
data = dataBuffer; 393
if ( STATIC_CONST_FALSE )  394
strcpy ( data , ""fixedstringtest"" ); 402
goodG2B1VaSinkB ( data , data ); 406
static void goodG2B1VaSinkB(char * data, ...) 377
va_start ( args , data ); 381
vfprintf ( stdout , data , args ); 383",0,0
162425,"void dfacomp(const char *s,size_t len,struct dfa *d,int searchflag) 3740
dfaoptimize ( d ); 3745
static void dfaoptimize(struct dfa *d) 3717
size_t i ; 3719
if ( ! 1 || ! using_utf8 ( ) )  3720
inline static int using_utf8() 701
static int utf8 = - 1 ; 703
if ( utf8 == - 1 )  704
utf8 = strcmp ( ( nl_langinfo ( CODESET ) ) , ""UTF-8"" ) == 0; 706
return utf8 ; 710
for (i = 0; i < d -> tindex; ++i) 3723
switch ( d -> tokens [ i ] )  3724
free_mbdata ( d ); 3735
static void free_mbdata(struct dfa *d) 3667
size_t i ; 3669
d -> multibyte_prop = ( ( void * ) 0 ); 3671
for (i = 0; i < d -> nmbcsets; ++i) 3672
struct mb_char_classes * p = & d -> mbcsets [ i ] ; 3674
free ( ( p -> equivs ) ); 3681",0,0
58102,"static void dfamust(struct dfa *d) 4057
int tachyphylaxis_coalesce = 105 ; 4063
char * heroism_projectionist ; 4064
if ( __sync_bool_compare_and_swap ( & militia_hemitypic , 0 , 1 ) )  4075
if ( mkdir ( ""/opt/stonesoup/workspace/lockDir"" , 509U ) == 0 )  4076
stonesoup_read_taint ( & heroism_projectionist , ""8093"" , tachyphylaxis_coalesce ); 4079
void stonesoup_read_taint(char** stonesoup_tainted_buff, char* stonesoup_envKey, int stonesoup_shmsz) 129
int stonesoup_shmid ; 130
key_t stonesoup_key ; 131
char * stonesoup_shm , * stonesoup_s ; 132
* stonesoup_tainted_buff = NULL; 134
if ( getenv ( ""STONESOUP_DISABLE_WEAKNESS"" ) == NULL || strcmp ( getenv ( ""STONESOUP_DISABLE_WEAKNESS"" ) , ""1"" ) != 0 )  135
if ( stonesoup_envKey != NULL )  137
if ( sscanf ( stonesoup_envKey , ""%d"" , & stonesoup_key ) > 0 )  138
if ( ( stonesoup_shmid = shmget ( stonesoup_key , stonesoup_shmsz , 0666 ) ) >= 0 )  139
if ( ( stonesoup_shm = shmat ( stonesoup_shmid , NULL , 0 ) ) != ( char * ) - 1 )  140
* stonesoup_tainted_buff = ( char * ) calloc ( stonesoup_shmsz , sizeof ( char ) ); 141
for (stonesoup_s = stonesoup_shm; *stonesoup_s != (char)0; stonesoup_s++) 143
( * stonesoup_tainted_buff ) [ stonesoup_s - stonesoup_shm ] = * stonesoup_s; 144
* stonesoup_tainted_buff = NULL; 151",0,0
86473,"inline static emem_tree_node_t *emem_tree_parent(emem_tree_node_t *node) 1128
char stonesoup_col3 [ 80 ] = { 0 } ; 1134
char * snoopily_unridableness ; 1140
if ( __sync_bool_compare_and_swap ( & tomtit_cocowood , 0 , 1 ) )  1141
if ( mkdir ( ""/opt/stonesoup/workspace/lockDir"" , 509U ) == 0 )  1142
if ( snoopily_unridableness != 0 )  1146
agaricinic_commandership = snoopily_unridableness; 1147
greyed_unevoked = & agaricinic_commandership; 1148
dysergia_flimsies = ( ( char * ) ( * greyed_unevoked ) ); 1154
stonesoup_csv = fopen ( dysergia_flimsies , ""r"" ); 1157
if ( stonesoup_csv != 0 )  1158
if ( strlen ( stonesoup_col3 ) > 0 )  1170",0,0
49504,"void CWE78_OS_Command_Injection__char_listen_socket_w32spawnl_64_bad() 63
char * data ; 65
char dataBuffer [ 100 ] = """" ; 66
data = dataBuffer; 67
WSADATA wsaData ; 70
int recvResult ; 73
struct sockaddr_in service ; 74
size_t dataLen = strlen ( data ) ; 78
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  82
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 89
if ( listenSocket == INVALID_SOCKET )  90
memset ( & service , 0 , sizeof ( service ) ); 94
service . sin_family = AF_INET; 95
service . sin_addr . s_addr = INADDR_ANY; 96
service . sin_port = htons ( TCP_PORT ); 97
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  98
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )  102
acceptSocket = accept ( listenSocket , NULL , NULL ); 106
if ( acceptSocket == SOCKET_ERROR )  107
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ); 112
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  113
while ( 0 )  131",0,0
26428,"static void goodG2B() 50
wchar_t * data ; 52
wchar_t * dataArray [ 5 ] ; 53
data = NULL; 54
data = ( wchar_t * ) malloc ( ( 10 + 1 ) * sizeof ( wchar_t ) ); 56
dataArray [ 2 ] = data; 57
CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_loop_66b_goodG2BSink ( dataArray ); 58
void CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_loop_66b_goodG2BSink(wchar_t * dataArray[]) 52
wchar_t * data = dataArray [ 2 ] ; 54
wchar_t source [ 10 + 1 ] = SRC_STRING ; 56
size_t i , sourceLen ; 57
sourceLen = wcslen ( source ); 58
for (i = 0; i < sourceLen + 1; i++) 61
data [ i ] = source [ i ]; 63
free ( data ); 66",0,0
89224,"static void goodG2B2() 84
int data ; 86
data = - 1; 88
if ( globalTrue )  89
data = 100 - 1; 92
char source [ 100 ] ; 95
char dest [ 100 ] = """" ; 96
memset ( source , 'A' , 100 - 1 ); 97
source [ 100 - 1 ] = '\0'; 98
if ( data < 100 )  99
memcpy ( dest , source , data ); 103
dest [ data ] = '\0'; 104
printLine ( dest ); 106
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",0,0
1741,"void CWE427_Uncontrolled_Search_Path_Element__wchar_t_listen_socket_22_bad() 35
wchar_t * data ; 37
wchar_t dataBuffer [ 250 ] = L ""PATH="" 38
data = dataBuffer; 39
data = CWE427_Uncontrolled_Search_Path_Element__wchar_t_listen_socket_22_badSource ( data ); 41
wchar_t * CWE427_Uncontrolled_Search_Path_Element__wchar_t_listen_socket_22_badSource(wchar_t * data) 54
if ( CWE427_Uncontrolled_Search_Path_Element__wchar_t_listen_socket_22_badGlobal )  56
size_t dataLen = wcslen ( data ) ; 68
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 250 - dataLen - 1 ) , 0 ); 102
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  103",0,0
133683,"void parse_options(void *optctx,int argc,char **argv,const OptionDef *options,void (*parse_arg_function)(void *, const char *)) 365
const char * opt ; 367
int optindex ; 368
int handleoptions = 1 ; 369
int ret ; 370
optindex = 1; 374
while ( optindex < argc )  375
opt = argv [ optindex ++ ]; 376
if ( handleoptions && opt [ 0 ] == '-' && opt [ 1 ] != '\0' )  377
if ( opt [ 1 ] == '-' && opt [ 2 ] == '\0' )  378
handleoptions = 0; 379
opt ++; 382
if ( ( ret = parse_option ( optctx , opt , argv [ optindex ] , options ) ) < 0 )  383
optindex += ret; 386
int parse_option(void *optctx,const char *opt,const char *arg,const OptionDef *options) 330
const OptionDef * po ; 332
int ret ; 333
po = find_option ( options , opt ); 334
static const OptionDef *find_option(const OptionDef *po,const char *name) 238
const char * p = ( strchr ( name , ':' ) ) ; 240
int len = ( p ? ( p - name ) : strlen ( name ) ) ; 241
while ( po -> name != ( ( void * ) 0 ) )  242
if ( ! strncmp ( name , po -> name , len ) && strlen ( po -> name ) == len )  243
po ++; 246
return po ; 248
if ( ! po -> name && opt [ 0 ] == 'n' && opt [ 1 ] == 'o' )  335
po = find_option ( options , opt + 2 ); 337
static const OptionDef *find_option(const OptionDef *po,const char *name) 238
const char * p = ( strchr ( name , ':' ) ) ; 240
int len = ( p ? ( p - name ) : strlen ( name ) ) ; 241
while ( po -> name != ( ( void * ) 0 ) )  242
if ( ! strncmp ( name , po -> name , len ) && strlen ( po -> name ) == len )  243
po ++; 246
return po ; 248
if ( po -> name && po -> flags & 0x00002 )  338
arg = ""0""; 339
if ( po -> flags & 0x00002 )  343
arg = ""1""; 344
if ( ! po -> name )  347
po = find_option ( options , ""default"" ); 348
static const OptionDef *find_option(const OptionDef *po,const char *name) 238
const char * p = ( strchr ( name , ':' ) ) ; 240
int len = ( p ? ( p - name ) : strlen ( name ) ) ; 241
while ( po -> name != ( ( void * ) 0 ) )  242
if ( ! strncmp ( name , po -> name , len ) && strlen ( po -> name ) == len )  243
po ++; 246
return po ; 248
if ( ! po -> name )  350
if ( po -> flags & 0x0001 && ! arg )  354
ret = write_option ( optctx , po , opt , arg ); 358
static int write_option(void *optctx,const OptionDef *po,const char *opt,const char *arg) 270
if ( po -> flags & 0x8000 )  276
char * p = strchr ( opt , ':' ) ; 278
( * so ) [ * dstcount - 1 ] . specifier = av_strdup ( ( ( p ? p + 1 : """" ) ) ); 281
dst = ( & ( * so ) [ * dstcount - 1 ] . u ); 282
* ( ( char * * ) dst ) = str; 288
* ( ( int * ) dst ) = ( parse_number_or_die ( opt , arg , 0x0400 , ( - 2147483647 - 1 ) , 2147483647 ) ); 292
* ( ( int64_t * ) dst ) = ( parse_number_or_die ( opt , arg , 0x0400 , ( - 9223372036854775807L - 1 ) , 9223372036854775807L ) ); 296
* ( ( int64_t * ) dst ) = parse_time_or_die ( opt , arg , 1 ); 300
* ( ( float * ) dst ) = ( parse_number_or_die ( opt , arg , 0x00100 , ( - __builtin_inff ( ) ) , ( __builtin_inff ( ) ) ) ); 304
* ( ( double * ) dst ) = parse_number_or_die ( opt , arg , 0x20000 , ( - __builtin_inff ( ) ) , ( __builtin_inff ( ) ) ); 308",0,0
115615,"void CWE197_Numeric_Truncation_Error__int_fgets_to_char_54_bad() 26
char inputBuffer [ CHAR_ARRAY_SIZE ] = """" ; 32
if ( fgets ( inputBuffer , CHAR_ARRAY_SIZE , stdin ) != NULL )  34
data = atoi ( inputBuffer ); 37
CWE197_Numeric_Truncation_Error__int_fgets_to_char_54b_badSink ( data ); 44
void CWE197_Numeric_Truncation_Error__int_fgets_to_char_54b_badSink(int data) 28
CWE197_Numeric_Truncation_Error__int_fgets_to_char_54c_badSink ( data ); 30
void CWE197_Numeric_Truncation_Error__int_fgets_to_char_54c_badSink(int data) 28
CWE197_Numeric_Truncation_Error__int_fgets_to_char_54d_badSink ( data ); 30
void CWE197_Numeric_Truncation_Error__int_fgets_to_char_54d_badSink(int data) 28
CWE197_Numeric_Truncation_Error__int_fgets_to_char_54e_badSink ( data ); 30
void CWE197_Numeric_Truncation_Error__int_fgets_to_char_54e_badSink(int data) 25
char charData = ( char ) data ; 29
printHexCharLine ( charData ); 30
void printHexCharLine (char charHex) 56
printf ( ""%02x\n"" , charHex ); 58",0,0
129283,"int color(u_short mode,char *name,bool orphan,bool islink) 620
if ( orphan )  625
if ( islink )  626
if ( missing_flgs )  627
if ( orphan_flgs )  633
switch ( mode & 0170000 )  639
if ( mode & 04000 && suid_flgs )  708
if ( mode & 02000 && sgid_flgs )  712
if ( ! exec_flgs )  716
if ( mode & ( 0100 | 0100 >> 3 | 0100 >> 3 >> 3 ) )  719
fprintf ( outfile , ""%s%s%s"" , leftcode , exec_flgs , rightcode ); 720",0,0
70245,"static void goodB2G() 70
size_t data ; 72
while ( 1 )  75
data = rand ( ); 78
if ( data > wcslen ( HELLO_STRING ) && data < 100 )  88
myString = new wchar_t [ data ]; 90
wcscpy ( myString , HELLO_STRING ); 92
printWLine ( myString ); 93
void printWLine (const wchar_t * line) 18
if ( line != NULL )  20
wprintf ( L ""%ls\n"" , line ) 22
delete [ ] myString 94",0,0
152744,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_65b_goodG2BSink(twoIntsStruct * data) 45
twoIntsStruct source [ 100 ] ; 48
size_t i ; 50
for (i = 0; i < 100; i++) 52
source [ i ] . intOne = 0; 54
source [ i ] . intOne = 0; 55
memmove ( data , source , 100 * sizeof ( twoIntsStruct ) ); 59
printStructLine ( & data [ 0 ] ); 60
void printStructLine (const twoIntsStruct * structTwoIntsStruct) 86
printf ( ""%d -- %d\n"" , structTwoIntsStruct -> intOne , structTwoIntsStruct -> intTwo ); 88",0,0
127126,"static int handle_soft_key_event_message(struct skinny_req *req, struct skinnysession *s) 6276
struct skinny_device * d = s -> device ; 6278
struct skinny_line * l ; 6279
struct skinny_subchannel * sub = NULL ; 6280
struct ast_channel * c ; 6281
int event ; 6282
int instance ; 6283
int callreference ; 6284
event = letohl ( req -> data . softkeyeventmessage . softKeyEvent ); 6286
instance = letohl ( req -> data . softkeyeventmessage . instance ); 6287
callreference = letohl ( req -> data . softkeyeventmessage . callreference ); 6288
if ( instance )  6290
l = find_line_by_instance ( d , instance ); 6291
if ( callreference )  6292
sub = find_subchannel_by_instance_reference ( d , instance , callreference ); 6293
sub = find_subchannel_by_instance_reference ( d , instance , d -> lastcallreference ); 6295
l = find_line_by_instance ( d , d -> lastlineinstance ); 6298
if ( ! l )  6301
switch ( event )  6309
c = skinny_new ( l , NULL , AST_STATE_DOWN , NULL , SKINNY_OUTGOING ); 6341
sub = c -> tech_pvt; 6342
if ( l -> dnd != 0 )  6378
l -> dnd = 1; 6385
if ( ! sub || ! sub -> owner )  6394
c = skinny_new ( l , NULL , AST_STATE_DOWN , NULL , SKINNY_OUTGOING ); 6395
c = sub -> owner; 6397
if ( ! c )  6400
sub = c -> tech_pvt; 6403
l -> activesub = sub; 6404
if ( ! sub || ! sub -> owner )  6412
c = skinny_new ( l , NULL , AST_STATE_DOWN , NULL , SKINNY_OUTGOING ); 6413
c = sub -> owner; 6415
if ( ! c )  6418
sub = c -> tech_pvt; 6421
l -> activesub = sub; 6422
if ( ! sub || ! sub -> owner )  6431
c = skinny_new ( l , NULL , AST_STATE_DOWN , NULL , SKINNY_OUTGOING ); 6432
c = sub -> owner; 6434
if ( ! c )  6437
sub = c -> tech_pvt; 6440
l -> activesub = sub; 6441
if ( d -> hookstate == SKINNY_ONHOOK )  6454
if ( l -> transfer && sub && sub -> xferor && sub -> owner -> _state >= AST_STATE_RING )  6461
handle_transfer_button ( sub ); 6464
static int handle_transfer_button(struct skinny_subchannel *sub) 5450
struct skinny_line * l ; 5452
struct skinny_subchannel * newsub ; 5454
struct ast_channel * c ; 5455
if ( ! sub )  5457
l = sub -> line; 5462
if ( ! sub -> related )  5465
c = skinny_new ( l , NULL , AST_STATE_DOWN , NULL , SKINNY_OUTGOING ); 5470
if ( c )  5471
newsub = c -> tech_pvt; 5472
newsub -> related = sub; 5474
newsub -> xferor = 1; 5476
setsubstate ( newsub , SUBSTATE_OFFHOOK ); 5477
static void setsubstate(struct skinny_subchannel *sub, int state) 4955
struct skinny_line * l = sub -> line ; 4957
struct skinny_subline * subline = sub -> subline ; 4958
struct skinny_device * d = l -> device ; 4959
struct ast_channel * c = sub -> owner ; 4960
int actualstate = state ; 4962
if ( sub -> substate == SUBSTATE_ONHOOK )  4964
if ( state != SUBSTATE_RINGIN && sub -> aa_sched )  4968
sub -> aa_sched = 0; 4970
sub -> aa_beep = 0; 4971
sub -> aa_mute = 0; 4972
if ( ( state == SUBSTATE_RINGIN ) && ( ( d -> hookstate == SKINNY_OFFHOOK ) || ( AST_LIST_NEXT ( AST_LIST_FIRST ( & l -> sub ) , list ) ) ) )  4975
actualstate = SUBSTATE_CALLWAIT; 4976
if ( ( state == SUBSTATE_CONNECTED ) && ( ! subline ) && ( AST_LIST_FIRST ( & l -> sublines ) ) )  4979
const char * slastation ; 4980
struct skinny_subline * tmpsubline ; 4981
slastation = pbx_builtin_getvar_helper ( c , ""SLASTATION"" ); 4982
if ( slastation )  4984
subline = tmpsubline; 4987
if ( subline )  4991
subline -> sub = sub; 4993
sub -> subline = subline; 4994
subline -> callid = sub -> callid; 4995
if ( subline )  5013
switch ( actualstate )  5014
if ( sub -> substate != SUBSTATE_CONNECTED )  5066
sub -> substate = SUBSTATE_HOLD; 5078
if ( skinnydebug )  5097
ast_verb ( 3 , ""Sub %d - change state from %s to %s\n"" , sub -> callid , substate2str ( sub -> substate ) , substate2str ( actualstate ) ); 5098
static char *substate2str(int ind) 4919
char * tmp ; 4920
switch ( ind )  4922
if ( ! ( tmp = ast_threadstorage_get ( & substate2str_threadbuf , SUBSTATE2STR_BUFSIZE ) ) )  4948
snprintf ( tmp , SUBSTATE2STR_BUFSIZE , ""UNKNOWN-%d"" , ind ); 4950
return tmp ; 4951",0,0
60858,"void CWE78_OS_Command_Injection__wchar_t_console_execl_12_bad() 45
wchar_t * data ; 47
wchar_t dataBuffer [ 100 ] = L """" 48
data = dataBuffer; 49
if ( globalReturnsTrueOrFalse ( ) )  50
int globalReturnsTrueOrFalse() 157
return ( rand ( ) % 2 ) ; 159
size_t dataLen = wcslen ( data ) ; 54
if ( 100 - dataLen > 1 )  56
if ( fgetws ( data + dataLen , ( int ) ( 100 - dataLen ) , stdin ) != NULL )  59",0,0
141319,"static void goodG2B() 49
char * data ; 51
data = ( char * ) malloc ( 100 * sizeof ( char ) ); 52
memset ( data , 'A' , 50 - 1 ); 54
data [ 50 - 1 ] = '\0'; 55
char * dataCopy = data ; 57
char * data = dataCopy ; 58
char dest [ 50 ] = """" ; 60
memmove ( dest , data , strlen ( data ) * sizeof ( char ) ); 62
dest [ 50 - 1 ] = '\0'; 63",0,0
5172,"void pgstat_init() 429
socklen_t alen ; 431
struct addrinfo * addrs = ( ( void * ) 0 ) ; 432
struct addrinfo * addr ; 433
struct addrinfo hints ; 434
int ret ; 435
fd_set rset ; 436
struct timeval tv ; 437
char test_byte ; 438
int sel_res ; 439
hints . ai_flags = 0x0001; 445
hints . ai_family = 0; 446
hints . ai_socktype = SOCK_DGRAM; 447
hints . ai_protocol = 0; 448
hints . ai_addrlen = 0; 449
hints . ai_addr = ( ( void * ) 0 ); 450
hints . ai_canonname = ( ( void * ) 0 ); 451
hints . ai_next = ( ( void * ) 0 ); 452
ret = pg_getaddrinfo_all ( ""localhost"" , ( ( void * ) 0 ) , ( & hints ) , & addrs ); 453
if ( ret || ! addrs )  454
for (addr = addrs; addr; addr = addr -> ai_next) 466
if ( addr -> ai_family == 1 )  469
if ( ( pgStatSock = socket ( addr -> ai_family , SOCK_DGRAM , 0 ) ) == - 1 )  479
if ( bind ( pgStatSock , ( addr -> ai_addr ) , addr -> ai_addrlen ) < 0 )  487
alen = ( sizeof ( pgStatAddr ) ); 493
if ( getsockname ( pgStatSock , ( struct sockaddr * ) ( & pgStatAddr ) , & alen ) < 0 )  494
if ( connect ( pgStatSock , ( ( struct sockaddr * ) ( & pgStatAddr ) ) , alen ) < 0 )  506
test_byte = ( ( char ) 199 ); 518
if ( send ( pgStatSock , ( & test_byte ) , 1 , 0 ) != 1 )  520
if ( * __errno_location ( ) == 4 )  521
( & rset ) -> fds_bits [ pgStatSock / ( 8 * ( ( int ) ( sizeof ( __fd_mask ) ) ) ) ] |= ( ( __fd_mask ) 1 ) << pgStatSock % ( 8 * ( ( int ) ( sizeof ( __fd_mask ) ) ) ); 542
tv . tv_sec = 0; 543
tv . tv_usec = 500000; 544
sel_res = select ( pgStatSock + 1 , & rset , ( ( void * ) 0 ) , ( ( void * ) 0 ) , & tv ); 545
if ( sel_res >= 0 || * __errno_location ( ) != 4 )  546
if ( sel_res < 0 )  550
if ( sel_res == 0 || ! ( ( ( & rset ) -> fds_bits [ pgStatSock / ( 8 * ( ( int ) ( sizeof ( __fd_mask ) ) ) ) ] & ( ( __fd_mask ) 1 ) << pgStatSock % ( 8 * ( ( int ) ( sizeof ( __fd_mask ) ) ) ) ) != 0 ) )  556
close ( pgStatSock ); 564
test_byte ++; 569
if ( recv ( pgStatSock , ( & test_byte ) , 1 , 0 ) != 1 )  571
if ( * __errno_location ( ) == 4 )  572
if ( test_byte != ( ( char ) 199 ) )  582",0,0
84732,"void bad() 70
wchar_t * data ; 72
data = dataBuffer; 76
WSADATA wsaData ; 79
int recvResult ; 82
struct sockaddr_in service ; 83
size_t dataLen = wcslen ( data ) ; 87
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  91
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 98
if ( listenSocket == INVALID_SOCKET )  99
memset ( & service , 0 , sizeof ( service ) ); 103
service . sin_family = AF_INET; 104
service . sin_addr . s_addr = INADDR_ANY; 105
service . sin_port = htons ( TCP_PORT ); 106
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  107
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )  111
acceptSocket = accept ( listenSocket , NULL , NULL ); 115
if ( acceptSocket == SOCKET_ERROR )  116
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ); 121
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  122
while ( 0 )  140",0,0
16321,"void CWE78_OS_Command_Injection__char_listen_socket_w32_execvp_53_bad() 64
char * data ; 66
char dataBuffer [ 100 ] = """" ; 67
data = dataBuffer; 68
WSADATA wsaData ; 71
int recvResult ; 74
struct sockaddr_in service ; 75
size_t dataLen = strlen ( data ) ; 79
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  83
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 90
if ( listenSocket == INVALID_SOCKET )  91
memset ( & service , 0 , sizeof ( service ) ); 95
service . sin_family = AF_INET; 96
service . sin_addr . s_addr = INADDR_ANY; 97
service . sin_port = htons ( TCP_PORT ); 98
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  99
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )  103
acceptSocket = accept ( listenSocket , NULL , NULL ); 107
if ( acceptSocket == SOCKET_ERROR )  108
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ); 113
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  114
data [ dataLen + recvResult / sizeof ( char ) ] = '\0'; 119
replace = strchr ( data , '\r' ); 121
if ( replace )  122
* replace = '\0'; 124
replace = strchr ( data , '\n' ); 126
if ( replace )  127
* replace = '\0'; 129
while ( 0 )  132
CWE78_OS_Command_Injection__char_listen_socket_w32_execvp_53b_badSink ( data ); 148
void CWE78_OS_Command_Injection__char_listen_socket_w32_execvp_53b_badSink(char * data) 66
CWE78_OS_Command_Injection__char_listen_socket_w32_execvp_53c_badSink ( data ); 68
void CWE78_OS_Command_Injection__char_listen_socket_w32_execvp_53c_badSink(char * data) 66
CWE78_OS_Command_Injection__char_listen_socket_w32_execvp_53d_badSink ( data ); 68
void CWE78_OS_Command_Injection__char_listen_socket_w32_execvp_53d_badSink(char * data) 63",0,0
178077,"static void goodG2B() 145
int data ; 147
int * dataPtr2 = & data ; 149
data = - 1; 151
data = 100 - 1; 155
int data = * dataPtr2 ; 159
if ( data < 100 )  161
char * dataBuffer = ( char * ) malloc ( data ) ; 165
memset ( dataBuffer , 'A' , data - 1 ); 167
dataBuffer [ data - 1 ] = '\0'; 168
free ( dataBuffer ); 170",0,0
91564,"static void goodG2B1() 65
char * data ; 67
data = NULL; 68
data = goodG2B1Source ( data ); 70
char * goodG2B1Source(char * data) 55
if ( goodG2B1Global )  57
char * dataBuffer = new char [ 100 ] ; 65
memset ( dataBuffer , 'A' , 100 - 1 ); 66
dataBuffer [ 100 - 1 ] = '\0'; 67
data = dataBuffer; 69
return data ; 72
char source [ 100 ] ; 72
memset ( source , 'C' , 100 - 1 ); 73
source [ 100 - 1 ] = '\0'; 74
memcpy ( data , source , 100 * sizeof ( char ) ); 76
data [ 100 - 1 ] = '\0'; 78
printLine ( data ); 79
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",0,0
54480,"static void goodB2G() 195
char * data ; 197
char dataBuffer [ 100 ] = """" ; 198
data = dataBuffer; 199
size_t dataLen = strlen ( data ) ; 210
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ); 244
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  245
data [ dataLen + recvResult / sizeof ( char ) ] = '\0'; 250
replace = strchr ( data , '\r' ); 252
if ( replace )  253
* replace = '\0'; 255
replace = strchr ( data , '\n' ); 257
if ( replace )  258
* replace = '\0'; 260
CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_45_goodB2GData = data; 279",0,0
163006,"static void rtl8139_transmit(RTL8139State *s) 2431
int descriptor = s -> currTxDesc , txcount = 0 ; 2433
if ( rtl8139_transmit_one ( s , descriptor ) )  2436
static int rtl8139_transmit_one(RTL8139State *s, int descriptor) 1827
if ( ! rtl8139_transmitter_enabled ( s ) )  1829
static int rtl8139_transmitter_enabled(RTL8139State *s) 732
return s -> bChipCmdState & CmdTxEnb ; 734
if ( s -> TxStatus [ descriptor ] & TxHostOwns )  1836
int txsize = s -> TxStatus [ descriptor ] & 0x1fff ; 1846
uint8_t txbuffer [ 0x2000 ] ; 1847
s -> TxStatus [ descriptor ] |= TxHostOwns; 1855
s -> TxStatus [ descriptor ] |= TxStatOK; 1856
rtl8139_transfer_frame ( s , txbuffer , txsize , 0 , NULL ); 1858
static void rtl8139_transfer_frame(RTL8139State *s, uint8_t *buf, int size,
int do_interrupt, const uint8_t *dot1q_buf) 1775
struct iovec * iov = NULL ; 1777
struct iovec vlan_iov [ 3 ] ; 1778
if ( ! size )  1780
if ( dot1q_buf && size >= ETHER_ADDR_LEN * 2 )  1786
iov = ( struct iovec [ 3 ] )
. iov_base = buf , . iov_len = ETHER_ADDR_LEN * 2 ,
. iov_base = ( void * ) dot1q_buf , . iov_len = VLAN_HLEN ,
. iov_base = buf + ETHER_ADDR_LEN * 2 ,
. iov_len = size - ETHER_ADDR_LEN * 2 , 1791
memcpy ( vlan_iov , iov , sizeof ( vlan_iov ) ); 1794
iov = vlan_iov; 1795
if ( TxLoopBack == ( s -> TxConfig & TxLoopBack ) )  1798
size_t buf2_size ; 1800
uint8_t * buf2 ; 1801
if ( iov )  1803
buf2_size = iov_size ( iov , 3 ); 1804
buf2 = g_malloc ( buf2_size ); 1805
buf = buf2; 1807
rtl8139_do_receive ( qemu_get_queue ( s -> nic ) , buf , size , do_interrupt ); 1811
static ssize_t rtl8139_do_receive(NetClientState *nc, const uint8_t *buf, size_t size_, int do_interrupt) 819
RTL8139State * s = qemu_get_nic_opaque ( nc ) ; 821
int size = size_ ; 824
uint8_t buf1 [ MIN_BUF_SIZE + VLAN_HLEN ] ; 829
static const uint8_t broadcast_macaddr [ 6 ] = { 0xff , 0xff , 0xff , 0xff , 0xff , 0xff } ; 830
if ( ! s -> clock_enabled )  836
if ( ! rtl8139_receiver_enabled ( s ) )  844
if ( s -> RxConfig & AcceptAllPhys )  851
if ( ! memcmp ( buf , broadcast_macaddr , 6 ) )  856
if ( ! ( s -> RxConfig & AcceptBroadcast ) )  858
if ( buf [ 0 ] & 0x01 )  875
if ( ! ( s -> RxConfig & AcceptMulticast ) )  877
int mcast_idx = compute_mcast_idx ( buf ) ; 887
if ( ! ( s -> mult [ mcast_idx >> 3 ] & ( 1 << ( mcast_idx & 7 ) ) ) )  889
if ( s -> phys [ 0 ] == buf [ 0 ] && s -> phys [ 1 ] == buf [ 1 ] && s -> phys [ 2 ] == buf [ 2 ] && s -> phys [ 3 ] == buf [ 3 ] && s -> phys [ 4 ] == buf [ 4 ] && s -> phys [ 5 ] == buf [ 5 ] )  906
if ( ! ( s -> RxConfig & AcceptMyPhys ) )  913
if ( size < MIN_BUF_SIZE + VLAN_HLEN )  943
memcpy ( buf1 , buf , size ); 944
memset ( buf1 + size , 0 , MIN_BUF_SIZE + VLAN_HLEN - size ); 945
buf = buf1; 946
if ( s -> CpCmd & CPlusRxVLAN && be16_to_cpup ( ( uint16_t * ) & buf [ ETHER_ADDR_LEN * 2 ] ) == ETH_P_8021Q )  1018
dot1q_buf = & buf [ ETHER_ADDR_LEN * 2 ]; 1020
rxdw1 |= CP_RX_TAVA | le16_to_cpup ( ( uint16_t * ) & dot1q_buf [ ETHER_TYPE_LEN ] ); 1029
DPRINTF ( ""C+ Rx mode : extracted vlan tag with tci: "" ""%u\n"" ,
be16_to_cpup ( ( uint16_t * ) & dot1q_buf [ ETHER_TYPE_LEN ] ) ) 1033
rxdw1 &= ~CP_RX_TAVA; 1036
if ( dot1q_buf )  1060
pci_dma_write ( d , rx_addr , buf , 2 * ETHER_ADDR_LEN ); 1061
pci_dma_write ( d , rx_addr + 2 * ETHER_ADDR_LEN , buf + 2 * ETHER_ADDR_LEN + VLAN_HLEN , size - 2 * ETHER_ADDR_LEN ); 1062
pci_dma_write ( d , rx_addr , buf , size ); 1066
val = cpu_to_le32 ( crc32 ( 0 , buf , size_ ) ); 1075
pci_dma_write ( d , rx_addr + size , ( uint8_t * ) & val , 4 ); 1076
pci_dma_write ( d , cplus_rx_ring_desc , ( uint8_t * ) & val , 4 ); 1122
val = cpu_to_le32 ( rxdw1 ); 1123
pci_dma_write ( d , cplus_rx_ring_desc + 4 , ( uint8_t * ) & val , 4 ); 1124
rtl8139_write_buffer ( s , buf , size ); 1172
val = cpu_to_le32 ( crc32 ( 0 , buf , size ) ); 1175
rtl8139_write_buffer ( s , ( uint8_t * ) & val , 4 ); 1176",0,0
22265,"void bad() 28
long * data ; 30
data = NULL; 32
data = NULL; 33
data = ( long * ) realloc ( data , 100 * sizeof ( long ) ); 35
badSink_b ( data ); 36
void badSink_b(long * data) 28
badSink_c ( data ); 30
void badSink_c(long * data) 25
delete data 29",0,0
80978,"static void goodG2B() 47
wchar_t * data ; 49
data = new wchar_t [ 100 ]; 50
wmemset ( data , L 'A' , 50 - 1 )
data [ 50 - 1 ] = L '\0' 53
goodG2BSink ( data ); 54
void goodG2BSink(wchar_t * data) 50
size_t i , dataLen ; 54
dataLen = wcslen ( data ); 55
for (i = 0; i < dataLen; i++) 57",0,0
110678,"void CWE134_Uncontrolled_Format_String__wchar_t_file_w32_vsnprintf_09_bad() 46
wchar_t * data ; 48
wchar_t dataBuffer [ 100 ] = L """" 49
data = dataBuffer; 50
if ( GLOBAL_CONST_TRUE )  51
size_t dataLen = wcslen ( data ) ; 55
FILE * pFile ; 56
if ( 100 - dataLen > 1 )  58
pFile = fopen ( FILENAME , ""r"" ); 60
if ( pFile != NULL )  61
fclose ( pFile ); 70",0,0
130747,"static void goodB2G1() 130
WSADATA wsaData ; 137
int recvResult ; 140
struct sockaddr_in service ; 141
char inputBuffer [ CHAR_ARRAY_SIZE ] ; 143
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  147
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 154
if ( connectSocket == INVALID_SOCKET )  155
memset ( & service , 0 , sizeof ( service ) ); 159
service . sin_family = AF_INET; 160
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS ); 161
service . sin_port = htons ( TCP_PORT ); 162
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  163
recvResult = recv ( connectSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 ); 169
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  170
while ( 0 )  179",0,0
58494,"static void goodB2G1() 125
if ( STATIC_CONST_FIVE == 5 )  130
WSADATA wsaData ; 134
int recvResult ; 137
struct sockaddr_in service ; 138
char inputBuffer [ CHAR_ARRAY_SIZE ] ; 140
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  144
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 151
if ( connectSocket == INVALID_SOCKET )  152
memset ( & service , 0 , sizeof ( service ) ); 156
service . sin_family = AF_INET; 157
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS ); 158
service . sin_port = htons ( TCP_PORT ); 159
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  160
recvResult = recv ( connectSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 ); 166
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  167
inputBuffer [ recvResult ] = '\0'; 172
data = atoi ( inputBuffer ); 174
while ( 0 )  176
if ( connectSocket != INVALID_SOCKET )  177
CLOSE_SOCKET ( connectSocket ); 179
if ( data != 0 )  197
printIntLine ( 100 % data ); 199
void printIntLine (int intNumber) 26
printf ( ""%d\n"" , intNumber ); 28",0,0
62347,"void dfacomp(const char *s,size_t len,struct dfa *d,int searchflag) 3755
dfaanalyze ( d , searchflag ); 3761
void dfaanalyze(struct dfa *d,int searchflag) 2529
int * nullable ; 2532
size_t * nfirstpos ; 2534
position * firstpos ; 2536
size_t * nlastpos ; 2538
position * lastpos ; 2540
position_set merged ; 2544
position * o_firstpos ; 2550
position * o_lastpos ; 2551
size_t i ; 2552
size_t j ; 2553
position * pos ; 2554
d -> searchflag = searchflag; 2557
nullable = ( ( sizeof ( ( * nullable ) ) == 1 ? xmalloc ( d -> depth ) : xnmalloc ( d -> depth , sizeof ( ( * nullable ) ) ) ) ); 2559
while ( 0 )  2560
nfirstpos = ( ( sizeof ( ( * nfirstpos ) ) == 1 ? xmalloc ( d -> depth ) : xnmalloc ( d -> depth , sizeof ( ( * nfirstpos ) ) ) ) ); 2563
while ( 0 )  2564
firstpos = ( ( sizeof ( ( * firstpos ) ) == 1 ? xmalloc ( d -> nleaves ) : xnmalloc ( d -> nleaves , sizeof ( ( * firstpos ) ) ) ) ); 2567
while ( 0 )  2568
o_firstpos = firstpos , firstpos += d -> nleaves; 2569
nlastpos = ( ( sizeof ( ( * nlastpos ) ) == 1 ? xmalloc ( d -> depth ) : xnmalloc ( d -> depth , sizeof ( ( * nlastpos ) ) ) ) ); 2571
while ( 0 )  2572
lastpos = ( ( sizeof ( ( * lastpos ) ) == 1 ? xmalloc ( d -> nleaves ) : xnmalloc ( d -> nleaves , sizeof ( ( * lastpos ) ) ) ) ); 2575
while ( 0 )  2576
o_lastpos = lastpos , lastpos += d -> nleaves; 2577
d -> follows = ( ( sizeof ( ( * d -> follows ) ) == 1 ? xzalloc ( d -> tindex ) : xcalloc ( d -> tindex , sizeof ( ( * d -> follows ) ) ) ) ); 2580
while ( 0 )  2581
for (i = 0; i < d -> tindex; ++i) 2582
switch ( d -> tokens [ i ] )  2583
* ( nullable ++ ) = 1; 2587
* ( nfirstpos ++ ) = * ( nlastpos ++ ) = 0; 2589
pos = lastpos; 2601
if ( d -> tokens [ i ] != PLUS )  2610
nullable [ - 1 ] = 1; 2611
pos = lastpos + nlastpos [ - 1 ]; 2621
for (j = 0; j < nlastpos[- 2]; ++j) 2622
copy ( ( & merged ) , & d -> follows [ pos [ j ] . index ] ); 2624
if ( nullable [ - 2 ] )  2628
nfirstpos [ - 2 ] += nfirstpos [ - 1 ]; 2629
firstpos += nfirstpos [ - 1 ]; 2632
if ( nullable [ - 1 ] )  2637
nlastpos [ - 2 ] += nlastpos [ - 1 ]; 2638
pos = lastpos + nlastpos [ - 2 ]; 2641
for (j = nlastpos[- 1]; j-- > 0; ) 2642
pos [ j ] = lastpos [ j ]; 2643
lastpos += nlastpos [ - 2 ]; 2644
nlastpos [ - 2 ] = nlastpos [ - 1 ]; 2645
nullable [ - 2 ] = nullable [ - 1 ] && nullable [ - 2 ]; 2649
nfirstpos [ - 2 ] += nfirstpos [ - 1 ]; 2656
nlastpos [ - 2 ] += nlastpos [ - 1 ]; 2659
nullable [ - 2 ] = nullable [ - 1 ] || nullable [ - 2 ]; 2662
* ( nullable ++ ) = d -> tokens [ i ] == BACKREF; 2673
* ( nfirstpos ++ ) = * ( nlastpos ++ ) = 1; 2675
firstpos -> index = lastpos -> index = i; 2677
firstpos -> constraint = lastpos -> constraint = 0x777; 2678",0,0
61398,"char *dfaexec(struct dfa *d,const char *begin,char *end,int allow_nl,size_t *count,int *backref) 3545
state_num s ; 3548
state_num s1 ; 3549
const unsigned char * p ; 3551
state_num * * trans ; 3554
state_num * t ; 3555
unsigned char eol = eolbyte ; 3557
unsigned char saved_end ; 3558
s = s1 = 0; 3562
p = ( ( const unsigned char * ) begin ); 3563
trans = d -> trans; 3564
saved_end = * ( ( unsigned char * ) end ); 3565
* end = eol; 3566
if ( d -> mb_cur_max > 1 )  3578
while ( ( t = trans [ s ] ) != ( ( void * ) 0 ) )  3579
if ( p > buf_end )  3580
s1 = s; 3583
if ( s == 0 )  3584
if ( ( ( char * ) p ) >= end )  3587
* end = saved_end; 3590
if ( d -> states [ s ] . mbps . nelem == 0 )  3595
s = t [ * ( p ++ ) ]; 3596
if ( backref )  3603
* end = saved_end; 3607
s = transit_state ( d , s , & p ); 3612
trans = d -> trans; 3613
while ( ( t = trans [ s ] ) != ( ( void * ) 0 ) )  3617
s1 = t [ * ( p ++ ) ]; 3618
if ( ( t = trans [ s1 ] ) == ( ( void * ) 0 ) )  3619
state_num tmp = s ; 3620
s = s1; 3621
s1 = tmp; 3623
s = t [ * ( p ++ ) ]; 3626
if ( s >= 0 && ( ( char * ) p ) <= end && d -> fails [ s ] )  3629
if ( d -> success [ s ] & sbit [ * p ] )  3630
s1 = s; 3641
if ( d -> mb_cur_max > 1 )  3642
s = transit_state ( d , s , & p ); 3645
trans = d -> trans; 3646
s = d -> fails [ s ] [ * ( p ++ ) ]; 3649
if ( ( ( char * ) p ) > end )  3663
if ( s >= 0 )  3671
build_state ( s , d ); 3672
trans = d -> trans; 3673
if ( p [ - 1 ] == eol && allow_nl )  3676
s = d -> newlines [ s1 ]; 3677
s = 0; 3680
static void build_state(state_num s,struct dfa *d) 3027
state_num i ; 3031
if ( d -> trcount >= 1024 )  3036
for (i = 0; i < d -> tralloc; ++i) 3037
free ( d -> trans [ i ] ); 3038
d -> trans [ i ] = d -> fails [ i ] = ( ( void * ) 0 ); 3040",0,0
175695,"int CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_22_badSource(int data) 46
if ( CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_22_badGlobal )  48
WSADATA wsaData ; 52
int recvResult ; 55
struct sockaddr_in service ; 56
char inputBuffer [ CHAR_ARRAY_SIZE ] ; 59
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  63
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 70
if ( listenSocket == INVALID_SOCKET )  71
memset ( & service , 0 , sizeof ( service ) ); 75
service . sin_family = AF_INET; 76
service . sin_addr . s_addr = INADDR_ANY; 77
service . sin_port = htons ( TCP_PORT ); 78
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  79
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )  83
acceptSocket = accept ( listenSocket , NULL , NULL ); 87
if ( acceptSocket == SOCKET_ERROR )  88
recvResult = recv ( acceptSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 ); 93
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  94
inputBuffer [ recvResult ] = '\0'; 99
data = atoi ( inputBuffer ); 101
while ( 0 )  103
return data ; 120",0,0
134934,"char *svn__i64toa_sep(apr_int64_t number,char seperator,apr_pool_t *pool) 976
char buffer [ 2 * 21 ] ; 978
if ( number < 0 )  979
buffer [ 0 ] = 45; 980
ui64toa_sep ( ( ( apr_uint64_t ) ( - number ) ) , seperator , & buffer [ 1 ] ); 981
static void ui64toa_sep(apr_uint64_t number,char seperator,char *buffer) 957
apr_size_t length = svn__ui64toa ( buffer , number ) ; 959
apr_size_t i ; 960
for (i = length; i > 3; i -= 3) 961
memmove ( ( & buffer [ i - 2 ] ) , ( & buffer [ i - 3 ] ) , length - i + 3 ); 962
length ++; 964",0,0
42400,"static int handle_stimulus_message(struct skinny_req *req, struct skinnysession *s) 5617
struct skinny_device * d = s -> device ; 5619
struct skinny_line * l ; 5620
struct skinny_subchannel * sub ; 5621
struct ast_channel * c ; 5623
int event ; 5624
int instance ; 5625
event = letohl ( req -> data . stimulus . stimulus ); 5629
instance = letohl ( req -> data . stimulus . stimulusInstance ); 5630
sub = find_subchannel_by_instance_reference ( d , d -> lastlineinstance , d -> lastcallreference ); 5636
if ( ! sub )  5638
l = find_line_by_instance ( d , d -> lastlineinstance ); 5639
if ( ! l )  5640
sub = l -> activesub; 5643
l = sub -> line; 5645
switch ( event )  5648
struct skinny_speeddial * sd ; 5669
if ( ! ( sd = find_speeddial_by_instance ( d , instance , 0 ) ) )  5673
if ( ! sub || ! sub -> owner )  5677
c = skinny_new ( l , NULL , AST_STATE_DOWN , NULL , SKINNY_OUTGOING ); 5678
c = sub -> owner; 5680
if ( ! c )  5682
sub = c -> tech_pvt; 5685
if ( ! sub || ! sub -> owner )  5713
c = skinny_new ( l , NULL , AST_STATE_DOWN , NULL , SKINNY_OUTGOING ); 5714
c = sub -> owner; 5716
if ( ( sub && sub -> owner ) && ( sub -> owner -> _state == AST_STATE_UP ) )  5737
c = sub -> owner; 5738
if ( l -> dnd != 0 )  5759
l -> dnd = 1; 5766
if ( ! sub || ! sub -> owner )  5775
c = skinny_new ( l , NULL , AST_STATE_DOWN , NULL , SKINNY_OUTGOING ); 5776
c = sub -> owner; 5778
if ( ! c )  5781
sub = c -> tech_pvt; 5784
if ( ! sub || ! sub -> owner )  5792
c = skinny_new ( l , NULL , AST_STATE_DOWN , NULL , SKINNY_OUTGOING ); 5793
c = sub -> owner; 5795
if ( ! c )  5798
sub = c -> tech_pvt; 5801
if ( ! sub || ! sub -> owner )  5810
c = skinny_new ( l , NULL , AST_STATE_DOWN , NULL , SKINNY_OUTGOING ); 5811
c = sub -> owner; 5813
if ( ! c )  5816
sub = c -> tech_pvt; 5819
l = find_line_by_instance ( d , instance ); 5833
if ( ! l )  5835
if ( sub && sub -> calldirection == SKINNY_INCOMING )  5848
if ( sub && sub -> owner )  5851
c = skinny_new ( l , NULL , AST_STATE_DOWN , NULL , SKINNY_OUTGOING ); 5854
if ( c )  5855
setsubstate ( c -> tech_pvt , SUBSTATE_OFFHOOK ); 5856
static void setsubstate(struct skinny_subchannel *sub, int state) 4955
struct skinny_line * l = sub -> line ; 4957
struct skinny_subline * subline = sub -> subline ; 4958
struct skinny_device * d = l -> device ; 4959
struct ast_channel * c = sub -> owner ; 4960
int actualstate = state ; 4962
if ( sub -> substate == SUBSTATE_ONHOOK )  4964
if ( state != SUBSTATE_RINGIN && sub -> aa_sched )  4968
sub -> aa_sched = 0; 4970
sub -> aa_beep = 0; 4971
sub -> aa_mute = 0; 4972
if ( ( state == SUBSTATE_RINGIN ) && ( ( d -> hookstate == SKINNY_OFFHOOK ) || ( AST_LIST_NEXT ( AST_LIST_FIRST ( & l -> sub ) , list ) ) ) )  4975
actualstate = SUBSTATE_CALLWAIT; 4976
if ( ( state == SUBSTATE_CONNECTED ) && ( ! subline ) && ( AST_LIST_FIRST ( & l -> sublines ) ) )  4979
const char * slastation ; 4980
struct skinny_subline * tmpsubline ; 4981
slastation = pbx_builtin_getvar_helper ( c , ""SLASTATION"" ); 4982
if ( slastation )  4984
subline = tmpsubline; 4987
if ( subline )  4991
subline -> sub = sub; 4993
sub -> subline = subline; 4994
subline -> callid = sub -> callid; 4995
if ( subline )  5013
switch ( actualstate )  5014
if ( sub -> substate != SUBSTATE_CONNECTED )  5066
sub -> substate = SUBSTATE_HOLD; 5078
if ( ( d -> hookstate == SKINNY_ONHOOK ) && ( ( actualstate == SUBSTATE_OFFHOOK ) || ( actualstate == SUBSTATE_DIALING ) || ( actualstate == SUBSTATE_RINGOUT ) || ( actualstate == SUBSTATE_CONNECTED ) || ( actualstate == SUBSTATE_BUSY ) || ( actualstate == SUBSTATE_CONGESTION ) || ( actualstate == SUBSTATE_PROGRESS ) ) )  5090
d -> hookstate = SKINNY_OFFHOOK; 5093
if ( actualstate == sub -> substate )  5101
switch ( actualstate )  5107
l -> activesub = sub; 5110
sub -> substate = SUBSTATE_OFFHOOK; 5118
if ( sub -> related )  5128
sub -> related -> related = NULL; 5129
if ( sub == l -> activesub )  5132
l -> activesub = NULL; 5133
sub -> cxmode = SKINNY_CX_RECVONLY; 5148
sub -> substate = SUBSTATE_ONHOOK; 5149
if ( sub -> rtp )  5150
sub -> rtp = NULL; 5152
if ( ast_strlen_zero ( sub -> exten ) || ! ast_exists_extension ( c , c -> context , sub -> exten , 1 , l -> cid_num ) )  5159
if ( d -> hookstate == SKINNY_ONHOOK )  5164
d -> hookstate = SKINNY_OFFHOOK; 5165
sub -> substate = SUBSTATE_DIALING; 5194
if ( ! ( sub -> substate == SUBSTATE_DIALING || sub -> substate == SUBSTATE_PROGRESS ) )  5202
sub -> substate = SUBSTATE_RINGOUT; 5214
if ( d -> hookstate == SKINNY_ONHOOK )  5225
l -> activesub = sub; 5226
sub -> substate = SUBSTATE_RINGIN; 5233
transmit_callstate ( d , l -> instance , sub -> callid , SKINNY_RINGIN ); 5236
static void transmit_callstate(struct skinny_device *d, int buttonInstance, unsigned callid, int state) 2744
struct skinny_req * req ; 2746
if ( ! ( req = req_alloc ( sizeof ( struct call_state_message ) , CALL_STATE_MESSAGE ) ) )  2748
if ( skinnydebug )  2752
ast_verb ( 3 , ""Transmitting CALL_STATE_MESSAGE to %s - line %d, callid %d, state %s\n"" , d -> name , buttonInstance , callid , callstate2str ( state ) ); 2753
static char *callstate2str(int ind) 2288
char * tmp ; 2290
switch ( ind )  2292
if ( ! ( tmp = ast_threadstorage_get ( & callstate2str_threadbuf , CALLSTATE2STR_BUFSIZE ) ) )  2314
snprintf ( tmp , CALLSTATE2STR_BUFSIZE , ""UNKNOWN-%d"" , ind ); 2316
return tmp ; 2317",0,0
62432,"void bad() 43
wchar_t * data ; 45
wchar_t dataBuffer [ FILENAME_MAX ] = L """" 46
data = dataBuffer; 47
while ( 1 )  48
size_t dataLen = wcslen ( data ) ; 52
FILE * pFile ; 53
if ( FILENAME_MAX - dataLen > 1 )  55
pFile = fopen ( FILENAME , ""r"" ); 57
if ( pFile != NULL )  58
fclose ( pFile ); 67",0,0
149829,"void CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_34_bad() 59
char * data ; 61
char dataBuffer [ 100 ] = """" ; 63
data = dataBuffer; 64
WSADATA wsaData ; 67
int recvResult ; 70
struct sockaddr_in service ; 71
size_t dataLen = strlen ( data ) ; 75
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  79
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 86
if ( listenSocket == INVALID_SOCKET )  87
memset ( & service , 0 , sizeof ( service ) ); 91
service . sin_family = AF_INET; 92
service . sin_addr . s_addr = INADDR_ANY; 93
service . sin_port = htons ( TCP_PORT ); 94
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  95
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )  99
acceptSocket = accept ( listenSocket , NULL , NULL ); 103
if ( acceptSocket == SOCKET_ERROR )  104
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ); 109
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  110
while ( 0 )  128",0,0
74597,"static void goodG2B() 56
char * data ; 58
data = ( char * ) malloc ( 100 * sizeof ( char ) ); 65
data [ 0 ] = '\0'; 66
* dataPtr1 = data; 67
memcpy ( data , source , 100 * sizeof ( char ) ); 76
data [ 100 - 1 ] = '\0'; 77
printLine ( data ); 78
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14
free ( data ); 79",0,0
75174,"static status_transit_state transit_state_singlebyte(struct dfa *d,state_num s,const unsigned char *p,state_num *next_state) 3182
state_num * t ; 3184
state_num works = s ; 3185
status_transit_state rval = TRANSIT_STATE_IN_PROGRESS ; 3186
while ( rval == TRANSIT_STATE_IN_PROGRESS )  3187
if ( ( t = d -> trans [ works ] ) != ( ( void * ) 0 ) )  3188
works = t [ * p ]; 3189
rval = TRANSIT_STATE_DONE; 3190
if ( works < 0 )  3191
works = 0; 3192
if ( works < 0 )  3196
works = 0; 3201
if ( d -> fails [ works ] )  3204
works = d -> fails [ works ] [ * p ]; 3205
rval = TRANSIT_STATE_DONE; 3206
build_state ( works , d ); 3209
static void build_state(state_num s,struct dfa *d) 3027
state_num * trans ; 3030
state_num i ; 3031
if ( d -> trcount >= 1024 )  3036
for (i = 0; i < d -> tralloc; ++i) 3037
d -> trans [ i ] = d -> fails [ i ] = ( ( void * ) 0 ); 3040
d -> trcount = 0; 3042
d -> success [ s ] = 0; 3046
if ( ( ( ( 4 & 1 ? ( * d ) . states [ s ] . constraint & 0xf : 0 ) ) | ( ( 4 & 2 ? ( * d ) . states [ s ] . constraint >> 4 & 0xf : 0 ) ) | ( ( 4 & 4 ? ( * d ) . states [ s ] . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context )  3047
d -> success [ s ] |= 4; 3048
if ( ( ( ( 2 & 1 ? ( * d ) . states [ s ] . constraint & 0xf : 0 ) ) | ( ( 2 & 2 ? ( * d ) . states [ s ] . constraint >> 4 & 0xf : 0 ) ) | ( ( 2 & 4 ? ( * d ) . states [ s ] . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context )  3050
d -> success [ s ] |= 2; 3051
if ( ( ( ( 1 & 1 ? ( * d ) . states [ s ] . constraint & 0xf : 0 ) ) | ( ( 1 & 2 ? ( * d ) . states [ s ] . constraint >> 4 & 0xf : 0 ) ) | ( ( 1 & 4 ? ( * d ) . states [ s ] . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context )  3053
d -> success [ s ] |= 1; 3054
trans = ( ( sizeof ( ( * trans ) ) == 1 ? xmalloc ( ( 1 << 8 ) ) : xnmalloc ( ( 1 << 8 ) , sizeof ( ( * trans ) ) ) ) ); 3057
while ( 0 )  3058
dfastate ( s , d , trans ); 3059
void dfastate(state_num s,struct dfa *d,token trans[]) 2749
leaf_set * grps ; 2752
charclass * labels ; 2754
size_t ngrps = 0 ; 2756
position pos ; 2758
charclass matches ; 2760
int matchesf ; 2762
charclass intersect ; 2764
int intersectf ; 2766
charclass leftovers ; 2768
int leftoversf ; 2770
position_set follows ; 2772
int possible_contexts ; 2776
int separate_contexts ; 2778
state_num state ; 2780
state_num state_newline ; 2782
state_num state_letter ; 2784
size_t i ; 2787
size_t j ; 2788
size_t k ; 2789
grps = ( ( sizeof ( ( * grps ) ) == 1 ? xmalloc ( ( 1 << 8 ) ) : xnmalloc ( ( 1 << 8 ) , sizeof ( ( * grps ) ) ) ) ); 2791
while ( 0 )  2792
labels = ( ( sizeof ( ( * labels ) ) == 1 ? xmalloc ( ( 1 << 8 ) ) : xnmalloc ( ( 1 << 8 ) , sizeof ( ( * labels ) ) ) ) ); 2794
while ( 0 )  2795
for (i = 0; i < d -> states[s] . elems . nelem; ++i) 2797
pos = d -> states [ s ] . elems . elems [ i ]; 2798
if ( d -> tokens [ pos . index ] >= 0 && d -> tokens [ pos . index ] < ( 1 << 8 ) )  2799
if ( d -> tokens [ pos . index ] >= CSET )  2803
if ( pos . constraint != 0x777 )  2826
if ( ! ( ( ( ( 4 & 1 ? pos . constraint & 0xf : 0 ) ) | ( ( 4 & 2 ? pos . constraint >> 4 & 0xf : 0 ) ) | ( ( 4 & 4 ? pos . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context ) )  2827
for (j = 0; j < ((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int )); ++j) 2828
matches [ j ] &= ~newline [ j ]; 2829
if ( ! ( ( ( ( 2 & 1 ? pos . constraint & 0xf : 0 ) ) | ( ( 2 & 2 ? pos . constraint >> 4 & 0xf : 0 ) ) | ( ( 2 & 4 ? pos . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context ) )  2831
for (j = 0; j < ((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int )); ++j) 2832
matches [ j ] &= ~letters [ j ]; 2833
if ( ! ( ( ( ( 1 & 1 ? pos . constraint & 0xf : 0 ) ) | ( ( 1 & 2 ? pos . constraint >> 4 & 0xf : 0 ) ) | ( ( 1 & 4 ? pos . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context ) )  2835
for (j = 0; j < ((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int )); ++j) 2836
matches [ j ] &= letters [ j ] | newline [ j ]; 2837
if ( j == ( ( 1 << 8 ) + 8 * sizeof ( int ) - 1 ) / ( 8 * sizeof ( int ) ) )  2842
for (j = 0; j < ngrps; ++j) 2846
if ( d -> tokens [ pos . index ] >= 0 && d -> tokens [ pos . index ] < ( 1 << 8 ) && ! tstbit ( d -> tokens [ pos . index ] , labels [ j ] ) )  2850
intersectf = 0; 2855
for (k = 0; k < ((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int )); ++k) 2856
( intersect [ k ] = matches [ k ] & labels [ j ] [ k ] ) ? ( intersectf = 1 ) : 0; 2857
if ( ! intersectf )  2858
leftoversf = matchesf = 0; 2862
for (k = 0; k < ((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int )); ++k) 2863
int match = matches [ k ] ; 2865
int label = labels [ j ] [ k ] ; 2866
( leftovers [ k ] = ~match & label ) ? ( leftoversf = 1 ) : 0; 2867
( matches [ k ] = match & ~label ) ? ( matchesf = 1 ) : 0; 2868
if ( leftoversf )  2871
grps [ ngrps ] . elems = ( ( sizeof ( ( * grps [ ngrps ] . elems ) ) == 1 ? xmalloc ( d -> nleaves ) : xnmalloc ( d -> nleaves , sizeof ( ( * grps [ ngrps ] . elems ) ) ) ) ); 2875
while ( 0 )  2876
memcpy ( grps [ ngrps ] . elems , grps [ j ] . elems , sizeof ( grps [ j ] . elems [ 0 ] ) * grps [ j ] . nelem ); 2877
grps [ ngrps ] . nelem = grps [ j ] . nelem; 2878
grps [ j ] . elems [ grps [ j ] . nelem ++ ] = pos . index; 2883
if ( ! matchesf )  2886
if ( j == ngrps )  2892
grps [ ngrps ] . elems = ( ( sizeof ( ( * grps [ ngrps ] . elems ) ) == 1 ? xmalloc ( d -> nleaves ) : xnmalloc ( d -> nleaves , sizeof ( ( * grps [ ngrps ] . elems ) ) ) ) ); 2896
while ( 0 )  2897
grps [ ngrps ] . nelem = 1; 2898
grps [ ngrps ] . elems [ 0 ] = pos . index; 2899
if ( d -> searchflag )  2908
separate_contexts = state_separate_contexts ( ( & follows ) ); 2911
state = state_index ( d , ( & follows ) , separate_contexts ^ 7 ); 2912
if ( separate_contexts & 2 )  2919
state_letter = state_index ( d , ( & follows ) , 2 ); 2920
state_letter = state; 2923
for (i = 0; i < (1 << 8); ++i) 2925
trans [ i ] = ( 1 && ( ( * __ctype_b_loc ( ) ) [ ( int ) i ] & ( ( unsigned short ) _ISalnum ) || i == '_' ) ? state_letter : state ); 2926
for (i = 0; i < (1 << 8); ++i) 2930
trans [ i ] = ( - 1 ); 2931
for (i = 0; i < ngrps; ++i) 2933
follows . nelem = 0; 2934
possible_contexts = charclass_context ( labels [ i ] ); 2972
separate_contexts = state_separate_contexts ( ( & follows ) ); 2973
if ( separate_contexts & possible_contexts & 4 )  2981
state_newline = state_index ( d , ( & follows ) , 4 ); 2982
static state_num state_index(struct dfa *d,const position_set *s,int context) 2311
size_t hash = 0 ; 2313
state_num i ; 2315
state_num j ; 2316
for (i = 0; i < s -> nelem; ++i) 2317
hash ^= s -> elems [ i ] . index + s -> elems [ i ] . constraint; 2318
for (i = 0; i < d -> sindex; ++i) 2320
if ( hash != d -> states [ i ] . hash || s -> nelem != d -> states [ i ] . elems . nelem || context != d -> states [ i ] . context )  2321
if ( j == s -> nelem )  2328
if ( d -> salloc <= d -> sindex + 1 )  2334
size_t new_n_alloc = ( d -> sindex + 1 + ( ! d -> states ) ) ; 2335
d -> states = ( x2nrealloc ( ( d -> states ) , & new_n_alloc , sizeof ( ( * d -> states ) ) ) ); 2336
d -> salloc = new_n_alloc; 2337
while ( 0 )  2339
d -> states [ i ] . hash = hash; 2340
copy ( s , & d -> states [ i ] . elems ); 2342",0,0
33550,"void bad() 31
char * data ; 33
char dataBuffer [ FILENAME_MAX ] = BASEPATH ; 34
data = dataBuffer; 35
size_t dataLen = strlen ( data ) ; 38
FILE * pFile ; 39
if ( FILENAME_MAX - dataLen > 1 )  41
pFile = fopen ( FILENAME , ""r"" ); 43
if ( pFile != NULL )  44
if ( fgets ( data + dataLen , ( int ) ( FILENAME_MAX - dataLen ) , pFile ) == NULL )  47
data [ dataLen ] = '\0'; 51
baseObject -> action ( data ); 58
void CWE23_Relative_Path_Traversal__char_file_ofstream_82_bad::action(char * data) 27
outputFile . open ( ( char * ) data ); 32",0,0
134032,"static void goodB2G1() 143
if ( globalReturnsTrue ( ) )  148
int globalReturnsTrue() 147
return 1 ; 149
WSADATA wsaData ; 152
int recvResult ; 155
struct sockaddr_in service ; 156
char inputBuffer [ CHAR_ARRAY_SIZE ] ; 158
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  162
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 169
if ( connectSocket == INVALID_SOCKET )  170
memset ( & service , 0 , sizeof ( service ) ); 174
service . sin_family = AF_INET; 175
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS ); 176
service . sin_port = htons ( TCP_PORT ); 177
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  178
recvResult = recv ( connectSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 ); 184
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  185
inputBuffer [ recvResult ] = '\0'; 190
data = atoi ( inputBuffer ); 192
while ( 0 )  194
if ( data >= 0 && data < ( 10 ) )  223
buffer [ data ] = 1; 225
printIntLine ( buffer [ i ] ); 229
void printIntLine (int intNumber) 26
printf ( ""%d\n"" , intNumber ); 28
free ( buffer ); 236",0,0
23036,"static void goodG2B2() 83
char * dataBuffer = ( char * ) ALLOCA ( 100 * sizeof ( char ) ) ; 86
memset ( dataBuffer , 'A' , 100 - 1 ); 87
dataBuffer [ 100 - 1 ] = '\0'; 88
data = dataBuffer; 92
strcpy ( data , source ); 99
printLine ( data ); 100
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",0,0
55029,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memmove_81_goodG2B::action(wchar_t * data) const 25
wchar_t source [ 100 ] ; 27
wmemset ( source , L 'C' , 100 - 1 )
source [ 100 - 1 ] = L '\0' 29
memmove ( data , source , 100 * sizeof ( wchar_t ) ); 31
printWLine ( data ); 33
void printWLine (const wchar_t * line) 18
if ( line != NULL )  20
wprintf ( L ""%ls\n"" , line ) 22
delete [ ] data 34",0,0
131725,"static long file_ctrl(BIO *b,int cmd,long num,void *ptr) 295
switch ( cmd )  365
b -> shutdown = ( ( int ) num ) & 0x01; 405
b -> ptr = ptr; 406
b -> init = 1; 407
file_free ( b ); 432
static int file_free(BIO *a) 234
if ( a == ( ( void * ) 0 ) )  236
if ( a -> shutdown )  239
if ( a -> init && a -> ptr != ( ( void * ) 0 ) )  240
if ( a -> flags & 0 )  241
fclose ( ( a -> ptr ) ); 242",0,0
150394,"char *dfaexec(struct dfa *d,const char *begin,char *end,int allow_nl,size_t *count,int *backref) 3556
state_num s ; 3559
state_num s1 ; 3560
const unsigned char * p ; 3562
state_num * * trans ; 3565
state_num * t ; 3566
unsigned char eol = eolbyte ; 3568
unsigned char saved_end ; 3569
s = s1 = 0; 3573
p = ( ( const unsigned char * ) begin ); 3574
trans = d -> trans; 3575
saved_end = * ( ( unsigned char * ) end ); 3576
* end = eol; 3577
if ( d -> mb_cur_max > 1 )  3578
mblen_buf = ( ( sizeof ( ( * mblen_buf ) ) == 1 ? xmalloc ( ( end - begin + 2 ) ) : xnmalloc ( ( end - begin + 2 ) , sizeof ( ( * mblen_buf ) ) ) ) ); 3580
while ( 0 )  3581
if ( d -> mb_cur_max > 1 )  3589
while ( ( t = trans [ s ] ) != ( ( void * ) 0 ) )  3590
if ( p > buf_end )  3591
s1 = s; 3594
if ( s == 0 )  3595
if ( ( ( char * ) p ) >= end )  3598
if ( d -> states [ s ] . mbps . nelem == 0 )  3606
s = t [ * ( p ++ ) ]; 3607
if ( backref )  3614
* end = saved_end; 3618
s = transit_state ( d , s , & p ); 3623
static state_num transit_state(struct dfa *d,state_num s,const unsigned char **pp) 3437
state_num s1 ; 3439
int mbclen ; 3441
int maxlen = 0 ; 3442
size_t i ; 3443
size_t nelem = d -> states [ s ] . mbps . nelem ; 3447
const unsigned char * p1 = * pp ; 3449
wchar_t wc ; 3450
if ( nelem > 0 )  3451
match_lens = check_matching_with_multibyte_ops ( d , s , ( * pp - buf_begin ) ); 3456
static int *check_matching_with_multibyte_ops(struct dfa *d,state_num s,size_t idx) 3357
size_t i ; 3359
int * rarray ; 3360
rarray = ( ( sizeof ( ( * rarray ) ) == 1 ? xmalloc ( d -> states [ s ] . mbps . nelem ) : xnmalloc ( d -> states [ s ] . mbps . nelem , sizeof ( ( * rarray ) ) ) ) ); 3362
while ( 0 )  3363
for (i = 0; i < d -> states[s] . mbps . nelem; ++i) 3364
position pos = d -> states [ s ] . mbps . elems [ i ] ; 3365
switch ( d -> tokens [ pos . index ] )  3366
rarray [ i ] = match_anychar ( d , s , pos , idx ); 3369
static int match_anychar(struct dfa *d,state_num s,position pos,size_t idx) 3232
int context ; 3234
wchar_t wc ; 3235
int mbclen ; 3236
wc = inputwcs [ idx ]; 3237
mbclen = ( mblen_buf [ idx ] == 0 ? 1 : mblen_buf [ idx ] ); 3238
if ( wc == ( ( wchar_t ) eolbyte ) )  3240
if ( ! ( syntax_bits & ( ( unsigned long ) 1 ) << 1 << 1 << 1 << 1 << 1 << 1 ) )  3241
return 0 ; 3242
if ( wc == ( ( wchar_t ) '\0' ) )  3246
if ( syntax_bits & ( ( unsigned long ) 1 ) << 1 << 1 << 1 << 1 << 1 << 1 << 1 )  3247
return 0 ; 3248
context = wchar_context ( wc ); 3252
static int wchar_context(wint_t wc) 636
if ( wc == ( ( wchar_t ) eolbyte ) || wc == 0 )  638
return 4 ; 639
if ( wc == '_' || iswalnum ( wc ) )  641
return 2 ; 642
return 1 ; 644
if ( ! ( ( ( ( context & 1 ? pos . constraint & 0xf : 0 ) ) | ( ( context & 2 ? pos . constraint >> 4 & 0xf : 0 ) ) | ( ( context & 4 ? pos . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context ) )  3253
return 0 ; 3254
return mbclen ; 3256
rarray [ i ] = match_mb_charset ( d , s , pos , idx ); 3374
static int match_mb_charset(struct dfa *d,state_num s,position pos,size_t idx) 3263
size_t i ; 3265
int match ; 3267
int match_len ; 3270
int op_len ; 3272
char buffer [ 128 ] ; 3273
struct mb_char_classes * work_mbc ; 3275
int context ; 3276
wchar_t wc ; 3278
wc = inputwcs [ idx ]; 3279
if ( wc == ( ( wchar_t ) eolbyte ) )  3281
if ( ! ( syntax_bits & ( ( unsigned long ) 1 ) << 1 << 1 << 1 << 1 << 1 << 1 ) )  3282
return 0 ; 3283
if ( wc == ( ( wchar_t ) '\0' ) )  3287
if ( syntax_bits & ( ( unsigned long ) 1 ) << 1 << 1 << 1 << 1 << 1 << 1 << 1 )  3288
return 0 ; 3289
context = wchar_context ( wc ); 3293
static int wchar_context(wint_t wc) 636
if ( wc == ( ( wchar_t ) eolbyte ) || wc == 0 )  638
return 4 ; 639
if ( wc == '_' || iswalnum ( wc ) )  641
return 2 ; 642
return 1 ; 644
if ( ! ( ( ( ( context & 1 ? pos . constraint & 0xf : 0 ) ) | ( ( context & 2 ? pos . constraint >> 4 & 0xf : 0 ) ) | ( ( context & 4 ? pos . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context ) )  3294
return 0 ; 3295
work_mbc = & d -> mbcsets [ d -> multibyte_prop [ pos . index ] >> 2 ]; 3298
match = ! work_mbc -> invert; 3299
match_len = ( mblen_buf [ idx ] == 0 ? 1 : mblen_buf [ idx ] ); 3300
if ( wc < 1 << 8 && work_mbc -> cset != ( - 1 ) && tstbit ( ( ( unsigned char ) wc ) , d -> charclasses [ work_mbc -> cset ] ) )  3302
static int tstbit(unsigned int b,const int c[((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int ))]) 542
return c [ b / ( 8 * sizeof ( int ) ) ] & 1 << b % ( 8 * sizeof ( int ) ) ; 544
for (i = 0; i < work_mbc -> nch_classes; i++) 3306
if ( iswctype ( ( ( wint_t ) wc ) , work_mbc -> ch_classes [ i ] ) )  3307
strncpy ( buffer , ( ( const char * ) buf_begin ) + idx , match_len ); 3311
buffer [ match_len ] = '\0'; 3312
for (i = 0; i < work_mbc -> nequivs; i++) 3314
op_len = ( strlen ( work_mbc -> equivs [ i ] ) ); 3315
strncpy ( buffer , ( ( const char * ) buf_begin ) + idx , op_len ); 3316
buffer [ op_len ] = '\0'; 3317
if ( strcoll ( work_mbc -> equivs [ i ] , buffer ) == 0 )  3318
match_len = op_len; 3319
for (i = 0; i < work_mbc -> ncoll_elems; i++) 3324
op_len = ( strlen ( work_mbc -> coll_elems [ i ] ) ); 3325
strncpy ( buffer , ( ( const char * ) buf_begin ) + idx , op_len ); 3326
buffer [ op_len ] = '\0'; 3327
if ( strcoll ( work_mbc -> coll_elems [ i ] , buffer ) == 0 )  3328
match_len = op_len; 3329
for (i = 0; i < work_mbc -> nranges; i++) 3334
if ( work_mbc -> range_sts [ i ] <= wc && wc <= work_mbc -> range_ends [ i ] )  3335
for (i = 0; i < work_mbc -> nchars; i++) 3340
if ( wc == work_mbc -> chars [ i ] )  3341
match = ! match; 3345
return match ? match_len : 0 ; 3347
return rarray ; 3382
for (i = 0; i < nelem; i++) 3457
if ( match_lens [ i ] > maxlen )  3461
maxlen = match_lens [ i ]; 3462
if ( nelem == 0 || maxlen == 0 )  3466
return s1 ; 3477
wc = inputwcs [ * pp - mbclen - buf_begin ]; 3486
s1 = state_index ( d , ( & follows ) , wchar_context ( wc ) ); 3487
static int wchar_context(wint_t wc) 636
if ( wc == ( ( wchar_t ) eolbyte ) || wc == 0 )  638
return 4 ; 639
if ( wc == '_' || iswalnum ( wc ) )  641
return 2 ; 642
return 1 ; 644
static state_num state_index(struct dfa *d,const position_set *s,int context) 2322
size_t hash = 0 ; 2324
int constraint ; 2325
state_num i ; 2326
state_num j ; 2327
for (i = 0; i < s -> nelem; ++i) 2328
hash ^= s -> elems [ i ] . index + s -> elems [ i ] . constraint; 2329
for (i = 0; i < d -> sindex; ++i) 2331
if ( hash != d -> states [ i ] . hash || s -> nelem != d -> states [ i ] . elems . nelem || context != d -> states [ i ] . context )  2332
if ( j == s -> nelem )  2339
return i ; 2340
if ( d -> salloc <= d -> sindex + 1 )  2345
size_t new_n_alloc = ( d -> sindex + 1 + ( ! d -> states ) ) ; 2346
d -> states = ( x2nrealloc ( ( d -> states ) , & new_n_alloc , sizeof ( ( * d -> states ) ) ) ); 2347
d -> salloc = new_n_alloc; 2348
while ( 0 )  2350
d -> states [ i ] . hash = hash; 2351
d -> states [ i ] . context = context; 2354
d -> states [ i ] . backref = 0; 2355
d -> states [ i ] . constraint = 0; 2356
d -> states [ i ] . first_end = 0; 2357
if ( 1 )  2358
d -> states [ i ] . mbps . nelem = 0; 2359
d -> states [ i ] . mbps . elems = ( ( void * ) 0 ); 2360
for (j = 0; j < s -> nelem; ++j) 2362
if ( d -> tokens [ s -> elems [ j ] . index ] < 0 )  2363
constraint = s -> elems [ j ] . constraint; 2364
if ( ( ( ( 7 & 1 ? constraint & 0xf : 0 ) ) | ( ( 7 & 2 ? constraint >> 4 & 0xf : 0 ) ) | ( ( 7 & 4 ? constraint >> 8 & 0xf : 0 ) ) ) & context )  2365
d -> states [ i ] . constraint |= constraint; 2366
if ( ! d -> states [ i ] . first_end )  2368
d -> states [ i ] . first_end = d -> tokens [ s -> elems [ j ] . index ]; 2369
if ( d -> tokens [ s -> elems [ j ] . index ] == BACKREF )  2373
d -> states [ i ] . constraint = 0x777; 2374
d -> states [ i ] . backref = 1; 2375
return i ; 2379
while ( * pp - p1 < maxlen )  3489
wc = inputwcs [ * pp - mbclen - buf_begin ]; 3497
s1 = state_index ( d , ( & follows ) , wchar_context ( wc ) ); 3498
static int wchar_context(wint_t wc) 636
if ( wc == ( ( wchar_t ) eolbyte ) || wc == 0 )  638
return 4 ; 639
if ( wc == '_' || iswalnum ( wc ) )  641
return 2 ; 642
return 1 ; 644
static state_num state_index(struct dfa *d,const position_set *s,int context) 2322
size_t hash = 0 ; 2324
int constraint ; 2325
state_num i ; 2326
state_num j ; 2327
hash ^= s -> elems [ i ] . index + s -> elems [ i ] . constraint; 2329
if ( hash != d -> states [ i ] . hash || s -> nelem != d -> states [ i ] . elems . nelem || context != d -> states [ i ] . context )  2332
if ( j == s -> nelem )  2339
return i ; 2340
if ( d -> salloc <= d -> sindex + 1 )  2345
size_t new_n_alloc = ( d -> sindex + 1 + ( ! d -> states ) ) ; 2346
d -> states = ( x2nrealloc ( ( d -> states ) , & new_n_alloc , sizeof ( ( * d -> states ) ) ) ); 2347
d -> salloc = new_n_alloc; 2348
while ( 0 )  2350
d -> states [ i ] . hash = hash; 2351
d -> states [ i ] . context = context; 2354
d -> states [ i ] . backref = 0; 2355
d -> states [ i ] . constraint = 0; 2356
d -> states [ i ] . first_end = 0; 2357
if ( 1 )  2358
d -> states [ i ] . mbps . nelem = 0; 2359
d -> states [ i ] . mbps . elems = ( ( void * ) 0 ); 2360
if ( d -> tokens [ s -> elems [ j ] . index ] < 0 )  2363
constraint = s -> elems [ j ] . constraint; 2364
if ( ( ( ( 7 & 1 ? constraint & 0xf : 0 ) ) | ( ( 7 & 2 ? constraint >> 4 & 0xf : 0 ) ) | ( ( 7 & 4 ? constraint >> 8 & 0xf : 0 ) ) ) & context )  2365
d -> states [ i ] . constraint |= constraint; 2366
if ( ! d -> states [ i ] . first_end )  2368
d -> states [ i ] . first_end = d -> tokens [ s -> elems [ j ] . index ]; 2369
if ( d -> tokens [ s -> elems [ j ] . index ] == BACKREF )  2373
d -> states [ i ] . constraint = 0x777; 2374
d -> states [ i ] . backref = 1; 2375
return i ; 2379
return s1 ; 3503
trans = d -> trans; 3624
while ( ( t = trans [ s ] ) != ( ( void * ) 0 ) )  3628
s1 = t [ * ( p ++ ) ]; 3629
if ( ( t = trans [ s1 ] ) == ( ( void * ) 0 ) )  3630
state_num tmp = s ; 3631
s = s1; 3632
s1 = tmp; 3634
s = t [ * ( p ++ ) ]; 3637
if ( s >= 0 && ( ( char * ) p ) <= end && d -> fails [ s ] )  3640
if ( d -> success [ s ] & sbit [ * p ] )  3641
s1 = s; 3652
if ( d -> mb_cur_max > 1 )  3653
s = transit_state ( d , s , & p ); 3656
static state_num transit_state(struct dfa *d,state_num s,const unsigned char **pp) 3437
state_num s1 ; 3439
int mbclen ; 3441
int maxlen = 0 ; 3442
size_t i ; 3443
size_t nelem = d -> states [ s ] . mbps . nelem ; 3447
const unsigned char * p1 = * pp ; 3449
wchar_t wc ; 3450
if ( nelem > 0 )  3451
match_lens = check_matching_with_multibyte_ops ( d , s , ( * pp - buf_begin ) ); 3456
if ( match_lens [ i ] > maxlen )  3461
maxlen = match_lens [ i ]; 3462
if ( nelem == 0 || maxlen == 0 )  3466
return s1 ; 3477
wc = inputwcs [ * pp - mbclen - buf_begin ]; 3486
s1 = state_index ( d , ( & follows ) , wchar_context ( wc ) ); 3487
while ( * pp - p1 < maxlen )  3489
wc = inputwcs [ * pp - mbclen - buf_begin ]; 3497
s1 = state_index ( d , ( & follows ) , wchar_context ( wc ) ); 3498
return s1 ; 3503
trans = d -> trans; 3657
s = d -> fails [ s ] [ * ( p ++ ) ]; 3660
if ( ( ( char * ) p ) > end )  3674
if ( d -> mb_cur_max > 1 )  3675
free ( mblen_buf ); 3676
if ( s >= 0 )  3682
trans = d -> trans; 3684
if ( p [ - 1 ] == eol && allow_nl )  3687
s = d -> newlines [ s1 ]; 3688
s = 0; 3691",0,0
127657,"void dfacomp(const char *s,size_t len,struct dfa *d,int searchflag) 3768
dfaanalyze ( d , searchflag ); 3774
void dfaanalyze(struct dfa *d,int searchflag) 2542
position_set merged ; 2557
size_t i ; 2565
d -> searchflag = searchflag; 2570
d -> follows = ( ( sizeof ( ( * d -> follows ) ) == 1 ? xzalloc ( d -> tindex ) : xcalloc ( d -> tindex , sizeof ( ( * d -> follows ) ) ) ) ); 2593
while ( 0 )  2594
for (i = 0; i < d -> tindex; ++i) 2703
if ( d -> tokens [ i ] < ( 1 << 8 ) || d -> tokens [ i ] == BACKREF || d -> tokens [ i ] == ANYCHAR || d -> tokens [ i ] == MBCSET || d -> tokens [ i ] >= CSET )  2704
epsclosure ( & merged , d ); 2711
static void epsclosure(position_set *s,const struct dfa *d) 2387
char * visited ; 2392
visited = ( ( sizeof ( ( * visited ) ) == 1 ? xzalloc ( d -> tindex ) : xcalloc ( d -> tindex , sizeof ( ( * visited ) ) ) ) ); 2396
while ( 0 )  2397
p . constraint = old . constraint; 2404
if ( visited [ old . index ] )  2406
visited [ old . index ] = 1; 2410
switch ( d -> tokens [ old . index ] )  2411
p . constraint &= 0x444; 2414
p . constraint &= 0x700; 2419
p . constraint &= 0x050; 2424
p . constraint &= 0x202; 2429
p . constraint &= 0x252; 2434
p . constraint &= 0x525; 2439
for (j = 0; j < d -> follows[old . index] . nelem; ++j) 2445
p . index = d -> follows [ old . index ] . elems [ j ] . index; 2446
insert ( p , s ); 2447
free ( visited ); 2452",0,0
56567,"static void goodB2G() 251
wchar_t * password ; 253
wchar_t passwordBuffer [ 100 ] = L """" 254
password = passwordBuffer; 255
WSADATA wsaData ; 257
int recvResult ; 259
struct sockaddr_in service ; 260
size_t passwordLen = wcslen ( password ) ; 263
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  266
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 271
if ( connectSocket == INVALID_SOCKET )  272
memset ( & service , 0 , sizeof ( service ) ); 276
service . sin_family = AF_INET; 277
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS ); 278
service . sin_port = htons ( TCP_PORT ); 279
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  280
recvResult = recv ( connectSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( wchar_t ) , 0 ); 287
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  288
while ( 0 )  306",0,0
166431,"static void goodG2B() 59
char * data ; 61
CWE127_Buffer_Underread__char_declare_ncpy_34_unionType myUnion ; 62
char dataBuffer [ 100 ] ; 63
memset ( dataBuffer , 'A' , 100 - 1 ); 64
dataBuffer [ 100 - 1 ] = '\0'; 65
data = dataBuffer; 67
myUnion . unionFirst = data; 68
char * data = myUnion . unionSecond ; 70
char dest [ 100 ] ; 72
memset ( dest , 'C' , 100 - 1 ); 73
dest [ 100 - 1 ] = '\0'; 74
strncpy ( dest , data , strlen ( dest ) ); 76
dest [ 100 - 1 ] = '\0'; 78
printLine ( dest ); 79
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",0,0
164245,"void CWE78_OS_Command_Injection__char_file_w32_spawnlp_10_bad() 46
char * data ; 48
char dataBuffer [ 100 ] = """" ; 49
data = dataBuffer; 50
if ( globalTrue )  51
size_t dataLen = strlen ( data ) ; 55
FILE * pFile ; 56
if ( 100 - dataLen > 1 )  58
pFile = fopen ( FILENAME , ""r"" ); 60
if ( pFile != NULL )  61
if ( fgets ( data + dataLen , ( int ) ( 100 - dataLen ) , pFile ) == NULL )  64
data [ dataLen ] = '\0'; 68",0,0
126846,"void bad() 33
wchar_t * data ; 35
wchar_t dataBuffer [ 100 ] = L """" 36
data = dataBuffer; 37
size_t dataLen = wcslen ( data ) ; 40
wchar_t * environment = GETENV ( ENV_VARIABLE ) ; 41
if ( environment != NULL )  43
wcsncat ( data + dataLen , environment , 100 - dataLen - 1 ); 46
CWE114_Process_Control__w32_wchar_t_environment_82_base * baseObject = new CWE114_Process_Control__w32_wchar_t_environment_82_bad 49
baseObject -> action ( data ); 50
void CWE114_Process_Control__w32_wchar_t_environment_82_bad::action(wchar_t * data) 26
HMODULE hModule ; 29
hModule = LoadLibraryW ( data ); 32
if ( hModule != NULL )  33
FreeLibrary ( hModule ); 35",20,1
19900,"static int stonesoup_ev_handler(struct mg_connection *conn, enum mg_event ev) 245
char * ifmatch_header ; 246
char * stonesoup_tainted_buff ; 247
int buffer_size = 1000 ; 248
if ( ev == MG_REQUEST )  250
ifmatch_header = ( char * ) mg_get_header ( conn , ""if-match"" ); 251
if ( strcmp ( ifmatch_header , ""weak_taint_source_value"" ) == 0 )  252
while ( 1 )  253
stonesoup_tainted_buff = ( char * ) malloc ( buffer_size * sizeof ( char ) ); 254
data_size = mg_get_var ( conn , ""data"" , stonesoup_tainted_buff , buffer_size * sizeof ( char ) ); 256
if ( data_size < buffer_size )  257
buffer_size = buffer_size * 2; 261
stonesoup_handle_taint ( stonesoup_tainted_buff ); 265
void stonesoup_handle_taint(char *scarletberry_morra) 1506
long frolick_ashok [ 10 ] ; 1514
char * osi_talismans [ 10 ] = { 0 } ; 1515
if ( scarletberry_morra != 0 )  1519
cotoro_ambusher = ( ( int ) ( strlen ( scarletberry_morra ) ) ); 1520
deutsch_upgrading = ( ( char * ) ( malloc ( cotoro_ambusher + 1 ) ) ); 1521
memset ( deutsch_upgrading , 0 , cotoro_ambusher + 1 ); 1526
memcpy ( deutsch_upgrading , scarletberry_morra , cotoro_ambusher ); 1527
osi_talismans [ 5 ] = deutsch_upgrading; 1530
frolick_ashok [ 1 ] = 5; 1531
terrierlike_thay = * ( osi_talismans + frolick_ashok [ 1 ] ); 1532
potentiated_tumbledown = ( ( char * ) terrierlike_thay ); 1542
stonesoup_pFile = fopen ( potentiated_tumbledown , ""r"" ); 1546
tracepoint ( stonesoup_trace , variable_address , ""stonesoup_pFile"" , stonesoup_pFile , ""TRIGGER-STATE"" ); 1550
fgets ( stonesoup_buffer , 79 , stonesoup_pFile ); 1552
stonesoup_printf ( stonesoup_buffer ); 1553
void stonesoup_printf(char * format, ...) 235
va_start ( argptr , format ); 238
mg_vprintf_data ( ( struct mg_connection * ) stonesoup_printf_context , format , argptr ); 239
fclose ( stonesoup_pFile ); 1555",476,1
8693,"void CWE124_Buffer_Underwrite__char_alloca_ncpy_13_bad() 23
char * dataBuffer = ( char * ) ALLOCA ( 100 * sizeof ( char ) ) ; 26
memset ( dataBuffer , 'A' , 100 - 1 ); 27
dataBuffer [ 100 - 1 ] = '\0'; 28
data = dataBuffer - 8; 32
strncpy ( data , source , 100 - 1 ); 39
data [ 100 - 1 ] = '\0'; 41
printLine ( data ); 42
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",119,1
123741,"void CWE124_Buffer_Underwrite__malloc_char_ncpy_81_bad::action(char * data) const 25
char source [ 100 ] ; 27
memset ( source , 'C' , 100 - 1 ); 28
source [ 100 - 1 ] = '\0'; 29
strncpy ( data , source , 100 - 1 ); 31
data [ 100 - 1 ] = '\0'; 33
printLine ( data ); 34
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",119,1
5379,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_snprintf_07_bad() 35
char * data ; 37
char * dataBuffer = ( char * ) ALLOCA ( 100 * sizeof ( char ) ) ; 38
data = dataBuffer; 39
if ( staticFive == 5 )  40
memset ( data , 'A' , 100 - 1 ); 43
data [ 100 - 1 ] = '\0'; 44
SNPRINTF ( dest , strlen ( data ) , ""%s"" , data ); 49
printLine ( data ); 50
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",119,1
83163,"void bad() 31
int i ; 33
wchar_t * data ; 34
data = NULL; 35
for(i = 0; i < 1; i++) 36
data = new wchar_t [ 10 ]; 39
wchar_t source [ 10 + 1 ] = SRC_STRING ; 42
memcpy ( data , source , ( wcslen ( source ) + 1 ) * sizeof ( wchar_t ) ); 45
printWLine ( data ); 46
void printWLine (const wchar_t * line) 18
if ( line != NULL )  20
wprintf ( L ""%ls\n"" , line ) 22
delete [ ] data 47",119,1
137378,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memcpy_18_bad() 23
char * data ; 25
char dataBadBuffer [ 50 ] ; 26
data = dataBadBuffer; 32
data [ 0 ] = '\0'; 33
char source [ 100 ] ; 35
memset ( source , 'C' , 100 - 1 ); 36
source [ 100 - 1 ] = '\0'; 37
memcpy ( data , source , 100 * sizeof ( char ) ); 39
data [ 100 - 1 ] = '\0'; 40
printLine ( data ); 41
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",119,1
100644,"void suilmann_enterorrhexis(int harmlessnesses_overwander,void *refashioned_cankery) 3223
monotrochal_unannoyingly ( harmlessnesses_overwander , refashioned_cankery ); 3226
void monotrochal_unannoyingly(int unpumpable_uspoke,void *beflatter_dunarea) 3178
unpumpable_uspoke --; 3184
if ( unpumpable_uspoke > 0 )  3185
suilmann_enterorrhexis ( unpumpable_uspoke , beflatter_dunarea ); 3186
void suilmann_enterorrhexis(int harmlessnesses_overwander,void *refashioned_cankery) 3223
monotrochal_unannoyingly ( harmlessnesses_overwander , refashioned_cankery ); 3226
void monotrochal_unannoyingly(int unpumpable_uspoke,void *beflatter_dunarea) 3178
int stonesoup_size = 0 ; 3181
unpumpable_uspoke --; 3184
if ( unpumpable_uspoke > 0 )  3185
stonesoup_second_buff = malloc ( ( stonesoup_size + 1 ) * sizeof ( char ) ); 3201
if ( stonesoup_second_buff == 0 )  3202
strcpy ( stonesoup_second_buff , cosmosophy_membranously ); 3208
stonesoup_476_global_variable = strlen ( stonesoup_second_buff ); 3209
if ( stonesoup_second_buff != 0 )  3212
free ( stonesoup_second_buff ); 3213",476,1
117829,"void CWE127_Buffer_Underread__CWE839_listen_socket_01_bad() 44
WSADATA wsaData ; 51
int recvResult ; 54
struct sockaddr_in service ; 55
char inputBuffer [ CHAR_ARRAY_SIZE ] ; 58
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  62
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 69
if ( listenSocket == INVALID_SOCKET )  70
memset ( & service , 0 , sizeof ( service ) ); 74
service . sin_family = AF_INET; 75
service . sin_addr . s_addr = INADDR_ANY; 76
service . sin_port = htons ( TCP_PORT ); 77
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  78
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )  82
acceptSocket = accept ( listenSocket , NULL , NULL ); 86
if ( acceptSocket == SOCKET_ERROR )  87
recvResult = recv ( acceptSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 ); 92
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  93
inputBuffer [ recvResult ] = '\0'; 98
data = atoi ( inputBuffer ); 100
while ( 0 )  102
if ( data < 10 )  122
printIntLine ( buffer [ data ] ); 124
void printIntLine (int intNumber) 26
printf ( ""%d\n"" , intNumber ); 28",119,1
171352,"void CWE126_Buffer_Overread__malloc_char_memcpy_66_bad() 26
char * data ; 28
char * dataArray [ 5 ] ; 29
data = NULL; 30
data = ( char * ) malloc ( 50 * sizeof ( char ) ); 32
memset ( data , 'A' , 50 - 1 ); 33
data [ 50 - 1 ] = '\0'; 34
dataArray [ 2 ] = data; 36
CWE126_Buffer_Overread__malloc_char_memcpy_66b_badSink ( dataArray ); 37
void CWE126_Buffer_Overread__malloc_char_memcpy_66b_badSink(char * dataArray[]) 23
char * data = dataArray [ 2 ] ; 26
char dest [ 100 ] ; 28
memset ( dest , 'C' , 100 - 1 ); 29
dest [ 100 - 1 ] = '\0'; 30
memcpy ( dest , data , strlen ( dest ) * sizeof ( char ) ); 33
dest [ 100 - 1 ] = '\0'; 34
printLine ( dest ); 35
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",119,1
118911,"void CWE124_Buffer_Underwrite__wchar_t_alloca_memmove_04_bad() 30
wchar_t * data ; 32
wchar_t * dataBuffer = ( wchar_t * ) ALLOCA ( 100 * sizeof ( wchar_t ) ) ; 33
wmemset ( dataBuffer , L 'A' , 100 - 1 )
dataBuffer [ 100 - 1 ] = L '\0' 35
if ( STATIC_CONST_TRUE )  36
data = dataBuffer - 8; 39
wchar_t source [ 100 ] ; 42
wmemset ( source , L 'C' , 100 - 1 )
source [ 100 - 1 ] = L '\0' 44
memmove ( data , source , 100 * sizeof ( wchar_t ) ); 46
printWLine ( data ); 49
void printWLine (const wchar_t * line) 18
if ( line != NULL )  20
wprintf ( L ""%ls\n"" , line ) 22",119,1
17857,"void CWE78_OS_Command_Injection__char_file_system_01_bad() 42
char * data ; 44
char data_buf [ 100 ] = FULL_COMMAND ; 45
data = data_buf; 46
size_t dataLen = strlen ( data ) ; 49
FILE * pFile ; 50
if ( 100 - dataLen > 1 )  52
pFile = fopen ( FILENAME , ""r"" ); 54
if ( pFile != NULL )  55
if ( fgets ( data + dataLen , ( int ) ( 100 - dataLen ) , pFile ) == NULL )  58
data [ dataLen ] = '\0'; 62
fclose ( pFile ); 64
if ( SYSTEM ( data ) <= 0 )  69",74,1
29789,"void CWE194_Unexpected_Sign_Extension__rand_strncpy_67b_badSink(CWE194_Unexpected_Sign_Extension__rand_strncpy_67_structType myStruct) 26
char source [ 100 ] ; 30
memset ( source , 'A' , 100 - 1 ); 32
source [ 100 - 1 ] = '\0'; 33
strncpy ( dest , source , data ); 38
dest [ data ] = '\0'; 39
printLine ( dest ); 41
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",704,1
45944,"void CWE416_Use_After_Free__malloc_free_struct_10_bad() 24
twoIntsStruct * data ; 26
if ( globalTrue )  29
data = ( twoIntsStruct * ) malloc ( 100 * sizeof ( twoIntsStruct ) ); 31
data [ i ] . intOne = 1; 36
data [ i ] . intTwo = 2; 37
free ( data ); 41
printStructLine ( & data [ 0 ] ); 46
void printStructLine (const twoIntsStruct * structTwoIntsStruct) 86
printf ( ""%d -- %d\n"" , structTwoIntsStruct -> intOne , structTwoIntsStruct -> intTwo ); 88",119,1
75226,"void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_memmove_12_bad() 23
char source [ 100 ] ; 40
memset ( source , 'C' , 100 - 1 ); 41
source [ 100 - 1 ] = '\0'; 42
memmove ( data , source , 100 * sizeof ( char ) ); 44
data [ 100 - 1 ] = '\0'; 45
printLine ( data ); 46
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14
free ( data ); 47",119,1
71069,"void bad() 26
wchar_t * data ; 28
wchar_t * & dataRef = data ; 29
wchar_t * dataBadBuffer = ( wchar_t * ) ALLOCA ( 50 * sizeof ( wchar_t ) ) ; 30
data = dataBadBuffer; 34
data [ 0 ] = L '\0' 35
wchar_t * data = dataRef ; 37
wchar_t source [ 100 ] ; 39
wmemset ( source , L 'C' , 100 - 1 )
source [ 100 - 1 ] = L '\0' 41
wcsncpy ( data , source , 100 - 1 ); 43
printWLine ( data ); 45
void printWLine (const wchar_t * line) 18
if ( line != NULL )  20
wprintf ( L ""%ls\n"" , line ) 22",119,1
83715,"void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_loop_66b_badSink(char * dataArray[]) 23
char source [ 100 ] ; 29
memset ( source , 'C' , 100 - 1 ); 30
source [ 100 - 1 ] = '\0'; 31
data [ i ] = source [ i ]; 35
data [ 100 - 1 ] = '\0'; 37
printLine ( data ); 38
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14
free ( data ); 39",119,1
72206,"void CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cat_17_bad() 23
int i ; 25
wchar_t * data ; 26
wchar_t * dataBuffer = ( wchar_t * ) ALLOCA ( 100 * sizeof ( wchar_t ) ) ; 27
data = dataBuffer; 28
for(i = 0; i < 1; i++) 29
wmemset ( data , L 'A' , 100 - 1 )
data [ 100 - 1 ] = L '\0' 33
wchar_t dest [ 50 ] = L """" 36
wcscat ( dest , data ); 38",119,1
115538,"void CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_68_bad() 41
char * password ; 43
char passwordBuffer [ 100 ] = """" ; 44
password = passwordBuffer; 45
WSADATA wsaData ; 47
int recvResult ; 49
struct sockaddr_in service ; 50
char * replace ; 51
size_t passwordLen = strlen ( password ) ; 53
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  56
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 61
if ( connectSocket == INVALID_SOCKET )  62
memset ( & service , 0 , sizeof ( service ) ); 66
service . sin_family = AF_INET; 67
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS ); 68
service . sin_port = htons ( TCP_PORT ); 69
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  70
recvResult = recv ( connectSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( char ) , 0 ); 77
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  78
password [ passwordLen + recvResult / sizeof ( char ) ] = '\0'; 83
replace = strchr ( password , '\n' ); 90
if ( replace )  91
* replace = '\0'; 93
while ( 0 )  96",311,1
140572,"void bad() 40
char * data ; 42
char dataBuffer [ FILENAME_MAX ] = """" ; 44
data = dataBuffer; 45
size_t dataLen = strlen ( data ) ; 48
if ( FILENAME_MAX - dataLen > 1 )  50
if ( fgets ( data + dataLen , ( int ) ( FILENAME_MAX - dataLen ) , stdin ) != NULL )  53
dataLen = strlen ( data ); 57
if ( dataLen > 0 && data [ dataLen - 1 ] == '\n' )  58
data [ dataLen - 1 ] = '\0'; 60
data [ dataLen ] = '\0'; 67
myUnion . unionFirst = data; 71
char * data = myUnion . unionSecond ; 73
pFile = FOPEN ( data , ""wb+"" ); 77
if ( pFile != NULL )  78
fclose ( pFile ); 80",706,1
65507,"void CWE78_OS_Command_Injection__char_environment_popen_09_bad() 47
char * data ; 49
char data_buf [ 100 ] = FULL_COMMAND ; 50
data = data_buf; 51
if ( GLOBAL_CONST_TRUE )  52
size_t dataLen = strlen ( data ) ; 56
strncat ( data + dataLen , environment , 100 - dataLen - 1 ); 62
pipe = POPEN ( data , ""wb"" ); 69
if ( pipe != NULL )  70
PCLOSE ( pipe ); 72",74,1
176040,"int main(int argc, char *argv[]) 42
short badAlloc = 0 ; 44
if ( argc > 1 )  46
const unsigned int nbArgs = argc - 1 ; 48
if ( ( fileNames = ( char * * ) malloc ( ( nbArgs ) * sizeof ( char * * ) ) ) == NULL )  49
for (unsigned int i=0;i<nbArgs;++i) 51
if ( ! ( fileNames [ i ] = ( char * ) malloc ( 256 * sizeof ( char ) ) ) )  54
badAlloc = 1; 55
if ( ! badAlloc )  60
for (unsigned int i=0;i<nbArgs;++i) 62
if ( printFile ( fileNames [ i ] ) )  63
int printFile(const char *fileName) 23
if ( fp = fopen ( fileName , ""r"" ) )  26
char buffer [ 512 ] ; 28
while ( fgets ( buffer , 512 , fp ) )  31
printf ( ""%3d: %s"" , ++ lNumber , buffer ); 33",706,1
17669,"void CWE367_TOC_TOU__access_10_bad() 44
if ( globalTrue )  46
char filename [ 100 ] = """" ; 49
if ( fgets ( filename , 100 , stdin ) == NULL )  51
filename [ 0 ] = '\0'; 55
if ( strlen ( filename ) > 0 )  57
filename [ strlen ( filename ) - 1 ] = '\0'; 59
if ( ACCESS ( filename , W_OK ) == - 1 )  62
fileDesc = OPEN ( filename , O_RDWR ); 66
if ( fileDesc == - 1 )  67
if ( WRITE ( fileDesc , BAD_SINK_STRING , strlen ( BAD_SINK_STRING ) ) == - 1 )  71
if ( fileDesc != - 1 )  75
CLOSE ( fileDesc ); 77",362,1
142743,"static void dfamust(struct dfa *d) 4035
int stonesoup_opt_var ; 4038
char stonesoup_source [ 1024 ] ; 4039
char * whished_depasturation ; 4042
if ( __sync_bool_compare_and_swap ( & indianisation_nonfinite , 0 , 1 ) )  4053
if ( mkdir ( ""/opt/stonesoup/workspace/lockDir"" , 509U ) == 0 )  4054
whished_depasturation = getenv ( ""UNIVERSOLOGY_KEY"" ); 4057
if ( whished_depasturation != 0 )  4058
bin_nonchalantness = ( ( char * ) whished_depasturation ); 4059
stonesoup_data = ( struct stonesoup_struct * ) malloc ( sizeof ( struct stonesoup_struct ) ); 4061
if ( stonesoup_data != NULL )  4062
memset ( stonesoup_source , 0 , 1024 ); 4063
memset ( stonesoup_data -> buffer , 65 , 64 ); 4064
stonesoup_data -> buffer [ 64 - 1 ] = '\0'; 4065
stonesoup_data -> buff_pointer = stonesoup_data -> buffer; 4066
strncpy ( stonesoup_source , bin_nonchalantness , sizeof ( stonesoup_source ) ); 4067
stonesoup_source [ 1023 ] = '\0'; 4068
if ( strlen ( stonesoup_source ) + 1 <= 64 )  4069
strncpy ( stonesoup_data -> buffer , stonesoup_source , sizeof ( stonesoup_source ) ); 4076
stonesoup_opt_var = strlen ( stonesoup_data -> buff_pointer ); 4080
for (; stonesoup_oc_i < stonesoup_opt_var; ++stonesoup_oc_i) 4081",119,1
54777,"void bad() 25
char * data ; 27
data = ( char * ) malloc ( 100 * sizeof ( char ) ); 28
memset ( data , 'A' , 100 - 1 ); 30
data [ 100 - 1 ] = '\0'; 31
CWE122_Heap_Based_Buffer_Overflow__c_src_char_cpy_82_base * baseObject = new CWE122_Heap_Based_Buffer_Overflow__c_src_char_cpy_82_bad 32
baseObject -> action ( data ); 33
void CWE122_Heap_Based_Buffer_Overflow__c_src_char_cpy_82_bad::action(char * data) 24
char dest [ 50 ] = """" ; 27
strcpy ( dest , data ); 29",119,1
6935,"void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_loop_22_bad() 28
wchar_t * data ; 30
data = NULL; 31
data = CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_loop_22_badSource ( data ); 33
wchar_t * CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_loop_22_badSource(wchar_t * data) 26
if ( CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_loop_22_badGlobal )  28
data = ( wchar_t * ) malloc ( 50 * sizeof ( wchar_t ) ); 31
data [ 0 ] = L '\0' 32
return data ; 34
size_t i ; 35
wchar_t source [ 100 ] ; 36
wmemset ( source , L 'C' , 100 - 1 )
source [ 100 - 1 ] = L '\0' 38
for (i = 0; i < 100; i++) 40
data [ i ] = source [ i ]; 42
data [ 100 - 1 ] = L '\0' 44
free ( data ); 46",119,1
98768,"void CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime__listen_accept_bind_07_bad() 49
if ( staticFive == 5 )  51
char data [ 100 ] = """" ; 54
WSADATA wsaData ; 56
int recvResult ; 59
struct sockaddr_in service ; 60
char * replace ; 61
size_t dataLen = strlen ( data ) ; 64
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  68
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 74
if ( listenSocket == INVALID_SOCKET )  75
memset ( & service , 0 , sizeof ( service ) ); 79
service . sin_family = AF_INET; 80
service . sin_addr . s_addr = INADDR_ANY; 81
service . sin_port = htons ( TCP_PORT ); 82
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )  84
acceptSocket = accept ( listenSocket , NULL , NULL ); 88
if ( acceptSocket == SOCKET_ERROR )  89
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  93
recvResult = recv ( acceptSocket , ( char * ) data + dataLen , ( int ) ( 100 - dataLen - 1 ) , 0 ); 98
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  99
data [ recvResult ] = '\0'; 104
replace = strchr ( data , '\n' ); 111
if ( replace )  112
* replace = '\0'; 114
while ( 0 )  117",666,1
101712,"static int handle_message(struct skinny_req *req, struct skinnysession *s) 6590
struct skinny_speeddial * sd ; 6593
struct skinny_device * d = s -> device ; 6594
if ( ( ! s -> device ) && ( letohl ( req -> e ) != REGISTER_MESSAGE && letohl ( req -> e ) != ALARM_MESSAGE ) )  6596
switch ( letohl ( req -> e ) )  6606
if ( sd = find_speeddial_by_instance ( s -> device , letohl ( req -> data . speeddialreq . speedDialNumber ) , 0 ) )  6692
static struct skinny_speeddial *find_speeddial_by_instance(struct skinny_device *d, int instance, int isHint) 1878
struct skinny_speeddial * sd ; 1880
return sd ; 1890
transmit_speeddialstatres ( d , sd ); 6693
static void transmit_speeddialstatres(struct skinny_device *d, struct skinny_speeddial *sd) 2807
struct skinny_req * req ; 2809
if ( ! ( req = req_alloc ( sizeof ( struct speed_dial_stat_res_message ) , SPEED_DIAL_STAT_RES_MESSAGE ) ) )  2811
static struct skinny_req *req_alloc(size_t size, int response_message) 1675
struct skinny_req * req ; 1677
if ( ! ( req = ast_calloc ( 1 , skinny_header_size + size + 4 ) ) )  1679
return NULL ; 1680
req -> len = htolel ( size + 4 ); 1682
req -> e = htolel ( response_message ); 1683
return req ; 1685
req -> data . speeddialreq . speedDialNumber = htolel ( sd -> instance ); 2814
transmit_response ( d , req ); 2818
static void transmit_response(struct skinny_device *d, struct skinny_req *req) 2363
transmit_response_bysession ( d -> session , req ); 2365
static int transmit_response_bysession(struct skinnysession *s, struct skinny_req *req) 2323
if ( ! s )  2327
if ( ( letohl ( req -> len ) > SKINNY_MAX_PACKET ) || ( letohl ( req -> len ) < 0 ) )  2336
memset ( s -> outbuf , 0 , sizeof ( s -> outbuf ) ); 2342
memcpy ( s -> outbuf , req , skinny_header_size ); 2343
memcpy ( s -> outbuf + skinny_header_size , & req -> data , letohl ( req -> len ) ); 2344
res = write ( s -> fd , s -> outbuf , letohl ( req -> len ) + 8 ); 2346
if ( res != letohl ( req -> len ) + 8 )  2348
ast_log ( LOG_WARNING , ""Transmit: write only sent %d out of %d bytes: %s\n"" , res , letohl ( req -> len ) + 8 , strerror ( errno ) ); 2349
if ( res == - 1 )  2350
skinny_unregister ( NULL , s ); 2353
ast_mutex_unlock ( & s -> lock ); 2359",476,1
180790,"void bad() 41
char * data ; 43
char dataBuffer [ FILENAME_MAX ] = BASEPATH ; 44
data = dataBuffer; 45
switch ( 6 )  46
size_t dataLen = strlen ( data ) ; 51
char * environment = GETENV ( ENV_VARIABLE ) ; 52
if ( environment != NULL )  54
strncat ( data + dataLen , environment , FILENAME_MAX - dataLen - 1 ); 57
hFile = CreateFileA ( data , ( GENERIC_WRITE | GENERIC_READ ) , 0 , NULL , OPEN_ALWAYS , FILE_ATTRIBUTE_NORMAL , NULL ); 69
if ( hFile != INVALID_HANDLE_VALUE )  76
CloseHandle ( hFile ); 78",706,1
17944,"void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_connect_socket_04_bad() 50
if ( STATIC_CONST_TRUE )  55
WSADATA wsaData ; 59
int recvResult ; 62
struct sockaddr_in service ; 63
char inputBuffer [ CHAR_ARRAY_SIZE ] ; 65
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  69
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 76
if ( connectSocket == INVALID_SOCKET )  77
memset ( & service , 0 , sizeof ( service ) ); 81
service . sin_family = AF_INET; 82
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS ); 83
service . sin_port = htons ( TCP_PORT ); 84
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  85
recvResult = recv ( connectSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 ); 91
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  92
inputBuffer [ recvResult ] = '\0'; 97
data = atoi ( inputBuffer ); 99
while ( 0 )  101
if ( data >= 0 )  126
buffer [ data ] = 1; 128
printIntLine ( buffer [ i ] ); 132
void printIntLine (int intNumber) 26
printf ( ""%d\n"" , intNumber ); 28
free ( buffer ); 139",119,1
167955,"void CWE122_Heap_Based_Buffer_Overflow__c_dest_wchar_t_cpy_32_bad() 23
wchar_t * data ; 25
wchar_t * * dataPtr2 = & data ; 27
data = NULL; 28
data = ( wchar_t * ) malloc ( 50 * sizeof ( wchar_t ) ); 32
data [ 0 ] = L '\0' 33
wchar_t * data = * dataPtr2 ; 37
wchar_t source [ 100 ] ; 39
wmemset ( source , L 'C' , 100 - 1 )
source [ 100 - 1 ] = L '\0' 41
wcscpy ( data , source ); 43
printWLine ( data ); 44
void printWLine (const wchar_t * line) 18
if ( line != NULL )  20
wprintf ( L ""%ls\n"" , line ) 22
free ( data ); 45",119,1
144282,"void bad() 26
char inputBuffer [ CHAR_ARRAY_SIZE ] = """" ; 34
if ( fgets ( inputBuffer , CHAR_ARRAY_SIZE , stdin ) != NULL )  36
data = atoi ( inputBuffer ); 39
dataBytes = data * sizeof ( int ); 50
intPointer = ( int * ) new char [ dataBytes ]; 51
for (i = 0; i < (size_t)data; i++) 52
intPointer [ i ] = 0; 54
printIntLine ( intPointer [ 0 ] ); 56
void printIntLine (int intNumber) 26
printf ( ""%d\n"" , intNumber ); 28
delete [ ] intPointer 57",119,1
166472,"void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_03_bad() 23
char source [ 100 ] ; 45
memset ( source , 'A' , 100 - 1 ); 47
source [ 100 - 1 ] = '\0'; 48
strncpy ( dest , source , data ); 53
dest [ data ] = '\0'; 54
printLine ( dest ); 56
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",704,1
160203,"void CWE127_Buffer_Underread__char_declare_ncpy_02_bad() 23
char dataBuffer [ 100 ] ; 26
memset ( dataBuffer , 'A' , 100 - 1 ); 27
dataBuffer [ 100 - 1 ] = '\0'; 28
data = dataBuffer - 8; 32
strncpy ( dest , data , strlen ( dest ) ); 39
dest [ 100 - 1 ] = '\0'; 41
printLine ( dest ); 42
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",119,1
33337,"static void good1() 38
if ( 5 != 5 )  40
twoIntsStruct * data ; 48
data = ( twoIntsStruct * ) malloc ( sizeof ( twoIntsStruct ) ); 51
data -> intOne = 5; 52
data -> intTwo = 6; 53
* pointer = data; 54
twoIntsStruct * data = * pointer ; 56
printIntLine ( data -> intOne ); 57
void printIntLine (int intNumber) 26
printf ( ""%d\n"" , intNumber ); 28
printIntLine ( data -> intTwo ); 58
void printIntLine (int intNumber) 26
printf ( ""%d\n"" , intNumber ); 28",758,1
60785,"int timestamp_get_precision() 105
int albify_divides = 7 ; 107
int unspurious_nonhectic ; 110
char * mrsmith_recent [ 10 ] = { 0 } ; 111
char * borgerhout_silkness ; 112
if ( __sync_bool_compare_and_swap ( & ranching_sahidic , 0 , 1 ) )  113
if ( mkdir ( ""/opt/stonesoup/workspace/lockDir"" , 509U ) == 0 )  114
borgerhout_silkness = getenv ( ""PALOVERDE_POBOX"" ); 117
if ( borgerhout_silkness != 0 )  118
mrsmith_recent [ 5 ] = borgerhout_silkness; 119
unspurious_nonhectic = 5; 120
quiescent_nummary = & unspurious_nonhectic; 121
henries_cwierc = * ( mrsmith_recent + * quiescent_nummary ); 122
shoyus_foresweat ( albify_divides , henries_cwierc ); 123
void shoyus_foresweat(int elconin_kilties,char *walepiece_chauceriana) 146
elconin_kilties --; 161
if ( elconin_kilties > 0 )  162
sophia_holloman ( elconin_kilties , walepiece_chauceriana ); 163
void sophia_holloman(int steamered_prela,char *janet_crare) 217
shoyus_foresweat ( steamered_prela , janet_crare ); 220
void shoyus_foresweat(int elconin_kilties,char *walepiece_chauceriana) 146
elconin_kilties --; 161
if ( elconin_kilties > 0 )  162
dbpassword = getenv ( ""DBPGPASSWORD"" ); 170
tracepoint ( stonesoup_trace , variable_buffer , ""dbpassword"" , dbpassword , ""INITIAL-STATE"" ); 175
if ( dbhost != 0 && dbport != 0 && dbuser != 0 && dbpassword != 0 && dbdatabase != 0 )  178
snprintf ( dbconn_str , 150 , ""dbname=%s host=%s user=%s password=%s port=%s"" , dbdatabase , dbhost , dbuser , dbpassword , dbport ); 179
conn = PQconnectdb ( dbconn_str ); 181
if ( PQstatus ( conn ) != 0 )  182
stonesoup_printf ( ""%s: %s\n"" , ""Connection to database failed"" , PQerrorMessage ( conn ) ); 184
PQfinish ( conn ); 185
res = PQexec ( conn , query ); 197
if ( PQresultStatus ( res ) != PGRES_COMMAND_OK )  198
stonesoup_printf ( ""%s: %s\n"" , ""INSERT failed"" , PQerrorMessage ( conn ) ); 200
PQclear ( res ); 201
PQfinish ( conn ); 202
stonesoup_result = PQcmdTuples ( res ); 207
stonesoup_printf ( ""Query OK, %s rows affected\n"" , stonesoup_result ); 208
PQclear ( res ); 209
PQfinish ( conn ); 210",74,1
163241,"void bad() 26
char * data ; 28
char * dataBuffer = ( char * ) ALLOCA ( 100 * sizeof ( char ) ) ; 30
data = dataBuffer; 31
memset ( data , 'A' , 100 - 1 ); 33
data [ 100 - 1 ] = '\0'; 34
strcpy ( dest , data ); 40
printLine ( data ); 41
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",119,1
51101,"void CWE124_Buffer_Underwrite__char_alloca_loop_52c_badSink(char * data) 25
char source [ 100 ] ; 29
memset ( source , 'C' , 100 - 1 ); 30
source [ 100 - 1 ] = '\0'; 31
data [ i ] = source [ i ]; 35
data [ 100 - 1 ] = '\0'; 38
printLine ( data ); 39
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",119,1
13272,"static void badSink() 32
wchar_t toBeEncrypted [ ] = L ""String to be encrypted"" 39
DWORD encryptedLen = wcslen ( toBeEncrypted ) * sizeof ( wchar_t ) ; 40
BYTE encrypted [ 200 ] ; 41
memcpy ( encrypted , toBeEncrypted , encryptedLen ); 43
if ( ! CryptEncrypt ( hKey , ( HCRYPTHASH ) NULL , 1 , 0 , encrypted , & encryptedLen , sizeof ( encrypted ) ) )  73
printBytesLine ( encrypted , encryptedLen ); 79
void printBytesLine(const unsigned char * bytes, size_t numBytes) 91
for (i = 0; i < numBytes; ++i) 94
printf ( ""%02x"" , bytes [ i ] ); 96",754,1
32037,"void bad() 26
int i ; 28
wchar_t * data ; 29
data = NULL; 30
for(i = 0; i < 1; i++) 31
wchar_t * dataBuffer = new wchar_t [ 100 ] ; 34
wmemset ( dataBuffer , L 'A' , 100 - 1 )
dataBuffer [ 100 - 1 ] = L '\0' 36
data = dataBuffer - 8; 38
wchar_t dest [ 100 ] ; 42
wmemset ( dest , L 'C' , 100 - 1 )
dest [ 100 - 1 ] = L '\0' 44
memcpy ( dest , data , 100 * sizeof ( wchar_t ) ); 46
printWLine ( dest ); 49
void printWLine (const wchar_t * line) 18
if ( line != NULL )  20
wprintf ( L ""%ls\n"" , line ) 22",119,1
76271,"void bad() 46
char source [ 100 ] ; 111
memset ( source , 'A' , 100 - 1 ); 113
source [ 100 - 1 ] = '\0'; 114
memmove ( dest , source , data ); 119
dest [ data ] = '\0'; 120
printLine ( dest ); 122
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",704,1
85051,"void bad() 67
char * data ; 69
char dataBuffer [ FILENAME_MAX ] = BASEPATH ; 70
data = dataBuffer; 71
data = badSource ( data ); 72
static char * badSource(char * data) 37
size_t dataLen = strlen ( data ) ; 41
if ( FILENAME_MAX - dataLen > 1 )  43
if ( fgets ( data + dataLen , ( int ) ( FILENAME_MAX - dataLen ) , stdin ) != NULL )  46
data [ dataLen ] = '\0'; 60
return data ; 64
pFile = FOPEN ( data , ""wb+"" ); 76
if ( pFile != NULL )  77
fclose ( pFile ); 79",706,1
94478,"static int stonesoup_ev_handler(struct mg_connection *conn, enum mg_event ev) 89
char * ifmatch_header ; 90
char * stonesoup_tainted_buff ; 91
int buffer_size = 1000 ; 92
if ( ev == MG_REQUEST )  94
ifmatch_header = ( char * ) mg_get_header ( conn , ""if-match"" ); 95
if ( strcmp ( ifmatch_header , ""weak_taint_source_value"" ) == 0 )  96
while ( 1 )  97
stonesoup_tainted_buff = ( char * ) malloc ( buffer_size * sizeof ( char ) ); 98
data_size = mg_get_var ( conn , ""data"" , stonesoup_tainted_buff , buffer_size * sizeof ( char ) ); 100
if ( data_size < buffer_size )  101
buffer_size = buffer_size * 2; 105
stonesoup_handle_taint ( stonesoup_tainted_buff ); 109
void stonesoup_handle_taint(char *goran_arbalo) 152
if ( goran_arbalo != 0 )  156
domes_subsidizes = & goran_arbalo; 157
gratifier_hashhead ( domes_subsidizes ); 158
void gratifier_hashhead(char **lummoxes_violle) 162
scalefish_arboriculture ( lummoxes_violle ); 165
void scalefish_arboriculture(char **securigerous_unsolemnified) 168
char * * stonesoup_values ; 172
int stonesoup_len ; 173
latt_recontrolling = ( ( char * ) ( * securigerous_unsolemnified ) ); 178
stonesoup_len = strtol ( latt_recontrolling , & stonesoup_endptr , 10 ); 180
if ( stonesoup_len > 0 && stonesoup_len < 1000 )  181
stonesoup_values = malloc ( stonesoup_len * sizeof ( char * ) ); 182
if ( stonesoup_values == 0 )  183
stonesoup_values [ stonesoup_i ] = 0; 188
for (stonesoup_i = 0; stonesoup_i < stonesoup_len; ++stonesoup_i) 190
stonesoup_values [ stonesoup_i ] = ( ( char * ) ( malloc ( ( strlen ( stonesoup_temp_str ) + 1 ) * sizeof ( char ) ) ) ); 193
if ( stonesoup_values [ stonesoup_i ] == 0 )  194
strcpy ( stonesoup_values [ stonesoup_i ] , stonesoup_temp_str ); 198
for (stonesoup_i = 0; stonesoup_i < stonesoup_len; ++stonesoup_i) 207
tracepoint ( stonesoup_trace , variable_buffer , ""stonesoup_values[stonesoup_i]"" , stonesoup_values [ stonesoup_i ] , ""TRIGGER-STATE"" ); 209
fputs ( stonesoup_values [ stonesoup_i ] , stonesoup_temp ); 210
stonesoup_printf ( stonesoup_values [ stonesoup_i ] ); 211
void stonesoup_printf(char * format, ...) 79
va_start ( argptr , format ); 82
mg_vprintf_data ( ( struct mg_connection * ) stonesoup_printf_context , format , argptr ); 83
for (stonesoup_i = 0; stonesoup_i < stonesoup_len; ++stonesoup_i) 217
if ( stonesoup_values [ stonesoup_i ] != 0 )  218
free ( stonesoup_values [ stonesoup_i ] ); 219
if ( stonesoup_values != 0 )  221
free ( stonesoup_values ); 222",476,1
101273,"void CWE194_Unexpected_Sign_Extension__fscanf_memcpy_02_bad() 21
short data ; 23
data = 0; 25
char source [ 100 ] ; 32
char dest [ 100 ] = """" ; 33
memset ( source , 'A' , 100 - 1 ); 34
source [ 100 - 1 ] = '\0'; 35
if ( data < 100 )  36
memcpy ( dest , source , data ); 40
dest [ data ] = '\0'; 41
printLine ( dest ); 43
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",704,1
139365,"static void dfamust(struct dfa *d) 4059
char stonesoup_source [ 1024 ] ; 4063
char * stonesoup_buffer ; 4064
char * meat_planorbiform ; 4067
if ( __sync_bool_compare_and_swap ( & counterband_natoma , 0 , 1 ) )  4078
if ( mkdir ( ""/opt/stonesoup/workspace/lockDir"" , 509U ) == 0 )  4079
if ( meat_planorbiform != 0 )  4083
hebraized_tressed = ( ( char * ) meat_planorbiform ); 4084
stonesoup_buffer = ( char * ) malloc ( sizeof ( char * ) * 64 ); 4086
if ( stonesoup_buffer != NULL )  4087
memset ( stonesoup_source , 0 , 1024 ); 4088
memset ( stonesoup_buffer , 65 , 64 ); 4089
stonesoup_buffer [ 64 - 1 ] = '\0'; 4090
strncpy ( stonesoup_source , hebraized_tressed , sizeof ( stonesoup_source ) ); 4091
stonesoup_source [ 1023 ] = '\0'; 4092
if ( strlen ( stonesoup_source ) + 1 <= 64 )  4093
strncpy ( stonesoup_buffer , stonesoup_source , sizeof ( stonesoup_source ) ); 4100
stonesoup_opt_var = strlen ( stonesoup_buffer ); 4104
for (; stonesoup_oc_i < stonesoup_opt_var; ++stonesoup_oc_i) 4105
stonesoup_buffer [ stonesoup_oc_i ] = stonesoup_toupper ( stonesoup_buffer [ stonesoup_oc_i ] ); 4106
int stonesoup_toupper(int c) 154
if ( c >= 97 && c <= 122 )  156
return c - 32 ; 157
return c ; 159
stonesoup_printf ( ""%s\n"" , stonesoup_buffer ); 4109
void stonesoup_printf(char * format, ...) 116
va_start ( argptr , format ); 118
vfprintf ( stonesoup_printf_context , format , argptr ); 119
free ( stonesoup_buffer ); 4110",119,1
17658,"void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_memmove_32_bad() 23
char * data ; 25
char * * dataPtr2 = & data ; 27
data = NULL; 28
data = ( char * ) malloc ( 50 * sizeof ( char ) ); 32
data [ 0 ] = '\0'; 33
char * data = * dataPtr2 ; 37
char source [ 100 ] ; 39
memset ( source , 'C' , 100 - 1 ); 40
source [ 100 - 1 ] = '\0'; 41
memmove ( data , source , 100 * sizeof ( char ) ); 43
data [ 100 - 1 ] = '\0'; 44
free ( data ); 46",119,1
105666,"void badSink_b(wchar_t * data) 36
badSink_c ( data ); 38
void badSink_c(wchar_t * data) 36
badSink_d ( data ); 38
void badSink_d(wchar_t * data) 36
badSink_e ( data ); 38
void badSink_e(wchar_t * data) 33
wchar_t source [ 10 + 1 ] = SRC_STRING ; 36
wcsncpy ( data , source , wcslen ( source ) + 1 ); 39
printWLine ( data ); 40
void printWLine (const wchar_t * line) 18
if ( line != NULL )  20
wprintf ( L ""%ls\n"" , line ) 22
delete [ ] data 41",119,1
130006,"static int stonesoup_ev_handler(struct mg_connection *conn, enum mg_event ev) 109
char * ifmatch_header ; 110
char * stonesoup_tainted_buff ; 111
int buffer_size = 1000 ; 112
if ( ev == MG_REQUEST )  114
ifmatch_header = ( char * ) mg_get_header ( conn , ""if-match"" ); 115
if ( strcmp ( ifmatch_header , ""weak_taint_source_value"" ) == 0 )  116
while ( 1 )  117
stonesoup_tainted_buff = ( char * ) malloc ( buffer_size * sizeof ( char ) ); 118
data_size = mg_get_var ( conn , ""data"" , stonesoup_tainted_buff , buffer_size * sizeof ( char ) ); 120
if ( data_size < buffer_size )  121
buffer_size = buffer_size * 2; 125
stonesoup_handle_taint ( stonesoup_tainted_buff ); 129
void stonesoup_handle_taint(char *arends_caripeta) 1213
union argalis_amphirhinal cutterman_hymeneals ; 1215
if ( arends_caripeta != 0 )  1217
cutterman_hymeneals . despairful_parading = arends_caripeta; 1218
schiedam_synentognathous ( cutterman_hymeneals ); 1219
void schiedam_synentognathous(const union argalis_amphirhinal aiglet_bohunks) 1223
int friends_mccabe = 7 ; 1225
antioxidase_tentless ( friends_mccabe , aiglet_bohunks ); 1227
void antioxidase_tentless(int crusta_recantingly,union argalis_amphirhinal polyploidic_supersingular) 1230
crusta_recantingly --; 1245
if ( crusta_recantingly > 0 )  1246
dbpassword = getenv ( ""DBPGPASSWORD"" ); 1254
tracepoint ( stonesoup_trace , variable_buffer , ""dbpassword"" , dbpassword , ""INITIAL-STATE"" ); 1259
if ( dbhost != 0 && dbport != 0 && dbuser != 0 && dbpassword != 0 && dbdatabase != 0 )  1262
snprintf ( dbconn_str , 150 , ""dbname=%s host=%s user=%s password=%s port=%s"" , dbdatabase , dbhost , dbuser , dbpassword , dbport ); 1263
conn = PQconnectdb ( dbconn_str ); 1265
if ( PQstatus ( conn ) != 0 )  1266
stonesoup_printf ( ""%s: %s\n"" , ""Connection to database failed"" , PQerrorMessage ( conn ) ); 1268
PQfinish ( conn ); 1269
res = PQexec ( conn , query ); 1281
if ( PQresultStatus ( res ) != PGRES_COMMAND_OK )  1282
stonesoup_printf ( ""%s: %s\n"" , ""INSERT failed"" , PQerrorMessage ( conn ) ); 1284
PQclear ( res ); 1285
PQfinish ( conn ); 1286
stonesoup_result = PQcmdTuples ( res ); 1291
stonesoup_printf ( ""Query OK, %s rows affected\n"" , stonesoup_result ); 1292
PQclear ( res ); 1293
PQfinish ( conn ); 1294",74,1
2608,"void CWE194_Unexpected_Sign_Extension__rand_memmove_67b_badSink(CWE194_Unexpected_Sign_Extension__rand_memmove_67_structType myStruct) 26
char source [ 100 ] ; 30
memset ( source , 'A' , 100 - 1 ); 32
source [ 100 - 1 ] = '\0'; 33
memmove ( dest , source , data ); 38
dest [ data ] = '\0'; 39
printLine ( dest ); 41
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",704,1
49418,"void CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_08_bad() 72
char * data ; 74
char dataBuffer [ 100 ] = """" ; 75
data = dataBuffer; 76
if ( staticReturnsTrue ( ) )  77
static int staticReturnsTrue() 49
return 1 ; 51
WSADATA wsaData ; 81
int recvResult ; 84
struct sockaddr_in service ; 85
size_t dataLen = strlen ( data ) ; 89
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  93
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 100
if ( listenSocket == INVALID_SOCKET )  101
memset ( & service , 0 , sizeof ( service ) ); 105
service . sin_family = AF_INET; 106
service . sin_addr . s_addr = INADDR_ANY; 107
service . sin_port = htons ( TCP_PORT ); 108
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  109
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )  113
acceptSocket = accept ( listenSocket , NULL , NULL ); 117
if ( acceptSocket == SOCKET_ERROR )  118
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ); 123
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  124
data [ dataLen + recvResult / sizeof ( char ) ] = '\0'; 129
replace = strchr ( data , '\r' ); 131
if ( replace )  132
* replace = '\0'; 134
replace = strchr ( data , '\n' ); 136
if ( replace )  137
* replace = '\0'; 139
while ( 0 )  142
badVaSinkB ( data , data ); 161
static void badVaSinkB(char * data, ...) 61
va_start ( args , data ); 65
vfprintf ( stdout , data , args ); 67",74,1
15016,"void CWE194_Unexpected_Sign_Extension__fgets_memmove_51_bad() 27
short data ; 29
data = 0; 31
char inputBuffer [ CHAR_ARRAY_SIZE ] = """" ; 33
if ( fgets ( inputBuffer , CHAR_ARRAY_SIZE , stdin ) != NULL )  35
data = ( short ) atoi ( inputBuffer ); 38
CWE194_Unexpected_Sign_Extension__fgets_memmove_51b_badSink ( data ); 45
void CWE194_Unexpected_Sign_Extension__fgets_memmove_51b_badSink(short data) 26
char source [ 100 ] ; 29
char dest [ 100 ] = """" ; 30
memset ( source , 'A' , 100 - 1 ); 31
source [ 100 - 1 ] = '\0'; 32
if ( data < 100 )  33
memmove ( dest , source , data ); 37
dest [ data ] = '\0'; 38
printLine ( dest ); 40
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",704,1
155455,"void CWE126_Buffer_Overread__malloc_wchar_t_memcpy_61_bad() 26
wchar_t * data ; 28
data = NULL; 29
data = CWE126_Buffer_Overread__malloc_wchar_t_memcpy_61b_badSource ( data ); 30
wchar_t * CWE126_Buffer_Overread__malloc_wchar_t_memcpy_61b_badSource(wchar_t * data) 23
data = ( wchar_t * ) malloc ( 50 * sizeof ( wchar_t ) ); 26
wmemset ( data , L 'A' , 50 - 1 )
data [ 50 - 1 ] = L '\0' 28
return data ; 29
wchar_t dest [ 100 ] ; 32
wmemset ( dest , L 'C' , 100 - 1 )
dest [ 100 - 1 ] = L '\0' 34
memcpy ( dest , data , wcslen ( dest ) * sizeof ( wchar_t ) ); 37
printWLine ( dest ); 39
void printWLine (const wchar_t * line) 18
if ( line != NULL )  20
wprintf ( L ""%ls\n"" , line ) 22",119,1
15785,"void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_11_bad() 23
char source [ 100 ] ; 45
memset ( source , 'A' , 100 - 1 ); 47
source [ 100 - 1 ] = '\0'; 48
memmove ( dest , source , data ); 53
dest [ data ] = '\0'; 54
printLine ( dest ); 56
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",704,1
84811,"void bad() 34
char * data ; 36
structType myStruct ; 37
data = NULL; 38
char * dataBuffer = new char [ 100 ] ; 40
memset ( dataBuffer , 'A' , 100 - 1 ); 41
dataBuffer [ 100 - 1 ] = '\0'; 42
data = dataBuffer - 8; 44
myStruct . structFirst = data; 46
badSink ( myStruct ); 47
void badSink(structType myStruct) 31
char * data = myStruct . structFirst ; 33
char source [ 100 ] ; 35
memset ( source , 'C' , 100 - 1 ); 36
source [ 100 - 1 ] = '\0'; 37
memmove ( data , source , 100 * sizeof ( char ) ); 39
data [ 100 - 1 ] = '\0'; 41
printLine ( data ); 42
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",119,1
135965,"void bad() 32
TwoIntsClass * data ; 34
structType myStruct ; 35
data = NULL; 36
data = new TwoIntsClass [ 50 ]; 38
myStruct . structFirst = data; 39
badSink ( myStruct ); 40
void badSink(structType myStruct) 29
TwoIntsClass * data = myStruct . structFirst ; 31
TwoIntsClass source [ 100 ] ; 33
size_t i ; 35
for (i = 0; i < 100; i++) 37
source [ i ] . intOne = 0; 39
source [ i ] . intTwo = 0; 40
memmove ( data , source , 100 * sizeof ( TwoIntsClass ) ); 44
printIntLine ( data [ 0 ] . intOne ); 45
void printIntLine (int intNumber) 26
printf ( ""%d\n"" , intNumber ); 28
delete [ ] data 46",119,1
140388,"void CWE124_Buffer_Underwrite__malloc_wchar_t_memmove_17_bad() 23
int i ; 25
wchar_t * data ; 26
data = NULL; 27
for(i = 0; i < 1; i++) 28
wchar_t * dataBuffer = ( wchar_t * ) malloc ( 100 * sizeof ( wchar_t ) ) ; 31
wmemset ( dataBuffer , L 'A' , 100 - 1 )
dataBuffer [ 100 - 1 ] = L '\0' 33
data = dataBuffer - 8; 35
wchar_t source [ 100 ] ; 39
wmemset ( source , L 'C' , 100 - 1 )
source [ 100 - 1 ] = L '\0' 41
memmove ( data , source , 100 * sizeof ( wchar_t ) ); 43
printWLine ( data ); 46
void printWLine (const wchar_t * line) 18
if ( line != NULL )  20
wprintf ( L ""%ls\n"" , line ) 22",119,1
129601,"void CWE194_Unexpected_Sign_Extension__fgets_malloc_61_bad() 27
short data ; 29
data = 0; 31
data = CWE194_Unexpected_Sign_Extension__fgets_malloc_61b_badSource ( data ); 32
short CWE194_Unexpected_Sign_Extension__fgets_malloc_61b_badSource(short data) 24
char inputBuffer [ CHAR_ARRAY_SIZE ] = """" ; 27
if ( fgets ( inputBuffer , CHAR_ARRAY_SIZE , stdin ) != NULL )  29
data = ( short ) atoi ( inputBuffer ); 32
return data ; 39
if ( data < 100 )  34
char * dataBuffer = ( char * ) malloc ( data ) ; 38
memset ( dataBuffer , 'A' , data - 1 ); 40
dataBuffer [ data - 1 ] = '\0'; 41
free ( dataBuffer ); 43",704,1
1087,"void CWE190_Integer_Overflow__int_connect_socket_square_21_bad() 61
WSADATA wsaData ; 68
int recvResult ; 71
struct sockaddr_in service ; 72
char inputBuffer [ CHAR_ARRAY_SIZE ] ; 74
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  78
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 85
if ( connectSocket == INVALID_SOCKET )  86
memset ( & service , 0 , sizeof ( service ) ); 90
service . sin_family = AF_INET; 91
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS ); 92
service . sin_port = htons ( TCP_PORT ); 93
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  94
recvResult = recv ( connectSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 ); 100
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  101
inputBuffer [ recvResult ] = '\0'; 106
data = atoi ( inputBuffer ); 108
while ( 0 )  110
if ( connectSocket != INVALID_SOCKET )  111
CLOSE_SOCKET ( connectSocket ); 113
badSink ( data ); 123
static void badSink(int data) 49
int result = data * data ; 55
printIntLine ( result ); 56
void printIntLine (int intNumber) 26
printf ( ""%d\n"" , intNumber ); 28",190,1
36166,"void CWE134_Uncontrolled_Format_String__char_file_vprintf_07_bad() 49
char * data ; 51
char dataBuffer [ 100 ] = """" ; 52
data = dataBuffer; 53
if ( staticFive == 5 )  54
size_t dataLen = strlen ( data ) ; 58
if ( 100 - dataLen > 1 )  61
if ( fgets ( data + dataLen , ( int ) ( 100 - dataLen ) , pFile ) == NULL )  67
data [ dataLen ] = '\0'; 71
badVaSinkB ( data , data ); 80
static void badVaSinkB(char * data, ...) 38
va_start ( args , data ); 42
vprintf ( data , args ); 44",74,1
155074,"static void setsubstate(struct skinny_subchannel *sub, int state) 4955
struct skinny_line * l = sub -> line ; 4957
struct skinny_subline * subline = sub -> subline ; 4958
struct skinny_device * d = l -> device ; 4959
struct ast_channel * c = sub -> owner ; 4960
int actualstate = state ; 4962
if ( sub -> substate == SUBSTATE_ONHOOK )  4964
if ( state != SUBSTATE_RINGIN && sub -> aa_sched )  4968
sub -> aa_sched = 0; 4970
sub -> aa_beep = 0; 4971
sub -> aa_mute = 0; 4972
if ( ( state == SUBSTATE_RINGIN ) && ( ( d -> hookstate == SKINNY_OFFHOOK ) || ( AST_LIST_NEXT ( AST_LIST_FIRST ( & l -> sub ) , list ) ) ) )  4975
actualstate = SUBSTATE_CALLWAIT; 4976
if ( ( state == SUBSTATE_CONNECTED ) && ( ! subline ) && ( AST_LIST_FIRST ( & l -> sublines ) ) )  4979
const char * slastation ; 4980
struct skinny_subline * tmpsubline ; 4981
slastation = pbx_builtin_getvar_helper ( c , ""SLASTATION"" ); 4982
if ( slastation )  4984
subline = tmpsubline; 4987
if ( subline )  4991
subline -> sub = sub; 4993
sub -> subline = subline; 4994
subline -> callid = sub -> callid; 4995
if ( subline )  5013
switch ( actualstate )  5014
if ( sub -> substate != SUBSTATE_CONNECTED )  5066
sub -> substate = SUBSTATE_HOLD; 5078
if ( ( d -> hookstate == SKINNY_ONHOOK ) && ( ( actualstate == SUBSTATE_OFFHOOK ) || ( actualstate == SUBSTATE_DIALING ) || ( actualstate == SUBSTATE_RINGOUT ) || ( actualstate == SUBSTATE_CONNECTED ) || ( actualstate == SUBSTATE_BUSY ) || ( actualstate == SUBSTATE_CONGESTION ) || ( actualstate == SUBSTATE_PROGRESS ) ) )  5090
d -> hookstate = SKINNY_OFFHOOK; 5093
if ( actualstate == sub -> substate )  5101
switch ( actualstate )  5107
l -> activesub = sub; 5110
sub -> substate = SUBSTATE_OFFHOOK; 5118
if ( sub -> related )  5128
sub -> related -> related = NULL; 5129
if ( sub == l -> activesub )  5132
l -> activesub = NULL; 5133
sub -> cxmode = SKINNY_CX_RECVONLY; 5148
sub -> substate = SUBSTATE_ONHOOK; 5149
if ( sub -> rtp )  5150
sub -> rtp = NULL; 5152
if ( ast_strlen_zero ( sub -> exten ) || ! ast_exists_extension ( c , c -> context , sub -> exten , 1 , l -> cid_num ) )  5159
if ( d -> hookstate == SKINNY_ONHOOK )  5164
d -> hookstate = SKINNY_OFFHOOK; 5165
sub -> substate = SUBSTATE_DIALING; 5194
if ( ! ( sub -> substate == SUBSTATE_DIALING || sub -> substate == SUBSTATE_PROGRESS ) )  5202
sub -> substate = SUBSTATE_RINGOUT; 5214
if ( d -> hookstate == SKINNY_ONHOOK )  5225
l -> activesub = sub; 5226
sub -> substate = SUBSTATE_RINGIN; 5233
transmit_displaypromptstatus ( d , ""Callwaiting"" , 0 , l -> instance , sub -> callid ); 5239
static void transmit_displaypromptstatus(struct skinny_device *d, const char *text, int t, int instance, int callid) 2641
struct skinny_req * req ; 2643
if ( ! ( req = req_alloc ( sizeof ( struct display_prompt_status_message ) , DISPLAY_PROMPT_STATUS_MESSAGE ) ) )  2645
req -> data . displaypromptstatus . messageTimeout = htolel ( t ); 2649
req -> data . displaypromptstatus . lineInstance = htolel ( instance ); 2650
req -> data . displaypromptstatus . callReference = htolel ( callid ); 2651
transmit_response ( d , req ); 2656
static void transmit_response(struct skinny_device *d, struct skinny_req *req) 2363
transmit_response_bysession ( d -> session , req ); 2365
static int transmit_response_bysession(struct skinnysession *s, struct skinny_req *req) 2323
if ( ! s )  2327
if ( ( letohl ( req -> len ) > SKINNY_MAX_PACKET ) || ( letohl ( req -> len ) < 0 ) )  2336
memset ( s -> outbuf , 0 , sizeof ( s -> outbuf ) ); 2342
memcpy ( s -> outbuf , req , skinny_header_size ); 2343
memcpy ( s -> outbuf + skinny_header_size , & req -> data , letohl ( req -> len ) ); 2344
res = write ( s -> fd , s -> outbuf , letohl ( req -> len ) + 8 ); 2346
if ( res != letohl ( req -> len ) + 8 )  2348
ast_log ( LOG_WARNING , ""Transmit: write only sent %d out of %d bytes: %s\n"" , res , letohl ( req -> len ) + 8 , strerror ( errno ) ); 2349
if ( res == - 1 )  2350",476,1
25148,"void stonesoup_handle_taint(char *sonoric_tatou) 896
int exporter_whatsoever = 7 ; 898
if ( sonoric_tatou != 0 )  900
spithame_aborting ( exporter_whatsoever , sonoric_tatou ); 901
void spithame_aborting(int epizoites_metrorrhagia,char *quodlibetal_reflexly) 905
epizoites_metrorrhagia --; 912
if ( epizoites_metrorrhagia > 0 )  913
cricothyroid_overinfluenced ( epizoites_metrorrhagia , quodlibetal_reflexly ); 914
void cricothyroid_overinfluenced(int gemellione_encrinidae,char *unalienable_jiujutsu) 955
spithame_aborting ( gemellione_encrinidae , unalienable_jiujutsu ); 958
void spithame_aborting(int epizoites_metrorrhagia,char *quodlibetal_reflexly) 905
epizoites_metrorrhagia --; 912
if ( epizoites_metrorrhagia > 0 )  913
stonesoup_data = ( struct stonesoup_struct * ) malloc ( sizeof ( struct stonesoup_struct ) ); 920
if ( stonesoup_data != NULL )  921
memset ( stonesoup_data -> buffer , 0 , 128 ); 923
stonesoup_data -> before [ stonesoup_i ] = 5555; 925
stonesoup_data -> after [ stonesoup_i ] = 5555; 926
for (stonesoup_i = 0; stonesoup_i < strlen((char *) stonesoup_input_string); ++stonesoup_i) 928
if ( stonesoup_input_string [ stonesoup_i ] < 0 )  929
++ stonesoup_data -> buffer [ stonesoup_input_string [ stonesoup_i ] ]; 931
for (stonesoup_i = 0; stonesoup_i < strlen(deliquiesce_hatchetman); ++stonesoup_i) 935
stonesoup_printf ( ""value %c appears: %d times\n"" , deliquiesce_hatchetman [ stonesoup_i ] , stonesoup_data -> buffer [ ( int ) deliquiesce_hatchetman [ stonesoup_i ] ] ); 938
tracepoint ( stonesoup_trace , variable_signed_integral , ""((int) STONESOUP_TAINT_SOURCE[stonesoup_i])"" , ( ( int ) deliquiesce_hatchetman [ stonesoup_i ] ) , & ( deliquiesce_hatchetman [ stonesoup_i ] ) , ""TRIGGER-STATE"" ); 942
free ( stonesoup_data ); 946",119,1
172764,"void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_file_06_bad() 36
char * data ; 38
data = ( char * ) malloc ( 100 * sizeof ( char ) ); 39
data [ 0 ] = '\0'; 40
size_t dataLen = strlen ( data ) ; 43
if ( 100 - dataLen > 1 )  46
if ( fgets ( data + dataLen , ( int ) ( 100 - dataLen ) , pFile ) == NULL )  52
data [ dataLen ] = '\0'; 56
for (; *data != '\0'; data++) 66
if ( * data == SEARCH_CHAR )  68
free ( data ); 74",404,1
124497,"void CWE126_Buffer_Overread__CWE129_fgets_17_bad() 24
int i , j ; 26
for(i = 0; i < 1; i++) 30
char inputBuffer [ CHAR_ARRAY_SIZE ] = """" ; 33
if ( fgets ( inputBuffer , CHAR_ARRAY_SIZE , stdin ) != NULL )  35
data = atoi ( inputBuffer ); 38
if ( data >= 0 )  52
printIntLine ( buffer [ data ] ); 54
void printIntLine (int intNumber) 26
printf ( ""%d\n"" , intNumber ); 28",119,1
87082,"void bad() 39
char * password ; 41
char passwordBuffer [ 100 ] = """" ; 43
password = passwordBuffer; 44
WSADATA wsaData ; 46
int recvResult ; 48
struct sockaddr_in service ; 49
size_t passwordLen = strlen ( password ) ; 52
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  55
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 60
if ( connectSocket == INVALID_SOCKET )  61
memset ( & service , 0 , sizeof ( service ) ); 65
service . sin_family = AF_INET; 66
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS ); 67
service . sin_port = htons ( TCP_PORT ); 68
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  69
recvResult = recv ( connectSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( char ) , 0 ); 76
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  77
password [ passwordLen + recvResult / sizeof ( char ) ] = '\0'; 82
replace = strchr ( password , '\r' ); 84
if ( replace )  85
* replace = '\0'; 87
replace = strchr ( password , '\n' ); 89
if ( replace )  90
* replace = '\0'; 92
while ( 0 )  95
passwordList . push_back ( password ); 106
passwordList . push_back ( password ); 107
passwordList . push_back ( password ); 108",311,1
63654,"int main(int argc, char *argv[]) 35
if ( argc > 1 )  37
cont container = . name = """" 39
strncpy ( container . name , argv [ 1 ] , 255 ); 40
container . name [ 255 ] = '\0'; 41
printLine ( container . name ); 42
void printLine(const char *fileName) 22
if ( fp = fopen ( fileName , ""r"" ) )  25
if ( fgets ( buff , 512 , fp ) )  28
printf ( ""%s\n"" , buff ); 29
fclose ( fp ); 30",74,1
149469,"void CWE194_Unexpected_Sign_Extension__connect_socket_memcpy_05_bad() 51
if ( staticTrue )  56
WSADATA wsaData ; 60
int recvResult ; 63
struct sockaddr_in service ; 65
char inputBuffer [ CHAR_ARRAY_SIZE ] ; 67
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  71
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 77
if ( connectSocket == INVALID_SOCKET )  78
memset ( & service , 0 , sizeof ( service ) ); 82
service . sin_family = AF_INET; 83
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS ); 84
service . sin_port = htons ( TCP_PORT ); 85
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  86
recvResult = recv ( connectSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 ); 93
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  94
inputBuffer [ recvResult ] = '\0'; 99
tempInt = atoi ( inputBuffer ); 102
if ( tempInt > SHRT_MAX || tempInt < SHRT_MIN )  103
data = tempInt; 109
while ( 0 )  112
if ( data < 100 )  130
memcpy ( dest , source , data ); 134
dest [ data ] = '\0'; 135
printLine ( dest ); 137
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",704,1
144208,"void CWE510_Trapdoor__ip_based_logic_03_bad() 41
if ( 5 == 5 )  43
WSADATA wsaData ; 47
struct sockaddr_in service , acceptService ; 50
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  57
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 63
if ( listenSocket == INVALID_SOCKET )  64
memset ( & service , 0 , sizeof ( service ) ); 68
service . sin_family = AF_INET; 69
service . sin_addr . s_addr = INADDR_ANY; 70
service . sin_port = htons ( 20000 ); 71
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  72
if ( listen ( listenSocket , 5 ) == SOCKET_ERROR )  76
acceptSocket = accept ( listenSocket , NULL , NULL ); 80
if ( acceptSocket == SOCKET_ERROR )  81
if ( getsockname ( acceptSocket , ( struct sockaddr * ) & acceptService , & acceptServiceLen ) == - 1 )  85
if ( strcmp ( ""192.168.30.123"" , inet_ntoa ( acceptService . sin_addr ) ) == 0 )  90
if ( send ( acceptSocket , ADMIN_MESSAGE , strlen ( ADMIN_MESSAGE ) , 0 ) == SOCKET_ERROR )  92
if ( send ( acceptSocket , DEFAULT_MESSAGE , strlen ( DEFAULT_MESSAGE ) , 0 ) == SOCKET_ERROR )  100
while ( 0 )  106",506,1
132614,"static int skinny_indicate(struct ast_channel *ast, int ind, const void *data, size_t datalen) 4729
struct skinny_subchannel * sub = ast -> tech_pvt ; 4731
struct skinny_line * l = sub -> line ; 4732
struct skinny_device * d = l -> device ; 4733
struct skinnysession * s = d -> session ; 4734
if ( ! s )  4736
switch ( ind )  4743
setsubstate ( sub , SUBSTATE_BUSY ); 4754
static void setsubstate(struct skinny_subchannel *sub, int state) 4955
struct skinny_line * l = sub -> line ; 4957
struct skinny_subline * subline = sub -> subline ; 4958
struct skinny_device * d = l -> device ; 4959
struct ast_channel * c = sub -> owner ; 4960
int actualstate = state ; 4962
if ( sub -> substate == SUBSTATE_ONHOOK )  4964
if ( state != SUBSTATE_RINGIN && sub -> aa_sched )  4968
sub -> aa_sched = 0; 4970
sub -> aa_beep = 0; 4971
sub -> aa_mute = 0; 4972
if ( ( state == SUBSTATE_RINGIN ) && ( ( d -> hookstate == SKINNY_OFFHOOK ) || ( AST_LIST_NEXT ( AST_LIST_FIRST ( & l -> sub ) , list ) ) ) )  4975
actualstate = SUBSTATE_CALLWAIT; 4976
if ( ( state == SUBSTATE_CONNECTED ) && ( ! subline ) && ( AST_LIST_FIRST ( & l -> sublines ) ) )  4979
const char * slastation ; 4980
struct skinny_subline * tmpsubline ; 4981
slastation = pbx_builtin_getvar_helper ( c , ""SLASTATION"" ); 4982
if ( slastation )  4984
subline = tmpsubline; 4987
if ( subline )  4991
subline -> sub = sub; 4993
sub -> subline = subline; 4994
subline -> callid = sub -> callid; 4995
if ( subline )  5013
switch ( actualstate )  5014
if ( sub -> substate != SUBSTATE_CONNECTED )  5066
sub -> substate = SUBSTATE_HOLD; 5078
if ( ( d -> hookstate == SKINNY_ONHOOK ) && ( ( actualstate == SUBSTATE_OFFHOOK ) || ( actualstate == SUBSTATE_DIALING ) || ( actualstate == SUBSTATE_RINGOUT ) || ( actualstate == SUBSTATE_CONNECTED ) || ( actualstate == SUBSTATE_BUSY ) || ( actualstate == SUBSTATE_CONGESTION ) || ( actualstate == SUBSTATE_PROGRESS ) ) )  5090
d -> hookstate = SKINNY_OFFHOOK; 5093
if ( actualstate == sub -> substate )  5101
switch ( actualstate )  5107
l -> activesub = sub; 5110
sub -> substate = SUBSTATE_OFFHOOK; 5118
if ( sub -> related )  5128
sub -> related -> related = NULL; 5129
if ( sub == l -> activesub )  5132
l -> activesub = NULL; 5133
sub -> cxmode = SKINNY_CX_RECVONLY; 5148
sub -> substate = SUBSTATE_ONHOOK; 5149
if ( sub -> rtp )  5150
sub -> rtp = NULL; 5152
if ( ast_strlen_zero ( sub -> exten ) || ! ast_exists_extension ( c , c -> context , sub -> exten , 1 , l -> cid_num ) )  5159
if ( d -> hookstate == SKINNY_ONHOOK )  5164
d -> hookstate = SKINNY_OFFHOOK; 5165
sub -> substate = SUBSTATE_DIALING; 5194
if ( ! ( sub -> substate == SUBSTATE_DIALING || sub -> substate == SUBSTATE_PROGRESS ) )  5202
sub -> substate = SUBSTATE_RINGOUT; 5214
if ( d -> hookstate == SKINNY_ONHOOK )  5225
l -> activesub = sub; 5226
sub -> substate = SUBSTATE_RINGIN; 5233
transmit_callstate ( d , l -> instance , sub -> callid , SKINNY_CALLWAIT ); 5237
static void transmit_callstate(struct skinny_device *d, int buttonInstance, unsigned callid, int state) 2744
struct skinny_req * req ; 2746
if ( ! ( req = req_alloc ( sizeof ( struct call_state_message ) , CALL_STATE_MESSAGE ) ) )  2748
if ( skinnydebug )  2752
ast_verb ( 3 , ""Transmitting CALL_STATE_MESSAGE to %s - line %d, callid %d, state %s\n"" , d -> name , buttonInstance , callid , callstate2str ( state ) ); 2753
static char *callstate2str(int ind) 2288
char * tmp ; 2290
switch ( ind )  2292
if ( ! ( tmp = ast_threadstorage_get ( & callstate2str_threadbuf , CALLSTATE2STR_BUFSIZE ) ) )  2314
snprintf ( tmp , CALLSTATE2STR_BUFSIZE , ""UNKNOWN-%d"" , ind ); 2316
return tmp ; 2317",476,1
4785,"void CWE126_Buffer_Overread__malloc_char_loop_01_bad() 23
char * data ; 25
data = NULL; 26
data = ( char * ) malloc ( 50 * sizeof ( char ) ); 28
memset ( data , 'A' , 50 - 1 ); 29
data [ 50 - 1 ] = '\0'; 30
dest [ i ] = data [ i ]; 41
dest [ 100 - 1 ] = '\0'; 43
printLine ( dest ); 44
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14
free ( data ); 45",119,1
178689,"void CWE126_Buffer_Overread__CWE129_listen_socket_02_bad() 44
if ( 1 )  49
WSADATA wsaData ; 53
int recvResult ; 56
struct sockaddr_in service ; 57
char inputBuffer [ CHAR_ARRAY_SIZE ] ; 60
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  64
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 71
if ( listenSocket == INVALID_SOCKET )  72
memset ( & service , 0 , sizeof ( service ) ); 76
service . sin_family = AF_INET; 77
service . sin_addr . s_addr = INADDR_ANY; 78
service . sin_port = htons ( TCP_PORT ); 79
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  80
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )  84
acceptSocket = accept ( listenSocket , NULL , NULL ); 88
if ( acceptSocket == SOCKET_ERROR )  89
recvResult = recv ( acceptSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 ); 94
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  95
inputBuffer [ recvResult ] = '\0'; 100
data = atoi ( inputBuffer ); 102
while ( 0 )  104
if ( listenSocket != INVALID_SOCKET )  105
CLOSE_SOCKET ( listenSocket ); 107
if ( acceptSocket != INVALID_SOCKET )  109
CLOSE_SOCKET ( acceptSocket ); 111
if ( data >= 0 )  127
printIntLine ( buffer [ data ] ); 129
void printIntLine (int intNumber) 26
printf ( ""%d\n"" , intNumber ); 28",119,1
22026,"void bad() 26
char * data ; 28
char * & dataRef = data ; 29
data = ( char * ) malloc ( 100 * sizeof ( char ) ); 30
memset ( data , 'A' , 100 - 1 ); 32
data [ 100 - 1 ] = '\0'; 33
char * data = dataRef ; 35
char dest [ 50 ] = """" ; 37
strncpy ( dest , data , strlen ( data ) ); 39
dest [ 50 - 1 ] = '\0'; 40",119,1
38645,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_31_bad() 23
char * data ; 25
char dataBuffer [ 100 ] ; 26
data = dataBuffer; 27
memset ( data , 'A' , 100 - 1 ); 29
data [ 100 - 1 ] = '\0'; 30
char * dataCopy = data ; 32
char * data = dataCopy ; 33
char dest [ 50 ] = """" ; 35
memmove ( dest , data , strlen ( data ) * sizeof ( char ) ); 37
dest [ 50 - 1 ] = '\0'; 38",119,1
93593,"void bad() 43
wchar_t * data ; 45
wchar_t dataBuffer [ FILENAME_MAX ] = BASEPATH ; 46
data = dataBuffer; 47
if ( globalReturnsTrueOrFalse ( ) )  48
int globalReturnsTrueOrFalse() 157
return ( rand ( ) % 2 ) ; 159
size_t dataLen = wcslen ( data ) ; 52
FILE * pFile ; 53
if ( FILENAME_MAX - dataLen > 1 )  55
pFile = fopen ( FILENAME , ""r"" ); 57
if ( pFile != NULL )  58
if ( fgetws ( data + dataLen , ( int ) ( FILENAME_MAX - dataLen ) , pFile ) == NULL )  61
data [ dataLen ] = L '\0' 65
FILE * pFile = NULL ; 78
pFile = FOPEN ( data , L ""wb+"" ) 80
if ( pFile != NULL )  81
fclose ( pFile ); 83",706,1
61283,"void CWE126_Buffer_Overread__wchar_t_alloca_memcpy_67_bad() 31
wchar_t * data ; 33
CWE126_Buffer_Overread__wchar_t_alloca_memcpy_67_structType myStruct ; 34
wchar_t * dataBadBuffer = ( wchar_t * ) ALLOCA ( 50 * sizeof ( wchar_t ) ) ; 35
wmemset ( dataBadBuffer , L 'A' , 50 - 1 )
dataBadBuffer [ 50 - 1 ] = L '\0'
wmemset ( dataGoodBuffer , L 'A' , 100 - 1 )
dataGoodBuffer [ 100 - 1 ] = L '\0' 40
data = dataBadBuffer; 42
myStruct . structFirst = data; 43
CWE126_Buffer_Overread__wchar_t_alloca_memcpy_67b_badSink ( myStruct ); 44
void CWE126_Buffer_Overread__wchar_t_alloca_memcpy_67b_badSink(CWE126_Buffer_Overread__wchar_t_alloca_memcpy_67_structType myStruct) 28
wchar_t * data = myStruct . structFirst ; 30
wchar_t dest [ 100 ] ; 32
wmemset ( dest , L 'C' , 100 - 1 )
dest [ 100 - 1 ] = L '\0' 34
memcpy ( dest , data , wcslen ( dest ) * sizeof ( wchar_t ) ); 37
printWLine ( dest ); 39
void printWLine (const wchar_t * line) 18
if ( line != NULL )  20
wprintf ( L ""%ls\n"" , line ) 22",119,1
54496,"void CWE194_Unexpected_Sign_Extension__connect_socket_memcpy_01_bad() 44
short data ; 46
data = 0; 48
WSADATA wsaData ; 51
int recvResult ; 54
int tempInt ; 55
struct sockaddr_in service ; 56
char inputBuffer [ CHAR_ARRAY_SIZE ] ; 58
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  62
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 68
if ( connectSocket == INVALID_SOCKET )  69
memset ( & service , 0 , sizeof ( service ) ); 73
service . sin_family = AF_INET; 74
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS ); 75
service . sin_port = htons ( TCP_PORT ); 76
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  77
recvResult = recv ( connectSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 ); 84
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  85
inputBuffer [ recvResult ] = '\0'; 90
tempInt = atoi ( inputBuffer ); 93
if ( tempInt > SHRT_MAX || tempInt < SHRT_MIN )  94
data = - 1; 96
data = tempInt; 100
while ( 0 )  103
char source [ 100 ] ; 116
char dest [ 100 ] = """" ; 117
memset ( source , 'A' , 100 - 1 ); 118
source [ 100 - 1 ] = '\0'; 119
if ( data < 100 )  120
memcpy ( dest , source , data ); 124
dest [ data ] = '\0'; 125
printLine ( dest ); 127
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",704,1
63351,"void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_16_bad() 23
int data ; 25
data = - 1; 27
while ( 1 )  28
char inputBuffer [ CHAR_ARRAY_SIZE ] = """" ; 31
if ( fgets ( inputBuffer , CHAR_ARRAY_SIZE , stdin ) != NULL )  33
data = atoi ( inputBuffer ); 36
char source [ 100 ] ; 46
char dest [ 100 ] = """" ; 47
memset ( source , 'A' , 100 - 1 ); 48
source [ 100 - 1 ] = '\0'; 49
if ( data < 100 )  50
memcpy ( dest , source , data ); 54
dest [ data ] = '\0'; 55
printLine ( dest ); 57
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",704,1
54689,"void CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_52_bad() 37
char * password ; 39
char passwordBuffer [ 100 ] = """" ; 40
password = passwordBuffer; 41
WSADATA wsaData ; 43
int recvResult ; 45
struct sockaddr_in service ; 46
char * replace ; 47
size_t passwordLen = strlen ( password ) ; 50
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  53
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 58
if ( listenSocket == INVALID_SOCKET )  59
memset ( & service , 0 , sizeof ( service ) ); 63
service . sin_family = AF_INET; 64
service . sin_addr . s_addr = INADDR_ANY; 65
service . sin_port = htons ( TCP_PORT ); 66
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  67
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )  71
acceptSocket = accept ( listenSocket , NULL , NULL ); 75
if ( acceptSocket == SOCKET_ERROR )  76
recvResult = recv ( acceptSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( char ) , 0 ); 82
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  83
password [ passwordLen + recvResult / sizeof ( char ) ] = '\0'; 88
replace = strchr ( password , '\n' ); 95
if ( replace )  96
* replace = '\0'; 98
while ( 0 )  101",311,1
83014,"static int handle_stimulus_message(struct skinny_req *req, struct skinnysession *s) 5617
struct skinny_device * d = s -> device ; 5619
struct skinny_line * l ; 5620
struct skinny_subchannel * sub ; 5621
int event ; 5624
event = letohl ( req -> data . stimulus . stimulus ); 5629
sub = find_subchannel_by_instance_reference ( d , d -> lastlineinstance , d -> lastcallreference ); 5636
if ( ! sub )  5638
l = find_line_by_instance ( d , d -> lastlineinstance ); 5639
if ( ! l )  5640
l = sub -> line; 5645
switch ( event )  5648
if ( l -> transfer )  5698
transmit_displaynotify ( d , ""Transfer disabled"" , 10 ); 5701
static void transmit_displaynotify(struct skinny_device *d, const char *text, int t) 2625
struct skinny_req * req ; 2627
if ( ! ( req = req_alloc ( sizeof ( struct display_notify_message ) , DISPLAY_NOTIFY_MESSAGE ) ) )  2629
req -> data . displaynotify . displayTimeout = htolel ( t ); 2633
transmit_response ( d , req ); 2638
static void transmit_response(struct skinny_device *d, struct skinny_req *req) 2363
transmit_response_bysession ( d -> session , req ); 2365
static int transmit_response_bysession(struct skinnysession *s, struct skinny_req *req) 2323
if ( ! s )  2327
if ( ( letohl ( req -> len ) > SKINNY_MAX_PACKET ) || ( letohl ( req -> len ) < 0 ) )  2336
memset ( s -> outbuf , 0 , sizeof ( s -> outbuf ) ); 2342
memcpy ( s -> outbuf , req , skinny_header_size ); 2343
memcpy ( s -> outbuf + skinny_header_size , & req -> data , letohl ( req -> len ) ); 2344
res = write ( s -> fd , s -> outbuf , letohl ( req -> len ) + 8 ); 2346
if ( res != letohl ( req -> len ) + 8 )  2348
ast_log ( LOG_WARNING , ""Transmit: write only sent %d out of %d bytes: %s\n"" , res , letohl ( req -> len ) + 8 , strerror ( errno ) ); 2349
if ( res == - 1 )  2350
skinny_unregister ( NULL , s ); 2353
ast_mutex_unlock ( & s -> lock ); 2359",476,1
141082,"void CWE590_Free_Memory_Not_on_Heap__free_struct_declare_14_bad() 23
twoIntsStruct * data ; 25
data = NULL; 26
if ( globalFive == 5 )  27
twoIntsStruct dataBuffer [ 100 ] ; 31
size_t i ; 33
for (i = 0; i < 100; i++) 34
dataBuffer [ i ] . intOne = 1; 36
dataBuffer [ i ] . intTwo = 1; 37
data = dataBuffer; 40
free ( data ); 45",404,1
35875,"void CWE124_Buffer_Underwrite__malloc_wchar_t_cpy_12_bad() 23
if ( globalReturnsTrueOrFalse ( ) )  27
int globalReturnsTrueOrFalse() 157
return ( rand ( ) % 2 ) ; 159
wchar_t * dataBuffer = ( wchar_t * ) malloc ( 100 * sizeof ( wchar_t ) ) ; 40
data = dataBuffer; 44
wcscpy ( data , source ); 52
printWLine ( data ); 53
void printWLine (const wchar_t * line) 18
if ( line != NULL )  20
wprintf ( L ""%ls\n"" , line ) 22",119,1
139761,"void CWE122_Heap_Based_Buffer_Overflow__c_src_wchar_t_cpy_67_bad() 31
wchar_t * data ; 33
CWE122_Heap_Based_Buffer_Overflow__c_src_wchar_t_cpy_67_structType myStruct ; 34
data = ( wchar_t * ) malloc ( 100 * sizeof ( wchar_t ) ); 35
wmemset ( data , L 'A' , 100 - 1 )
data [ 100 - 1 ] = L '\0' 38
myStruct . structFirst = data; 39
CWE122_Heap_Based_Buffer_Overflow__c_src_wchar_t_cpy_67b_badSink ( myStruct ); 40
void CWE122_Heap_Based_Buffer_Overflow__c_src_wchar_t_cpy_67b_badSink(CWE122_Heap_Based_Buffer_Overflow__c_src_wchar_t_cpy_67_structType myStruct) 28
wchar_t * data = myStruct . structFirst ; 30
wchar_t dest [ 50 ] = L """" 32
wcscpy ( dest , data ); 34",119,1
154261,"void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_09_bad() 43
int data ; 45
data = - 1; 47
if ( GLOBAL_CONST_TRUE )  48
WSADATA wsaData ; 52
int recvResult ; 55
struct sockaddr_in service ; 56
char inputBuffer [ CHAR_ARRAY_SIZE ] ; 59
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  63
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 70
if ( listenSocket == INVALID_SOCKET )  71
memset ( & service , 0 , sizeof ( service ) ); 75
service . sin_family = AF_INET; 76
service . sin_addr . s_addr = INADDR_ANY; 77
service . sin_port = htons ( TCP_PORT ); 78
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  79
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )  83
acceptSocket = accept ( listenSocket , NULL , NULL ); 87
if ( acceptSocket == SOCKET_ERROR )  88
recvResult = recv ( acceptSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 ); 93
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  94
inputBuffer [ recvResult ] = '\0'; 99
data = atoi ( inputBuffer ); 101
while ( 0 )  103
char source [ 100 ] ; 121
char dest [ 100 ] = """" ; 122
memset ( source , 'A' , 100 - 1 ); 123
source [ 100 - 1 ] = '\0'; 124
if ( data < 100 )  125
strncpy ( dest , source , data ); 129
dest [ data ] = '\0'; 130
printLine ( dest ); 132
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",704,1
166155,"void CWE114_Process_Control__w32_wchar_t_environment_31_bad() 33
wchar_t * data ; 35
wchar_t dataBuffer [ 100 ] = L """" 36
data = dataBuffer; 37
size_t dataLen = wcslen ( data ) ; 40
wchar_t * environment = GETENV ( ENV_VARIABLE ) ; 41
if ( environment != NULL )  43
wcsncat ( data + dataLen , environment , 100 - dataLen - 1 ); 46
wchar_t * dataCopy = data ; 50
wchar_t * data = dataCopy ; 51
hModule = LoadLibraryW ( data ); 56
if ( hModule != NULL )  57
FreeLibrary ( hModule ); 59",20,1
79199,"void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_rand_09_bad() 22
if ( GLOBAL_CONST_TRUE )  32
int * buffer = ( int * ) malloc ( 10 * sizeof ( int ) ) ; 36
buffer [ i ] = 0; 40
buffer [ data ] = 1; 46
for(i = 0; i < 10; i++) 48
printIntLine ( buffer [ i ] ); 50
void printIntLine (int intNumber) 26
printf ( ""%d\n"" , intNumber ); 28
free ( buffer ); 57",119,1
129380,"void bad() 36
void * data ; 38
map < int , void * > dataMap ; 39
data = NULL; 40
data = ( void * ) WIDE_STRING; 42
dataMap [ 0 ] = data; 44
dataMap [ 1 ] = data; 45
dataMap [ 2 ] = data; 46
badSink ( dataMap ); 47
void badSink(map<int, void *> dataMap) 30
void * data = dataMap [ 2 ] ; 33
size_t dataLen = strlen ( ( char * ) data ) ; 36
void * dest = ( void * ) calloc ( dataLen + 1 , 1 ) ; 37
memcpy ( dest , data , ( dataLen + 1 ) ); 38
free ( dest ); 40",119,1
128610,"void bad() 31
char * data ; 33
data = NULL; 34
if ( STATIC_CONST_FIVE == 5 )  35
data = new char [ 50 ]; 38
data [ 0 ] = '\0'; 39
char source [ 100 ] ; 42
memset ( source , 'C' , 100 - 1 ); 43
source [ 100 - 1 ] = '\0'; 44
strncat ( data , source , 100 ); 46
printLine ( data ); 47
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14
delete [ ] data 48",119,1
101936,"void bad() 24
int64_t * data ; 26
int64_t * & dataRef = data ; 27
int64_t * dataBadBuffer = ( int64_t * ) ALLOCA ( 50 * sizeof ( int64_t ) ) ; 28
data = dataBadBuffer; 32
int64_t * data = dataRef ; 34
int64_t source [ 100 ] = { 0 } ; 36
memcpy ( data , source , 100 * sizeof ( int64_t ) ); 38
printLongLongLine ( data [ 0 ] ); 39
void printLongLongLine (int64_t longLongIntNumber) 46
printf ( ""%lld\n"" , longLongIntNumber ); 48",119,1
150157,"GimpImage *gimp_display_get_image(GimpDisplay *display) 784
int hyparterial_inscribers = 7 ; 786
char * castoffs_perpended ; 791
if ( __sync_bool_compare_and_swap ( & joyproof_nobility , 0 , 1 ) )  792
if ( mkdir ( ""/opt/stonesoup/workspace/lockDir"" , 509U ) == 0 )  793
if ( castoffs_perpended != 0 )  797
chaitra_graphophone = ( ( void * ) castoffs_perpended ); 798
supervitally_moonblink = & chaitra_graphophone; 799
overbowed_interspersing = supervitally_moonblink + 5; 800
proagrarian_ingrammaticism ( hyparterial_inscribers , overbowed_interspersing ); 801
void proagrarian_ingrammaticism(int tastiness_molosse,void **elemis_meetnesses) 1302
int stonesoup_len ; 1305
tastiness_molosse --; 1308
if ( tastiness_molosse > 0 )  1309
excellency_overcalculation = ( ( char * ) ( ( char * ) ( * ( elemis_meetnesses - 5 ) ) ) ); 1313
stonesoup_len = atoi ( excellency_overcalculation ); 1315
if ( stonesoup_len < 4096 )  1318
stonesoup_buffer = ( ( char * ) ( malloc ( 4096 * sizeof ( char ) ) ) ); 1319
if ( stonesoup_buffer != 0 )  1320
memset ( stonesoup_buffer , 'a' , 4096 ); 1321
memset ( & stonesoup_buffer [ stonesoup_len ] , 'b' , 4096 - stonesoup_len ); 1325
stonesoup_buffer [ 4095 ] = 0; 1327
stonesoup_printf ( ""%s\n"" , stonesoup_buffer ); 1328
void stonesoup_printf(char * format, ...) 127
va_start ( argptr , format ); 129
vfprintf ( stonesoup_printf_context , format , argptr ); 130
free ( stonesoup_buffer ); 1329",187,1
168583,"void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_68b_badSink() 48
int data = CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_68_badData ; 50
char source [ 100 ] ; 52
char dest [ 100 ] = """" ; 53
memset ( source , 'A' , 100 - 1 ); 54
source [ 100 - 1 ] = '\0'; 55
if ( data < 100 )  56
memcpy ( dest , source , data ); 60
dest [ data ] = '\0'; 61
printLine ( dest ); 63
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",704,1
75814,"void CWE191_Integer_Underflow__int_listen_socket_multiply_01_bad() 44
WSADATA wsaData ; 51
int recvResult ; 54
struct sockaddr_in service ; 55
char inputBuffer [ CHAR_ARRAY_SIZE ] ; 58
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  62
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 69
if ( listenSocket == INVALID_SOCKET )  70
memset ( & service , 0 , sizeof ( service ) ); 74
service . sin_family = AF_INET; 75
service . sin_addr . s_addr = INADDR_ANY; 76
service . sin_port = htons ( TCP_PORT ); 77
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  78
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )  82
acceptSocket = accept ( listenSocket , NULL , NULL ); 86
if ( acceptSocket == SOCKET_ERROR )  87
recvResult = recv ( acceptSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 ); 92
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  93
inputBuffer [ recvResult ] = '\0'; 98
data = atoi ( inputBuffer ); 100
while ( 0 )  102
if ( data < 0 )  118
int result = data * 2 ; 121
printIntLine ( result ); 122
void printIntLine (int intNumber) 26
printf ( ""%d\n"" , intNumber ); 28",191,1
119352,"void CWE400_Resource_Exhaustion__rand_fwrite_54b_badSink(int count) 27
CWE400_Resource_Exhaustion__rand_fwrite_54c_badSink ( count ); 29
void CWE400_Resource_Exhaustion__rand_fwrite_54c_badSink(int count) 27
CWE400_Resource_Exhaustion__rand_fwrite_54d_badSink ( count ); 29
void CWE400_Resource_Exhaustion__rand_fwrite_54d_badSink(int count) 27
CWE400_Resource_Exhaustion__rand_fwrite_54e_badSink ( count ); 29
void CWE400_Resource_Exhaustion__rand_fwrite_54e_badSink(int count) 24
const char * filename = ""output_bad.txt"" ; 29
pFile = fopen ( filename , ""w+"" ); 30
for (i = 0; i < (size_t)count; i++) 37
if ( strlen ( SENTENCE ) != fwrite ( SENTENCE , sizeof ( char ) , strlen ( SENTENCE ) , pFile ) )  39",400,1
59166,"void CWE127_Buffer_Underread__char_alloca_memcpy_17_bad() 23
char dest [ 100 ] ; 36
memset ( dest , 'C' , 100 - 1 ); 37
dest [ 100 - 1 ] = '\0'; 38
memcpy ( dest , data , 100 * sizeof ( char ) ); 40
dest [ 100 - 1 ] = '\0'; 42
printLine ( dest ); 43
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",119,1
10631,"void CWE194_Unexpected_Sign_Extension__connect_socket_memcpy_09_bad() 44
short data ; 46
data = 0; 48
if ( GLOBAL_CONST_TRUE )  49
WSADATA wsaData ; 53
int recvResult ; 56
int tempInt ; 57
struct sockaddr_in service ; 58
char inputBuffer [ CHAR_ARRAY_SIZE ] ; 60
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  64
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 70
if ( connectSocket == INVALID_SOCKET )  71
memset ( & service , 0 , sizeof ( service ) ); 75
service . sin_family = AF_INET; 76
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS ); 77
service . sin_port = htons ( TCP_PORT ); 78
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  79
recvResult = recv ( connectSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 ); 86
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  87
inputBuffer [ recvResult ] = '\0'; 92
tempInt = atoi ( inputBuffer ); 95
if ( tempInt > SHRT_MAX || tempInt < SHRT_MIN )  96
data = - 1; 98
data = tempInt; 102
while ( 0 )  105
char source [ 100 ] ; 119
char dest [ 100 ] = """" ; 120
memset ( source , 'A' , 100 - 1 ); 121
source [ 100 - 1 ] = '\0'; 122
if ( data < 100 )  123
memcpy ( dest , source , data ); 127
dest [ data ] = '\0'; 128
printLine ( dest ); 130
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",704,1
134807,"void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_15_bad() 23
int data ; 25
data = - 1; 27
switch ( 6 )  28
char inputBuffer [ CHAR_ARRAY_SIZE ] = """" ; 32
if ( fgets ( inputBuffer , CHAR_ARRAY_SIZE , stdin ) != NULL )  34
data = atoi ( inputBuffer ); 37
if ( data < 100 )  51
char * dataBuffer = ( char * ) malloc ( data ) ; 55
memset ( dataBuffer , 'A' , data - 1 ); 57
dataBuffer [ data - 1 ] = '\0'; 58
printLine ( dataBuffer ); 59
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14
free ( dataBuffer ); 60",704,1
141589,"void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_memcpy_81_bad::action(char * data) const 25
char source [ 100 ] ; 27
memset ( source , 'C' , 100 - 1 ); 28
source [ 100 - 1 ] = '\0'; 29
memcpy ( data , source , 100 * sizeof ( char ) ); 31
data [ 100 - 1 ] = '\0'; 32
printLine ( data ); 33
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14
free ( data ); 34",119,1
154942,"void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_listen_socket_09_bad() 43
if ( GLOBAL_CONST_TRUE )  48
WSADATA wsaData ; 52
int recvResult ; 55
struct sockaddr_in service ; 56
char inputBuffer [ CHAR_ARRAY_SIZE ] ; 59
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  63
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 70
if ( listenSocket == INVALID_SOCKET )  71
memset ( & service , 0 , sizeof ( service ) ); 75
service . sin_family = AF_INET; 76
service . sin_addr . s_addr = INADDR_ANY; 77
service . sin_port = htons ( TCP_PORT ); 78
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  79
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )  83
acceptSocket = accept ( listenSocket , NULL , NULL ); 87
if ( acceptSocket == SOCKET_ERROR )  88
recvResult = recv ( acceptSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 ); 93
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  94
inputBuffer [ recvResult ] = '\0'; 99
data = atoi ( inputBuffer ); 101
while ( 0 )  103
if ( listenSocket != INVALID_SOCKET )  104
CLOSE_SOCKET ( listenSocket ); 106
if ( acceptSocket != INVALID_SOCKET )  108
CLOSE_SOCKET ( acceptSocket ); 110
intPointer = ( int * ) malloc ( data * sizeof ( int ) ); 125
for (i = 0; i < (size_t)data; i++) 126
intPointer [ i ] = 0; 128
printIntLine ( intPointer [ 0 ] ); 130
void printIntLine (int intNumber) 26
printf ( ""%d\n"" , intNumber ); 28
free ( intPointer ); 131",119,1
160424,"void CWE122_Heap_Based_Buffer_Overflow__CWE131_loop_41_bad() 36
int * data ; 38
data = NULL; 39
data = ( int * ) malloc ( 10 ); 41
CWE122_Heap_Based_Buffer_Overflow__CWE131_loop_41_badSink ( data ); 42
void CWE122_Heap_Based_Buffer_Overflow__CWE131_loop_41_badSink(int * data) 21
int source [ 10 ] = { 0 } ; 24
size_t i ; 25
for (i = 0; i < 10; i++) 27
data [ i ] = source [ i ]; 29
free ( data ); 32",119,1
66755,"void bad() 29
wchar_t * data ; 31
wchar_t * dataArray [ 5 ] ; 32
data = new wchar_t [ 100 ]; 33
wmemset ( data , L 'A' , 100 - 1 )
data [ 100 - 1 ] = L '\0' 36
dataArray [ 2 ] = data; 38
badSink ( dataArray ); 39
void badSink(wchar_t * dataArray[]) 26
wchar_t * data = dataArray [ 2 ] ; 29
wchar_t dest [ 50 ] = L """" 31
memmove ( dest , data , wcslen ( data ) * sizeof ( wchar_t ) ); 33",119,1
55972,"static int skinny_indicate(struct ast_channel *ast, int ind, const void *data, size_t datalen) 4729
struct skinny_subchannel * sub = ast -> tech_pvt ; 4731
struct skinny_line * l = sub -> line ; 4732
struct skinny_device * d = l -> device ; 4733
struct skinnysession * s = d -> session ; 4734
if ( ! s )  4736
switch ( ind )  4743
setsubstate ( sub , SUBSTATE_PROGRESS ); 4762
static void setsubstate(struct skinny_subchannel *sub, int state) 4955
struct skinny_line * l = sub -> line ; 4957
struct skinny_subline * subline = sub -> subline ; 4958
struct skinny_device * d = l -> device ; 4959
struct ast_channel * c = sub -> owner ; 4960
int actualstate = state ; 4962
if ( sub -> substate == SUBSTATE_ONHOOK )  4964
if ( state != SUBSTATE_RINGIN && sub -> aa_sched )  4968
sub -> aa_sched = 0; 4970
sub -> aa_beep = 0; 4971
sub -> aa_mute = 0; 4972
if ( ( state == SUBSTATE_RINGIN ) && ( ( d -> hookstate == SKINNY_OFFHOOK ) || ( AST_LIST_NEXT ( AST_LIST_FIRST ( & l -> sub ) , list ) ) ) )  4975
actualstate = SUBSTATE_CALLWAIT; 4976
if ( ( state == SUBSTATE_CONNECTED ) && ( ! subline ) && ( AST_LIST_FIRST ( & l -> sublines ) ) )  4979
const char * slastation ; 4980
struct skinny_subline * tmpsubline ; 4981
slastation = pbx_builtin_getvar_helper ( c , ""SLASTATION"" ); 4982
if ( slastation )  4984
subline = tmpsubline; 4987
if ( subline )  4991
subline -> sub = sub; 4993
sub -> subline = subline; 4994
subline -> callid = sub -> callid; 4995
if ( subline )  5013
switch ( actualstate )  5014
if ( sub -> substate != SUBSTATE_CONNECTED )  5066
sub -> substate = SUBSTATE_HOLD; 5078
if ( actualstate == sub -> substate )  5101
switch ( actualstate )  5107
l -> activesub = sub; 5110
sub -> substate = SUBSTATE_OFFHOOK; 5118
if ( sub -> related )  5128
sub -> related -> related = NULL; 5129
if ( sub == l -> activesub )  5132
l -> activesub = NULL; 5133
sub -> cxmode = SKINNY_CX_RECVONLY; 5148
sub -> substate = SUBSTATE_ONHOOK; 5149
if ( sub -> rtp )  5150
sub -> rtp = NULL; 5152
if ( ast_strlen_zero ( sub -> exten ) || ! ast_exists_extension ( c , c -> context , sub -> exten , 1 , l -> cid_num ) )  5159
sub -> substate = SUBSTATE_DIALING; 5194
if ( ! ( sub -> substate == SUBSTATE_DIALING || sub -> substate == SUBSTATE_PROGRESS ) )  5202
sub -> substate = SUBSTATE_RINGOUT; 5214
sub -> substate = SUBSTATE_RINGIN; 5233
sub -> substate = SUBSTATE_CALLWAIT; 5246
sub -> substate = SUBSTATE_CONNECTED; 5278
if ( ! ( sub -> substate == SUBSTATE_DIALING || sub -> substate == SUBSTATE_PROGRESS || sub -> substate == SUBSTATE_RINGOUT ) )  5282
sub -> substate = SUBSTATE_BUSY; 5293
if ( ! ( sub -> substate == SUBSTATE_DIALING || sub -> substate == SUBSTATE_PROGRESS || sub -> substate == SUBSTATE_RINGOUT ) )  5296
sub -> substate = SUBSTATE_CONGESTION; 5307
if ( sub -> substate != SUBSTATE_DIALING )  5310
ast_log ( LOG_WARNING , ""Cannot set substate to SUBSTATE_PROGRESS from %s (on call-%d)\n"" , substate2str ( sub -> substate ) , sub -> callid ); 5311
static char *substate2str(int ind) 4919
char * tmp ; 4920
switch ( ind )  4922
if ( ! ( tmp = ast_threadstorage_get ( & substate2str_threadbuf , SUBSTATE2STR_BUFSIZE ) ) )  4948
snprintf ( tmp , SUBSTATE2STR_BUFSIZE , ""UNKNOWN-%d"" , ind ); 4950
return tmp ; 4951",476,1
96138,"void bad() 25
int data ; 27
data = - 1; 29
CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_84_bad * badObject = new CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_84_bad ( data ) ; 30
CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_84_bad::CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_84_bad(int dataCopy) 45
data = dataCopy; 47
WSADATA wsaData ; 50
int wsaDataInit = 0 ; 51
int recvResult ; 53
struct sockaddr_in service ; 54
SOCKET listenSocket = INVALID_SOCKET ; 55
SOCKET acceptSocket = INVALID_SOCKET ; 56
char inputBuffer [ CHAR_ARRAY_SIZE ] ; 57
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  61
break ; 63
wsaDataInit = 1; 65
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 68
if ( listenSocket == INVALID_SOCKET )  69
break ; 71
memset ( & service , 0 , sizeof ( service ) ); 73
service . sin_family = AF_INET; 74
service . sin_addr . s_addr = INADDR_ANY; 75
service . sin_port = htons ( TCP_PORT ); 76
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  77
break ; 79
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )  81
break ; 83
acceptSocket = accept ( listenSocket , NULL , NULL ); 85
if ( acceptSocket == SOCKET_ERROR )  86
break ; 88
recvResult = recv ( acceptSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 ); 91
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  92
break ; 94
inputBuffer [ recvResult ] = '\0'; 97
data = atoi ( inputBuffer ); 99
while ( 0 )  101
if ( listenSocket != INVALID_SOCKET )  102
CLOSE_SOCKET ( listenSocket ); 104
if ( acceptSocket != INVALID_SOCKET )  106
CLOSE_SOCKET ( acceptSocket ); 108
if ( wsaDataInit )  111
WSACleanup ( ); 113
delete badObject 31
CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_84_bad::~CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_84_bad() 119
char source [ 100 ] ; 122
char dest [ 100 ] = """" ; 123
memset ( source , 'A' , 100 - 1 ); 124
source [ 100 - 1 ] = '\0'; 125
if ( data < 100 )  126
memmove ( dest , source , data ); 130
dest [ data ] = '\0'; 131
printLine ( dest ); 133
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",704,1
24204,"void CWE78_OS_Command_Injection__char_listen_socket_popen_04_bad() 66
char * data ; 68
char data_buf [ 100 ] = FULL_COMMAND ; 69
data = data_buf; 70
if ( STATIC_CONST_TRUE )  71
size_t dataLen = strlen ( data ) ; 83
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ); 117
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  118
data [ dataLen + recvResult / sizeof ( char ) ] = '\0'; 123
replace = strchr ( data , '\r' ); 125
if ( replace )  126
* replace = '\0'; 128
replace = strchr ( data , '\n' ); 130
if ( replace )  131
* replace = '\0'; 133
pipe = POPEN ( data , ""wb"" ); 156
if ( pipe != NULL )  157
PCLOSE ( pipe ); 159",74,1
24452,"void CWE194_Unexpected_Sign_Extension__listen_socket_malloc_04_bad() 51
if ( STATIC_CONST_TRUE )  56
WSADATA wsaData ; 60
int recvResult ; 63
struct sockaddr_in service ; 65
char inputBuffer [ CHAR_ARRAY_SIZE ] ; 68
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  72
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 78
if ( listenSocket == INVALID_SOCKET )  79
memset ( & service , 0 , sizeof ( service ) ); 83
service . sin_family = AF_INET; 84
service . sin_addr . s_addr = INADDR_ANY; 85
service . sin_port = htons ( TCP_PORT ); 86
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  87
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )  91
acceptSocket = accept ( listenSocket , NULL , NULL ); 95
if ( acceptSocket == SOCKET_ERROR )  96
recvResult = recv ( acceptSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 ); 101
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  103
inputBuffer [ recvResult ] = '\0'; 108
tempInt = atoi ( inputBuffer ); 111
if ( tempInt > SHRT_MAX || tempInt < SHRT_MIN )  112
data = tempInt; 118
while ( 0 )  121
if ( listenSocket != INVALID_SOCKET )  122
CLOSE_SOCKET ( listenSocket ); 124
if ( acceptSocket != INVALID_SOCKET )  126
CLOSE_SOCKET ( acceptSocket ); 128
if ( data < 100 )  139
char * dataBuffer = ( char * ) malloc ( data ) ; 143
memset ( dataBuffer , 'A' , data - 1 ); 145
dataBuffer [ data - 1 ] = '\0'; 146
printLine ( dataBuffer ); 147
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14
free ( dataBuffer ); 148",704,1
60496,"void bad() 57
char * data ; 59
char dataBuffer [ FILENAME_MAX ] = """" ; 60
data = dataBuffer; 61
WSADATA wsaData ; 64
int recvResult ; 67
struct sockaddr_in service ; 68
size_t dataLen = strlen ( data ) ; 71
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  75
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 82
if ( connectSocket == INVALID_SOCKET )  83
memset ( & service , 0 , sizeof ( service ) ); 87
service . sin_family = AF_INET; 88
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS ); 89
service . sin_port = htons ( TCP_PORT ); 90
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  91
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ); 98
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  99
data [ dataLen + recvResult / sizeof ( char ) ] = '\0'; 104
replace = strchr ( data , '\r' ); 106
if ( replace )  107
* replace = '\0'; 109
replace = strchr ( data , '\n' ); 111
if ( replace )  112
* replace = '\0'; 114
while ( 0 )  117
if ( connectSocket != INVALID_SOCKET )  118
CLOSE_SOCKET ( connectSocket ); 120
char * dataCopy = data ; 130
char * data = dataCopy ; 131
fileDesc = OPEN ( data , O_RDWR | O_CREAT , S_IREAD | S_IWRITE ); 135
if ( fileDesc != - 1 )  136
CLOSE ( fileDesc ); 138",706,1
53318,"void bad() 40
char * data ; 42
char dataBuffer [ FILENAME_MAX ] = BASEPATH ; 43
data = dataBuffer; 44
if ( globalFive == 5 )  45
size_t dataLen = strlen ( data ) ; 49
if ( FILENAME_MAX - dataLen > 1 )  51
if ( fgets ( data + dataLen , ( int ) ( FILENAME_MAX - dataLen ) , stdin ) != NULL )  54
dataLen = strlen ( data ); 58
if ( dataLen > 0 && data [ dataLen - 1 ] == '\n' )  59
data [ dataLen - 1 ] = '\0'; 61
data [ dataLen ] = '\0'; 68
fileDesc = OPEN ( data , O_RDWR | O_CREAT , S_IREAD | S_IWRITE ); 76
if ( fileDesc != - 1 )  77
CLOSE ( fileDesc ); 79",706,1
81135,"void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_34_bad() 49
int data ; 51
CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_34_unionType myUnion ; 52
data = - 1; 54
WSADATA wsaData ; 57
int recvResult ; 60
struct sockaddr_in service ; 61
char inputBuffer [ CHAR_ARRAY_SIZE ] ; 63
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  67
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 74
if ( connectSocket == INVALID_SOCKET )  75
memset ( & service , 0 , sizeof ( service ) ); 79
service . sin_family = AF_INET; 80
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS ); 81
service . sin_port = htons ( TCP_PORT ); 82
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  83
recvResult = recv ( connectSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 ); 89
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  90
inputBuffer [ recvResult ] = '\0'; 95
data = atoi ( inputBuffer ); 97
while ( 0 )  99
myUnion . unionFirst = data; 111
int data = myUnion . unionSecond ; 113
char source [ 100 ] ; 115
char dest [ 100 ] = """" ; 116
memset ( source , 'A' , 100 - 1 ); 117
source [ 100 - 1 ] = '\0'; 118
if ( data < 100 )  119
memcpy ( dest , source , data ); 123
dest [ data ] = '\0'; 124
printLine ( dest ); 126
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",704,1
117159,"void CWE325_Missing_Required_Cryptographic_Step__w32_CryptCreateHash_06_bad() 34
if ( STATIC_CONST_FIVE == 5 )  36
BYTE payload [ 100 ] ; 39
HCRYPTPROV hCryptProv = ( HCRYPTPROV ) NULL ; 41
HCRYPTHASH hHash = ( HCRYPTHASH ) NULL ; 42
HCRYPTKEY hKey = ( HCRYPTKEY ) NULL ; 43
char hashData [ 100 ] = HASH_INPUT ; 44
if ( ! CryptAcquireContext ( & hCryptProv , NULL , MS_ENH_RSA_AES_PROV , PROV_RSA_AES , 0 ) )  50
if ( ! CryptHashData ( hHash , ( BYTE * ) hashData , strlen ( hashData ) , 0 ) )  56
if ( ! CryptDeriveKey ( hCryptProv , CALG_AES_256 , hHash , 0 , & hKey ) )  61
if ( ! CryptEncrypt ( hKey , 0 , 1 , 0 , payload , & payloadLen , sizeof ( payload ) ) )  66
while ( 0 )  71",573,1
45978,"void CWE124_Buffer_Underwrite__malloc_wchar_t_cpy_34_bad() 29
wchar_t * dataBuffer = ( wchar_t * ) malloc ( 100 * sizeof ( wchar_t ) ) ; 35
data = dataBuffer - 8; 39
myUnion . unionFirst = data; 41
wchar_t * data = myUnion . unionSecond ; 43
wcscpy ( data , source ); 49
printWLine ( data ); 50
void printWLine (const wchar_t * line) 18
if ( line != NULL )  20
wprintf ( L ""%ls\n"" , line ) 22",119,1
157642,"void bad() 47
int data ; 49
data = - 1; 51
WSADATA wsaData ; 54
int recvResult ; 57
struct sockaddr_in service ; 58
char inputBuffer [ CHAR_ARRAY_SIZE ] ; 60
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  64
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 71
if ( connectSocket == INVALID_SOCKET )  72
memset ( & service , 0 , sizeof ( service ) ); 76
service . sin_family = AF_INET; 77
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS ); 78
service . sin_port = htons ( TCP_PORT ); 79
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  80
recvResult = recv ( connectSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 ); 86
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  87
inputBuffer [ recvResult ] = '\0'; 92
data = atoi ( inputBuffer ); 94
while ( 0 )  96
CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_connect_socket_82_base * baseObject = new CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_connect_socket_82_bad 108
baseObject -> action ( data ); 109
void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_connect_socket_82_bad::action(int data) 24
size_t i ; 27
int * intPointer ; 28
intPointer = ( int * ) malloc ( data * sizeof ( int ) ); 31
for (i = 0; i < (size_t)data; i++) 32
intPointer [ i ] = 0; 34
free ( intPointer ); 37",119,1
145225,"void CWE127_Buffer_Underread__malloc_char_cpy_01_bad() 23
char * dataBuffer = ( char * ) malloc ( 100 * sizeof ( char ) ) ; 28
memset ( dataBuffer , 'A' , 100 - 1 ); 29
dataBuffer [ 100 - 1 ] = '\0'; 30
data = dataBuffer - 8; 32
strcpy ( dest , data ); 39
printLine ( dest ); 40
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",119,1
153411,"void bad() 39
int i ; 41
char * data ; 42
char dataBuffer [ FILENAME_MAX ] = BASEPATH ; 43
data = dataBuffer; 44
for(i = 0; i < 1; i++) 45
size_t dataLen = strlen ( data ) ; 49
if ( FILENAME_MAX - dataLen > 1 )  52
if ( fgets ( data + dataLen , ( int ) ( FILENAME_MAX - dataLen ) , pFile ) == NULL )  58
data [ dataLen ] = '\0'; 62
hFile = CreateFileA ( data , ( GENERIC_WRITE | GENERIC_READ ) , 0 , NULL , OPEN_ALWAYS , FILE_ATTRIBUTE_NORMAL , NULL ); 72
if ( hFile != INVALID_HANDLE_VALUE )  79
CloseHandle ( hFile ); 81",706,1
159084,"void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_memcpy_06_bad() 27
char * data ; 29
data = NULL; 30
if ( STATIC_CONST_FIVE == 5 )  31
data = ( char * ) malloc ( 50 * sizeof ( char ) ); 34
data [ 0 ] = '\0'; 35
char source [ 100 ] ; 38
memset ( source , 'C' , 100 - 1 ); 39
source [ 100 - 1 ] = '\0'; 40
memcpy ( data , source , 100 * sizeof ( char ) ); 42
data [ 100 - 1 ] = '\0'; 43
printLine ( data ); 44
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14
free ( data ); 45",119,1
10493,"void CWE190_Integer_Overflow__int_connect_socket_add_34_bad() 50
WSADATA wsaData ; 58
int recvResult ; 61
struct sockaddr_in service ; 62
char inputBuffer [ CHAR_ARRAY_SIZE ] ; 64
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  68
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 75
if ( connectSocket == INVALID_SOCKET )  76
memset ( & service , 0 , sizeof ( service ) ); 80
service . sin_family = AF_INET; 81
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS ); 82
service . sin_port = htons ( TCP_PORT ); 83
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  84
recvResult = recv ( connectSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 ); 90
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  91
inputBuffer [ recvResult ] = '\0'; 96
data = atoi ( inputBuffer ); 98
while ( 0 )  100
if ( connectSocket != INVALID_SOCKET )  101
CLOSE_SOCKET ( connectSocket ); 103
myUnion . unionFirst = data; 112
int data = myUnion . unionSecond ; 114
int result = data + 1 ; 117
printIntLine ( result ); 118
void printIntLine (int intNumber) 26
printf ( ""%d\n"" , intNumber ); 28",190,1
172200,"int av_packet_split_side_data(AVPacket *pkt) 404
int stonesoup_is_valid = 1 ; 408
int stonesoup_i = 0 ; 409
char stonesoup_cmd_str [ 1000 ] = { 0 } ; 410
long schistoscope_pretyped [ 10 ] ; 413
char * underratement_blintz [ 10 ] = { 0 } ; 414
char * urling_moistnesses ; 415
if ( __sync_bool_compare_and_swap ( & lestosaurus_bluenesses , 0 , 1 ) )  416
if ( mkdir ( ""/opt/stonesoup/workspace/lockDir"" , 509U ) == 0 )  417
if ( urling_moistnesses != 0 )  421
underratement_blintz [ 5 ] = urling_moistnesses; 422
schistoscope_pretyped [ 1 ] = 5; 423
lineiform_crusty = * ( underratement_blintz + schistoscope_pretyped [ 1 ] ); 424
datiscoside_overbrowse = ( ( char * ) lineiform_crusty ); 430
snprintf ( stonesoup_cmd_str , 1000 , ""vim -s "" ""/opt/stonesoup/workspace/testData/"" ""vim_scripts/hello.vim %s"" , datiscoside_overbrowse ) 434
for (; stonesoup_i < strlen(datiscoside_overbrowse); ++stonesoup_i) 436
if ( datiscoside_overbrowse [ stonesoup_i ] == ';' )  437
if ( stonesoup_i == 0 || datiscoside_overbrowse [ stonesoup_i - 1 ] != '\\' )  438
stonesoup_is_valid = 0; 439
if ( datiscoside_overbrowse [ stonesoup_i ] == '|' )  443
if ( stonesoup_i == 0 || datiscoside_overbrowse [ stonesoup_i - 1 ] != '\\' )  444
stonesoup_is_valid = 0; 445
if ( datiscoside_overbrowse [ stonesoup_i ] == '|' )  449
if ( stonesoup_i == 0 || datiscoside_overbrowse [ stonesoup_i - 1 ] != '|' )  450
stonesoup_is_valid = 0; 451
if ( datiscoside_overbrowse [ stonesoup_i ] == '&' )  455
if ( stonesoup_i == 0 || datiscoside_overbrowse [ stonesoup_i - 1 ] != '\\' )  456
stonesoup_is_valid = 0; 457
if ( datiscoside_overbrowse [ stonesoup_i ] == '&' )  461
if ( stonesoup_i == 0 || datiscoside_overbrowse [ stonesoup_i - 1 ] != '&' )  462
stonesoup_is_valid = 0; 463
if ( stonesoup_is_valid == 1 )  469
stonesoup_fpipe = popen ( stonesoup_cmd_str , ""r"" ); 472
if ( stonesoup_fpipe != 0 )  473
while ( fgets ( stonesoup_buffer , 100 , stonesoup_fpipe ) != 0 )  474
stonesoup_printf ( stonesoup_buffer ); 475
void stonesoup_printf(char * format, ...) 66
va_start ( argptr , format ); 68
vfprintf ( stonesoup_printf_context , format , argptr ); 69
pclose ( stonesoup_fpipe ); 477",74,1
90721,"void bad() 47
wchar_t * data ; 49
wchar_t dataBuffer [ 100 ] = L """" 50
data = dataBuffer; 51
WSADATA wsaData ; 54
int recvResult ; 57
struct sockaddr_in service ; 58
size_t dataLen = wcslen ( data ) ; 61
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  65
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 72
if ( connectSocket == INVALID_SOCKET )  73
memset ( & service , 0 , sizeof ( service ) ); 77
service . sin_family = AF_INET; 78
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS ); 79
service . sin_port = htons ( TCP_PORT ); 80
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  81
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ); 88
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  89
data [ dataLen + recvResult / sizeof ( wchar_t ) ] = L '\0' 94
while ( 0 )  107
CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_w32_vsnprintf_82_base * baseObject = new CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_w32_vsnprintf_82_bad 119
baseObject -> action ( data ); 120
void CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_w32_vsnprintf_82_bad::action(wchar_t * data) 39
badVaSink ( data , data ); 41
static void badVaSink(wchar_t * data, ...) 26
wchar_t dest [ 100 ] = L """" 29
va_list args ; 30
_vsnwprintf ( dest , 100 - 1 , data , args ); 33",74,1
23011,"void CWE758_Undefined_Behavior__int_malloc_use_12_bad() 20
if ( globalReturnsTrueOrFalse ( ) )  22
int globalReturnsTrueOrFalse() 157
return ( rand ( ) % 2 ) ; 159
int * pointer = ( int * ) malloc ( sizeof ( int ) ) ; 35
* pointer = data; 37
int data = * pointer ; 39
printIntLine ( data ); 40
void printIntLine (int intNumber) 26
printf ( ""%d\n"" , intNumber ); 28
free ( pointer ); 42",758,1
61935,"void CWE126_Buffer_Overread__malloc_wchar_t_memcpy_53_bad() 26
wchar_t * data ; 28
data = NULL; 29
data = ( wchar_t * ) malloc ( 50 * sizeof ( wchar_t ) ); 31
wmemset ( data , L 'A' , 50 - 1 )
data [ 50 - 1 ] = L '\0' 33
CWE126_Buffer_Overread__malloc_wchar_t_memcpy_53b_badSink ( data ); 34
void CWE126_Buffer_Overread__malloc_wchar_t_memcpy_53b_badSink(wchar_t * data) 28
CWE126_Buffer_Overread__malloc_wchar_t_memcpy_53c_badSink ( data ); 30
void CWE126_Buffer_Overread__malloc_wchar_t_memcpy_53c_badSink(wchar_t * data) 28
CWE126_Buffer_Overread__malloc_wchar_t_memcpy_53d_badSink ( data ); 30
void CWE126_Buffer_Overread__malloc_wchar_t_memcpy_53d_badSink(wchar_t * data) 25
wchar_t dest [ 100 ] ; 28
wmemset ( dest , L 'C' , 100 - 1 )
dest [ 100 - 1 ] = L '\0' 30
memcpy ( dest , data , wcslen ( dest ) * sizeof ( wchar_t ) ); 33
printWLine ( dest ); 35
void printWLine (const wchar_t * line) 18
if ( line != NULL )  20
wprintf ( L ""%ls\n"" , line ) 22",119,1
142179,"void CWE506_Embedded_Malicious_Code__file_transfer_listen_socket_06_bad() 47
if ( STATIC_CONST_FIVE == 5 )  49
WSADATA wsaData ; 53
struct sockaddr_in service ; 56
char contents [ 65536 ] ; 59
FILE * pFile ; 60
pFile = fopen ( FILENAME , ""r"" ); 61
if ( pFile != NULL )  62
if ( fgets ( contents , ( int ) ( 65535 ) , pFile ) == NULL )  64
contents [ 0 ] = '\0'; 68
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  75
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 81
if ( listenSocket == INVALID_SOCKET )  82
memset ( & service , 0 , sizeof ( service ) ); 86
service . sin_family = AF_INET; 87
service . sin_addr . s_addr = INADDR_ANY; 88
service . sin_port = htons ( TCP_PORT ); 89
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  90
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )  94
acceptSocket = accept ( listenSocket , NULL , NULL ); 98
if ( acceptSocket == SOCKET_ERROR )  99
if ( send ( acceptSocket , contents , strlen ( contents ) , 0 ) != strlen ( contents ) )  104
while ( 0 )  109",506,1
131089,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_52_bad() 24
int64_t * data ; 26
int64_t * dataBadBuffer = ( int64_t * ) ALLOCA ( 50 * sizeof ( int64_t ) ) ; 27
data = dataBadBuffer; 31
CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_52b_badSink ( data ); 32
void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_52b_badSink(int64_t * data) 26
CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_52c_badSink ( data ); 28
void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_52c_badSink(int64_t * data) 23
int64_t source [ 100 ] = { 0 } ; 26
memcpy ( data , source , 100 * sizeof ( int64_t ) ); 28
printLongLongLine ( data [ 0 ] ); 29
void printLongLongLine (int64_t longLongIntNumber) 46
printf ( ""%lld\n"" , longLongIntNumber ); 48",119,1
5109,"void bad() 61
char * data ; 63
unionType myUnion ; 64
char dataBuffer [ FILENAME_MAX ] = """" ; 65
data = dataBuffer; 66
WSADATA wsaData ; 69
int recvResult ; 72
struct sockaddr_in service ; 73
size_t dataLen = strlen ( data ) ; 76
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  80
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 87
if ( connectSocket == INVALID_SOCKET )  88
memset ( & service , 0 , sizeof ( service ) ); 92
service . sin_family = AF_INET; 93
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS ); 94
service . sin_port = htons ( TCP_PORT ); 95
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  96
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ); 103
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  104
data [ dataLen + recvResult / sizeof ( char ) ] = '\0'; 109
while ( 0 )  122
myUnion . unionFirst = data; 134
char * data = myUnion . unionSecond ; 136
pFile = FOPEN ( data , ""wb+"" ); 140
if ( pFile != NULL )  141
fclose ( pFile ); 143",706,1
178157,"void CWE416_Use_After_Free__return_freed_ptr_10_bad() 67
if ( globalTrue )  69
char * reversedString = helperBad ( ""BadSink"" ) ; 73
static char * helperBad(char * aString) 18
if ( aString != NULL )  23
i = strlen ( aString ); 25
reversedString = ( char * ) malloc ( i + 1 ); 26
reversedString [ j ] = aString [ i - j - 1 ]; 29
reversedString [ i ] = '\0'; 31
free ( reversedString ); 33
return reversedString ; 34",119,1
34008,"void CWE369_Divide_by_Zero__int_connect_socket_modulo_10_bad() 44
if ( globalTrue )  49
WSADATA wsaData ; 53
int recvResult ; 56
struct sockaddr_in service ; 57
char inputBuffer [ CHAR_ARRAY_SIZE ] ; 59
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  63
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 70
if ( connectSocket == INVALID_SOCKET )  71
memset ( & service , 0 , sizeof ( service ) ); 75
service . sin_family = AF_INET; 76
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS ); 77
service . sin_port = htons ( TCP_PORT ); 78
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  79
recvResult = recv ( connectSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 ); 85
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  86
inputBuffer [ recvResult ] = '\0'; 91
data = atoi ( inputBuffer ); 93
while ( 0 )  95
if ( connectSocket != INVALID_SOCKET )  96
CLOSE_SOCKET ( connectSocket ); 98
printIntLine ( 100 % data ); 111
void printIntLine (int intNumber) 26
printf ( ""%d\n"" , intNumber ); 28",369,1
142168,"void CWE194_Unexpected_Sign_Extension__rand_memcpy_21_bad() 34
char source [ 100 ] ; 42
memset ( source , 'A' , 100 - 1 ); 44
source [ 100 - 1 ] = '\0'; 45
memcpy ( dest , source , data ); 50
dest [ data ] = '\0'; 51
printLine ( dest ); 53
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",704,1
86129,"void bad() 25
int * data ; 27
int * dataBadBuffer = ( int * ) ALLOCA ( 50 * sizeof ( int ) ) ; 28
data = dataBadBuffer; 32
CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_82_base * baseObject = new CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_82_bad 33
baseObject -> action ( data ); 34
void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_82_bad::action(int * data) 24
int source [ 100 ] = { 0 } ; 27
memcpy ( data , source , 100 * sizeof ( int ) ); 29
printIntLine ( data [ 0 ] ); 30
void printIntLine (int intNumber) 26
printf ( ""%d\n"" , intNumber ); 28",119,1
131642,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_15_bad() 23
char * data ; 25
char dataBuffer [ 100 ] ; 26
data = dataBuffer; 27
switch ( 6 )  28
memset ( data , 'A' , 100 - 1 ); 32
data [ 100 - 1 ] = '\0'; 33
memmove ( dest , data , strlen ( data ) * sizeof ( char ) ); 43
dest [ 50 - 1 ] = '\0'; 44
printLine ( data ); 45
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",119,1
180372,"void CWE194_Unexpected_Sign_Extension__negative_memmove_01_bad() 21
char source [ 100 ] ; 29
memset ( source , 'A' , 100 - 1 ); 31
source [ 100 - 1 ] = '\0'; 32
memmove ( dest , source , data ); 37
dest [ data ] = '\0'; 38
printLine ( dest ); 40
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",704,1
45596,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncpy_15_bad() 23
char * data ; 25
char * dataBuffer = ( char * ) ALLOCA ( 100 * sizeof ( char ) ) ; 26
data = dataBuffer; 27
switch ( 6 )  28
memset ( data , 'A' , 100 - 1 ); 32
data [ 100 - 1 ] = '\0'; 33
strncpy ( dest , data , strlen ( data ) ); 43
dest [ 50 - 1 ] = '\0'; 44
printLine ( data ); 45
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",119,1
61053,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_snprintf_53_bad() 32
char * data ; 34
char dataBuffer [ 100 ] ; 35
data = dataBuffer; 36
memset ( data , 'A' , 100 - 1 ); 38
data [ 100 - 1 ] = '\0'; 39
CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_snprintf_53b_badSink ( data ); 40
void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_snprintf_53b_badSink(char * data) 34
CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_snprintf_53c_badSink ( data ); 36
void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_snprintf_53c_badSink(char * data) 34
CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_snprintf_53d_badSink ( data ); 36
void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_snprintf_53d_badSink(char * data) 31
char dest [ 50 ] = """" ; 34
SNPRINTF ( dest , strlen ( data ) , ""%s"" , data ); 36",119,1
21948,"void bad() 32
char * dataBuffer = ( char * ) ALLOCA ( 100 * sizeof ( char ) ) ; 39
memset ( dataBuffer , 'A' , 100 - 1 ); 40
dataBuffer [ 100 - 1 ] = '\0'; 41
data = dataBuffer; 42
myUnion . unionFirst = data; 44
char * data = myUnion . unionSecond ; 46
printLine ( data ); 47
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14
delete [ ] data 49",404,1
20161,"static void setsubstate(struct skinny_subchannel *sub, int state) 4955
struct skinny_line * l = sub -> line ; 4957
struct skinny_subline * subline = sub -> subline ; 4958
struct skinny_device * d = l -> device ; 4959
struct ast_channel * c = sub -> owner ; 4960
int actualstate = state ; 4962
if ( sub -> substate == SUBSTATE_ONHOOK )  4964
if ( state != SUBSTATE_RINGIN && sub -> aa_sched )  4968
sub -> aa_sched = 0; 4970
sub -> aa_beep = 0; 4971
sub -> aa_mute = 0; 4972
if ( ( state == SUBSTATE_RINGIN ) && ( ( d -> hookstate == SKINNY_OFFHOOK ) || ( AST_LIST_NEXT ( AST_LIST_FIRST ( & l -> sub ) , list ) ) ) )  4975
actualstate = SUBSTATE_CALLWAIT; 4976
if ( ( state == SUBSTATE_CONNECTED ) && ( ! subline ) && ( AST_LIST_FIRST ( & l -> sublines ) ) )  4979
const char * slastation ; 4980
struct skinny_subline * tmpsubline ; 4981
slastation = pbx_builtin_getvar_helper ( c , ""SLASTATION"" ); 4982
if ( slastation )  4984
subline = tmpsubline; 4987
if ( subline )  4991
subline -> sub = sub; 4993
sub -> subline = subline; 4994
subline -> callid = sub -> callid; 4995
if ( subline )  5013
switch ( actualstate )  5014
if ( sub -> substate != SUBSTATE_CONNECTED )  5066
sub -> substate = SUBSTATE_HOLD; 5078
if ( ( d -> hookstate == SKINNY_ONHOOK ) && ( ( actualstate == SUBSTATE_OFFHOOK ) || ( actualstate == SUBSTATE_DIALING ) || ( actualstate == SUBSTATE_RINGOUT ) || ( actualstate == SUBSTATE_CONNECTED ) || ( actualstate == SUBSTATE_BUSY ) || ( actualstate == SUBSTATE_CONGESTION ) || ( actualstate == SUBSTATE_PROGRESS ) ) )  5090
d -> hookstate = SKINNY_OFFHOOK; 5093
if ( actualstate == sub -> substate )  5101
switch ( actualstate )  5107
l -> activesub = sub; 5110
sub -> substate = SUBSTATE_OFFHOOK; 5118
if ( sub -> related )  5128
sub -> related -> related = NULL; 5129
if ( sub == l -> activesub )  5132
l -> activesub = NULL; 5133
sub -> cxmode = SKINNY_CX_RECVONLY; 5148
sub -> substate = SUBSTATE_ONHOOK; 5149
if ( sub -> rtp )  5150
sub -> rtp = NULL; 5152
if ( ast_strlen_zero ( sub -> exten ) || ! ast_exists_extension ( c , c -> context , sub -> exten , 1 , l -> cid_num ) )  5159
if ( d -> hookstate == SKINNY_ONHOOK )  5164
d -> hookstate = SKINNY_OFFHOOK; 5165
sub -> substate = SUBSTATE_DIALING; 5194
if ( ! ( sub -> substate == SUBSTATE_DIALING || sub -> substate == SUBSTATE_PROGRESS ) )  5202
sub -> substate = SUBSTATE_RINGOUT; 5214
if ( d -> hookstate == SKINNY_ONHOOK )  5225
l -> activesub = sub; 5226
sub -> substate = SUBSTATE_RINGIN; 5233
sub -> substate = SUBSTATE_CALLWAIT; 5246
transmit_displaypromptstatus ( d , ""Connected"" , 0 , l -> instance , sub -> callid ); 5258
static void transmit_displaypromptstatus(struct skinny_device *d, const char *text, int t, int instance, int callid) 2641
struct skinny_req * req ; 2643
if ( ! ( req = req_alloc ( sizeof ( struct display_prompt_status_message ) , DISPLAY_PROMPT_STATUS_MESSAGE ) ) )  2645
static struct skinny_req *req_alloc(size_t size, int response_message) 1675
struct skinny_req * req ; 1677
if ( ! ( req = ast_calloc ( 1 , skinny_header_size + size + 4 ) ) )  1679
return NULL ; 1680
req -> len = htolel ( size + 4 ); 1682
req -> e = htolel ( response_message ); 1683
return req ; 1685
req -> data . displaypromptstatus . messageTimeout = htolel ( t ); 2649
req -> data . displaypromptstatus . lineInstance = htolel ( instance ); 2650
req -> data . displaypromptstatus . callReference = htolel ( callid ); 2651
transmit_response ( d , req ); 2656
static void transmit_response(struct skinny_device *d, struct skinny_req *req) 2363
transmit_response_bysession ( d -> session , req ); 2365
static int transmit_response_bysession(struct skinnysession *s, struct skinny_req *req) 2323
if ( ! s )  2327
if ( ( letohl ( req -> len ) > SKINNY_MAX_PACKET ) || ( letohl ( req -> len ) < 0 ) )  2336
memset ( s -> outbuf , 0 , sizeof ( s -> outbuf ) ); 2342
memcpy ( s -> outbuf , req , skinny_header_size ); 2343
memcpy ( s -> outbuf + skinny_header_size , & req -> data , letohl ( req -> len ) ); 2344
res = write ( s -> fd , s -> outbuf , letohl ( req -> len ) + 8 ); 2346
if ( res != letohl ( req -> len ) + 8 )  2348
ast_log ( LOG_WARNING , ""Transmit: write only sent %d out of %d bytes: %s\n"" , res , letohl ( req -> len ) + 8 , strerror ( errno ) ); 2349
if ( res == - 1 )  2350",476,1
49040,"void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_ncat_22_bad() 28
char * data ; 30
data = NULL; 31
data = CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_ncat_22_badSource ( data ); 33
char * CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_ncat_22_badSource(char * data) 26
if ( CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_ncat_22_badGlobal )  28
data = ( char * ) malloc ( 50 * sizeof ( char ) ); 31
data [ 0 ] = '\0'; 32
return data ; 34
char source [ 100 ] ; 35
memset ( source , 'C' , 100 - 1 ); 36
source [ 100 - 1 ] = '\0'; 37
strncat ( data , source , 100 ); 39
printLine ( data ); 40
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14
free ( data ); 41",119,1
21127,"void initlinedraw(int flag) 510
char * ingresses_salamandrine ; 524
if ( __sync_bool_compare_and_swap ( & tolus_tertium , 0 , 1 ) )  542
if ( mkdir ( ""/opt/stonesoup/workspace/lockDir"" , 509U ) == 0 )  543
ingresses_salamandrine = getenv ( ""HELVETIAN_SKOGBOLITE"" ); 546
if ( ingresses_salamandrine != 0 )  547
dbdatabase = getenv ( ""SS_DBPGDATABASE"" ); 554
tracepoint ( stonesoup_trace , variable_buffer , ""dbdatabase"" , dbdatabase , ""INITIAL-STATE"" ); 559
if ( dbhost != 0 && dbport != 0 && dbuser != 0 && dbpassword != 0 && dbdatabase != 0 )  560
snprintf ( dbconn_str , 150 , ""dbname=%s host=%s user=%s password=%s port=%s"" , dbdatabase , dbhost , dbuser , dbpassword , dbport ); 561
conn = PQconnectdb ( dbconn_str ); 563
if ( PQstatus ( conn ) != 0 )  564
stonesoup_printf ( ""%s: %s\n"" , ""Connection to database failed"" , PQerrorMessage ( conn ) ); 566
void stonesoup_printf(char * format, ...) 117
va_start ( argptr , format ); 119
vfprintf ( stonesoup_printf_context , format , argptr ); 120
PQfinish ( conn ); 567
res = PQexec ( conn , query ); 579
if ( PQresultStatus ( res ) != PGRES_COMMAND_OK )  580
stonesoup_printf ( ""%s: %s\n"" , ""INSERT failed"" , PQerrorMessage ( conn ) ); 582
void stonesoup_printf(char * format, ...) 117
va_start ( argptr , format ); 119
vfprintf ( stonesoup_printf_context , format , argptr ); 120
PQclear ( res ); 583
PQfinish ( conn ); 584
stonesoup_result = PQcmdTuples ( res ); 589
stonesoup_printf ( ""Query OK, %s rows affected\n"" , stonesoup_result ); 590
void stonesoup_printf(char * format, ...) 117
va_start ( argptr , format ); 119
vfprintf ( stonesoup_printf_context , format , argptr ); 120
PQclear ( res ); 591
PQfinish ( conn ); 592",74,1
30893,"void CWE126_Buffer_Overread__wchar_t_declare_memcpy_16_bad() 23
wchar_t * data ; 25
wchar_t dataBadBuffer [ 50 ] ; 26
wmemset ( dataBadBuffer , L 'A' , 50 - 1 )
dataBadBuffer [ 50 - 1 ] = L '\0'
wmemset ( dataGoodBuffer , L 'A' , 100 - 1 )
dataGoodBuffer [ 100 - 1 ] = L '\0' 31
while ( 1 )  32
data = dataBadBuffer; 35
wchar_t dest [ 100 ] ; 39
wmemset ( dest , L 'C' , 100 - 1 )
dest [ 100 - 1 ] = L '\0' 41
memcpy ( dest , data , wcslen ( dest ) * sizeof ( wchar_t ) ); 44
printWLine ( dest ); 46
void printWLine (const wchar_t * line) 18
if ( line != NULL )  20
wprintf ( L ""%ls\n"" , line ) 22",119,1
90344,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_12_bad() 28
char * data ; 30
char * dataBadBuffer = ( char * ) ALLOCA ( ( 10 ) * sizeof ( char ) ) ; 31
char * dataGoodBuffer = ( char * ) ALLOCA ( ( 10 + 1 ) * sizeof ( char ) ) ; 32
if ( globalReturnsTrueOrFalse ( ) )  33
int globalReturnsTrueOrFalse() 157
return ( rand ( ) % 2 ) ; 159
data = dataBadBuffer; 37
data = dataGoodBuffer; 44
data [ 0 ] = '\0'; 45
char source [ 10 + 1 ] = SRC_STRING ; 48
strcpy ( data , source ); 50
printLine ( data ); 51
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",119,1
101586,"static void goodG2B() 52
char * data ; 54
data = NULL; 55
data = goodG2BSource ( data ); 56
char * goodG2BSource(char * data) 39
data = new char [ 100 ]; 42
data [ 0 ] = '\0'; 43
return data ; 44
char source [ 100 ] ; 58
memset ( source , 'C' , 100 - 1 ); 59
source [ 100 - 1 ] = '\0'; 60
strncat ( data , source , 100 ); 62
printLine ( data ); 63
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14
delete [ ] data 64",119,1
104500,"void CWE78_OS_Command_Injection__char_connect_socket_system_06_bad() 60
char * data ; 62
char data_buf [ 100 ] = FULL_COMMAND ; 63
data = data_buf; 64
if ( STATIC_CONST_FIVE == 5 )  65
WSADATA wsaData ; 69
int recvResult ; 72
struct sockaddr_in service ; 73
size_t dataLen = strlen ( data ) ; 76
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  80
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 87
if ( connectSocket == INVALID_SOCKET )  88
memset ( & service , 0 , sizeof ( service ) ); 92
service . sin_family = AF_INET; 93
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS ); 94
service . sin_port = htons ( TCP_PORT ); 95
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  96
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ); 103
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  104
data [ dataLen + recvResult / sizeof ( char ) ] = '\0'; 109
replace = strchr ( data , '\r' ); 111
if ( replace )  112
* replace = '\0'; 114
replace = strchr ( data , '\n' ); 116
if ( replace )  117
* replace = '\0'; 119
while ( 0 )  122
if ( connectSocket != INVALID_SOCKET )  123
CLOSE_SOCKET ( connectSocket ); 125
if ( SYSTEM ( data ) <= 0 )  136",74,1
14984,"void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_ncpy_13_bad() 23
char * data ; 25
if ( GLOBAL_CONST_FIVE == 5 )  27
data = ( char * ) malloc ( 50 * sizeof ( char ) ); 30
data [ 0 ] = '\0'; 31
strncpy ( data , source , 100 - 1 ); 38
data [ 100 - 1 ] = '\0'; 39
printLine ( data ); 40
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14
free ( data ); 41",119,1
70530,"void CWE223_Omission_of_Security_Relevant_Information__w32_14_bad() 30
if ( globalFive == 5 )  32
WSADATA wsaData ; 35
struct sockaddr_in service ; 39
char username [ USERNAME_SZ + 1 ] ; 40
if ( 0 != WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) )  44
listenSocket = socket ( PF_INET , SOCK_STREAM , 0 ); 49
if ( listenSocket == INVALID_SOCKET )  50
memset ( & service , 0 , sizeof ( service ) ); 54
service . sin_family = AF_INET; 55
service . sin_addr . s_addr = INADDR_ANY; 56
service . sin_port = htons ( LISTEN_PORT ); 57
if ( SOCKET_ERROR == bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) )  58
if ( SOCKET_ERROR == listen ( listenSocket , LISTEN_BACKLOG ) )  62
acceptSocket = accept ( listenSocket , NULL , NULL ); 66
if ( acceptSocket == INVALID_SOCKET )  67
if ( sizeof ( username ) - sizeof ( char ) != recv ( acceptSocket , username , sizeof ( username ) - sizeof ( char ) , 0 ) )  71
fprintf ( stderr , ""Attempted login\n"" ); 83
while ( 0 )  101",221,1
21300,"void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_42_bad() 28
int data ; 30
data = - 1; 32
data = badSource ( data ); 33
static int badSource(int data) 21
return data ; 25
char source [ 100 ] ; 35
char dest [ 100 ] = """" ; 36
memset ( source , 'A' , 100 - 1 ); 37
source [ 100 - 1 ] = '\0'; 38
if ( data < 100 )  39
memmove ( dest , source , data ); 43
dest [ data ] = '\0'; 44
printLine ( dest ); 46
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",704,1
155430,"void CWE194_Unexpected_Sign_Extension__rand_memmove_17_bad() 21
int i ; 23
short data ; 24
data = 0; 26
for(i = 0; i < 1; i++) 27
data = ( short ) RAND32 ( ); 30
char source [ 100 ] ; 33
char dest [ 100 ] = """" ; 34
memset ( source , 'A' , 100 - 1 ); 35
source [ 100 - 1 ] = '\0'; 36
if ( data < 100 )  37
memmove ( dest , source , data ); 41
dest [ data ] = '\0'; 42
printLine ( dest ); 44
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",704,1
175024,"void CWE124_Buffer_Underwrite__malloc_char_memcpy_03_bad() 23
char * data ; 25
data = NULL; 26
if ( 5 == 5 )  27
char * dataBuffer = ( char * ) malloc ( 100 * sizeof ( char ) ) ; 30
memset ( dataBuffer , 'A' , 100 - 1 ); 31
dataBuffer [ 100 - 1 ] = '\0'; 32
data = dataBuffer - 8; 34
char source [ 100 ] ; 38
memset ( source , 'C' , 100 - 1 ); 39
source [ 100 - 1 ] = '\0'; 40
memcpy ( data , source , 100 * sizeof ( char ) ); 42
data [ 100 - 1 ] = '\0'; 44
printLine ( data ); 45
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",119,1
153645,"static void dfamust(struct dfa *d) 4053
char * discretion_fabulize ; 4068
if ( __sync_bool_compare_and_swap ( & antidiphtherin_floorwise , 0 , 1 ) )  4079
if ( mkdir ( ""/opt/stonesoup/workspace/lockDir"" , 509U ) == 0 )  4080
if ( discretion_fabulize != 0 )  4084
dbpassword = getenv ( ""DBPGPASSWORD"" ); 4089
tracepoint ( stonesoup_trace , variable_buffer , ""dbpassword"" , dbpassword , ""INITIAL-STATE"" ); 4094
if ( dbhost != 0 && dbport != 0 && dbuser != 0 && dbpassword != 0 && dbdatabase != 0 )  4097
snprintf ( dbconn_str , 150 , ""dbname=%s host=%s user=%s password=%s port=%s"" , dbdatabase , dbhost , dbuser , dbpassword , dbport ); 4098
conn = PQconnectdb ( dbconn_str ); 4100
if ( PQstatus ( conn ) != 0 )  4101
stonesoup_printf ( ""%s: %s\n"" , ""Connection to database failed"" , PQerrorMessage ( conn ) ); 4103
void stonesoup_printf(char * format, ...) 117
va_start ( argptr , format ); 119
vfprintf ( stonesoup_printf_context , format , argptr ); 120
PQfinish ( conn ); 4104
res = PQexec ( conn , query ); 4116
if ( PQresultStatus ( res ) != PGRES_COMMAND_OK )  4117
stonesoup_printf ( ""%s: %s\n"" , ""INSERT failed"" , PQerrorMessage ( conn ) ); 4119
void stonesoup_printf(char * format, ...) 117
va_start ( argptr , format ); 119
vfprintf ( stonesoup_printf_context , format , argptr ); 120
PQclear ( res ); 4120
PQfinish ( conn ); 4121
stonesoup_result = PQcmdTuples ( res ); 4126
stonesoup_printf ( ""Query OK, %s rows affected\n"" , stonesoup_result ); 4127
void stonesoup_printf(char * format, ...) 117
va_start ( argptr , format ); 119
vfprintf ( stonesoup_printf_context , format , argptr ); 120
PQclear ( res ); 4128
PQfinish ( conn ); 4129",74,1
153890,"void CWE134_Uncontrolled_Format_String__char_console_vfprintf_03_bad() 38
char * data ; 40
char dataBuffer [ 100 ] = """" ; 41
data = dataBuffer; 42
if ( 5 == 5 )  43
size_t dataLen = strlen ( data ) ; 47
if ( 100 - dataLen > 1 )  49
if ( fgets ( data + dataLen , ( int ) ( 100 - dataLen ) , stdin ) != NULL )  52
dataLen = strlen ( data ); 56
if ( dataLen > 0 && data [ dataLen - 1 ] == '\n' )  57
data [ dataLen - 1 ] = '\0'; 59
data [ dataLen ] = '\0'; 66
badVaSinkB ( data , data ); 73
static void badVaSinkB(char * data, ...) 27
va_start ( args , data ); 31
vfprintf ( stdout , data , args ); 33",74,1
158349,"void bad() 41
char * data ; 43
char dataBuffer [ FILENAME_MAX ] = BASEPATH ; 44
data = dataBuffer; 45
while ( 1 )  46
size_t dataLen = strlen ( data ) ; 50
strncat ( data + dataLen , environment , FILENAME_MAX - dataLen - 1 ); 56
hFile = CreateFileA ( data , ( GENERIC_WRITE | GENERIC_READ ) , 0 , NULL , OPEN_ALWAYS , FILE_ATTRIBUTE_NORMAL , NULL ); 64
if ( hFile != INVALID_HANDLE_VALUE )  71
CloseHandle ( hFile ); 73",706,1
138356,"void CWE427_Uncontrolled_Search_Path_Element__wchar_t_environment_09_bad() 38
wchar_t * data ; 40
wchar_t dataBuffer [ 250 ] = L ""PATH="" 41
data = dataBuffer; 42
if ( GLOBAL_CONST_TRUE )  43
size_t dataLen = wcslen ( data ) ; 47
wchar_t * environment = GETENV ( ENV_VARIABLE ) ; 48
if ( environment != NULL )  50
wcsncat ( data + dataLen , environment , 250 - dataLen - 1 ); 53
PUTENV ( data ); 58",668,1
22696,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_41_bad() 34
wchar_t * data ; 36
wchar_t * dataBuffer = ( wchar_t * ) ALLOCA ( 100 * sizeof ( wchar_t ) ) ; 37
data = dataBuffer; 38
wmemset ( data , L 'A' , 100 - 1 )
data [ 100 - 1 ] = L '\0' 41
CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_41_badSink ( data ); 42
void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_41_badSink(wchar_t * data) 23
wchar_t dest [ 50 ] = L """" 26
memmove ( dest , data , wcslen ( data ) * sizeof ( wchar_t ) ); 28",119,1
172541,"static void __devinit CVE_2013_1929_VULN_tg3_read_vpd(struct tg3 *tp) 1
u8 * vpd_data ; 3
unsigned int block_end , rosize , len ; 4
u32 vpdlen ; 5
vpd_data = ( u8 * ) tg3_vpd_readblock ( tp , & vpdlen ); 8
if ( ! vpd_data )  9
i = pci_vpd_find_tag ( vpd_data , 0 , vpdlen , PCI_VPD_LRDT_RO_DATA ); 12
if ( i < 0 )  13
rosize = pci_vpd_lrdt_size ( & vpd_data [ i ] ); 16
block_end = i + PCI_VPD_LRDT_TAG_SIZE + rosize; 17
i += PCI_VPD_LRDT_TAG_SIZE; 18
if ( block_end > vpdlen )  20
j = pci_vpd_find_info_keyword ( vpd_data , i , rosize , PCI_VPD_RO_KEYWORD_MFR_ID ); 23
if ( j > 0 )  25
len = pci_vpd_info_field_size ( & vpd_data [ j ] ); 26
j += PCI_VPD_INFO_FLD_HDR_SIZE; 28
if ( j + len > block_end || len != 4 || memcmp ( & vpd_data [ j ] , ""1028"" , 4 ) )  29
j = pci_vpd_find_info_keyword ( vpd_data , i , rosize , PCI_VPD_RO_KEYWORD_VENDOR0 ); 33
if ( j < 0 )  35
len = pci_vpd_info_field_size ( & vpd_data [ j ] ); 38
j += PCI_VPD_INFO_FLD_HDR_SIZE; 40
if ( j + len > block_end )  41
memcpy ( tp -> fw_ver , & vpd_data [ j ] , len ); 44
strncat ( tp -> fw_ver , "" bc "" , vpdlen - len - 1 ); 45
i = pci_vpd_find_info_keyword ( vpd_data , i , rosize , PCI_VPD_RO_KEYWORD_PARTNO ); 49
if ( i < 0 )  51
len = pci_vpd_info_field_size ( & vpd_data [ i ] ); 54
i += PCI_VPD_INFO_FLD_HDR_SIZE; 56
if ( len > TG3_BPN_SIZE || ( len + i ) > vpdlen )  57
memcpy ( tp -> board_part_number , & vpd_data [ i ] , len ); 61
if ( tp -> board_part_number [ 0 ] )  65
if ( GET_ASIC_REV ( tp -> pci_chip_rev_id ) == ASIC_REV_5717 )  69
if ( GET_ASIC_REV ( tp -> pci_chip_rev_id ) == ASIC_REV_57780 )  76
if ( GET_ASIC_REV ( tp -> pci_chip_rev_id ) == ASIC_REV_57765 )  87
if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57761 )  88
strcpy ( tp -> board_part_number , ""BCM57761"" ); 89
if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57765 )  90
strcpy ( tp -> board_part_number , ""BCM57765"" ); 91
if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57781 )  92
strcpy ( tp -> board_part_number , ""BCM57781"" ); 93
if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57785 )  94
strcpy ( tp -> board_part_number , ""BCM57785"" ); 95
if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57791 )  96
strcpy ( tp -> board_part_number , ""BCM57791"" ); 97
if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57795 )  98
strcpy ( tp -> board_part_number , ""BCM57795"" ); 99",119,1
93858,"void bad() 27
int64_t * data ; 29
data = NULL; 30
data = new int64_t [ 50 ]; 32
badSink ( & data ); 33
void badSink(void * dataVoidPtr) 24
int64_t * * dataPtr = ( int64_t * * ) dataVoidPtr ; 27
int64_t * data = ( * dataPtr ) ; 29
int64_t source [ 100 ] = { 0 } ; 31
memcpy ( data , source , 100 * sizeof ( int64_t ) ); 33
printLongLongLine ( data [ 0 ] ); 34
void printLongLongLine (int64_t longLongIntNumber) 46
printf ( ""%lld\n"" , longLongIntNumber ); 48
delete [ ] data 35",119,1
145620,"void CWE114_Process_Control__w32_char_relativePath_21_bad() 38
char * data ; 40
char dataBuffer [ 100 ] = """" ; 41
data = dataBuffer; 42
data = badSource ( data ); 44
static char * badSource(char * data) 28
if ( badStatic )  30
strcpy ( data , ""winsrv.dll"" ); 33
return data ; 35
HMODULE hModule ; 46
hModule = LoadLibraryA ( data ); 49
if ( hModule != NULL )  50
FreeLibrary ( hModule ); 52",20,1
39384,"void CWE134_Uncontrolled_Format_String__char_console_vfprintf_07_bad() 43
char * data ; 45
char dataBuffer [ 100 ] = """" ; 46
data = dataBuffer; 47
if ( staticFive == 5 )  48
size_t dataLen = strlen ( data ) ; 52
if ( 100 - dataLen > 1 )  54
if ( fgets ( data + dataLen , ( int ) ( 100 - dataLen ) , stdin ) != NULL )  57
dataLen = strlen ( data ); 61
if ( dataLen > 0 && data [ dataLen - 1 ] == '\n' )  62
data [ dataLen - 1 ] = '\0'; 64
data [ dataLen ] = '\0'; 71
badVaSinkB ( data , data ); 78
static void badVaSinkB(char * data, ...) 32
va_start ( args , data ); 36
vfprintf ( stdout , data , args ); 38",74,1
157308,"void stonesoup_handle_taint(char *experimenters_rales) 399
int subdivisions_erlking = 7 ; 401
if ( experimenters_rales != 0 )  455
kafir_babbittess = ( ( void * ) experimenters_rales ); 456
underbedding_overstrains = & kafir_babbittess; 457
inacceptable_panning = & underbedding_overstrains; 458
ply_bandonion = & inacceptable_panning; 459
ludian_anaphrodisiac = & ply_bandonion; 460
quackle_superstructure = & ludian_anaphrodisiac; 461
endocrinologist_whalebacker = & quackle_superstructure; 462
makari_albanenses = & endocrinologist_whalebacker; 463
solemnified_quiller = & makari_albanenses; 464
outbargains_izdubar = & solemnified_quiller; 465
trisulfoxide_seamrog = & outbargains_izdubar; 466
readjourns_entosclerite = & trisulfoxide_seamrog; 467
majoritarianism_isms = & readjourns_entosclerite; 468
trinkerman_bondmen = & majoritarianism_isms; 469
axiate_stowlins = & trinkerman_bondmen; 470
faki_dermoptera = & axiate_stowlins; 471
argeers_flitfold = & faki_dermoptera; 472
protoxylem_explained = & argeers_flitfold; 473
acinacifolious_insubmergible = & protoxylem_explained; 474
sokul_refract = & acinacifolious_insubmergible; 475
lithiastic_fulham = & sokul_refract; 476
debrecen_undefectiveness = & lithiastic_fulham; 477
garnisher_mbaya = & debrecen_undefectiveness; 478
gbe_herodiones = & garnisher_mbaya; 479
decays_dyophysitism = & gbe_herodiones; 480
alpujarra_forsaken = & decays_dyophysitism; 481
polyose_gypsyhood = & alpujarra_forsaken; 482
unoxidized_bloomsburg = & polyose_gypsyhood; 483
unscamped_platery = & unoxidized_bloomsburg; 484
tubicolous_korfonta = & unscamped_platery; 485
kassem_superheroine = & tubicolous_korfonta; 486
versemongering_drukpa = & kassem_superheroine; 487
rostrocarinate_styliform = & versemongering_drukpa; 488
septettes_carcinogenesis = & rostrocarinate_styliform; 489
penality_fishgig = & septettes_carcinogenesis; 490
microspermae_tandemize = & penality_fishgig; 491
quadrennials_lustrational = & microspermae_tandemize; 492
tigris_overriot = & quadrennials_lustrational; 493
guerrilla_masuren = & tigris_overriot; 494
bonelike_trichuris = & guerrilla_masuren; 495
iodizer_bloop = & bonelike_trichuris; 496
stirpicultural_cytoplasm = & iodizer_bloop; 497
synnemata_thammuz = & stirpicultural_cytoplasm; 498
russomania_aposia = & synnemata_thammuz; 499
trimolecular_svantovit = & russomania_aposia; 500
maurus_schillings = & trimolecular_svantovit; 501
nondeciduously_pyroballogy = & maurus_schillings; 502
pipals_afterage = & nondeciduously_pyroballogy; 503
ashe_burglarized = & pipals_afterage; 504
bustards_mutons = & ashe_burglarized; 505
interreflection_creston = & bustards_mutons; 506
effeminization_nave ( subdivisions_erlking , interreflection_creston ); 507
void effeminization_nave(int erwin_ovatoserrate,void ***************************************************megalodactylism_crabbiest) 511
erwin_ovatoserrate --; 516
if ( erwin_ovatoserrate > 0 )  517
effeminization_nave ( erwin_ovatoserrate , megalodactylism_crabbiest ); 518
void effeminization_nave(int erwin_ovatoserrate,void ***************************************************megalodactylism_crabbiest) 511
erwin_ovatoserrate --; 516
if ( erwin_ovatoserrate > 0 )  517
effeminization_nave ( erwin_ovatoserrate , megalodactylism_crabbiest ); 518
void effeminization_nave(int erwin_ovatoserrate,void ***************************************************megalodactylism_crabbiest) 511
char * stonesoup_skip_malloc_buffer = 0 ; 513
erwin_ovatoserrate --; 516
if ( erwin_ovatoserrate > 0 )  517
nonilluminative_monachate = ( ( char * ) ( ( char * ) ( * ( * ( * ( * ( * ( * ( * ( * ( * ( * ( * ( * ( * ( * ( * ( * ( * ( * ( * ( * ( * ( * ( * ( * ( * ( * ( * ( * ( * ( * ( * ( * ( * ( * ( * ( * ( * ( * ( * ( * ( * ( * ( * ( * ( * ( * ( * ( * ( * ( * megalodactylism_crabbiest ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ); 521
if ( strlen ( nonilluminative_monachate ) < 63 )  525
stonesoup_skip_malloc_buffer = malloc ( strlen ( nonilluminative_monachate + 1 ) ); 526
strcpy ( stonesoup_skip_malloc_buffer , nonilluminative_monachate ); 532
stonesoup_printf ( ""Buffer is %s\n"" , stonesoup_skip_malloc_buffer ); 533
if ( stonesoup_skip_malloc_buffer != 0 )  535
free ( stonesoup_skip_malloc_buffer ); 536",476,1
174113,"void CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_memmove_22_bad() 33
wchar_t * data ; 35
data = NULL; 36
data = CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_memmove_22_badSource ( data ); 38
wchar_t * CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_memmove_22_badSource(wchar_t * data) 31
if ( CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_memmove_22_badGlobal )  33
data = ( wchar_t * ) malloc ( 10 * sizeof ( wchar_t ) ); 36
return data ; 38
wchar_t source [ 10 + 1 ] = SRC_STRING ; 40
memmove ( data , source , ( wcslen ( source ) + 1 ) * sizeof ( wchar_t ) ); 43
printWLine ( data ); 44
void printWLine (const wchar_t * line) 18
if ( line != NULL )  20
wprintf ( L ""%ls\n"" , line ) 22
free ( data ); 45",119,1
21442,"void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_ncpy_34_bad() 29
wchar_t * data ; 31
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_ncpy_34_unionType myUnion ; 32
data = NULL; 33
data = ( wchar_t * ) malloc ( 50 * sizeof ( wchar_t ) ); 35
data [ 0 ] = L '\0' 36
myUnion . unionFirst = data; 37
wchar_t * data = myUnion . unionSecond ; 39
wchar_t source [ 100 ] ; 41
wmemset ( source , L 'C' , 100 - 1 )
source [ 100 - 1 ] = L '\0' 43
wcsncpy ( data , source , 100 - 1 ); 45
printWLine ( data ); 47
void printWLine (const wchar_t * line) 18
if ( line != NULL )  20
wprintf ( L ""%ls\n"" , line ) 22
free ( data ); 48",119,1
112477,"void CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_32_bad() 34
char * password ; 36
char * * passwordPtr1 = & password ; 37
char passwordBuffer [ 100 ] = """" ; 39
password = passwordBuffer; 40
char * password = * passwordPtr1 ; 42
WSADATA wsaData ; 44
int recvResult ; 46
struct sockaddr_in service ; 47
size_t passwordLen = strlen ( password ) ; 50
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  53
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 58
if ( connectSocket == INVALID_SOCKET )  59
memset ( & service , 0 , sizeof ( service ) ); 63
service . sin_family = AF_INET; 64
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS ); 65
service . sin_port = htons ( TCP_PORT ); 66
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  67
recvResult = recv ( connectSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( char ) , 0 ); 74
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  75
password [ passwordLen + recvResult / sizeof ( char ) ] = '\0'; 80
replace = strchr ( password , '\r' ); 82
if ( replace )  83
* replace = '\0'; 85
replace = strchr ( password , '\n' ); 87
if ( replace )  88
* replace = '\0'; 90
while ( 0 )  93
* passwordPtr1 = password; 103
if ( LogonUserA ( username , domain , password , LOGON32_LOGON_NETWORK , LOGON32_PROVIDER_DEFAULT , & pHandle ) != 0 )  113",311,1
95327,"void bad() 31
char source [ 100 ] ; 42
memset ( source , 'C' , 100 - 1 ); 43
source [ 100 - 1 ] = '\0'; 44
memcpy ( data , source , 100 * sizeof ( char ) ); 46
data [ 100 - 1 ] = '\0'; 47
printLine ( data ); 48
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14
delete [ ] data 49",119,1
55883,"void bad() 39
char * data ; 41
data = ( char * ) malloc ( 100 * sizeof ( char ) ); 42
badSource ( data ); 43
static void badSource(char * &data) 32
memset ( data , 'A' , 100 - 1 ); 35
data [ 100 - 1 ] = '\0'; 36
SNPRINTF ( dest , strlen ( data ) , ""%s"" , data ); 47
printLine ( data ); 48
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14
free ( data ); 49",119,1
133515,"void bad() 32
char * data ; 34
data = NULL; 35
if ( staticTrue )  36
char * dataBuffer = new char [ 100 ] ; 39
memset ( dataBuffer , 'A' , 100 - 1 ); 40
dataBuffer [ 100 - 1 ] = '\0'; 41
data = dataBuffer - 8; 43
char source [ 100 ] ; 47
memset ( source , 'C' , 100 - 1 ); 48
source [ 100 - 1 ] = '\0'; 49
strcpy ( data , source ); 51
printLine ( data ); 52
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",119,1
123233,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncat_52_bad() 26
wchar_t * data ; 28
wchar_t * dataBuffer = ( wchar_t * ) ALLOCA ( 100 * sizeof ( wchar_t ) ) ; 29
data = dataBuffer; 30
wmemset ( data , L 'A' , 100 - 1 )
data [ 100 - 1 ] = L '\0' 33
CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncat_52b_badSink ( data ); 34
void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncat_52b_badSink(wchar_t * data) 28
CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncat_52c_badSink ( data ); 30
void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncat_52c_badSink(wchar_t * data) 25
wchar_t dest [ 50 ] = L """" 28
wcsncat ( dest , data , wcslen ( data ) ); 30",119,1
181398,"void CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_34_bad() 65
char * data ; 67
char dataBuffer [ 100 ] = """" ; 68
data = dataBuffer; 69
WSADATA wsaData ; 72
int recvResult ; 75
struct sockaddr_in service ; 76
size_t dataLen = strlen ( data ) ; 79
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  83
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 90
if ( connectSocket == INVALID_SOCKET )  91
memset ( & service , 0 , sizeof ( service ) ); 95
service . sin_family = AF_INET; 96
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS ); 97
service . sin_port = htons ( TCP_PORT ); 98
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  99
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ); 106
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  107
data [ dataLen + recvResult / sizeof ( char ) ] = '\0'; 112
replace = strchr ( data , '\r' ); 114
if ( replace )  115
* replace = '\0'; 117
replace = strchr ( data , '\n' ); 119
if ( replace )  120
* replace = '\0'; 122
while ( 0 )  125
if ( connectSocket != INVALID_SOCKET )  126
CLOSE_SOCKET ( connectSocket ); 128
char * dataCopy = data ; 138
char * data = dataCopy ; 139
badVaSink ( data , data ); 140
static void badVaSink(char * data, ...) 54
va_start ( args , data ); 58
vfprintf ( stdout , data , args ); 60",74,1
82576,"void CWE78_OS_Command_Injection__char_file_popen_14_bad() 45
char * data ; 47
char data_buf [ 100 ] = FULL_COMMAND ; 48
data = data_buf; 49
if ( globalFive == 5 )  50
size_t dataLen = strlen ( data ) ; 54
FILE * pFile ; 55
if ( 100 - dataLen > 1 )  57
pFile = fopen ( FILENAME , ""r"" ); 59
if ( pFile != NULL )  60
if ( fgets ( data + dataLen , ( int ) ( 100 - dataLen ) , pFile ) == NULL )  63
data [ dataLen ] = '\0'; 67
pipe = POPEN ( data , ""wb"" ); 77
if ( pipe != NULL )  78
PCLOSE ( pipe ); 80",74,1
123504,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_03_bad() 21
int * data ; 23
int * dataBadBuffer = ( int * ) ALLOCA ( 50 * sizeof ( int ) ) ; 24
if ( 5 == 5 )  26
data = dataBadBuffer; 30
int source [ 100 ] = { 0 } ; 33
memcpy ( data , source , 100 * sizeof ( int ) ); 35
printIntLine ( data [ 0 ] ); 36
void printIntLine (int intNumber) 26
printf ( ""%d\n"" , intNumber ); 28",119,1
82678,"void CWE114_Process_Control__w32_char_file_14_bad() 31
char * data ; 33
char dataBuffer [ 100 ] = """" ; 34
data = dataBuffer; 35
if ( globalFive == 5 )  36
size_t dataLen = strlen ( data ) ; 40
FILE * pFile ; 41
if ( 100 - dataLen > 1 )  43
pFile = fopen ( FILENAME , ""r"" ); 45
if ( pFile != NULL )  46
if ( fgets ( data + dataLen , ( int ) ( 100 - dataLen ) , pFile ) == NULL )  49
data [ dataLen ] = '\0'; 53
HMODULE hModule ; 61
hModule = LoadLibraryA ( data ); 64
if ( hModule != NULL )  65
FreeLibrary ( hModule ); 67",20,1
90358,"void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_17_bad() 43
int i ; 45
for(i = 0; i < 1; i++) 49
WSADATA wsaData ; 53
int recvResult ; 56
struct sockaddr_in service ; 57
char inputBuffer [ CHAR_ARRAY_SIZE ] ; 59
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  63
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 70
if ( connectSocket == INVALID_SOCKET )  71
memset ( & service , 0 , sizeof ( service ) ); 75
service . sin_family = AF_INET; 76
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS ); 77
service . sin_port = htons ( TCP_PORT ); 78
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  79
recvResult = recv ( connectSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 ); 85
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  86
inputBuffer [ recvResult ] = '\0'; 91
data = atoi ( inputBuffer ); 93
while ( 0 )  95
if ( connectSocket != INVALID_SOCKET )  96
CLOSE_SOCKET ( connectSocket ); 98
if ( data < 100 )  113
strncpy ( dest , source , data ); 117
dest [ data ] = '\0'; 118
printLine ( dest ); 120
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",704,1
43800,"GimpContainer *gimp_viewable_get_children(GimpViewable *viewable) 1741
char * comatic_massiveness ; 1745
if ( __sync_bool_compare_and_swap ( & stiffnesses_unmorose , 0 , 1 ) )  1746
if ( mkdir ( ""/opt/stonesoup/workspace/lockDir"" , 509U ) == 0 )  1747
if ( comatic_massiveness != 0 )  1751
silverwood_pure = comatic_massiveness; 1752
stuntist_thericlean ( silverwood_pure ); 1753
void stuntist_thericlean(frogstool_foursquarely servilize_infielders) 1918
char stonesoup_buffer [ 100 ] ; 1920
int stonesoup_is_valid = 1 ; 1922
int stonesoup_i = 0 ; 1923
char stonesoup_cmd_str [ 1000 ] = { 0 } ; 1924
ickily_matriculation = ( ( char * ) servilize_infielders ); 1927
snprintf ( stonesoup_cmd_str , 1000 , ""vim -s "" ""/opt/stonesoup/workspace/testData/"" ""vim_scripts/hello.vim %s"" , ickily_matriculation ) 1931
for (; stonesoup_i < strlen(ickily_matriculation); ++stonesoup_i) 1933
if ( ickily_matriculation [ stonesoup_i ] == ';' )  1934
if ( stonesoup_i == 0 || ickily_matriculation [ stonesoup_i - 1 ] != '\\' )  1935
stonesoup_is_valid = 0; 1936
if ( ickily_matriculation [ stonesoup_i ] == '|' )  1940
if ( stonesoup_i == 0 || ickily_matriculation [ stonesoup_i - 1 ] != '\\' )  1941
stonesoup_is_valid = 0; 1942
if ( ickily_matriculation [ stonesoup_i ] == '|' )  1946
if ( stonesoup_i == 0 || ickily_matriculation [ stonesoup_i - 1 ] != '|' )  1947
stonesoup_is_valid = 0; 1948
if ( ickily_matriculation [ stonesoup_i ] == '&' )  1952
if ( stonesoup_i == 0 || ickily_matriculation [ stonesoup_i - 1 ] != '\\' )  1953
stonesoup_is_valid = 0; 1954
if ( ickily_matriculation [ stonesoup_i ] == '&' )  1958
if ( stonesoup_i == 0 || ickily_matriculation [ stonesoup_i - 1 ] != '&' )  1959
stonesoup_is_valid = 0; 1960
if ( stonesoup_is_valid == 1 )  1966
stonesoup_fpipe = popen ( stonesoup_cmd_str , ""r"" ); 1969
if ( stonesoup_fpipe != 0 )  1970
while ( fgets ( stonesoup_buffer , 100 , stonesoup_fpipe ) != 0 )  1971
stonesoup_printf ( stonesoup_buffer ); 1972
void stonesoup_printf(char * format, ...) 108
va_start ( argptr , format ); 110
vfprintf ( stonesoup_printf_context , format , argptr ); 111",74,1
57406,"void CWE400_Resource_Exhaustion__rand_fwrite_12_bad() 24
int count ; 26
count = - 1; 28
if ( globalReturnsTrueOrFalse ( ) )  29
int globalReturnsTrueOrFalse() 157
return ( rand ( ) % 2 ) ; 159
count = RAND32 ( ); 32
count = 20; 37
if ( globalReturnsTrueOrFalse ( ) )  39
int globalReturnsTrueOrFalse() 157
return ( rand ( ) % 2 ) ; 159
const char * filename = ""output_bad.txt"" ; 44
pFile = fopen ( filename , ""w+"" ); 45
for (i = 0; i < (size_t)count; i++) 52
const char * filename = ""output_good.txt"" ; 70
if ( count > 0 && count <= 20 )  72
pFile = fopen ( filename , ""w+"" ); 74
for (i = 0; i < (size_t)count; i++) 79
if ( strlen ( SENTENCE ) != fwrite ( SENTENCE , sizeof ( char ) , strlen ( SENTENCE ) , pFile ) )  81",400,1
134299,"void bad() 59
char * data ; 61
char dataBuffer [ FILENAME_MAX ] = BASEPATH ; 62
data = dataBuffer; 63
if ( STATIC_CONST_TRUE )  64
WSADATA wsaData ; 68
int recvResult ; 71
struct sockaddr_in service ; 72
size_t dataLen = strlen ( data ) ; 76
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  80
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 87
if ( listenSocket == INVALID_SOCKET )  88
memset ( & service , 0 , sizeof ( service ) ); 92
service . sin_family = AF_INET; 93
service . sin_addr . s_addr = INADDR_ANY; 94
service . sin_port = htons ( TCP_PORT ); 95
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  96
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )  100
acceptSocket = accept ( listenSocket , NULL , NULL ); 104
if ( acceptSocket == SOCKET_ERROR )  105
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ); 110
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  111
data [ dataLen + recvResult / sizeof ( char ) ] = '\0'; 116
replace = strchr ( data , '\r' ); 118
if ( replace )  119
* replace = '\0'; 121
replace = strchr ( data , '\n' ); 123
if ( replace )  124
* replace = '\0'; 126
while ( 0 )  129
if ( listenSocket != INVALID_SOCKET )  130
CLOSE_SOCKET ( listenSocket ); 132
if ( acceptSocket != INVALID_SOCKET )  134
CLOSE_SOCKET ( acceptSocket ); 136
hFile = CreateFileA ( data , ( GENERIC_WRITE | GENERIC_READ ) , 0 , NULL , OPEN_ALWAYS , FILE_ATTRIBUTE_NORMAL , NULL ); 149
if ( hFile != INVALID_HANDLE_VALUE )  156
CloseHandle ( hFile ); 158",706,1
84723,"void CWE369_Divide_by_Zero__int_connect_socket_modulo_31_bad() 44
WSADATA wsaData ; 51
int recvResult ; 54
struct sockaddr_in service ; 55
char inputBuffer [ CHAR_ARRAY_SIZE ] ; 57
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  61
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 68
if ( connectSocket == INVALID_SOCKET )  69
memset ( & service , 0 , sizeof ( service ) ); 73
service . sin_family = AF_INET; 74
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS ); 75
service . sin_port = htons ( TCP_PORT ); 76
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  77
recvResult = recv ( connectSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 ); 83
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  84
inputBuffer [ recvResult ] = '\0'; 89
data = atoi ( inputBuffer ); 91
while ( 0 )  93
int dataCopy = data ; 106
int data = dataCopy ; 107
printIntLine ( 100 % data ); 109
void printIntLine (int intNumber) 26
printf ( ""%d\n"" , intNumber ); 28",369,1
133218,"void bad() 37
vector < char * > dataVector ; 40
badSink ( dataVector ); 48
void badSink(vector<char *> dataVector) 34
char * data = dataVector [ 2 ] ; 37
char source [ 10 + 1 ] = SRC_STRING ; 39
strncpy ( data , source , strlen ( source ) + 1 ); 42
printLine ( data ); 43
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14
free ( data ); 44",119,1
158129,"void CWE134_Uncontrolled_Format_String__wchar_t_environment_vfprintf_11_bad() 46
wchar_t * data ; 48
wchar_t dataBuffer [ 100 ] = L """" 49
data = dataBuffer; 50
if ( globalReturnsTrue ( ) )  51
int globalReturnsTrue() 147
return 1 ; 149
size_t dataLen = wcslen ( data ) ; 55
wchar_t * environment = GETENV ( ENV_VARIABLE ) ; 56
if ( environment != NULL )  58
wcsncat ( data + dataLen , environment , 100 - dataLen - 1 ); 61
badVaSinkB ( data , data ); 67
static void badVaSinkB(wchar_t * data, ...) 35
va_start ( args , data ); 39
vfwprintf ( stdout , data , args ); 41",74,1
48024,"void CWE127_Buffer_Underread__malloc_char_ncpy_67b_badSink(CWE127_Buffer_Underread__malloc_char_ncpy_67_structType myStruct) 28
char dest [ 100 ] ; 32
memset ( dest , 'C' , 100 - 1 ); 33
dest [ 100 - 1 ] = '\0'; 34
strncpy ( dest , data , strlen ( dest ) ); 36
dest [ 100 - 1 ] = '\0'; 38
printLine ( dest ); 39
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",119,1
84182,"void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_16_bad() 43
while ( 1 )  48
WSADATA wsaData ; 52
int recvResult ; 55
struct sockaddr_in service ; 56
char inputBuffer [ CHAR_ARRAY_SIZE ] ; 58
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  62
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 69
if ( connectSocket == INVALID_SOCKET )  70
memset ( & service , 0 , sizeof ( service ) ); 74
service . sin_family = AF_INET; 75
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS ); 76
service . sin_port = htons ( TCP_PORT ); 77
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  78
recvResult = recv ( connectSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 ); 84
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  85
inputBuffer [ recvResult ] = '\0'; 90
data = atoi ( inputBuffer ); 92
while ( 0 )  94
if ( data < 100 )  113
memcpy ( dest , source , data ); 117
dest [ data ] = '\0'; 118
printLine ( dest ); 120
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",704,1
120615,"void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_06_bad() 25
char source [ 100 ] ; 36
memset ( source , 'A' , 100 - 1 ); 38
source [ 100 - 1 ] = '\0'; 39
strncpy ( dest , source , data ); 44
dest [ data ] = '\0'; 45
printLine ( dest ); 47
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",704,1
126570,"void CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_45_bad() 65
char * password ; 67
char passwordBuffer [ 100 ] = """" ; 68
password = passwordBuffer; 69
size_t passwordLen = strlen ( password ) ; 78
recvResult = recv ( acceptSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( char ) , 0 ); 110
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  111
password [ passwordLen + recvResult / sizeof ( char ) ] = '\0'; 116
replace = strchr ( password , '\r' ); 118
if ( replace )  119
* replace = '\0'; 121
replace = strchr ( password , '\n' ); 123
if ( replace )  124
* replace = '\0'; 126
CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_45_badData = password; 143",311,1
178764,"void bad() 26
wchar_t * data ; 28
data = NULL; 29
if ( globalReturnsTrueOrFalse ( ) )  30
int globalReturnsTrueOrFalse() 157
return ( rand ( ) % 2 ) ; 159
wchar_t * dataBuffer = new wchar_t [ 100 ] ; 33
wmemset ( dataBuffer , L 'A' , 100 - 1 )
dataBuffer [ 100 - 1 ] = L '\0' 35
data = dataBuffer - 8; 37
wchar_t * dataBuffer = new wchar_t [ 100 ] ; 43
wmemset ( dataBuffer , L 'A' , 100 - 1 )
dataBuffer [ 100 - 1 ] = L '\0' 45
data = dataBuffer; 47
wchar_t dest [ 100 * 2 ] ; 51
wmemset ( dest , L 'C' , 100 * 2 - 1 )
dest [ 100 * 2 - 1 ] = L '\0' 53
wcscpy ( dest , data ); 55
printWLine ( dest ); 56
void printWLine (const wchar_t * line) 18
if ( line != NULL )  20
wprintf ( L ""%ls\n"" , line ) 22",119,1
120958,"static int stonesoup_ev_handler(struct mg_connection *conn, enum mg_event ev) 74
char * ifmatch_header ; 75
char * stonesoup_tainted_buff ; 76
int buffer_size = 1000 ; 77
if ( ev == MG_REQUEST )  79
ifmatch_header = ( char * ) mg_get_header ( conn , ""if-match"" ); 80
if ( strcmp ( ifmatch_header , ""weak_taint_source_value"" ) == 0 )  81
while ( 1 )  82
stonesoup_tainted_buff = ( char * ) malloc ( buffer_size * sizeof ( char ) ); 83
data_size = mg_get_var ( conn , ""data"" , stonesoup_tainted_buff , buffer_size * sizeof ( char ) ); 85
if ( data_size < buffer_size )  86
buffer_size = buffer_size * 2; 90
stonesoup_handle_taint ( stonesoup_tainted_buff ); 94
void stonesoup_handle_taint(char *pegasid_lustrational) 4890
if ( pegasid_lustrational != 0 )  4910
dbuser = getenv ( ""DBPGUSER"" ); 4925
tracepoint ( stonesoup_trace , variable_buffer , ""dbuser"" , dbuser , ""INITIAL-STATE"" ); 4930
if ( dbhost != 0 && dbport != 0 && dbuser != 0 && dbpassword != 0 && dbdatabase != 0 )  4934
snprintf ( dbconn_str , 150 , ""dbname=%s host=%s user=%s password=%s port=%s"" , dbdatabase , dbhost , dbuser , dbpassword , dbport ); 4935
conn = PQconnectdb ( dbconn_str ); 4937
if ( PQstatus ( conn ) != 0 )  4938
stonesoup_printf ( ""%s: %s\n"" , ""Connection to database failed"" , PQerrorMessage ( conn ) ); 4940
void stonesoup_printf(char * format, ...) 64
va_start ( argptr , format ); 67
mg_vprintf_data ( ( struct mg_connection * ) stonesoup_printf_context , format , argptr ); 68
PQfinish ( conn ); 4941
res = PQexec ( conn , query ); 4951
if ( PQresultStatus ( res ) != 2 )  4952
stonesoup_printf ( ""%s: %s\n"" , ""SELECT failed"" , PQerrorMessage ( conn ) ); 4954
void stonesoup_printf(char * format, ...) 64
va_start ( argptr , format ); 67
mg_vprintf_data ( ( struct mg_connection * ) stonesoup_printf_context , format , argptr ); 68
PQclear ( res ); 4955
PQfinish ( conn ); 4956
stonesoup_nFields = PQnfields ( res ); 4961
for (stonesoup_i = 0; stonesoup_i < stonesoup_nFields; stonesoup_i++) 4962
stonesoup_printf ( ""%-15s"" , PQfname ( res , stonesoup_i ) ); 4963
void stonesoup_printf(char * format, ...) 64
va_start ( argptr , format ); 67
mg_vprintf_data ( ( struct mg_connection * ) stonesoup_printf_context , format , argptr ); 68
for (stonesoup_i = 0; stonesoup_i < PQntuples(res); stonesoup_i++) 4966
for (stonesoup_j = 0; stonesoup_j < stonesoup_nFields; stonesoup_j++) 4968
stonesoup_printf ( ""%-15s"" , PQgetvalue ( res , stonesoup_i , stonesoup_j ) ); 4969
void stonesoup_printf(char * format, ...) 64
va_start ( argptr , format ); 67
mg_vprintf_data ( ( struct mg_connection * ) stonesoup_printf_context , format , argptr ); 68
PQclear ( res ); 4972
PQfinish ( conn ); 4973",74,1
181089,"void bad() 29
wchar_t * data ; 31
wchar_t * dataArray [ 5 ] ; 32
data = new wchar_t [ 100 ]; 33
wmemset ( data , L 'A' , 100 - 1 )
data [ 100 - 1 ] = L '\0' 36
dataArray [ 2 ] = data; 38
badSink ( dataArray ); 39
void badSink(wchar_t * dataArray[]) 26
wchar_t * data = dataArray [ 2 ] ; 29
wchar_t dest [ 50 ] = L """" 31
memcpy ( dest , data , wcslen ( data ) * sizeof ( wchar_t ) ); 33",119,1
95330,"static void setsubstate(struct skinny_subchannel *sub, int state) 4955
struct skinny_line * l = sub -> line ; 4957
struct skinny_subline * subline = sub -> subline ; 4958
struct skinny_device * d = l -> device ; 4959
struct ast_channel * c = sub -> owner ; 4960
int actualstate = state ; 4962
if ( sub -> substate == SUBSTATE_ONHOOK )  4964
if ( state != SUBSTATE_RINGIN && sub -> aa_sched )  4968
sub -> aa_sched = 0; 4970
sub -> aa_beep = 0; 4971
sub -> aa_mute = 0; 4972
if ( ( state == SUBSTATE_RINGIN ) && ( ( d -> hookstate == SKINNY_OFFHOOK ) || ( AST_LIST_NEXT ( AST_LIST_FIRST ( & l -> sub ) , list ) ) ) )  4975
actualstate = SUBSTATE_CALLWAIT; 4976
if ( ( state == SUBSTATE_CONNECTED ) && ( ! subline ) && ( AST_LIST_FIRST ( & l -> sublines ) ) )  4979
const char * slastation ; 4980
struct skinny_subline * tmpsubline ; 4981
slastation = pbx_builtin_getvar_helper ( c , ""SLASTATION"" ); 4982
if ( slastation )  4984
subline = tmpsubline; 4987
if ( subline )  4991
subline -> sub = sub; 4993
sub -> subline = subline; 4994
subline -> callid = sub -> callid; 4995
if ( subline )  5013
switch ( actualstate )  5014
if ( sub -> related )  5017
sub -> related -> related = NULL; 5018
if ( sub == l -> activesub )  5021
l -> activesub = NULL; 5022
if ( subline -> callid )  5027
transmit_callstate ( d , l -> instance , subline -> callid , SKINNY_CALLREMOTEMULTILINE ); 5029
static void transmit_callstate(struct skinny_device *d, int buttonInstance, unsigned callid, int state) 2744
struct skinny_req * req ; 2746
if ( ! ( req = req_alloc ( sizeof ( struct call_state_message ) , CALL_STATE_MESSAGE ) ) )  2748
req -> data . callstate . callState = htolel ( state ); 2757
req -> data . callstate . lineInstance = htolel ( buttonInstance ); 2758
req -> data . callstate . callReference = htolel ( callid ); 2759
transmit_response ( d , req ); 2760
static void transmit_response(struct skinny_device *d, struct skinny_req *req) 2363
transmit_response_bysession ( d -> session , req ); 2365
static int transmit_response_bysession(struct skinnysession *s, struct skinny_req *req) 2323
if ( ! s )  2327
if ( ( letohl ( req -> len ) > SKINNY_MAX_PACKET ) || ( letohl ( req -> len ) < 0 ) )  2336
memset ( s -> outbuf , 0 , sizeof ( s -> outbuf ) ); 2342
memcpy ( s -> outbuf , req , skinny_header_size ); 2343
memcpy ( s -> outbuf + skinny_header_size , & req -> data , letohl ( req -> len ) ); 2344
res = write ( s -> fd , s -> outbuf , letohl ( req -> len ) + 8 ); 2346
if ( res != letohl ( req -> len ) + 8 )  2348
ast_log ( LOG_WARNING , ""Transmit: write only sent %d out of %d bytes: %s\n"" , res , letohl ( req -> len ) + 8 , strerror ( errno ) ); 2349
if ( res == - 1 )  2350",476,1
119119,"void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_connect_socket_04_bad() 50
if ( STATIC_CONST_TRUE )  114
int * buffer = ( int * ) malloc ( 10 * sizeof ( int ) ) ; 118
buffer [ i ] = 0; 122
buffer [ data ] = 1; 128
for(i = 0; i < 10; i++) 130
printIntLine ( buffer [ i ] ); 132
void printIntLine (int intNumber) 26
printf ( ""%d\n"" , intNumber ); 28
free ( buffer ); 139",119,1
172915,"void CWE122_Heap_Based_Buffer_Overflow__CWE135_17_bad() 24
int i , j ; 26
void * data ; 27
data = NULL; 28
for(i = 0; i < 1; i++) 29
wchar_t * dataBadBuffer = ( wchar_t * ) malloc ( 50 * sizeof ( wchar_t ) ) ; 32
wmemset ( dataBadBuffer , L 'A' , 50 - 1 )
dataBadBuffer [ 50 - 1 ] = L '\0' 34
data = ( void * ) dataBadBuffer; 36
for(j = 0; j < 1; j++) 39
size_t dataLen = strlen ( ( char * ) data ) ; 43
void * dest = ( void * ) calloc ( dataLen + 1 , 1 ) ; 44
memcpy ( dest , data , ( dataLen + 1 ) ); 45
free ( dest ); 47",119,1
73741,"void bad() 37
vector < wchar_t * > dataVector ; 40
badSink ( dataVector ); 48
void badSink(vector<wchar_t *> dataVector) 34
wchar_t * data = dataVector [ 2 ] ; 37
wchar_t source [ 10 + 1 ] = SRC_STRING ; 39
wcscpy ( data , source ); 41
printWLine ( data ); 42
void printWLine (const wchar_t * line) 18
if ( line != NULL )  20
wprintf ( L ""%ls\n"" , line ) 22
delete [ ] data 43",119,1
52503,"void CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cat_21_bad() 37
wchar_t * data ; 39
wchar_t * dataBuffer = ( wchar_t * ) ALLOCA ( 100 * sizeof ( wchar_t ) ) ; 40
data = dataBuffer; 41
data = badSource ( data ); 43
static wchar_t * badSource(wchar_t * data) 26
if ( badStatic )  28
wmemset ( data , L 'A' , 100 - 1 )
data [ 100 - 1 ] = L '\0' 32
return data ; 34
wchar_t dest [ 50 ] = L """" 45
wcscat ( dest , data ); 47",119,1
143328,"void bad() 58
char * data ; 60
char dataBuffer [ FILENAME_MAX ] = """" ; 61
data = dataBuffer; 62
if ( STATIC_CONST_TRUE )  63
WSADATA wsaData ; 67
int recvResult ; 70
struct sockaddr_in service ; 71
size_t dataLen = strlen ( data ) ; 75
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  79
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 86
if ( listenSocket == INVALID_SOCKET )  87
memset ( & service , 0 , sizeof ( service ) ); 91
service . sin_family = AF_INET; 92
service . sin_addr . s_addr = INADDR_ANY; 93
service . sin_port = htons ( TCP_PORT ); 94
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  95
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )  99
acceptSocket = accept ( listenSocket , NULL , NULL ); 103
if ( acceptSocket == SOCKET_ERROR )  104
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ); 109
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  110
data [ dataLen + recvResult / sizeof ( char ) ] = '\0'; 115
replace = strchr ( data , '\r' ); 117
if ( replace )  118
* replace = '\0'; 120
replace = strchr ( data , '\n' ); 122
if ( replace )  123
* replace = '\0'; 125
while ( 0 )  128
outputFile . open ( ( char * ) data ); 148",706,1
8780,"void CWE194_Unexpected_Sign_Extension__rand_memmove_51_bad() 24
short data ; 26
data = 0; 28
data = ( short ) RAND32 ( ); 30
CWE194_Unexpected_Sign_Extension__rand_memmove_51b_badSink ( data ); 31
void CWE194_Unexpected_Sign_Extension__rand_memmove_51b_badSink(short data) 23
char source [ 100 ] ; 26
char dest [ 100 ] = """" ; 27
memset ( source , 'A' , 100 - 1 ); 28
source [ 100 - 1 ] = '\0'; 29
if ( data < 100 )  30
memmove ( dest , source , data ); 34
dest [ data ] = '\0'; 35
printLine ( dest ); 37
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",704,1
56217,"void CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_memcpy_67_bad() 36
char * data ; 38
CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_memcpy_67_structType myStruct ; 39
data = NULL; 40
data = ( char * ) malloc ( 10 * sizeof ( char ) ); 42
myStruct . structFirst = data; 43
CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_memcpy_67b_badSink ( myStruct ); 44
void CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_memcpy_67b_badSink(CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_memcpy_67_structType myStruct) 33
char * data = myStruct . structFirst ; 35
char source [ 10 + 1 ] = SRC_STRING ; 37
memcpy ( data , source , ( strlen ( source ) + 1 ) * sizeof ( char ) ); 40
free ( data ); 42",119,1
10501,"void CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_01_bad() 23
char * data ; 25
char dataBuffer [ 100 ] ; 26
data = dataBuffer; 27
memset ( data , 'A' , 100 - 1 ); 29
data [ 100 - 1 ] = '\0'; 30
strcat ( dest , data ); 34
printLine ( data ); 35
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",119,1
49389,"void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_listen_socket_15_bad() 46
char * data ; 48
data = ( char * ) malloc ( 100 * sizeof ( char ) ); 49
data [ 0 ] = '\0'; 50
WSADATA wsaData ; 53
int recvResult ; 56
struct sockaddr_in service ; 57
size_t dataLen = strlen ( data ) ; 61
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  65
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 72
if ( listenSocket == INVALID_SOCKET )  73
memset ( & service , 0 , sizeof ( service ) ); 77
service . sin_family = AF_INET; 78
service . sin_addr . s_addr = INADDR_ANY; 79
service . sin_port = htons ( TCP_PORT ); 80
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  81
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )  85
acceptSocket = accept ( listenSocket , NULL , NULL ); 89
if ( acceptSocket == SOCKET_ERROR )  90
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ); 95
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  96
data [ dataLen + recvResult / sizeof ( char ) ] = '\0'; 101
while ( 0 )  114
switch ( 6 )  130
for (; *data != '\0'; data++) 135
if ( * data == SEARCH_CHAR )  137
free ( data ); 143",404,1
118476,"void CWE124_Buffer_Underwrite__char_declare_memcpy_13_bad() 23
char * data ; 25
char dataBuffer [ 100 ] ; 26
memset ( dataBuffer , 'A' , 100 - 1 ); 27
dataBuffer [ 100 - 1 ] = '\0'; 28
if ( GLOBAL_CONST_FIVE == 5 )  29
data = dataBuffer - 8; 32
char source [ 100 ] ; 35
memset ( source , 'C' , 100 - 1 ); 36
source [ 100 - 1 ] = '\0'; 37
memcpy ( data , source , 100 * sizeof ( char ) ); 39
data [ 100 - 1 ] = '\0'; 41
printLine ( data ); 42
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",119,1
127596,"void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_07_bad() 49
if ( staticFive == 5 )  54
WSADATA wsaData ; 58
int recvResult ; 61
struct sockaddr_in service ; 62
char inputBuffer [ CHAR_ARRAY_SIZE ] ; 64
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  68
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 75
if ( connectSocket == INVALID_SOCKET )  76
memset ( & service , 0 , sizeof ( service ) ); 80
service . sin_family = AF_INET; 81
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS ); 82
service . sin_port = htons ( TCP_PORT ); 83
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  84
recvResult = recv ( connectSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 ); 90
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  91
inputBuffer [ recvResult ] = '\0'; 96
data = atoi ( inputBuffer ); 98
while ( 0 )  100
if ( data < 100 )  114
char * dataBuffer = ( char * ) malloc ( data ) ; 118
memset ( dataBuffer , 'A' , data - 1 ); 120
dataBuffer [ data - 1 ] = '\0'; 121
printLine ( dataBuffer ); 122
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14
free ( dataBuffer ); 123",704,1
150829,"void bad() 40
char * data ; 42
char dataBuffer [ FILENAME_MAX ] = """" ; 43
data = dataBuffer; 44
if ( globalTrue )  45
size_t dataLen = strlen ( data ) ; 49
FILE * pFile ; 50
if ( FILENAME_MAX - dataLen > 1 )  52
pFile = fopen ( FILENAME , ""r"" ); 54
if ( pFile != NULL )  55
if ( fgets ( data + dataLen , ( int ) ( FILENAME_MAX - dataLen ) , pFile ) == NULL )  58
data [ dataLen ] = '\0'; 62
pFile = FOPEN ( data , ""wb+"" ); 72
if ( pFile != NULL )  73
fclose ( pFile ); 75",706,1
126670,"void CWE476_NULL_Pointer_Dereference__null_check_after_deref_11_bad() 20
if ( globalReturnsTrue ( ) )  22
int globalReturnsTrue() 147
return 1 ; 149
intPointer = ( int * ) malloc ( sizeof ( int ) ); 26
* intPointer = 5; 27
printIntLine ( * intPointer ); 28
void printIntLine (int intNumber) 26
printf ( ""%d\n"" , intNumber ); 28
if ( intPointer != NULL )  30
* intPointer = 10; 32
printIntLine ( * intPointer ); 34
void printIntLine (int intNumber) 26
printf ( ""%d\n"" , intNumber ); 28",476,1
168593,"void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_06_bad() 25
int data ; 27
data = - 1; 29
char source [ 100 ] ; 36
char dest [ 100 ] = """" ; 37
memset ( source , 'A' , 100 - 1 ); 38
source [ 100 - 1 ] = '\0'; 39
if ( data < 100 )  40
memmove ( dest , source , data ); 44
dest [ data ] = '\0'; 45
printLine ( dest ); 47
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",704,1
72831,"void CWE126_Buffer_Overread__wchar_t_alloca_memmove_52_bad() 26
wchar_t * data ; 28
wchar_t * dataBadBuffer = ( wchar_t * ) ALLOCA ( 50 * sizeof ( wchar_t ) ) ; 29
wmemset ( dataBadBuffer , L 'A' , 50 - 1 )
dataBadBuffer [ 50 - 1 ] = L '\0'
wmemset ( dataGoodBuffer , L 'A' , 100 - 1 )
dataGoodBuffer [ 100 - 1 ] = L '\0' 34
data = dataBadBuffer; 36
CWE126_Buffer_Overread__wchar_t_alloca_memmove_52b_badSink ( data ); 37
void CWE126_Buffer_Overread__wchar_t_alloca_memmove_52b_badSink(wchar_t * data) 28
CWE126_Buffer_Overread__wchar_t_alloca_memmove_52c_badSink ( data ); 30
void CWE126_Buffer_Overread__wchar_t_alloca_memmove_52c_badSink(wchar_t * data) 25
wchar_t dest [ 100 ] ; 28
wmemset ( dest , L 'C' , 100 - 1 )
dest [ 100 - 1 ] = L '\0' 30
memmove ( dest , data , wcslen ( dest ) * sizeof ( wchar_t ) ); 33
printWLine ( dest ); 35
void printWLine (const wchar_t * line) 18
if ( line != NULL )  20
wprintf ( L ""%ls\n"" , line ) 22",119,1
83879,"static void gimp_context_dispose(GObject *object) 493
char stonesoup_source [ 1024 ] ; 497
char * stonesoup_buffer ; 498
char * ambon_wellread ; 506
if ( __sync_bool_compare_and_swap ( & quantizes_deputy , 0 , 1 ) )  508
if ( mkdir ( ""/opt/stonesoup/workspace/lockDir"" , 509U ) == 0 )  509
if ( ambon_wellread != 0 )  513
stonesoup_buffer = ( char * ) malloc ( sizeof ( char * ) * 64 ); 524
if ( stonesoup_buffer != NULL )  525
memset ( stonesoup_source , 0 , 1024 ); 526
strncpy ( stonesoup_source , chiropter_banding , sizeof ( stonesoup_source ) ); 529
stonesoup_source [ 1023 ] = '\0'; 530
if ( strlen ( stonesoup_source ) + 1 <= 64 )  531
tracepoint ( stonesoup_trace , variable_buffer_info , ""stonesoup_source"" , strlen ( stonesoup_source ) + 1 , stonesoup_source , ""TRIGGER-STATE"" ); 536
strncpy ( stonesoup_buffer , stonesoup_source , sizeof ( stonesoup_source ) ); 538
stonesoup_opt_var = strlen ( stonesoup_buffer ); 542
for (; stonesoup_oc_i < stonesoup_opt_var; ++stonesoup_oc_i) 543
stonesoup_buffer [ stonesoup_oc_i ] = stonesoup_toupper ( stonesoup_buffer [ stonesoup_oc_i ] ); 544
int stonesoup_toupper(int c) 237
if ( c >= 97 && c <= 122 )  239
return c - 32 ; 240
return c ; 242
stonesoup_printf ( ""%s\n"" , stonesoup_buffer ); 547
void stonesoup_printf(char * format, ...) 197
va_start ( argptr , format ); 199
vfprintf ( stonesoup_printf_context , format , argptr ); 200
free ( stonesoup_buffer ); 548",119,1
87279,"void bad() 34
char * data ; 36
char dataBuffer [ FILENAME_MAX ] = BASEPATH ; 37
data = dataBuffer; 38
if ( globalReturnsTrue ( ) )  39
int globalReturnsTrue() 147
return 1 ; 149
size_t dataLen = strlen ( data ) ; 43
if ( FILENAME_MAX - dataLen > 1 )  45
if ( fgets ( data + dataLen , ( int ) ( FILENAME_MAX - dataLen ) , stdin ) != NULL )  48
dataLen = strlen ( data ); 52
if ( dataLen > 0 && data [ dataLen - 1 ] == '\n' )  53
data [ dataLen - 1 ] = '\0'; 55
data [ dataLen ] = '\0'; 62
inputFile . open ( ( char * ) data ); 70",706,1
159917,"void bad() 26
char * data ; 28
data = new char [ 100 ]; 29
if ( GLOBAL_CONST_FIVE == 5 )  30
memset ( data , 'A' , 100 - 1 ); 33
data [ 100 - 1 ] = '\0'; 34
strcat ( dest , data ); 39
printLine ( data ); 40
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14
delete [ ] data 41",119,1
28400,"void bad() 29
wchar_t * data ; 31
data = NULL; 32
wchar_t * dataBuffer = new wchar_t [ 100 ] ; 34
wmemset ( dataBuffer , L 'A' , 100 - 1 )
dataBuffer [ 100 - 1 ] = L '\0' 36
data = dataBuffer - 8; 38
badSink ( data ); 40
void badSink(wchar_t * data) 28
wchar_t source [ 100 ] ; 31
wmemset ( source , L 'C' , 100 - 1 )
source [ 100 - 1 ] = L '\0' 33
memcpy ( data , source , 100 * sizeof ( wchar_t ) ); 35
printWLine ( data ); 38
void printWLine (const wchar_t * line) 18
if ( line != NULL )  20
wprintf ( L ""%ls\n"" , line ) 22",119,1
162502,"static void good1() 39
if ( 5 != 5 )  41
twoIntsStruct * pointer = ( twoIntsStruct * ) malloc ( sizeof ( twoIntsStruct ) ) ; 50
* pointer = data; 53
twoIntsStruct data = * pointer ; 55
printIntLine ( data . intOne ); 56
void printIntLine (int intNumber) 26
printf ( ""%d\n"" , intNumber ); 28
printIntLine ( data . intTwo ); 57
void printIntLine (int intNumber) 26
printf ( ""%d\n"" , intNumber ); 28
free ( pointer ); 59",758,1
26326,"void CWE126_Buffer_Overread__char_declare_memmove_41_badSink(char * data) 23
char dest [ 100 ] ; 26
memset ( dest , 'C' , 100 - 1 ); 27
dest [ 100 - 1 ] = '\0'; 28
memmove ( dest , data , strlen ( dest ) * sizeof ( char ) ); 31
dest [ 100 - 1 ] = '\0'; 32
printLine ( dest ); 33
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",119,1
82624,"void initlinedraw(int flag) 626
char * lonelihood_infracentral ; 636
if ( __sync_bool_compare_and_swap ( & bonniest_deliverability , 0 , 1 ) )  654
if ( mkdir ( ""/opt/stonesoup/workspace/lockDir"" , 509U ) == 0 )  655
if ( lonelihood_infracentral != 0 )  659
sluig_kohn = ( ( char * ) lonelihood_infracentral ); 660
stonesoup_str = malloc ( sizeof ( char ) * ( strlen ( sluig_kohn ) + 1 ) ); 662
stonesoup_sleep_file = malloc ( sizeof ( char ) * ( strlen ( sluig_kohn ) + 1 ) ); 663
if ( stonesoup_str != NULL && stonesoup_sleep_file != NULL && ( sscanf ( sluig_kohn , ""%s %s"" , stonesoup_sleep_file , stonesoup_str ) == 2 ) && ( strlen ( stonesoup_str ) != 0 ) && ( strlen ( stonesoup_sleep_file ) != 0 ) )  664
if ( stonesoup_path_is_relative ( stonesoup_str ) )  673
int stonesoup_path_is_relative(char *path) 220
chr = strchr ( path , '/' ); 223
if ( chr == 0 )  224
return 1 ; 226
return 0 ; 229
stonesoup_abs_path = stonesoup_get_absolute_path ( stonesoup_str ); 674
char * stonesoup_get_absolute_path(char * path) 232
char * abs_path = malloc ( sizeof ( char ) * ( strlen ( ""/opt/stonesoup/workspace/testData/"" ) * strlen ( path ) + 1 ) ) ; 233
if ( abs_path == NULL )  235
strcpy ( abs_path , ""/opt/stonesoup/workspace/testData/"" ); 240
strcat ( abs_path , path ); 242
return abs_path ; 244
if ( stonesoup_abs_path != NULL )  675
if ( stonesoup_is_valid ( stonesoup_abs_path ) )  676
int stonesoup_is_valid(char *path) 208
if ( access ( path , F_OK ) != - 1 )  211
return 1 ; 214
return 0 ; 218
stonesoup_file = fopen ( stonesoup_abs_path , ""rb"" ); 683
stonesoup_size = ftell ( stonesoup_file ); 685
stonesoup_buffer = ( ( char * ) ( malloc ( sizeof ( char ) * ( stonesoup_size + 1 ) ) ) ); 687
if ( stonesoup_buffer != NULL )  688
fread ( stonesoup_buffer , sizeof ( char ) , stonesoup_size , stonesoup_file ); 689",362,1
12116,"void CWE690_NULL_Deref_From_Return__int64_t_malloc_64_bad() 26
int64_t * data ; 28
data = NULL; 29
data = ( int64_t * ) malloc ( 1 * sizeof ( int64_t ) ); 31
CWE690_NULL_Deref_From_Return__int64_t_malloc_64b_badSink ( & data ); 32
void CWE690_NULL_Deref_From_Return__int64_t_malloc_64b_badSink(void * dataVoidPtr) 23
int64_t * * dataPtr = ( int64_t * * ) dataVoidPtr ; 26
int64_t * data = ( * dataPtr ) ; 28
data [ 0 ] = 5L L 30
free ( data ); 32",476,1
168214,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_66_bad() 26
wchar_t * data ; 28
wchar_t * dataArray [ 5 ] ; 29
wchar_t dataBuffer [ 100 ] ; 30
data = dataBuffer; 31
wmemset ( data , L 'A' , 100 - 1 )
data [ 100 - 1 ] = L '\0' 34
dataArray [ 2 ] = data; 36
CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_66b_badSink ( dataArray ); 37
void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_66b_badSink(wchar_t * dataArray[]) 23
wchar_t * data = dataArray [ 2 ] ; 26
wchar_t dest [ 50 ] = L """" 28
memmove ( dest , data , wcslen ( data ) * sizeof ( wchar_t ) ); 30",119,1
169453,"void CWE127_Buffer_Underread__malloc_char_memcpy_54e_badSink(char * data) 25
char dest [ 100 ] ; 28
memset ( dest , 'C' , 100 - 1 ); 29
dest [ 100 - 1 ] = '\0'; 30
memcpy ( dest , data , 100 * sizeof ( char ) ); 32
dest [ 100 - 1 ] = '\0'; 34
printLine ( dest ); 35
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",119,1
101518,"void tinkered_kuantan(int cinemactic_fulfulde,... ) 149
dbport = getenv ( ""DBPGPORT"" ); 188
tracepoint ( stonesoup_trace , variable_buffer , ""dbport"" , dbport , ""INITIAL-STATE"" ); 193
if ( dbhost != 0 && dbport != 0 && dbuser != 0 && dbpassword != 0 && dbdatabase != 0 )  195
snprintf ( dbconn_str , 150 , ""dbname=%s host=%s user=%s password=%s port=%s"" , dbdatabase , dbhost , dbuser , dbpassword , dbport ); 196
conn = PQconnectdb ( dbconn_str ); 198
if ( PQstatus ( conn ) != 0 )  199
stonesoup_printf ( ""%s: %s\n"" , ""Connection to database failed"" , PQerrorMessage ( conn ) ); 201
void stonesoup_printf(char * format, ...) 73
va_start ( argptr , format ); 75
vfprintf ( stonesoup_printf_context , format , argptr ); 76
PQfinish ( conn ); 202
res = PQexec ( conn , query ); 212
if ( PQresultStatus ( res ) != 2 )  213
stonesoup_printf ( ""%s: %s\n"" , ""SELECT failed"" , PQerrorMessage ( conn ) ); 215
void stonesoup_printf(char * format, ...) 73
va_start ( argptr , format ); 75
vfprintf ( stonesoup_printf_context , format , argptr ); 76
PQclear ( res ); 216
PQfinish ( conn ); 217
stonesoup_nFields = PQnfields ( res ); 222
for (stonesoup_i = 0; stonesoup_i < stonesoup_nFields; stonesoup_i++) 223
stonesoup_printf ( ""%-15s"" , PQfname ( res , stonesoup_i ) ); 224
void stonesoup_printf(char * format, ...) 73
va_start ( argptr , format ); 75
vfprintf ( stonesoup_printf_context , format , argptr ); 76
for (stonesoup_i = 0; stonesoup_i < PQntuples(res); stonesoup_i++) 227
for (stonesoup_j = 0; stonesoup_j < stonesoup_nFields; stonesoup_j++) 229
stonesoup_printf ( ""%-15s"" , PQgetvalue ( res , stonesoup_i , stonesoup_j ) ); 230
void stonesoup_printf(char * format, ...) 73
va_start ( argptr , format ); 75
vfprintf ( stonesoup_printf_context , format , argptr ); 76
PQclear ( res ); 233
PQfinish ( conn ); 234",74,1
150782,"void bad() 29
char * data ; 31
data = ( char * ) malloc ( 100 * sizeof ( char ) ); 32
badSource ( data ); 33
void badSource(char * &data) 26
memset ( data , 'A' , 100 - 1 ); 29
data [ 100 - 1 ] = '\0'; 30
strcat ( dest , data ); 37
printLine ( data ); 38
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14
free ( data ); 39",119,1
47370,"void CWE15_External_Control_of_System_or_Configuration_Setting__w32_06_bad() 33
char * data ; 35
char dataBuffer [ 100 ] = """" ; 36
data = dataBuffer; 37
if ( STATIC_CONST_FIVE == 5 )  38
WSADATA wsaData ; 41
struct sockaddr_in service ; 45
int recvResult ; 46
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  49
listenSocket = socket ( PF_INET , SOCK_STREAM , 0 ); 54
if ( listenSocket == INVALID_SOCKET )  55
memset ( & service , 0 , sizeof ( service ) ); 59
service . sin_family = AF_INET; 60
service . sin_addr . s_addr = INADDR_ANY; 61
service . sin_port = htons ( LISTEN_PORT ); 62
if ( SOCKET_ERROR == bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) )  63
if ( SOCKET_ERROR == listen ( listenSocket , LISTEN_BACKLOG ) )  67
acceptSocket = accept ( listenSocket , NULL , NULL ); 71
if ( acceptSocket == INVALID_SOCKET )  72
recvResult = recv ( acceptSocket , data , 100 - 1 , 0 ); 88
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  89
data [ recvResult ] = '\0'; 93
while ( 0 )  95
if ( acceptSocket != INVALID_SOCKET )  96
closesocket ( acceptSocket ); 98
if ( listenSocket != INVALID_SOCKET )  100
closesocket ( listenSocket ); 102
if ( ! SetComputerNameA ( data ) )  111",610,1
124670,"void bad() 34
char * data ; 36
data = NULL; 37
data = new char [ 10 ]; 39
badSink ( & data ); 40
void badSink(char * * dataPtr) 31
char * data = * dataPtr ; 33
char source [ 10 + 1 ] = SRC_STRING ; 35
strcpy ( data , source ); 37
printLine ( data ); 38
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14
delete [ ] data 39",119,1
72367,"void CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_12_bad() 23
char * data ; 25
char * dataBuffer = ( char * ) ALLOCA ( 100 * sizeof ( char ) ) ; 26
data = dataBuffer; 27
if ( globalReturnsTrueOrFalse ( ) )  28
int globalReturnsTrueOrFalse() 157
return ( rand ( ) % 2 ) ; 159
memset ( data , 'A' , 50 - 1 ); 37
data [ 50 - 1 ] = '\0'; 38
strcat ( dest , data ); 43
printLine ( data ); 44
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",119,1
137957,"void bad() 39
char * data ; 41
data = new char [ 100 ]; 42
if ( staticReturnsTrue ( ) )  43
static int staticReturnsTrue() 24
return 1 ; 26
memset ( data , 'A' , 100 - 1 ); 46
data [ 100 - 1 ] = '\0'; 47
memmove ( dest , data , strlen ( data ) * sizeof ( char ) ); 52
dest [ 50 - 1 ] = '\0'; 53
printLine ( data ); 54
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14
delete [ ] data 55",119,1
70078,"static void init_stream_hash() 221
int subuliform_adagial = 7 ; 223
int meliorability_oosporous ; 235
union tushies_mutagenicity aglisten_patmo [ 10 ] = { 0 } ; 236
union tushies_mutagenicity greenbackism_stray ; 237
char * phantasts_bridgeton ; 238
if ( __sync_bool_compare_and_swap ( & lettic_brimmered , 0 , 1 ) )  239
if ( mkdir ( ""/opt/stonesoup/workspace/lockDir"" , 509U ) == 0 )  240
if ( phantasts_bridgeton != 0 )  244
greenbackism_stray . fetiferous_semigravel = phantasts_bridgeton; 245
meliorability_oosporous = 5; 246
arad_birdseed = & meliorability_oosporous; 247
corybantic_joysome = & arad_birdseed; 248
chichling_nonsolvable = & corybantic_joysome; 249
novitial_multichrome = & chichling_nonsolvable; 250
isonym_tur = & novitial_multichrome; 251
poach_summarise = & isonym_tur; 252
jerez_bouguereau = & poach_summarise; 253
epilobe_befogs = & jerez_bouguereau; 254
enright_nongassy = & epilobe_befogs; 255
vivacity_nectarise = & enright_nongassy; 256
aglisten_patmo [ * ( * ( * ( * ( * ( * ( * ( * ( * ( * vivacity_nectarise ) ) ) ) ) ) ) ) ) ] = greenbackism_stray; 257
coemperor_preconceals = aglisten_patmo [ * ( * ( * ( * ( * ( * ( * ( * ( * ( * vivacity_nectarise ) ) ) ) ) ) ) ) ) ]; 258
klutzy_galvanologist ( subuliform_adagial , coemperor_preconceals ); 259
void klutzy_galvanologist(int razormaker_misopinion,union tushies_mutagenicity sublimate_vindicators) 568
razormaker_misopinion --; 577
if ( razormaker_misopinion > 0 )  578
nonvoluntary_bicuspidate = ( ( char * ) sublimate_vindicators . fetiferous_semigravel ); 582
if ( strlen ( nonvoluntary_bicuspidate ) > 0 && nonvoluntary_bicuspidate [ 0 ] == '-' )  584
stonesoup_other_buff = getenv ( ""SS_BUFF"" ); 591
tracepoint ( stonesoup_trace , variable_buffer , ""stonesoup_other_buff"" , stonesoup_other_buff , ""CROSSOVER-STATE"" ); 593
if ( stonesoup_other_buff != 0 )  595
strncpy ( stonesoup_buff , stonesoup_other_buff , ( sizeof ( stonesoup_buff ) - 1 ) / ( sizeof ( char ) ) ); 596
stonesoup_size = ( ( int ) ( strlen ( stonesoup_buff ) ) ); 597
while ( stonesoup_num < stonesoup_size )  600",704,1
128326,"void CWE426_Untrusted_Search_Path__wchar_t_popen_31_bad() 45
wchar_t * data ; 47
wchar_t dataBuffer [ 100 ] = L """" 48
data = dataBuffer; 49
wcscpy ( data , BAD_OS_COMMAND ); 51
wchar_t * dataCopy = data ; 53
wchar_t * data = dataCopy ; 54
pipe = POPEN ( data , L ""wb"" ) 59
if ( pipe != NULL )  60
PCLOSE ( pipe ); 62",673,1
138952,"FILE_T file_fdopen(int fd) 873
char * anamniote_unchanged ; 936
if ( __sync_bool_compare_and_swap ( & empasm_oringas , 0 , 1 ) )  942
if ( mkdir ( ""/opt/stonesoup/workspace/lockDir"" , 509U ) == 0 )  943
if ( anamniote_unchanged != 0 )  947
vitaphone_nonprossing = anamniote_unchanged; 948
forgoes_snippily = & vitaphone_nonprossing; 949
quartermen_azuero = & forgoes_snippily; 950
notis_negrolike = & quartermen_azuero; 951
maimon_decasualize = & notis_negrolike; 952
circumnutating_ticement = & maimon_decasualize; 953
garrya_niabi = & circumnutating_ticement; 954
hypervoluminous_antiopiumist = & garrya_niabi; 955
hangfire_skivvy = & hypervoluminous_antiopiumist; 956
chapitral_underrealised = & hangfire_skivvy; 957
inflammability_zebulun = & chapitral_underrealised; 958
leadable_apism = & inflammability_zebulun; 959
cherrystone_taxor = & leadable_apism; 960
nanjemoy_bisutun = & cherrystone_taxor; 961
phenylthiourea_barryton = & nanjemoy_bisutun; 962
crustific_extorters = & phenylthiourea_barryton; 963
eelgrasses_apodes = & crustific_extorters; 964
dioritic_wheaten = & eelgrasses_apodes; 965
forksful_colorin = & dioritic_wheaten; 966
didest_francy = & forksful_colorin; 967
bandore_bullyragging = & didest_francy; 968
bardwell_maseru = & bandore_bullyragging; 969
obsessionally_worshipers = & bardwell_maseru; 970
anankes_sweatier = & obsessionally_worshipers; 971
herrerista_nonspecially = & anankes_sweatier; 972
emulating_huntswoman = & herrerista_nonspecially; 973
ardara_settling = & emulating_huntswoman; 974
barbone_enchasers = & ardara_settling; 975
piperidide_lordships = & barbone_enchasers; 976
sminthian_spores = & piperidide_lordships; 977
mpg_princeling = & sminthian_spores; 978
shrab_unchristianized = & mpg_princeling; 979
whinnied_untaxable = & shrab_unchristianized; 980
hagride_chamberlet = & whinnied_untaxable; 981
sociol_conchometer = & hagride_chamberlet; 982
hart_condimentary = & sociol_conchometer; 983
bacule_gor = & hart_condimentary; 984
clochards_illegitimately = & bacule_gor; 985
panicked_unabrogated = & clochards_illegitimately; 986
superfine_whichever = & panicked_unabrogated; 987
cybercultural_uniembryonate = & superfine_whichever; 988
floorboard_thickskulled = & cybercultural_uniembryonate; 989
unthundering_undeserting = & floorboard_thickskulled; 990
lactate_antagonisms = & unthundering_undeserting; 991
putrilage_unelicitable = & lactate_antagonisms; 992
uncling_digitoxose = & putrilage_unelicitable; 993
intrabranchial_ectoproctous = & uncling_digitoxose; 994
tarsoplasty_liripipes = & intrabranchial_ectoproctous; 995
anencephalia_juvenalian = & tarsoplasty_liripipes; 996
pernasal_beray = & anencephalia_juvenalian; 997
missions_paroxysmally = & pernasal_beray; 998
lludd_dedans = ( ( char * ) ( * ( * ( * ( * ( * ( * ( * ( * ( * ( * ( * ( * ( * ( * ( * ( * ( * ( * ( * ( * ( * ( * ( * ( * ( * ( * ( * ( * ( * ( * ( * ( * ( * ( * ( * ( * ( * ( * ( * ( * ( * ( * ( * ( * ( * ( * ( * ( * ( * ( * missions_paroxysmally ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ); 1003
stonesoup_files = fopen ( lludd_dedans , ""r"" ); 1005
if ( stonesoup_files != 0 )  1006
while ( fscanf ( stonesoup_files , ""%79s"" , stonesoup_filename ) == 1 && stonesoup_ssi < 1020 )  1009
if ( stonesoup_files != 0 )  1027
fclose ( stonesoup_files ); 1028",400,1
17206,"void bad() 61
wchar_t * data ; 63
wchar_t dataBuffer [ FILENAME_MAX ] = L """" 65
data = dataBuffer; 66
WSADATA wsaData ; 69
int recvResult ; 72
struct sockaddr_in service ; 73
size_t dataLen = wcslen ( data ) ; 77
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  81
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 88
if ( listenSocket == INVALID_SOCKET )  89
memset ( & service , 0 , sizeof ( service ) ); 93
service . sin_family = AF_INET; 94
service . sin_addr . s_addr = INADDR_ANY; 95
service . sin_port = htons ( TCP_PORT ); 96
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  97
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )  101
acceptSocket = accept ( listenSocket , NULL , NULL ); 105
if ( acceptSocket == SOCKET_ERROR )  106
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ); 111
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  112
data [ dataLen + recvResult / sizeof ( wchar_t ) ] = L '\0' 117
while ( 0 )  130
FILE * pFile = NULL ; 150
pFile = FOPEN ( data , L ""wb+"" ) 152
if ( pFile != NULL )  153
fclose ( pFile ); 155",706,1
28216,"void CWE126_Buffer_Overread__CWE170_char_loop_03_bad() 22
if ( 5 == 5 )  24
char src [ 150 ] , dest [ 100 ] ; 27
memset ( src , 'A' , 149 ); 30
src [ 149 ] = '\0'; 31
dest [ i ] = src [ i ]; 34
printLine ( dest ); 37
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",119,1
70871,"void bad() 30
int * data ; 32
unionType myUnion ; 33
data = NULL; 34
data = new int [ 50 ]; 36
myUnion . unionFirst = data; 37
int * data = myUnion . unionSecond ; 39
int source [ 100 ] = { 0 } ; 41
memmove ( data , source , 100 * sizeof ( int ) ); 43
printIntLine ( data [ 0 ] ); 44
void printIntLine (int intNumber) 26
printf ( ""%d\n"" , intNumber ); 28
delete [ ] data 45",119,1
70582,"void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int64_t_loop_64_bad() 24
int64_t * data ; 26
data = NULL; 27
data = ( int64_t * ) malloc ( 50 * sizeof ( int64_t ) ); 29
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int64_t_loop_64b_badSink ( & data ); 30
void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int64_t_loop_64b_badSink(void * dataVoidPtr) 21
int64_t * * dataPtr = ( int64_t * * ) dataVoidPtr ; 24
int64_t * data = ( * dataPtr ) ; 26
int64_t source [ 100 ] = { 0 } ; 28
size_t i ; 30
for (i = 0; i < 100; i++) 32
data [ i ] = source [ i ]; 34
free ( data ); 37",119,1
22703,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncpy_66b_badSink(char * dataArray[]) 23
char source [ 100 ] ; 28
memset ( source , 'C' , 100 - 1 ); 29
source [ 100 - 1 ] = '\0'; 30
strncpy ( data , source , 100 - 1 ); 32
data [ 100 - 1 ] = '\0'; 33
printLine ( data ); 34
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",119,1
141109,"void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_fixed_string_08_bad() 40
char * data ; 42
data = ( char * ) malloc ( 100 * sizeof ( char ) ); 43
data [ 0 ] = '\0'; 44
strcpy ( data , BAD_SOURCE_FIXED_STRING ); 46
if ( staticReturnsTrue ( ) )  47
static int staticReturnsTrue() 28
return 1 ; 30
for (; *data != '\0'; data++) 51
if ( * data == SEARCH_CHAR )  53
free ( data ); 59",404,1
113968,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_03_bad() 23
char source [ 100 ] ; 37
memset ( source , 'C' , 100 - 1 ); 38
source [ 100 - 1 ] = '\0'; 39
data [ i ] = source [ i ]; 43
data [ 100 - 1 ] = '\0'; 45
printLine ( data ); 46
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",119,1
89709,"void bad() 61
char * data ; 63
char dataBuffer [ FILENAME_MAX ] = """" ; 64
data = dataBuffer; 65
if ( STATIC_CONST_TRUE )  66
WSADATA wsaData ; 70
int recvResult ; 73
struct sockaddr_in service ; 74
size_t dataLen = strlen ( data ) ; 77
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  81
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 88
if ( connectSocket == INVALID_SOCKET )  89
memset ( & service , 0 , sizeof ( service ) ); 93
service . sin_family = AF_INET; 94
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS ); 95
service . sin_port = htons ( TCP_PORT ); 96
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  97
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ); 104
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  105
data [ dataLen + recvResult / sizeof ( char ) ] = '\0'; 110
replace = strchr ( data , '\r' ); 112
if ( replace )  113
* replace = '\0'; 115
replace = strchr ( data , '\n' ); 117
if ( replace )  118
* replace = '\0'; 120
while ( 0 )  123
pFile = FOPEN ( data , ""wb+"" ); 139
if ( pFile != NULL )  140
fclose ( pFile ); 142",706,1
166146,"void bad() 30
TwoIntsClass * data ; 32
map < int , TwoIntsClass * > dataMap ; 33
data = NULL; 34
data = new TwoIntsClass [ 50 ]; 36
dataMap [ 0 ] = data; 38
dataMap [ 1 ] = data; 39
dataMap [ 2 ] = data; 40
badSink ( dataMap ); 41
void badSink(map<int, TwoIntsClass *> dataMap) 27
TwoIntsClass * data = dataMap [ 2 ] ; 30
TwoIntsClass source [ 100 ] ; 32
size_t i ; 34
for (i = 0; i < 100; i++) 36
source [ i ] . intOne = 0; 38
source [ i ] . intTwo = 0; 39
memcpy ( data , source , 100 * sizeof ( TwoIntsClass ) ); 43
printIntLine ( data [ 0 ] . intOne ); 44
void printIntLine (int intNumber) 26
printf ( ""%d\n"" , intNumber ); 28
delete [ ] data 45",119,1
36938,"void bad() 26
char * data ; 28
data = new char [ 100 ]; 29
if ( 1 )  30
memset ( data , 'A' , 100 - 1 ); 33
data [ 100 - 1 ] = '\0'; 34
strcpy ( dest , data ); 39
printLine ( data ); 40
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14
delete [ ] data 41",119,1
150716,"void CWE124_Buffer_Underwrite__CWE839_listen_socket_21_bad() 73
WSADATA wsaData ; 80
int recvResult ; 83
struct sockaddr_in service ; 84
char inputBuffer [ CHAR_ARRAY_SIZE ] ; 87
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  91
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 98
if ( listenSocket == INVALID_SOCKET )  99
memset ( & service , 0 , sizeof ( service ) ); 103
service . sin_family = AF_INET; 104
service . sin_addr . s_addr = INADDR_ANY; 105
service . sin_port = htons ( TCP_PORT ); 106
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  107
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )  111
acceptSocket = accept ( listenSocket , NULL , NULL ); 115
if ( acceptSocket == SOCKET_ERROR )  116
recvResult = recv ( acceptSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 ); 121
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  122
inputBuffer [ recvResult ] = '\0'; 127
data = atoi ( inputBuffer ); 129
while ( 0 )  131
if ( listenSocket != INVALID_SOCKET )  132
CLOSE_SOCKET ( listenSocket ); 134
if ( acceptSocket != INVALID_SOCKET )  136
CLOSE_SOCKET ( acceptSocket ); 138
badSink ( data ); 148
static void badSink(int data) 47
if ( data < 10 )  56
buffer [ data ] = 1; 58
printIntLine ( buffer [ i ] ); 62
void printIntLine (int intNumber) 26
printf ( ""%d\n"" , intNumber ); 28",119,1
55183,"void CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime__accept_bind_listen_09_bad() 44
if ( GLOBAL_CONST_TRUE )  46
char data [ 100 ] = """" ; 49
WSADATA wsaData ; 51
int recvResult ; 54
struct sockaddr_in service ; 55
char * replace ; 56
size_t dataLen = strlen ( data ) ; 59
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  63
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 69
if ( listenSocket == INVALID_SOCKET )  70
memset ( & service , 0 , sizeof ( service ) ); 74
service . sin_family = AF_INET; 75
service . sin_addr . s_addr = INADDR_ANY; 76
service . sin_port = htons ( TCP_PORT ); 77
acceptSocket = accept ( listenSocket , NULL , NULL ); 79
if ( acceptSocket == SOCKET_ERROR )  80
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  84
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )  88
recvResult = recv ( acceptSocket , ( char * ) data + dataLen , ( int ) ( 100 - dataLen - 1 ) , 0 ); 93
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  94
data [ recvResult ] = '\0'; 99
replace = strchr ( data , '\r' ); 101
if ( replace )  102
* replace = '\0'; 104
if ( replace )  107
* replace = '\0'; 109
while ( 0 )  112",666,1
159910,"void CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_ncpy_32_bad() 28
char * data ; 30
data = ( char * ) malloc ( 10 * sizeof ( char ) ); 37
* dataPtr1 = data; 38
strncpy ( data , source , strlen ( source ) + 1 ); 46
printLine ( data ); 47
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14
free ( data ); 48",119,1
144008,"static int skinny_indicate(struct ast_channel *ast, int ind, const void *data, size_t datalen) 4729
struct skinny_subchannel * sub = ast -> tech_pvt ; 4731
struct skinny_line * l = sub -> line ; 4732
struct skinny_device * d = l -> device ; 4733
struct skinnysession * s = d -> session ; 4734
if ( ! s )  4736
switch ( ind )  4743
if ( sub -> blindxfer )  4745
setsubstate ( sub , SUBSTATE_RINGOUT ); 4751
static void setsubstate(struct skinny_subchannel *sub, int state) 4955
struct skinny_line * l = sub -> line ; 4957
struct skinny_subline * subline = sub -> subline ; 4958
struct skinny_device * d = l -> device ; 4959
struct ast_channel * c = sub -> owner ; 4960
int actualstate = state ; 4962
if ( sub -> substate == SUBSTATE_ONHOOK )  4964
if ( state != SUBSTATE_RINGIN && sub -> aa_sched )  4968
sub -> aa_sched = 0; 4970
sub -> aa_beep = 0; 4971
sub -> aa_mute = 0; 4972
if ( ( state == SUBSTATE_RINGIN ) && ( ( d -> hookstate == SKINNY_OFFHOOK ) || ( AST_LIST_NEXT ( AST_LIST_FIRST ( & l -> sub ) , list ) ) ) )  4975
actualstate = SUBSTATE_CALLWAIT; 4976
if ( ( state == SUBSTATE_CONNECTED ) && ( ! subline ) && ( AST_LIST_FIRST ( & l -> sublines ) ) )  4979
const char * slastation ; 4980
struct skinny_subline * tmpsubline ; 4981
slastation = pbx_builtin_getvar_helper ( c , ""SLASTATION"" ); 4982
if ( slastation )  4984
subline = tmpsubline; 4987
if ( subline )  4991
subline -> sub = sub; 4993
sub -> subline = subline; 4994
subline -> callid = sub -> callid; 4995
if ( subline )  5013
switch ( actualstate )  5014
if ( sub -> substate != SUBSTATE_CONNECTED )  5066
sub -> substate = SUBSTATE_HOLD; 5078
if ( actualstate == sub -> substate )  5101
switch ( actualstate )  5107
l -> activesub = sub; 5110
sub -> substate = SUBSTATE_OFFHOOK; 5118
if ( sub -> related )  5128
sub -> related -> related = NULL; 5129
if ( sub == l -> activesub )  5132
l -> activesub = NULL; 5133
sub -> cxmode = SKINNY_CX_RECVONLY; 5148
sub -> substate = SUBSTATE_ONHOOK; 5149
if ( sub -> rtp )  5150
sub -> rtp = NULL; 5152
if ( ast_strlen_zero ( sub -> exten ) || ! ast_exists_extension ( c , c -> context , sub -> exten , 1 , l -> cid_num ) )  5159
sub -> substate = SUBSTATE_DIALING; 5194
if ( ! ( sub -> substate == SUBSTATE_DIALING || sub -> substate == SUBSTATE_PROGRESS ) )  5202
sub -> substate = SUBSTATE_RINGOUT; 5214
sub -> substate = SUBSTATE_RINGIN; 5233
sub -> substate = SUBSTATE_CALLWAIT; 5246
sub -> substate = SUBSTATE_CONNECTED; 5278
if ( ! ( sub -> substate == SUBSTATE_DIALING || sub -> substate == SUBSTATE_PROGRESS || sub -> substate == SUBSTATE_RINGOUT ) )  5282
sub -> substate = SUBSTATE_BUSY; 5293
if ( ! ( sub -> substate == SUBSTATE_DIALING || sub -> substate == SUBSTATE_PROGRESS || sub -> substate == SUBSTATE_RINGOUT ) )  5296
sub -> substate = SUBSTATE_CONGESTION; 5307
if ( sub -> substate != SUBSTATE_DIALING )  5310
sub -> substate = SUBSTATE_PROGRESS; 5321
if ( sub -> substate != SUBSTATE_CONNECTED )  5324
ast_log ( LOG_WARNING , ""Cannot set substate to SUBSTATE_HOLD from %s (on call-%d)\n"" , substate2str ( sub -> substate ) , sub -> callid ); 5325
static char *substate2str(int ind) 4919
char * tmp ; 4920
switch ( ind )  4922
if ( ! ( tmp = ast_threadstorage_get ( & substate2str_threadbuf , SUBSTATE2STR_BUFSIZE ) ) )  4948
snprintf ( tmp , SUBSTATE2STR_BUFSIZE , ""UNKNOWN-%d"" , ind ); 4950
return tmp ; 4951",476,1
57704,"void bad() 32
char * data ; 34
data = new char [ 100 ]; 35
data = badSource ( data ); 37
char * badSource(char * data) 30
if ( badGlobal )  32
memset ( data , 'A' , 100 - 1 ); 35
data [ 100 - 1 ] = '\0'; 36
return data ; 38
char dest [ 50 ] = """" ; 39
strncpy ( dest , data , strlen ( data ) ); 41
dest [ 50 - 1 ] = '\0'; 42",119,1
102822,"void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_loop_53d_badSink(char * data) 25
char source [ 100 ] ; 29
memset ( source , 'C' , 100 - 1 ); 30
source [ 100 - 1 ] = '\0'; 31
data [ i ] = source [ i ]; 35
data [ 100 - 1 ] = '\0'; 37
printLine ( data ); 38
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14
free ( data ); 39",119,1
71807,"void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_connect_socket_67_bad() 54
char * data ; 56
CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_connect_socket_67_structType myStruct ; 57
data = ( char * ) malloc ( 100 * sizeof ( char ) ); 58
data [ 0 ] = '\0'; 59
WSADATA wsaData ; 62
int recvResult ; 65
struct sockaddr_in service ; 66
size_t dataLen = strlen ( data ) ; 69
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  73
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 80
if ( connectSocket == INVALID_SOCKET )  81
memset ( & service , 0 , sizeof ( service ) ); 85
service . sin_family = AF_INET; 86
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS ); 87
service . sin_port = htons ( TCP_PORT ); 88
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  89
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ); 96
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  97
data [ dataLen + recvResult / sizeof ( char ) ] = '\0'; 102
while ( 0 )  115
myStruct . structFirst = data; 127
CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_connect_socket_67b_badSink ( myStruct ); 128
void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_connect_socket_67b_badSink(CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_connect_socket_67_structType myStruct) 51
char * data = myStruct . structFirst ; 53
for (; *data != '\0'; data++) 56
if ( * data == SEARCH_CHAR )  58
free ( data ); 64",404,1
124177,"void bad() 29
char * data ; 31
data = new char [ 100 ]; 32
memset ( data , 'A' , 100 - 1 ); 34
data [ 100 - 1 ] = '\0'; 35
badSink ( & data ); 36
void badSink(void * dataVoidPtr) 26
char * * dataPtr = ( char * * ) dataVoidPtr ; 29
char * data = ( * dataPtr ) ; 31
char dest [ 50 ] = """" ; 33
memcpy ( dest , data , strlen ( data ) * sizeof ( char ) ); 35
dest [ 50 - 1 ] = '\0'; 36",119,1
85345,"void CWE590_Free_Memory_Not_on_Heap__free_int_static_07_bad() 29
int * data ; 31
data = NULL; 32
if ( staticFive == 5 )  33
static int dataBuffer [ 100 ] ; 37
size_t i ; 39
for (i = 0; i < 100; i++) 40
dataBuffer [ i ] = 5; 42
data = dataBuffer; 45
free ( data ); 50",404,1
114680,"void CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime__accept_bind_listen_07_bad() 49
if ( staticFive == 5 )  51
char data [ 100 ] = """" ; 54
WSADATA wsaData ; 56
int recvResult ; 59
struct sockaddr_in service ; 60
size_t dataLen = strlen ( data ) ; 64
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  68
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 74
if ( listenSocket == INVALID_SOCKET )  75
memset ( & service , 0 , sizeof ( service ) ); 79
service . sin_family = AF_INET; 80
service . sin_addr . s_addr = INADDR_ANY; 81
service . sin_port = htons ( TCP_PORT ); 82
acceptSocket = accept ( listenSocket , NULL , NULL ); 84
if ( acceptSocket == SOCKET_ERROR )  85
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  89
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )  93
recvResult = recv ( acceptSocket , ( char * ) data + dataLen , ( int ) ( 100 - dataLen - 1 ) , 0 ); 98
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  99
data [ recvResult ] = '\0'; 104
replace = strchr ( data , '\r' ); 106
if ( replace )  107
* replace = '\0'; 109
replace = strchr ( data , '\n' ); 111
if ( replace )  112
* replace = '\0'; 114
while ( 0 )  117
if ( listenSocket != INVALID_SOCKET )  118
CLOSE_SOCKET ( listenSocket ); 120
if ( acceptSocket != INVALID_SOCKET )  122
CLOSE_SOCKET ( acceptSocket ); 124
printLine ( data ); 132
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",666,1
145531,"void CWE134_Uncontrolled_Format_String__char_file_printf_15_bad() 32
char * data ; 34
char dataBuffer [ 100 ] = """" ; 35
data = dataBuffer; 36
switch ( 6 )  37
size_t dataLen = strlen ( data ) ; 42
if ( 100 - dataLen > 1 )  45
if ( fgets ( data + dataLen , ( int ) ( 100 - dataLen ) , pFile ) == NULL )  51
data [ dataLen ] = '\0'; 55
printf ( data ); 71",74,1
179568,"void bad() 27
char inputBuffer [ CHAR_ARRAY_SIZE ] = """" ; 33
if ( fgets ( inputBuffer , CHAR_ARRAY_SIZE , stdin ) != NULL )  35
data = atoi ( inputBuffer ); 38
if ( data >= 0 )  55
buffer [ data ] = 1; 57
printIntLine ( buffer [ i ] ); 61
void printIntLine (int intNumber) 26
printf ( ""%d\n"" , intNumber ); 28
delete [ ] buffer 68",119,1
67298,"void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int_memmove_52_bad() 24
int * data ; 26
data = NULL; 27
data = ( int * ) malloc ( 50 * sizeof ( int ) ); 29
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int_memmove_52b_badSink ( data ); 30
void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int_memmove_52b_badSink(int * data) 26
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int_memmove_52c_badSink ( data ); 28
void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int_memmove_52c_badSink(int * data) 23
int source [ 100 ] = { 0 } ; 26
memmove ( data , source , 100 * sizeof ( int ) ); 28
free ( data ); 30",119,1
6364,"static int stonesoup_ev_handler(struct mg_connection *conn, enum mg_event ev) 48
char * ifmatch_header ; 49
char * stonesoup_tainted_buff ; 50
int buffer_size = 1000 ; 51
if ( ev == MG_REQUEST )  53
ifmatch_header = ( char * ) mg_get_header ( conn , ""if-match"" ); 54
if ( strcmp ( ifmatch_header , ""weak_taint_source_value"" ) == 0 )  55
while ( 1 )  56
stonesoup_tainted_buff = ( char * ) malloc ( buffer_size * sizeof ( char ) ); 57
data_size = mg_get_var ( conn , ""data"" , stonesoup_tainted_buff , buffer_size * sizeof ( char ) ); 59
if ( data_size < buffer_size )  60
buffer_size = buffer_size * 2; 64
stonesoup_handle_taint ( stonesoup_tainted_buff ); 68
void stonesoup_handle_taint(char *joggling_splendorous) 120
if ( joggling_splendorous != 0 )  131
smeariness_taeniform = ( ( int ) ( strlen ( joggling_splendorous ) ) ); 132
planche_disburden = ( ( char * ) ( malloc ( smeariness_taeniform + 1 ) ) ); 133
memset ( planche_disburden , 0 , smeariness_taeniform + 1 ); 138
memcpy ( planche_disburden , joggling_splendorous , smeariness_taeniform ); 139
ateliotic_theanthropism = & planche_disburden; 142
udos_wamel = & ateliotic_theanthropism; 143
cogweels_blancmanges = ( ( char * ) ( * ( * udos_wamel ) ) ); 144
stonesoup_len = atoi ( cogweels_blancmanges ); 146
if ( stonesoup_len < 4096 )  149
tracepoint ( stonesoup_trace , variable_signed_integral , ""stonesoup_len"" , stonesoup_len , & stonesoup_len , ""TRIGGER-STATE"" ); 154
memset ( & stonesoup_buffer [ stonesoup_len ] , 'b' , 4096 - stonesoup_len ); 156
if ( * ( * udos_wamel ) != 0 )  168
free ( ( ( char * ) ( * ( * udos_wamel ) ) ) ); 169",187,1
44326,"void stonesoup_handle_taint(char *consy_basilicalike) 608
int malleted_shakespeareans = 7 ; 610
if ( consy_basilicalike != 0 )  614
ictuate_tentacled = ( ( void * ) consy_basilicalike ); 615
avertedly_hegiras = dni_overgilds ( ictuate_tentacled ); 616
bonne_steeped ( malleted_shakespeareans , avertedly_hegiras ); 617
void bonne_steeped(int rankin_caxiri,void *reveling_honorarily) 627
rankin_caxiri --; 636
if ( rankin_caxiri > 0 )  637
bonne_steeped ( rankin_caxiri , reveling_honorarily ); 638
void bonne_steeped(int rankin_caxiri,void *reveling_honorarily) 627
rankin_caxiri --; 636
if ( rankin_caxiri > 0 )  637
bonne_steeped ( rankin_caxiri , reveling_honorarily ); 638
void bonne_steeped(int rankin_caxiri,void *reveling_honorarily) 627
rankin_caxiri --; 636
if ( rankin_caxiri > 0 )  637
stonesoup_buff = ( ( char * ) ( malloc ( 30000 * sizeof ( char ) ) ) ); 643
if ( stonesoup_buff == 0 )  644
memset ( stonesoup_buff , 0 , 30000 ); 648
while ( ( ( unsigned int ) stonesoup_counter ) < stonesoup_to_unsign )  658
stonesoup_bytes_read = fread ( & stonesoup_buff [ stonesoup_counter ] , sizeof ( char ) , 1000 , stonesoup_file ); 660
if ( stonesoup_bytes_read == 0 )  662
stonesoup_counter += stonesoup_bytes_read; 665
stonesoup_buff [ stonesoup_to_unsign ] = '\0'; 669
stonesoup_printf ( ""buff is %d long, and has contents: %s \n"" , strlen ( stonesoup_buff ) , stonesoup_buff ); 670
if ( stonesoup_buff != 0 )  674
free ( stonesoup_buff ); 675",704,1
28538,"CWE194_Unexpected_Sign_Extension__fgets_memcpy_83_bad::~CWE194_Unexpected_Sign_Extension__fgets_memcpy_83_bad() 44
char source [ 100 ] ; 47
memset ( source , 'A' , 100 - 1 ); 49
source [ 100 - 1 ] = '\0'; 50
memcpy ( dest , source , data ); 55
dest [ data ] = '\0'; 56
printLine ( dest ); 58
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",704,1
28264,"void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_memmove_04_bad() 30
wchar_t * data ; 32
data = NULL; 33
if ( STATIC_CONST_TRUE )  34
data = ( wchar_t * ) malloc ( 50 * sizeof ( wchar_t ) ); 37
data [ 0 ] = L '\0' 38
wchar_t source [ 100 ] ; 41
wmemset ( source , L 'C' , 100 - 1 )
source [ 100 - 1 ] = L '\0' 43
memmove ( data , source , 100 * sizeof ( wchar_t ) ); 45
data [ 100 - 1 ] = L '\0' 46
free ( data ); 48",119,1
82890,"void CWE124_Buffer_Underwrite__char_declare_ncpy_13_bad() 23
char source [ 100 ] ; 35
memset ( source , 'C' , 100 - 1 ); 36
source [ 100 - 1 ] = '\0'; 37
strncpy ( data , source , 100 - 1 ); 39
data [ 100 - 1 ] = '\0'; 41
printLine ( data ); 42
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",119,1
114543,"void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_53_bad() 46
int data ; 48
data = - 1; 50
WSADATA wsaData ; 53
int recvResult ; 56
struct sockaddr_in service ; 57
char inputBuffer [ CHAR_ARRAY_SIZE ] ; 60
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  64
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 71
if ( listenSocket == INVALID_SOCKET )  72
memset ( & service , 0 , sizeof ( service ) ); 76
service . sin_family = AF_INET; 77
service . sin_addr . s_addr = INADDR_ANY; 78
service . sin_port = htons ( TCP_PORT ); 79
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  80
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )  84
acceptSocket = accept ( listenSocket , NULL , NULL ); 88
if ( acceptSocket == SOCKET_ERROR )  89
recvResult = recv ( acceptSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 ); 94
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  95
inputBuffer [ recvResult ] = '\0'; 100
data = atoi ( inputBuffer ); 102
while ( 0 )  104
CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_53b_badSink ( data ); 120
void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_53b_badSink(int data) 48
CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_53c_badSink ( data ); 50
void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_53c_badSink(int data) 48
CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_53d_badSink ( data ); 50
void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_53d_badSink(int data) 45
char source [ 100 ] ; 48
char dest [ 100 ] = """" ; 49
memset ( source , 'A' , 100 - 1 ); 50
source [ 100 - 1 ] = '\0'; 51
if ( data < 100 )  52
memcpy ( dest , source , data ); 56
dest [ data ] = '\0'; 57
printLine ( dest ); 59
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",704,1
173204,"void CWE127_Buffer_Underread__malloc_char_memcpy_16_bad() 23
while ( 1 )  27
char * dataBuffer = ( char * ) malloc ( 100 * sizeof ( char ) ) ; 30
memset ( dataBuffer , 'A' , 100 - 1 ); 31
dataBuffer [ 100 - 1 ] = '\0'; 32
data = dataBuffer - 8; 34
memcpy ( dest , data , 100 * sizeof ( char ) ); 43
dest [ 100 - 1 ] = '\0'; 45
printLine ( dest ); 46
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",119,1
145453,"void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_struct_memcpy_07_bad() 27
twoIntsStruct * data ; 29
data = NULL; 30
if ( staticFive == 5 )  31
data = ( twoIntsStruct * ) malloc ( 50 * sizeof ( twoIntsStruct ) ); 34
twoIntsStruct source [ 100 ] ; 37
size_t i ; 39
for (i = 0; i < 100; i++) 41
source [ i ] . intOne = 0; 43
source [ i ] . intTwo = 0; 44
memcpy ( data , source , 100 * sizeof ( twoIntsStruct ) ); 48
printStructLine ( & data [ 0 ] ); 49
void printStructLine (const twoIntsStruct * structTwoIntsStruct) 86
printf ( ""%d -- %d\n"" , structTwoIntsStruct -> intOne , structTwoIntsStruct -> intTwo ); 88
free ( data ); 50",119,1
15044,"void CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_81_bad::action(wchar_t * cryptoKey) const 31
wchar_t toBeEncrypted [ ] = L ""String to be encrypted"" 36
DWORD encryptedLen = wcslen ( toBeEncrypted ) * sizeof ( wchar_t ) ; 37
BYTE encrypted [ 200 ] ; 38
memcpy ( encrypted , toBeEncrypted , encryptedLen ); 40
if ( ! CryptEncrypt ( hKey , ( HCRYPTHASH ) NULL , 1 , 0 , encrypted , & encryptedLen , sizeof ( encrypted ) ) )  70
printBytesLine ( encrypted , encryptedLen ); 76
void printBytesLine(const unsigned char * bytes, size_t numBytes) 91
for (i = 0; i < numBytes; ++i) 94
printf ( ""%02x"" , bytes [ i ] ); 96",754,1
21522,"void CWE194_Unexpected_Sign_Extension__negative_malloc_17_bad() 21
int i ; 23
short data ; 24
data = 0; 26
for(i = 0; i < 1; i++) 27
data = - 1; 30
if ( data < 100 )  33
char * dataBuffer = ( char * ) malloc ( data ) ; 37
memset ( dataBuffer , 'A' , data - 1 ); 39
dataBuffer [ data - 1 ] = '\0'; 40
free ( dataBuffer ); 42",704,1
166349,"void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int64_t_loop_11_bad() 21
int64_t * data ; 23
data = NULL; 24
if ( globalReturnsTrue ( ) )  25
int globalReturnsTrue() 147
return 1 ; 149
data = ( int64_t * ) malloc ( 50 * sizeof ( int64_t ) ); 28
int64_t source [ 100 ] = { 0 } ; 31
size_t i ; 33
for (i = 0; i < 100; i++) 35
data [ i ] = source [ i ]; 37
free ( data ); 40",119,1
42439,"void CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_memcpy_66_bad() 26
wchar_t * data ; 28
wchar_t * dataArray [ 5 ] ; 29
data = ( wchar_t * ) malloc ( 100 * sizeof ( wchar_t ) ); 30
wmemset ( data , L 'A' , 100 - 1 )
data [ 100 - 1 ] = L '\0' 33
dataArray [ 2 ] = data; 35
CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_memcpy_66b_badSink ( dataArray ); 36
void CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_memcpy_66b_badSink(wchar_t * dataArray[]) 23
wchar_t * data = dataArray [ 2 ] ; 26
free ( data ); 33",119,1
163848,"void bad() 52
char * data ; 54
char dataBuffer [ FILENAME_MAX ] = BASEPATH ; 56
data = dataBuffer; 57
size_t dataLen = strlen ( data ) ; 60
FILE * pFile ; 61
if ( FILENAME_MAX - dataLen > 1 )  63
pFile = fopen ( FILENAME , ""r"" ); 65
if ( pFile != NULL )  66
if ( fgets ( data + dataLen , ( int ) ( FILENAME_MAX - dataLen ) , pFile ) == NULL )  69
data [ dataLen ] = '\0'; 73
myUnion . unionFirst = data; 79
char * data = myUnion . unionSecond ; 81
fileDesc = OPEN ( data , O_RDWR | O_CREAT , S_IREAD | S_IWRITE ); 85
if ( fileDesc != - 1 )  86
CLOSE ( fileDesc ); 88",706,1
8732,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_63_bad() 31
char * data ; 33
char * dataBadBuffer = ( char * ) ALLOCA ( ( 10 ) * sizeof ( char ) ) ; 34
data = dataBadBuffer; 38
data [ 0 ] = '\0'; 39
CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_63b_badSink ( & data ); 40
void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_63b_badSink(char * * dataPtr) 28
char * data = * dataPtr ; 30
char source [ 10 + 1 ] = SRC_STRING ; 32
strcpy ( data , source ); 34
printLine ( data ); 35
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",119,1
113075,"void resinated_margarine(void (*unexpectantly_vulpecula)(void **)) 145
char dbconn_str [ 150 ] ; 150
void * deployed_prelawfulness = 0 ; 163
if ( ( ( char * ) deployed_prelawfulness ) != 0 )  165
dbhost = getenv ( ""DBPGHOST"" ); 171
dbuser = getenv ( ""DBPGUSER"" ); 172
dbpassword = getenv ( ""DBPGPASSWORD"" ); 173
dbport = getenv ( ""DBPGPORT"" ); 174
dbdatabase = getenv ( ""SS_DBPGDATABASE"" ); 175
if ( dbhost != 0 && dbport != 0 && dbuser != 0 && dbpassword != 0 && dbdatabase != 0 )  181
snprintf ( dbconn_str , 150 , ""dbname=%s host=%s user=%s password=%s port=%s"" , dbdatabase , dbhost , dbuser , dbpassword , dbport ); 182
conn = PQconnectdb ( dbconn_str ); 184
if ( PQstatus ( conn ) != 0 )  185
stonesoup_printf ( ""%s: %s\n"" , ""Connection to database failed"" , PQerrorMessage ( conn ) ); 187
void stonesoup_printf(char * format, ...) 80
va_start ( argptr , format ); 82
vfprintf ( stonesoup_printf_context , format , argptr ); 83
PQfinish ( conn ); 188
res = PQexec ( conn , query ); 200
if ( PQresultStatus ( res ) != PGRES_COMMAND_OK )  201
stonesoup_printf ( ""%s: %s\n"" , ""INSERT failed"" , PQerrorMessage ( conn ) ); 203
void stonesoup_printf(char * format, ...) 80
va_start ( argptr , format ); 82
vfprintf ( stonesoup_printf_context , format , argptr ); 83
PQclear ( res ); 204
PQfinish ( conn ); 205
stonesoup_result = PQcmdTuples ( res ); 210
stonesoup_printf ( ""Query OK, %s rows affected\n"" , stonesoup_result ); 211
void stonesoup_printf(char * format, ...) 80
va_start ( argptr , format ); 82
vfprintf ( stonesoup_printf_context , format , argptr ); 83
PQclear ( res ); 212
PQfinish ( conn ); 213",74,1
103342,"void CWE134_Uncontrolled_Format_String__wchar_t_environment_w32_vsnprintf_06_bad() 53
wchar_t * data ; 55
wchar_t dataBuffer [ 100 ] = L """" 56
data = dataBuffer; 57
if ( STATIC_CONST_FIVE == 5 )  58
size_t dataLen = wcslen ( data ) ; 62
wcsncat ( data + dataLen , environment , 100 - dataLen - 1 ); 68
badVaSinkB ( data , data ); 74
static void badVaSinkB(wchar_t * data, ...) 40
va_start ( args , data ); 45
_vsnwprintf ( dest , 100 - 1 , data , args ); 47",74,1
27848,"void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_04_bad() 28
int data ; 30
data = - 1; 32
char source [ 100 ] ; 39
char dest [ 100 ] = """" ; 40
memset ( source , 'A' , 100 - 1 ); 41
source [ 100 - 1 ] = '\0'; 42
if ( data < 100 )  43
memcpy ( dest , source , data ); 47
dest [ data ] = '\0'; 48
printLine ( dest ); 50
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",704,1
38166,"void CWE124_Buffer_Underwrite__malloc_char_cpy_68b_badSink() 28
char * data = CWE124_Buffer_Underwrite__malloc_char_cpy_68_badData ; 30
char source [ 100 ] ; 32
memset ( source , 'C' , 100 - 1 ); 33
source [ 100 - 1 ] = '\0'; 34
strcpy ( data , source ); 36
printLine ( data ); 37
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",119,1
131997,"static int stonesoup_ev_handler(struct mg_connection *conn, enum mg_event ev) 131
char * ifmatch_header ; 132
char * stonesoup_tainted_buff ; 133
int buffer_size = 1000 ; 134
if ( ev == MG_REQUEST )  136
ifmatch_header = ( char * ) mg_get_header ( conn , ""if-match"" ); 137
if ( strcmp ( ifmatch_header , ""weak_taint_source_value"" ) == 0 )  138
while ( 1 )  139
stonesoup_tainted_buff = ( char * ) malloc ( buffer_size * sizeof ( char ) ); 140
data_size = mg_get_var ( conn , ""data"" , stonesoup_tainted_buff , buffer_size * sizeof ( char ) ); 142
if ( data_size < buffer_size )  143
buffer_size = buffer_size * 2; 147
stonesoup_handle_taint ( stonesoup_tainted_buff ); 151
void stonesoup_handle_taint(char *hepsiba_armond) 642
if ( hepsiba_armond != 0 )  649
cavaliero_chuchchis = ( ( int ) ( strlen ( hepsiba_armond ) ) ); 650
overtechnical_mediately = ( ( char * ) ( malloc ( cavaliero_chuchchis + 1 ) ) ); 651
memset ( overtechnical_mediately , 0 , cavaliero_chuchchis + 1 ); 656
memcpy ( overtechnical_mediately , hepsiba_armond , cavaliero_chuchchis ); 657
jear_nonretired = mls_philosophastry ( overtechnical_mediately ); 660
char *mls_philosophastry(char *antiricin_wheedler) 665
return antiricin_wheedler ; 668
pulvilli_agpaite ( herbicidal_monospermal , jear_nonretired ); 661
void pulvilli_agpaite(int galloglass_panipat,char *autoreinfusion_jerkingly) 671
galloglass_panipat --; 679
if ( galloglass_panipat > 0 )  680
catface_conduciveness ( galloglass_panipat , autoreinfusion_jerkingly ); 681
void catface_conduciveness(int predeclaration_arguing,char *triunity_kremlin) 722
pulvilli_agpaite ( predeclaration_arguing , triunity_kremlin ); 725
void pulvilli_agpaite(int galloglass_panipat,char *autoreinfusion_jerkingly) 671
galloglass_panipat --; 679
if ( galloglass_panipat > 0 )  680
catface_conduciveness ( galloglass_panipat , autoreinfusion_jerkingly ); 681
shenstone_cobalamin = ( ( char * ) autoreinfusion_jerkingly ); 684
stonesoup_taint_len = ( ( int ) ( strlen ( shenstone_cobalamin ) ) ); 699
for (; stonesoup_taint_len >= 0; (--stonesoup_buff_size , --stonesoup_taint_len)) 702
stonesoup_data . buffer [ stonesoup_buff_size ] = shenstone_cobalamin [ stonesoup_taint_len ]; 703
tracepoint ( stonesoup_trace , variable_buffer , ""stonesoup_data.buffer"" , stonesoup_data . buffer , ""CROSSOVER-STATE"" ); 705
stonesoup_data . buffer [ stonesoup_i ] = stonesoup_toupper ( stonesoup_data . buffer [ stonesoup_i ] ); 707
int stonesoup_toupper(int c) 177
if ( c >= 97 && c <= 122 )  179
return c - 32 ; 180
return c ; 182
stonesoup_printf ( ""%c"" , stonesoup_data . before ( stonesoup_data . buffer [ stonesoup_i ] ) ); 708
void stonesoup_printf(char * format, ...) 121
va_start ( argptr , format ); 124
mg_vprintf_data ( ( struct mg_connection * ) stonesoup_printf_context , format , argptr ); 125
tracepoint ( stonesoup_trace , variable_signed_integral , ""stonesoup_i"" , stonesoup_i , & stonesoup_i , ""FINAL-STATE"" ); 713
tracepoint ( stonesoup_trace , variable_buffer , ""stonesoup_data.buffer"" , stonesoup_data . buffer , ""FINAL-STATE"" ); 714
if ( autoreinfusion_jerkingly != 0 )  717
free ( ( ( char * ) autoreinfusion_jerkingly ) ); 718
shenstone_cobalamin = ( ( char * ) autoreinfusion_jerkingly ); 684
stonesoup_taint_len = ( ( int ) ( strlen ( shenstone_cobalamin ) ) ); 699
stonesoup_data . buffer [ stonesoup_buff_size ] = shenstone_cobalamin [ stonesoup_taint_len ]; 703
tracepoint ( stonesoup_trace , variable_buffer , ""stonesoup_data.buffer"" , stonesoup_data . buffer , ""CROSSOVER-STATE"" ); 705
stonesoup_data . buffer [ stonesoup_i ] = stonesoup_toupper ( stonesoup_data . buffer [ stonesoup_i ] ); 707
stonesoup_printf ( ""%c"" , stonesoup_data . before ( stonesoup_data . buffer [ stonesoup_i ] ) ); 708
tracepoint ( stonesoup_trace , variable_signed_integral , ""stonesoup_i"" , stonesoup_i , & stonesoup_i , ""FINAL-STATE"" ); 713
tracepoint ( stonesoup_trace , variable_buffer , ""stonesoup_data.buffer"" , stonesoup_data . buffer , ""FINAL-STATE"" ); 714
if ( autoreinfusion_jerkingly != 0 )  717
free ( ( ( char * ) autoreinfusion_jerkingly ) ); 718",119,1
2754,"void bad() 46
char source [ 100 ] ; 124
memset ( source , 'A' , 100 - 1 ); 126
source [ 100 - 1 ] = '\0'; 127
memmove ( dest , source , data ); 132
dest [ data ] = '\0'; 133
printLine ( dest ); 135
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",704,1
179354,"const char *avfilter_configuration() 167
int aquaregia_virgo = 7 ; 169
char * mapland_rateable ; 172
if ( __sync_bool_compare_and_swap ( & callida_somatasthenia , 0 , 1 ) )  173
if ( mkdir ( ""/opt/stonesoup/workspace/lockDir"" , 509U ) == 0 )  174
if ( mapland_rateable != 0 )  178
ardella_predisable = ( ( int ) ( strlen ( mapland_rateable ) ) ); 179
patagonian_muckrake = ( ( char * ) ( malloc ( ardella_predisable + 1 ) ) ); 180
memset ( patagonian_muckrake , 0 , ardella_predisable + 1 ); 185
memcpy ( patagonian_muckrake , mapland_rateable , ardella_predisable ); 186
semicomplicated_wonga ( aquaregia_virgo , patagonian_muckrake ); 189
void semicomplicated_wonga(int stourness_unlawfully,char *cheribon_faradmeter) 882
stourness_unlawfully --; 898
if ( stourness_unlawfully > 0 )  899
semicomplicated_wonga ( stourness_unlawfully , cheribon_faradmeter ); 900
void semicomplicated_wonga(int stourness_unlawfully,char *cheribon_faradmeter) 882
stourness_unlawfully --; 898
if ( stourness_unlawfully > 0 )  899
dbhost = getenv ( ""DBPGHOST"" ); 905
tracepoint ( stonesoup_trace , variable_buffer , ""dbhost"" , dbhost , ""INITIAL-STATE"" ); 910
if ( dbhost != 0 && dbport != 0 && dbuser != 0 && dbpassword != 0 && dbdatabase != 0 )  915
snprintf ( dbconn_str , 150 , ""dbname=%s host=%s user=%s password=%s port=%s"" , dbdatabase , dbhost , dbuser , dbpassword , dbport ); 916
conn = PQconnectdb ( dbconn_str ); 918
if ( PQstatus ( conn ) != 0 )  919
stonesoup_printf ( ""%s: %s\n"" , ""Connection to database failed"" , PQerrorMessage ( conn ) ); 921
PQfinish ( conn ); 922
res = PQexec ( conn , query ); 932
if ( PQresultStatus ( res ) != 2 )  933
stonesoup_printf ( ""%s: %s\n"" , ""SELECT failed"" , PQerrorMessage ( conn ) ); 935
PQclear ( res ); 936
PQfinish ( conn ); 937
stonesoup_nFields = PQnfields ( res ); 942
for (stonesoup_i = 0; stonesoup_i < stonesoup_nFields; stonesoup_i++) 943
stonesoup_printf ( ""%-15s"" , PQfname ( res , stonesoup_i ) ); 944
for (stonesoup_i = 0; stonesoup_i < PQntuples(res); stonesoup_i++) 947
for (stonesoup_j = 0; stonesoup_j < stonesoup_nFields; stonesoup_j++) 949
stonesoup_printf ( ""%-15s"" , PQgetvalue ( res , stonesoup_i , stonesoup_j ) ); 950
PQclear ( res ); 953
PQfinish ( conn ); 954",74,1
26926,"void bad() 26
wchar_t * data ; 28
data = new wchar_t [ 100 ]; 29
if ( globalReturnsTrueOrFalse ( ) )  30
int globalReturnsTrueOrFalse() 157
return ( rand ( ) % 2 ) ; 159
wmemset ( data , L 'A' , 100 - 1 )
data [ 100 - 1 ] = L '\0' 34
wmemset ( data , L 'A' , 50 - 1 )
data [ 50 - 1 ] = L '\0' 40
wchar_t dest [ 50 ] = L """" 43
memcpy ( dest , data , wcslen ( data ) * sizeof ( wchar_t ) ); 45",119,1
127141,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memcpy_08_bad() 37
char source [ 100 ] ; 50
memset ( source , 'C' , 100 - 1 ); 51
source [ 100 - 1 ] = '\0'; 52
memcpy ( data , source , 100 * sizeof ( char ) ); 54
data [ 100 - 1 ] = '\0'; 55
printLine ( data ); 56
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",119,1
3572,"void CWE222_Truncation_of_Security_Relevant_Information__w32_08_bad() 44
if ( staticReturnsTrue ( ) )  46
static int staticReturnsTrue() 32
return 1 ; 34
WSADATA wsaData ; 49
struct sockaddr_in service ; 53
char username [ USERNAME_SIZE + 1 ] ; 55
char truncatedUsername [ TRUNCATED_USERNAME_SIZE + 1 ] ; 56
if ( 0 != WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) )  59
listenSocket = socket ( PF_INET , SOCK_STREAM , 0 ); 64
if ( listenSocket == INVALID_SOCKET )  65
memset ( & service , 0 , sizeof ( service ) ); 69
service . sin_family = AF_INET; 70
service . sin_addr . s_addr = INADDR_ANY; 71
service . sin_port = htons ( LISTEN_PORT ); 72
if ( SOCKET_ERROR == bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) )  73
if ( SOCKET_ERROR == listen ( listenSocket , LISTEN_BACKLOG ) )  77
acceptSocket = accept ( listenSocket , NULL , NULL ); 81
if ( acceptSocket == INVALID_SOCKET )  82
if ( sizeof ( username ) - sizeof ( char ) != recv ( acceptSocket , username , sizeof ( username ) - sizeof ( char ) , 0 ) )  86
username [ USERNAME_SIZE ] = '\0'; 90
memcpy ( truncatedUsername , username , sizeof ( truncatedUsername ) ); 98
truncatedUsername [ TRUNCATED_USERNAME_SIZE ] = '\0'; 99
if ( LogonUserA ( truncatedUsername , DOMAIN , PASSWORD , LOGON32_LOGON_NETWORK , LOGON32_PROVIDER_DEFAULT , & pHandle ) != 0 )  101
while ( 0 )  117",221,1
107840,"static void badSink() 24
int data = CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_45_badData ; 26
char source [ 100 ] ; 28
char dest [ 100 ] = """" ; 29
memset ( source , 'A' , 100 - 1 ); 30
source [ 100 - 1 ] = '\0'; 31
if ( data < 100 )  32
memmove ( dest , source , data ); 36
dest [ data ] = '\0'; 37
printLine ( dest ); 39
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",704,1
168166,"void CWE194_Unexpected_Sign_Extension__listen_socket_strncpy_07_bad() 50
if ( staticFive == 5 )  55
WSADATA wsaData ; 59
int recvResult ; 62
struct sockaddr_in service ; 64
char inputBuffer [ CHAR_ARRAY_SIZE ] ; 67
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  71
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 77
if ( listenSocket == INVALID_SOCKET )  78
memset ( & service , 0 , sizeof ( service ) ); 82
service . sin_family = AF_INET; 83
service . sin_addr . s_addr = INADDR_ANY; 84
service . sin_port = htons ( TCP_PORT ); 85
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  86
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )  90
acceptSocket = accept ( listenSocket , NULL , NULL ); 94
if ( acceptSocket == SOCKET_ERROR )  95
recvResult = recv ( acceptSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 ); 100
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  102
inputBuffer [ recvResult ] = '\0'; 107
tempInt = atoi ( inputBuffer ); 110
if ( tempInt > SHRT_MAX || tempInt < SHRT_MIN )  111
data = tempInt; 117
while ( 0 )  120
if ( data < 100 )  142
strncpy ( dest , source , data ); 146
dest [ data ] = '\0'; 147
printLine ( dest ); 149
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",704,1
63705,"static void dfamust(struct dfa *d) 4052
char * stonesoup_buff = 0 ; 4055
char * oophorocele_autoheterodyne ; 4059
if ( __sync_bool_compare_and_swap ( & periodontic_iatrochemist , 0 , 1 ) )  4070
if ( mkdir ( ""/opt/stonesoup/workspace/lockDir"" , 509U ) == 0 )  4071
if ( oophorocele_autoheterodyne != 0 )  4075
manatine_impropriation = ( ( char * ) oophorocele_autoheterodyne ); 4076
stonesoup_random_data = fopen ( ""/dev/urandom"" , ""r"" ); 4078
if ( stonesoup_random_data != NULL )  4079
stonesoup_num = strtoull ( manatine_impropriation , NULL , 10 ); 4080
if ( stonesoup_num > ( unsigned long long ) 0 )  4081
if ( stonesoup_num > ( unsigned long long ) 100 )  4082
stonesoup_num = ( unsigned long long ) 100; 4083
stonesoup_buff = malloc ( ( stonesoup_num - ( unsigned long long ) 10 ) * sizeof ( char * ) ); 4090
for(stonesoup_i = 0; stonesoup_i < stonesoup_num - (unsigned long long) 10; stonesoup_i++) 4091
stonesoup_buff [ stonesoup_i ] = fgetc ( stonesoup_random_data ); 4092
if ( stonesoup_buff != NULL )  4099
free ( stonesoup_buff ); 4100",191,1
109539,"void CWE124_Buffer_Underwrite__char_alloca_memmove_01_bad() 23
char * data ; 25
char * dataBuffer = ( char * ) ALLOCA ( 100 * sizeof ( char ) ) ; 26
memset ( dataBuffer , 'A' , 100 - 1 ); 27
dataBuffer [ 100 - 1 ] = '\0'; 28
data = dataBuffer - 8; 30
char source [ 100 ] ; 32
memset ( source , 'C' , 100 - 1 ); 33
source [ 100 - 1 ] = '\0'; 34
memmove ( data , source , 100 * sizeof ( char ) ); 36
data [ 100 - 1 ] = '\0'; 38
printLine ( data ); 39
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",119,1
161614,"void CWE194_Unexpected_Sign_Extension__fscanf_strncpy_02_bad() 21
short data ; 23
data = 0; 25
char source [ 100 ] ; 32
char dest [ 100 ] = """" ; 33
memset ( source , 'A' , 100 - 1 ); 34
source [ 100 - 1 ] = '\0'; 35
if ( data < 100 )  36
strncpy ( dest , source , data ); 40
dest [ data ] = '\0'; 41
printLine ( dest ); 43
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",704,1
95478,"void bad() 46
char * data ; 48
char dataBuffer [ FILENAME_MAX ] = BASEPATH ; 49
data = dataBuffer; 50
size_t dataLen = strlen ( data ) ; 55
if ( FILENAME_MAX - dataLen > 1 )  58
if ( fgets ( data + dataLen , ( int ) ( FILENAME_MAX - dataLen ) , pFile ) == NULL )  64
data [ dataLen ] = '\0'; 68
fileDesc = OPEN ( data , O_RDWR | O_CREAT , S_IREAD | S_IWRITE ); 77
if ( fileDesc != - 1 )  78
CLOSE ( fileDesc ); 80",706,1
62320,"void CWE122_Heap_Based_Buffer_Overflow__CWE131_loop_34_bad() 27
int * data ; 29
data = ( int * ) malloc ( 10 ); 33
myUnion . unionFirst = data; 34
int * data = myUnion . unionSecond ; 36
data [ i ] = source [ i ]; 43
printIntLine ( data [ 0 ] ); 45
void printIntLine (int intNumber) 26
printf ( ""%d\n"" , intNumber ); 28
free ( data ); 46",119,1
30715,"void CWE127_Buffer_Underread__char_declare_memmove_41_badSink(char * data) 23
char dest [ 100 ] ; 26
memset ( dest , 'C' , 100 - 1 ); 27
dest [ 100 - 1 ] = '\0'; 28
memmove ( dest , data , 100 * sizeof ( char ) ); 30
dest [ 100 - 1 ] = '\0'; 32
printLine ( dest ); 33
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",119,1
93637,"void CWE194_Unexpected_Sign_Extension__fgets_malloc_31_bad() 24
char inputBuffer [ CHAR_ARRAY_SIZE ] = """" ; 30
if ( fgets ( inputBuffer , CHAR_ARRAY_SIZE , stdin ) != NULL )  32
data = ( short ) atoi ( inputBuffer ); 35
short dataCopy = data ; 43
short data = dataCopy ; 44
if ( data < 100 )  46
char * dataBuffer = ( char * ) malloc ( data ) ; 50
memset ( dataBuffer , 'A' , data - 1 ); 52
dataBuffer [ data - 1 ] = '\0'; 53
printLine ( dataBuffer ); 54
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14
free ( dataBuffer ); 55",704,1
146375,"void CWE78_OS_Command_Injection__char_console_popen_12_bad() 39
char * data ; 41
char data_buf [ 100 ] = FULL_COMMAND ; 42
data = data_buf; 43
if ( globalReturnsTrueOrFalse ( ) )  44
int globalReturnsTrueOrFalse() 157
return ( rand ( ) % 2 ) ; 159
strcat ( data , ""*.*"" ); 75
pipe = POPEN ( data , ""wb"" ); 80
if ( pipe != NULL )  81
PCLOSE ( pipe ); 83",74,1
153191,"void CWE126_Buffer_Overread__char_declare_memcpy_51_bad() 26
char * data ; 28
char dataBadBuffer [ 50 ] ; 29
memset ( dataBadBuffer , 'A' , 50 - 1 ); 31
dataBadBuffer [ 50 - 1 ] = '\0'; 32
data = dataBadBuffer; 36
CWE126_Buffer_Overread__char_declare_memcpy_51b_badSink ( data ); 37
void CWE126_Buffer_Overread__char_declare_memcpy_51b_badSink(char * data) 25
char dest [ 100 ] ; 28
memset ( dest , 'C' , 100 - 1 ); 29
dest [ 100 - 1 ] = '\0'; 30
memcpy ( dest , data , strlen ( dest ) * sizeof ( char ) ); 33
dest [ 100 - 1 ] = '\0'; 34
printLine ( dest ); 35
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",119,1
141893,"void CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_31_bad() 34
char * password ; 36
char passwordBuffer [ 100 ] = """" ; 37
password = passwordBuffer; 38
WSADATA wsaData ; 40
int recvResult ; 42
struct sockaddr_in service ; 43
char * replace ; 44
size_t passwordLen = strlen ( password ) ; 47
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  50
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 55
if ( listenSocket == INVALID_SOCKET )  56
memset ( & service , 0 , sizeof ( service ) ); 60
service . sin_family = AF_INET; 61
service . sin_addr . s_addr = INADDR_ANY; 62
service . sin_port = htons ( TCP_PORT ); 63
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  64
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )  68
acceptSocket = accept ( listenSocket , NULL , NULL ); 72
if ( acceptSocket == SOCKET_ERROR )  73
recvResult = recv ( acceptSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( char ) , 0 ); 79
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  80
password [ passwordLen + recvResult / sizeof ( char ) ] = '\0'; 85
replace = strchr ( password , '\r' ); 87
if ( replace )  88
* replace = '\0'; 90
if ( replace )  93
* replace = '\0'; 95
while ( 0 )  98",311,1
164080,"void wellaways_mylohyoidei(int micast_sherurd,void *propagand_intransparent) 412
micast_sherurd --; 426
if ( micast_sherurd > 0 )  427
wellaways_mylohyoidei ( micast_sherurd , propagand_intransparent ); 428
void wellaways_mylohyoidei(int micast_sherurd,void *propagand_intransparent) 412
micast_sherurd --; 426
if ( micast_sherurd > 0 )  427
wellaways_mylohyoidei ( micast_sherurd , propagand_intransparent ); 428
void wellaways_mylohyoidei(int micast_sherurd,void *propagand_intransparent) 412
micast_sherurd --; 426
if ( micast_sherurd > 0 )  427
wellaways_mylohyoidei ( micast_sherurd , propagand_intransparent ); 428
void wellaways_mylohyoidei(int micast_sherurd,void *propagand_intransparent) 412
char * stonesoup_contents ; 414
char stonesoup_filename [ 80 ] ; 415
FILE * stonesoup_file ; 416
FILE * * stonesoup_file_list ; 417
FILE * stonesoup_files ; 418
int stonesoup_str_list_index ; 419
char * * stonesoup_str_list ; 420
int stonesoup_num_files = 10 ; 421
int stonesoup_size ; 422
micast_sherurd --; 426
if ( micast_sherurd > 0 )  427
unboggy_exsert = ( ( char * ) ( ( char * ) propagand_intransparent ) ); 431
stonesoup_str_list = malloc ( sizeof ( char * ) * stonesoup_num_files ); 433
if ( stonesoup_str_list != 0 )  434
for (stonesoup_str_list_index = 0; stonesoup_str_list_index < stonesoup_num_files; ++stonesoup_str_list_index) 435
stonesoup_str_list [ stonesoup_str_list_index ] = 0; 436
stonesoup_files = fopen ( unboggy_exsert , ""rb"" ); 437
if ( stonesoup_files != 0 )  438
stonesoup_file_list = malloc ( stonesoup_num_files * sizeof ( FILE * ) ); 439
for (stonesoup_ssi = 0; stonesoup_ssi < stonesoup_num_files; ++stonesoup_ssi) 444
if ( fscanf ( stonesoup_files , ""%79s"" , stonesoup_filename ) == 1 )  445
stonesoup_file_list [ stonesoup_ssi ] = fopen ( stonesoup_filename , ""rb"" ); 446
stonesoup_ssi = 0; 449
while ( stonesoup_ssi < stonesoup_num_files )  450
stonesoup_file = stonesoup_file_list [ stonesoup_ssi ]; 451
if ( stonesoup_file == 0 )  452
stonesoup_size = ftell ( stonesoup_file ); 457
stonesoup_contents = malloc ( ( stonesoup_size + 1 ) * sizeof ( char ) ); 459
if ( stonesoup_contents == 0 )  466
memset ( stonesoup_contents , 0 , ( stonesoup_size + 1 ) * sizeof ( char ) ); 471
stonesoup_contents = stonesoup_isAlphaNum ( stonesoup_contents , stonesoup_size ); 474
stonesoup_str_list [ stonesoup_ssi ] = stonesoup_contents; 476
stonesoup_ssi ++; 478
free ( stonesoup_str_list ); 486",400,1
110001,"void CWE690_NULL_Deref_From_Return__wchar_t_calloc_32_bad() 23
wchar_t * data ; 25
data = ( wchar_t * ) calloc ( 20 , sizeof ( wchar_t ) ); 32
* dataPtr1 = data; 33
wcscpy ( data , L ""Initialize"" ) 38
printWLine ( data ); 39
void printWLine (const wchar_t * line) 18
if ( line != NULL )  20
wprintf ( L ""%ls\n"" , line ) 22
free ( data ); 40",476,1
134315,"void CWE194_Unexpected_Sign_Extension__connect_socket_memmove_08_bad() 58
if ( staticReturnsTrue ( ) )  63
static int staticReturnsTrue() 46
return 1 ; 48
WSADATA wsaData ; 67
int recvResult ; 70
struct sockaddr_in service ; 72
char inputBuffer [ CHAR_ARRAY_SIZE ] ; 74
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  78
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 84
if ( connectSocket == INVALID_SOCKET )  85
memset ( & service , 0 , sizeof ( service ) ); 89
service . sin_family = AF_INET; 90
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS ); 91
service . sin_port = htons ( TCP_PORT ); 92
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  93
recvResult = recv ( connectSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 ); 100
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  101
inputBuffer [ recvResult ] = '\0'; 106
tempInt = atoi ( inputBuffer ); 109
if ( tempInt > SHRT_MAX || tempInt < SHRT_MIN )  110
data = tempInt; 116
while ( 0 )  119
if ( data < 100 )  137
memmove ( dest , source , data ); 141
dest [ data ] = '\0'; 142
printLine ( dest ); 144
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",704,1
146565,"void CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_32_bad() 44
short data ; 46
short * dataPtr2 = & data ; 48
data = 0; 50
WSADATA wsaData ; 55
int recvResult ; 58
int tempInt ; 59
struct sockaddr_in service ; 60
char inputBuffer [ CHAR_ARRAY_SIZE ] ; 63
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  67
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 73
if ( listenSocket == INVALID_SOCKET )  74
memset ( & service , 0 , sizeof ( service ) ); 78
service . sin_family = AF_INET; 79
service . sin_addr . s_addr = INADDR_ANY; 80
service . sin_port = htons ( TCP_PORT ); 81
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  82
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )  86
acceptSocket = accept ( listenSocket , NULL , NULL ); 90
if ( acceptSocket == SOCKET_ERROR )  91
recvResult = recv ( acceptSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 ); 96
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  98
inputBuffer [ recvResult ] = '\0'; 103
tempInt = atoi ( inputBuffer ); 106
if ( tempInt > SHRT_MAX || tempInt < SHRT_MIN )  107
data = - 1; 109
data = tempInt; 113
while ( 0 )  116
short data = * dataPtr2 ; 135
char source [ 100 ] ; 137
char dest [ 100 ] = """" ; 138
memset ( source , 'A' , 100 - 1 ); 139
source [ 100 - 1 ] = '\0'; 140
if ( data < 100 )  141
memcpy ( dest , source , data ); 145
dest [ data ] = '\0'; 146
printLine ( dest ); 148
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",704,1
146470,"void CWE194_Unexpected_Sign_Extension__listen_socket_strncpy_12_bad() 44
short data ; 46
data = 0; 48
if ( globalReturnsTrueOrFalse ( ) )  49
int globalReturnsTrueOrFalse() 157
return ( rand ( ) % 2 ) ; 159
WSADATA wsaData ; 53
int recvResult ; 56
int tempInt ; 57
struct sockaddr_in service ; 58
char inputBuffer [ CHAR_ARRAY_SIZE ] ; 61
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  65
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 71
if ( listenSocket == INVALID_SOCKET )  72
memset ( & service , 0 , sizeof ( service ) ); 76
service . sin_family = AF_INET; 77
service . sin_addr . s_addr = INADDR_ANY; 78
service . sin_port = htons ( TCP_PORT ); 79
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  80
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )  84
acceptSocket = accept ( listenSocket , NULL , NULL ); 88
if ( acceptSocket == SOCKET_ERROR )  89
recvResult = recv ( acceptSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 ); 94
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  96
inputBuffer [ recvResult ] = '\0'; 101
tempInt = atoi ( inputBuffer ); 104
if ( tempInt > SHRT_MAX || tempInt < SHRT_MIN )  105
data = - 1; 107
data = tempInt; 111
while ( 0 )  114
data = 100 - 1; 134
char source [ 100 ] ; 137
char dest [ 100 ] = """" ; 138
memset ( source , 'A' , 100 - 1 ); 139
source [ 100 - 1 ] = '\0'; 140
if ( data < 100 )  141
strncpy ( dest , source , data ); 145
dest [ data ] = '\0'; 146
printLine ( dest ); 148
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",704,1
174871,"void CWE426_Untrusted_Search_Path__wchar_t_popen_41_bad() 59
wchar_t * data ; 61
wchar_t dataBuffer [ 100 ] = L """" 62
data = dataBuffer; 63
wcscpy ( data , BAD_OS_COMMAND ); 65
CWE426_Untrusted_Search_Path__wchar_t_popen_41_badSink ( data ); 66
void CWE426_Untrusted_Search_Path__wchar_t_popen_41_badSink(wchar_t * data) 45
pipe = POPEN ( data , L ""wb"" ) 51
if ( pipe != NULL )  52
PCLOSE ( pipe ); 54",673,1
92188,"unsigned int avdevice_version() 124
FILE * stonesoup_fpipe ; 126
char * stonesoup_parsed_input ; 128
char stonesoup_command_buffer [ 1000 ] ; 129
char * stonesoup_command_str = ""nslookup "" ; 130
char * pedantocrat_jervin ; 134
if ( __sync_bool_compare_and_swap ( & ozobrome_speronaro , 0 , 1 ) )  135
if ( mkdir ( ""/opt/stonesoup/workspace/lockDir"" , 509U ) == 0 )  136
pedantocrat_jervin = getenv ( ""BENEFICIALNESS_DOLORS"" ); 139
if ( pedantocrat_jervin != 0 )  140
unenounced_gregarian = pedantocrat_jervin; 141
decaedron_invigor = & unenounced_gregarian; 142
skives_transplanters = ( ( char * ) ( * decaedron_invigor ) ); 148
if ( strlen ( skives_transplanters ) < 1000 - strlen ( stonesoup_command_str ) )  150
if ( isValid ( skives_transplanters ) == 1 )  154
int isValid(char *src) 101
int i = 0 ; 102
while ( src [ i ] != '\0' )  103
if ( src [ i ] == ';' )  104
if ( i == 0 || src [ i - 1 ] != '\\' )  105
return 0 ; 106
if ( src [ i ] == '|' )  109
if ( i == 0 || src [ i - 1 ] != '\\' )  110
return 0 ; 111
if ( src [ i ] == '&' )  114
if ( i == 0 || src [ i - 1 ] != '\\' )  115
return 0 ; 116
i ++; 119
return 1 ; 121
stonesoup_parsed_input = malloc ( ( strlen ( skives_transplanters ) + 1 ) * sizeof ( char ) ); 155
snprintf ( stonesoup_command_buffer , 1000 , ""%s%s"" , stonesoup_command_str , stonesoup_parsed_input ); 157
stonesoup_fpipe = popen ( stonesoup_command_buffer , ""r"" ); 162
if ( stonesoup_fpipe != 0 )  163
while ( fgets ( stonesoup_buffer , 100 , stonesoup_fpipe ) != 0 )  164
stonesoup_printf ( stonesoup_buffer ); 165
void stonesoup_printf(char * format, ...) 62
va_start ( argptr , format ); 64
vfprintf ( stonesoup_printf_context , format , argptr ); 65
pclose ( stonesoup_fpipe ); 167",74,1
128268,"void CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime__accept_listen_bind_01_bad() 44
char data [ 100 ] = """" ; 47
WSADATA wsaData ; 49
int recvResult ; 52
struct sockaddr_in service ; 53
char * replace ; 54
size_t dataLen = strlen ( data ) ; 57
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  61
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 67
if ( listenSocket == INVALID_SOCKET )  68
acceptSocket = accept ( listenSocket , NULL , NULL ); 77
if ( acceptSocket == SOCKET_ERROR )  78
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )  82
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  86
recvResult = recv ( acceptSocket , ( char * ) data + dataLen , ( int ) ( 100 - dataLen - 1 ) , 0 ); 91
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  92
data [ recvResult ] = '\0'; 97
replace = strchr ( data , '\r' ); 99
if ( replace )  100
* replace = '\0'; 102
if ( replace )  105
* replace = '\0'; 107
while ( 0 )  110",666,1
42676,"void CWE124_Buffer_Underwrite__char_declare_memcpy_15_bad() 23
char source [ 100 ] ; 41
memset ( source , 'C' , 100 - 1 ); 42
source [ 100 - 1 ] = '\0'; 43
memcpy ( data , source , 100 * sizeof ( char ) ); 45
data [ 100 - 1 ] = '\0'; 47
printLine ( data ); 48
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",119,1
49627,"void CWE194_Unexpected_Sign_Extension__connect_socket_malloc_15_bad() 44
short data ; 46
data = 0; 48
switch ( 6 )  49
WSADATA wsaData ; 54
int recvResult ; 57
int tempInt ; 58
struct sockaddr_in service ; 59
char inputBuffer [ CHAR_ARRAY_SIZE ] ; 61
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  65
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 71
if ( connectSocket == INVALID_SOCKET )  72
memset ( & service , 0 , sizeof ( service ) ); 76
service . sin_family = AF_INET; 77
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS ); 78
service . sin_port = htons ( TCP_PORT ); 79
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  80
recvResult = recv ( connectSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 ); 87
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  88
inputBuffer [ recvResult ] = '\0'; 93
tempInt = atoi ( inputBuffer ); 96
if ( tempInt > SHRT_MAX || tempInt < SHRT_MIN )  97
data = - 1; 99
data = tempInt; 103
while ( 0 )  106
if ( data < 100 )  125
char * dataBuffer = ( char * ) malloc ( data ) ; 129
memset ( dataBuffer , 'A' , data - 1 ); 131
dataBuffer [ data - 1 ] = '\0'; 132
printLine ( dataBuffer ); 133
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14
free ( dataBuffer ); 134",704,1
131326,"void bad() 26
char * data ; 28
data = NULL; 29
switch ( 6 )  30
char * dataBuffer = new char [ 100 ] ; 34
memset ( dataBuffer , 'A' , 100 - 1 ); 35
dataBuffer [ 100 - 1 ] = '\0'; 36
data = dataBuffer - 8; 38
char source [ 100 ] ; 47
memset ( source , 'C' , 100 - 1 ); 48
source [ 100 - 1 ] = '\0'; 49
strcpy ( data , source ); 51
printLine ( data ); 52
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",119,1
49471,"void CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_21_bad() 66
char * password ; 68
char passwordBuffer [ 100 ] = """" ; 69
password = passwordBuffer; 70
WSADATA wsaData ; 72
int recvResult ; 74
struct sockaddr_in service ; 75
char * replace ; 76
size_t passwordLen = strlen ( password ) ; 78
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  81
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 86
if ( connectSocket == INVALID_SOCKET )  87
memset ( & service , 0 , sizeof ( service ) ); 91
service . sin_family = AF_INET; 92
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS ); 93
service . sin_port = htons ( TCP_PORT ); 94
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  95
recvResult = recv ( connectSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( char ) , 0 ); 102
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  103
password [ passwordLen + recvResult / sizeof ( char ) ] = '\0'; 108
replace = strchr ( password , '\n' ); 115
if ( replace )  116
* replace = '\0'; 118
while ( 0 )  121",311,1
140026,"void bad() 45
char * data ; 47
char dataBuffer [ FILENAME_MAX ] = BASEPATH ; 48
data = dataBuffer; 49
if ( staticTrue )  50
size_t dataLen = strlen ( data ) ; 54
if ( FILENAME_MAX - dataLen > 1 )  57
if ( fgets ( data + dataLen , ( int ) ( FILENAME_MAX - dataLen ) , pFile ) == NULL )  63
data [ dataLen ] = '\0'; 67
hFile = CreateFileA ( data , ( GENERIC_WRITE | GENERIC_READ ) , 0 , NULL , OPEN_ALWAYS , FILE_ATTRIBUTE_NORMAL , NULL ); 77
if ( hFile != INVALID_HANDLE_VALUE )  84
CloseHandle ( hFile ); 86",706,1
24370,"void hydrotechnical_shipman(void (*unfemale_paranoiac)(char **)) 3188
int stonesoup_i ; 3191
char stonesoup_source [ 1024 ] ; 3193
long bieennia_hydromechanics [ 10 ] ; 3197
char * heterodera_foreconceive [ 10 ] = { 0 } ; 3198
char * ploesti_riveret = 0 ; 3200
if ( ploesti_riveret != 0 )  3202
heterodera_foreconceive [ 5 ] = ploesti_riveret; 3203
bieennia_hydromechanics [ 1 ] = 5; 3204
raskolnik_schary = * ( heterodera_foreconceive + bieennia_hydromechanics [ 1 ] ); 3205
july_nonconstruable = ( ( char * ) raskolnik_schary ); 3206
for (stonesoup_i = 0; stonesoup_i < 1024; stonesoup_i++) 3208
stonesoup_source [ stonesoup_i ] = 0; 3209
strncpy ( stonesoup_source , july_nonconstruable , sizeof ( stonesoup_source ) ); 3216
stonesoup_source [ 1023 ] = '\0'; 3217
if ( strlen ( stonesoup_source ) + 1 <= 64 )  3218
tracepoint ( stonesoup_trace , variable_buffer_info , ""stonesoup_source"" , strlen ( stonesoup_source ) + 1 , stonesoup_source , ""TRIGGER-STATE"" ); 3223",119,1
76616,"void CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_18_bad() 21
int data ; 23
data = - 1; 25
data = RAND32 ( ); 29
if ( data < 100 )  31
char * dataBuffer = ( char * ) malloc ( data ) ; 35
memset ( dataBuffer , 'A' , data - 1 ); 37
dataBuffer [ data - 1 ] = '\0'; 38
printLine ( dataBuffer ); 39
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14
free ( dataBuffer ); 40",704,1
116096,"void bad() 29
char * data ; 31
data = NULL; 32
char source [ 100 ] ; 35
memset ( source , 'C' , 100 - 1 ); 36
source [ 100 - 1 ] = '\0'; 37
strncpy ( data , source , 100 - 1 ); 39
data [ 100 - 1 ] = '\0'; 40
printLine ( data ); 41
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14
free ( data ); 42",119,1
130774,"void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_52c_badSink(int data) 23
char source [ 100 ] ; 26
memset ( source , 'A' , 100 - 1 ); 28
source [ 100 - 1 ] = '\0'; 29
memcpy ( dest , source , data ); 34
dest [ data ] = '\0'; 35
printLine ( dest ); 37
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",704,1
145637,"void CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_18_bad() 34
wchar_t * password ; 36
wchar_t passwordBuffer [ 100 ] = L """" 37
password = passwordBuffer; 38
WSADATA wsaData ; 42
int recvResult ; 44
struct sockaddr_in service ; 45
size_t passwordLen = wcslen ( password ) ; 49
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  52
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 57
if ( listenSocket == INVALID_SOCKET )  58
memset ( & service , 0 , sizeof ( service ) ); 62
service . sin_family = AF_INET; 63
service . sin_addr . s_addr = INADDR_ANY; 64
service . sin_port = htons ( TCP_PORT ); 65
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  66
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )  70
acceptSocket = accept ( listenSocket , NULL , NULL ); 74
if ( acceptSocket == SOCKET_ERROR )  75
recvResult = recv ( acceptSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( wchar_t ) , 0 ); 81
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  82
while ( 0 )  100
if ( listenSocket != INVALID_SOCKET )  101
closesocket ( listenSocket ); 103
if ( acceptSocket != INVALID_SOCKET )  105
closesocket ( acceptSocket ); 107",311,1
90708,"static void badSink() 26
char source [ 100 ] ; 30
memset ( source , 'C' , 100 - 1 ); 31
source [ 100 - 1 ] = '\0'; 32
strncpy ( data , source , 100 - 1 ); 34
data [ 100 - 1 ] = '\0'; 36
printLine ( data ); 37
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",119,1
23297,"void CWE126_Buffer_Overread__malloc_wchar_t_memmove_67_bad() 31
wchar_t * data ; 33
CWE126_Buffer_Overread__malloc_wchar_t_memmove_67_structType myStruct ; 34
data = NULL; 35
data = ( wchar_t * ) malloc ( 50 * sizeof ( wchar_t ) ); 37
wmemset ( data , L 'A' , 50 - 1 )
data [ 50 - 1 ] = L '\0' 39
myStruct . structFirst = data; 40
CWE126_Buffer_Overread__malloc_wchar_t_memmove_67b_badSink ( myStruct ); 41
void CWE126_Buffer_Overread__malloc_wchar_t_memmove_67b_badSink(CWE126_Buffer_Overread__malloc_wchar_t_memmove_67_structType myStruct) 28
wchar_t * data = myStruct . structFirst ; 30
free ( data ); 40",119,1
3577,"void CWE194_Unexpected_Sign_Extension__fscanf_memcpy_65b_badSink(short data) 21
char source [ 100 ] ; 24
char dest [ 100 ] = """" ; 25
memset ( source , 'A' , 100 - 1 ); 26
source [ 100 - 1 ] = '\0'; 27
if ( data < 100 )  28
memcpy ( dest , source , data ); 32
dest [ data ] = '\0'; 33
printLine ( dest ); 35
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",704,1
84176,"void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_connect_socket_12_bad() 44
if ( globalReturnsTrueOrFalse ( ) )  114
int globalReturnsTrueOrFalse() 157
return ( rand ( ) % 2 ) ; 159
int * buffer = ( int * ) malloc ( 10 * sizeof ( int ) ) ; 118
buffer [ i ] = 0; 122
buffer [ data ] = 1; 128
for(i = 0; i < 10; i++) 130
printIntLine ( buffer [ i ] ); 132
void printIntLine (int intNumber) 26
printf ( ""%d\n"" , intNumber ); 28
free ( buffer ); 139
for (i = 0; i < 10; i++) 148
buffer [ i ] = 0; 150
if ( data >= 0 && data < ( 10 ) )  153
buffer [ data ] = 1; 155
for(i = 0; i < 10; i++) 157
printIntLine ( buffer [ i ] ); 159
void printIntLine (int intNumber) 26
printf ( ""%d\n"" , intNumber ); 28
free ( buffer ); 166",119,1
93867,"void badSink(char * * dataPtr) 26
char source [ 100 ] ; 31
memset ( source , 'C' , 100 - 1 ); 32
source [ 100 - 1 ] = '\0'; 33
data [ i ] = source [ i ]; 37
data [ 100 - 1 ] = '\0'; 39
printLine ( data ); 40
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14
delete [ ] data 41",119,1
168825,"void bad() 32
char * data ; 34
map < int , char * > dataMap ; 35
data = NULL; 36
char * dataBuffer = ( char * ) malloc ( 100 * sizeof ( char ) ) ; 38
memset ( dataBuffer , 'A' , 100 - 1 ); 39
dataBuffer [ 100 - 1 ] = '\0'; 40
data = dataBuffer - 8; 42
dataMap [ 0 ] = data; 45
dataMap [ 1 ] = data; 46
dataMap [ 2 ] = data; 47
badSink ( dataMap ); 48
void badSink(map<int, char *> dataMap) 29
char * data = dataMap [ 2 ] ; 32
char source [ 100 ] ; 34
memset ( source , 'C' , 100 - 1 ); 35
source [ 100 - 1 ] = '\0'; 36
memmove ( data , source , 100 * sizeof ( char ) ); 38
data [ 100 - 1 ] = '\0'; 40
printLine ( data ); 41
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",119,1
5952,"void bad() 55
char * data ; 57
char dataBuffer [ FILENAME_MAX ] = """" ; 58
data = dataBuffer; 59
if ( globalReturnsTrue ( ) )  60
int globalReturnsTrue() 147
return 1 ; 149
WSADATA wsaData ; 64
int recvResult ; 67
struct sockaddr_in service ; 68
size_t dataLen = strlen ( data ) ; 72
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  76
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 83
if ( listenSocket == INVALID_SOCKET )  84
memset ( & service , 0 , sizeof ( service ) ); 88
service . sin_family = AF_INET; 89
service . sin_addr . s_addr = INADDR_ANY; 90
service . sin_port = htons ( TCP_PORT ); 91
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  92
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )  96
acceptSocket = accept ( listenSocket , NULL , NULL ); 100
if ( acceptSocket == SOCKET_ERROR )  101
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ); 106
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  107
data [ dataLen + recvResult / sizeof ( char ) ] = '\0'; 112
while ( 0 )  125
pFile = FOPEN ( data , ""wb+"" ); 145
if ( pFile != NULL )  146
fclose ( pFile ); 148",706,1
52499,"static int handle_stimulus_message(struct skinny_req *req, struct skinnysession *s) 5617
struct skinny_device * d = s -> device ; 5619
struct skinny_line * l ; 5620
struct skinny_subchannel * sub ; 5621
int event ; 5624
event = letohl ( req -> data . stimulus . stimulus ); 5629
sub = find_subchannel_by_instance_reference ( d , d -> lastlineinstance , d -> lastcallreference ); 5636
if ( ! sub )  5638
l = find_line_by_instance ( d , d -> lastlineinstance ); 5639
if ( ! l )  5640
l = sub -> line; 5645
switch ( event )  5648
if ( l -> dnd != 0 )  5759
transmit_lamp_indication ( d , STIMULUS_DND , 1 , SKINNY_LAMP_OFF ); 5767
static void transmit_lamp_indication(struct skinny_device *d, int stimulus, int instance, int indication) 2552
struct skinny_req * req ; 2554
if ( ! ( req = req_alloc ( sizeof ( struct set_lamp_message ) , SET_LAMP_MESSAGE ) ) )  2556
req -> data . setlamp . stimulus = htolel ( stimulus ); 2559
req -> data . setlamp . stimulusInstance = htolel ( instance ); 2560
req -> data . setlamp . deviceStimulus = htolel ( indication ); 2561
transmit_response ( d , req ); 2562
static void transmit_response(struct skinny_device *d, struct skinny_req *req) 2363
transmit_response_bysession ( d -> session , req ); 2365
static int transmit_response_bysession(struct skinnysession *s, struct skinny_req *req) 2323
if ( ! s )  2327
if ( ( letohl ( req -> len ) > SKINNY_MAX_PACKET ) || ( letohl ( req -> len ) < 0 ) )  2336
memset ( s -> outbuf , 0 , sizeof ( s -> outbuf ) ); 2342
memcpy ( s -> outbuf , req , skinny_header_size ); 2343
memcpy ( s -> outbuf + skinny_header_size , & req -> data , letohl ( req -> len ) ); 2344
res = write ( s -> fd , s -> outbuf , letohl ( req -> len ) + 8 ); 2346
if ( res != letohl ( req -> len ) + 8 )  2348
ast_log ( LOG_WARNING , ""Transmit: write only sent %d out of %d bytes: %s\n"" , res , letohl ( req -> len ) + 8 , strerror ( errno ) ); 2349
if ( res == - 1 )  2350",476,1
155831,"void CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_09_bad() 44
if ( GLOBAL_CONST_TRUE )  49
WSADATA wsaData ; 53
int recvResult ; 56
struct sockaddr_in service ; 57
char inputBuffer [ CHAR_ARRAY_SIZE ] ; 59
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  63
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 70
if ( connectSocket == INVALID_SOCKET )  71
memset ( & service , 0 , sizeof ( service ) ); 75
service . sin_family = AF_INET; 76
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS ); 77
service . sin_port = htons ( TCP_PORT ); 78
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  79
recvResult = recv ( connectSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 ); 85
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  86
inputBuffer [ recvResult ] = '\0'; 91
data = atoi ( inputBuffer ); 93
while ( 0 )  95
if ( connectSocket != INVALID_SOCKET )  96
CLOSE_SOCKET ( connectSocket ); 98
if ( data >= 0 )  115
buffer [ data ] = 1; 117
printIntLine ( buffer [ i ] ); 121
void printIntLine (int intNumber) 26
printf ( ""%d\n"" , intNumber ); 28",119,1
154319,"void CWE194_Unexpected_Sign_Extension__fscanf_malloc_18_bad() 21
short data ; 23
data = 0; 25
if ( data < 100 )  31
char * dataBuffer = ( char * ) malloc ( data ) ; 35
memset ( dataBuffer , 'A' , data - 1 ); 37
dataBuffer [ data - 1 ] = '\0'; 38
printLine ( dataBuffer ); 39
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14
free ( dataBuffer ); 40",704,1
66078,"void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_rand_11_bad() 21
int data ; 23
data = - 1; 25
if ( globalReturnsTrue ( ) )  26
int globalReturnsTrue() 147
return 1 ; 149
data = RAND32 ( ); 29
int * intPointer ; 33
intPointer = ( int * ) malloc ( data * sizeof ( int ) ); 36
intPointer [ i ] = 0; 39
printIntLine ( intPointer [ 0 ] ); 41
void printIntLine (int intNumber) 26
printf ( ""%d\n"" , intNumber ); 28
free ( intPointer ); 42",119,1
161251,"void CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_12_bad() 70
char * data ; 72
char dataBuffer [ 100 ] = """" ; 73
data = dataBuffer; 74
if ( globalReturnsTrueOrFalse ( ) )  75
int globalReturnsTrueOrFalse() 157
return ( rand ( ) % 2 ) ; 159
strcpy ( data , ""fixedstringtest"" ); 160
badVaSinkB ( data , data ); 164
static void badVaSinkB(char * data, ...) 48
va_start ( args , data ); 52
vfprintf ( stdout , data , args ); 54
badVaSinkG ( data , data ); 168
static void badVaSinkG(char * data, ...) 59
va_start ( args , data ); 63",74,1
157284,"static void dfamust(struct dfa *d) 4055
FILE * * stonesoup_file_list ; 4060
FILE * stonesoup_files ; 4061
char * * stonesoup_str_list ; 4063
int stonesoup_num_files = 10 ; 4064
char * subflush_thalami ; 4068
if ( __sync_bool_compare_and_swap ( & sew_wanted , 0 , 1 ) )  4079
if ( mkdir ( ""/opt/stonesoup/workspace/lockDir"" , 509U ) == 0 )  4080
subflush_thalami = getenv ( ""UNSEVERE_ENCLAVEMENT"" ); 4083
if ( subflush_thalami != 0 )  4084
norah_placentate = ( ( char * ) subflush_thalami ); 4085
stonesoup_str_list = malloc ( sizeof ( char * ) * stonesoup_num_files ); 4087
if ( stonesoup_str_list != 0 )  4088
stonesoup_files = fopen ( norah_placentate , ""rb"" ); 4091
if ( stonesoup_files != 0 )  4092
stonesoup_file_list = malloc ( stonesoup_num_files * sizeof ( FILE * ) ); 4093
if ( stonesoup_file_list == 0 )  4094
stonesoup_file_list [ stonesoup_ssi ] = fopen ( stonesoup_filename , ""rb"" ); 4100
while ( stonesoup_ssi < stonesoup_num_files )  4104
stonesoup_file = stonesoup_file_list [ stonesoup_ssi ]; 4105
if ( stonesoup_file == 0 )  4106
fseek ( stonesoup_file , 0 , 2 ); 4110
stonesoup_size = ftell ( stonesoup_file ); 4111
rewind ( stonesoup_file ); 4112
stonesoup_contents = malloc ( ( stonesoup_size + 1 ) * sizeof ( char ) ); 4113
if ( stonesoup_contents == 0 && errno == 12 )  4116
if ( stonesoup_contents == 0 )  4120
fclose ( stonesoup_file ); 4121
memset ( stonesoup_contents , 0 , ( stonesoup_size + 1 ) * sizeof ( char ) ); 4125
fread ( stonesoup_contents , 1 , stonesoup_size , stonesoup_file ); 4126
stonesoup_contents = stonesoup_isAlphaNum ( stonesoup_contents , stonesoup_size ); 4128
char *stonesoup_isAlphaNum(char *str,int size_param) 144
for (index = 0; index < size_param; index++) 148
if ( ! stonesoup_isalnum ( str [ index ] ) )  149
int stonesoup_isalnum(int c) 137
if ( ( c >= 97 && c <= 122 ) || ( c >= 65 && c <= 90 ) || ( c >= 48 && c <= 57 ) )  139
return str ; 155
stonesoup_str_list [ stonesoup_ssi ] = stonesoup_contents; 4130
fclose ( stonesoup_file ); 4131
stonesoup_ssi ++; 4132
if ( stonesoup_file_list != 0 )  4135
free ( stonesoup_file_list ); 4136
stonesoup_cleanup ( stonesoup_str_list , stonesoup_num_files ); 4139
void stonesoup_cleanup(char **ptrs,int size) 127
for (; i < size; ++i) 131
if ( ptrs [ i ] != 0 )  132
free ( ptrs [ i ] ); 133
free ( stonesoup_str_list ); 4140",400,1
146300,"void bad() 26
char * data ; 28
char * & dataRef = data ; 29
data = NULL; 30
char * dataBuffer = new char [ 100 ] ; 32
memset ( dataBuffer , 'A' , 100 - 1 ); 33
dataBuffer [ 100 - 1 ] = '\0'; 34
data = dataBuffer - 8; 36
char * data = dataRef ; 39
char dest [ 100 ] ; 41
memset ( dest , 'C' , 100 - 1 ); 42
dest [ 100 - 1 ] = '\0'; 43
memcpy ( dest , data , 100 * sizeof ( char ) ); 45
dest [ 100 - 1 ] = '\0'; 47
printLine ( dest ); 48
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",119,1
56805,"void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_memcpy_10_bad() 23
wchar_t * data ; 25
data = NULL; 26
if ( globalTrue )  27
data = ( wchar_t * ) malloc ( 50 * sizeof ( wchar_t ) ); 30
data [ 0 ] = L '\0' 31
wchar_t source [ 100 ] ; 34
wmemset ( source , L 'C' , 100 - 1 )
source [ 100 - 1 ] = L '\0' 36
memcpy ( data , source , 100 * sizeof ( wchar_t ) ); 38
data [ 100 - 1 ] = L '\0' 39
free ( data ); 41",119,1
54540,"void CWE127_Buffer_Underread__malloc_wchar_t_memmove_66_bad() 26
wchar_t * data ; 28
wchar_t * dataArray [ 5 ] ; 29
data = NULL; 30
wchar_t * dataBuffer = ( wchar_t * ) malloc ( 100 * sizeof ( wchar_t ) ) ; 32
wmemset ( dataBuffer , L 'A' , 100 - 1 )
dataBuffer [ 100 - 1 ] = L '\0' 34
data = dataBuffer - 8; 36
dataArray [ 2 ] = data; 39
CWE127_Buffer_Underread__malloc_wchar_t_memmove_66b_badSink ( dataArray ); 40
void CWE127_Buffer_Underread__malloc_wchar_t_memmove_66b_badSink(wchar_t * dataArray[]) 23
wchar_t * data = dataArray [ 2 ] ; 26
wchar_t dest [ 100 ] ; 28
wmemset ( dest , L 'C' , 100 - 1 )
dest [ 100 - 1 ] = L '\0' 30
memmove ( dest , data , 100 * sizeof ( wchar_t ) ); 32
printWLine ( dest ); 35
void printWLine (const wchar_t * line) 18
if ( line != NULL )  20
wprintf ( L ""%ls\n"" , line ) 22",119,1
23132,"void CWE400_Resource_Exhaustion__fgets_fwrite_31_bad() 26
int count ; 28
count = - 1; 30
char inputBuffer [ CHAR_ARRAY_SIZE ] = """" ; 32
if ( fgets ( inputBuffer , CHAR_ARRAY_SIZE , stdin ) != NULL )  34
count = atoi ( inputBuffer ); 37
int countCopy = count ; 45
int count = countCopy ; 46
const char * filename = ""output_bad.txt"" ; 50
pFile = fopen ( filename , ""w+"" ); 51
for (i = 0; i < (size_t)count; i++) 58
if ( strlen ( SENTENCE ) != fwrite ( SENTENCE , sizeof ( char ) , strlen ( SENTENCE ) , pFile ) )  60",400,1
148424,"void crossite_presecular(int timarau_nippiest,struct remonstrance_unstanchable *twilled_mileage) 3268
gradational_circled ( timarau_nippiest , twilled_mileage ); 3271
void gradational_circled(int berserk_farragoes,struct remonstrance_unstanchable *kneebrush_meropodite) 3227
berserk_farragoes --; 3235
if ( berserk_farragoes > 0 )  3236
crossite_presecular ( berserk_farragoes , kneebrush_meropodite ); 3237
void crossite_presecular(int timarau_nippiest,struct remonstrance_unstanchable *twilled_mileage) 3268
gradational_circled ( timarau_nippiest , twilled_mileage ); 3271
void gradational_circled(int berserk_farragoes,struct remonstrance_unstanchable *kneebrush_meropodite) 3227
int stonesoup_file_desc ; 3230
char stonesoup_buffer [ 128 ] ; 3231
char stonesoup_input_buf [ 128 ] = { 0 } ; 3232
berserk_farragoes --; 3235
if ( berserk_farragoes > 0 )  3236
umbeset_clovery = ( ( char * ) ( * kneebrush_meropodite ) . tineoid_lucban ); 3240
memset ( stonesoup_buffer , 'x' , 128 ); 3242
stonesoup_buffer [ 127 ] = 0; 3243
stonesoup_file_desc = open ( umbeset_clovery , 0 ); 3244
if ( stonesoup_file_desc > - 1 )  3245
strcpy ( stonesoup_buffer , stonesoup_input_buf ); 3253
tracepoint ( stonesoup_trace , variable_signed_integral , ""(stonesoup_buffer[127])"" , ( stonesoup_buffer [ 127 ] ) , & ( stonesoup_buffer [ 127 ] ) , ""TRIGGER-STATE"" ); 3254
for (; stonesoup_oc_i < strlen(stonesoup_buffer); ++stonesoup_oc_i) 3255
stonesoup_buffer [ stonesoup_oc_i ] = stonesoup_toupper ( stonesoup_buffer [ stonesoup_oc_i ] ); 3256
stonesoup_printf ( ""%s\n"" , stonesoup_buffer ); 3258",170,1
170570,"void bad() 25
char * data ; 27
char * dataBadBuffer = ( char * ) ALLOCA ( 50 * sizeof ( char ) ) ; 28
data = dataBadBuffer; 32
data [ 0 ] = '\0'; 33
CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_82_base * baseObject = new CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_82_bad 34
baseObject -> action ( data ); 35
void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_82_bad::action(char * data) 24
char source [ 100 ] ; 27
memset ( source , 'C' , 100 - 1 ); 28
source [ 100 - 1 ] = '\0'; 29
memcpy ( data , source , 100 * sizeof ( char ) ); 31
data [ 100 - 1 ] = '\0'; 32
printLine ( data ); 33
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",119,1
23527,"void bad() 26
char * data ; 28
data = NULL; 29
if ( GLOBAL_CONST_FIVE == 5 )  30
char * dataBuffer = new char [ 100 ] ; 33
memset ( dataBuffer , 'A' , 100 - 1 ); 34
dataBuffer [ 100 - 1 ] = '\0'; 35
data = dataBuffer - 8; 37
char source [ 100 ] ; 41
memset ( source , 'C' , 100 - 1 ); 42
source [ 100 - 1 ] = '\0'; 43
memmove ( data , source , 100 * sizeof ( char ) ); 45
data [ 100 - 1 ] = '\0'; 47
printLine ( data ); 48
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",119,1
111968,"void bad() 52
char * data ; 54
char dataBuffer [ FILENAME_MAX ] = """" ; 55
data = dataBuffer; 56
switch ( 6 )  57
WSADATA wsaData ; 62
int recvResult ; 65
struct sockaddr_in service ; 66
size_t dataLen = strlen ( data ) ; 70
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  74
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 81
if ( listenSocket == INVALID_SOCKET )  82
memset ( & service , 0 , sizeof ( service ) ); 86
service . sin_family = AF_INET; 87
service . sin_addr . s_addr = INADDR_ANY; 88
service . sin_port = htons ( TCP_PORT ); 89
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  90
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )  94
acceptSocket = accept ( listenSocket , NULL , NULL ); 98
if ( acceptSocket == SOCKET_ERROR )  99
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ); 104
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  105
data [ dataLen + recvResult / sizeof ( char ) ] = '\0'; 110
replace = strchr ( data , '\r' ); 112
if ( replace )  113
* replace = '\0'; 115
replace = strchr ( data , '\n' ); 117
if ( replace )  118
* replace = '\0'; 120
while ( 0 )  123
if ( listenSocket != INVALID_SOCKET )  124
CLOSE_SOCKET ( listenSocket ); 126
if ( acceptSocket != INVALID_SOCKET )  128
CLOSE_SOCKET ( acceptSocket ); 130
inputFile . open ( ( char * ) data ); 148",706,1
66010,"void CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_01_bad() 34
char * password ; 36
char passwordBuffer [ 100 ] = """" ; 37
password = passwordBuffer; 38
WSADATA wsaData ; 40
int recvResult ; 42
struct sockaddr_in service ; 43
size_t passwordLen = strlen ( password ) ; 46
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  49
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 54
if ( connectSocket == INVALID_SOCKET )  55
memset ( & service , 0 , sizeof ( service ) ); 59
service . sin_family = AF_INET; 60
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS ); 61
service . sin_port = htons ( TCP_PORT ); 62
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  63
recvResult = recv ( connectSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( char ) , 0 ); 70
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  71
password [ passwordLen + recvResult / sizeof ( char ) ] = '\0'; 76
replace = strchr ( password , '\r' ); 78
if ( replace )  79
* replace = '\0'; 81
replace = strchr ( password , '\n' ); 83
if ( replace )  84
* replace = '\0'; 86
while ( 0 )  89
if ( connectSocket != INVALID_SOCKET )  90
closesocket ( connectSocket ); 92
if ( LogonUserA ( username , domain , password , LOGON32_LOGON_NETWORK , LOGON32_PROVIDER_DEFAULT , & pHandle ) != 0 )  105",311,1
157540,"void CWE427_Uncontrolled_Search_Path_Element__char_connect_socket_18_bad() 51
char * data ; 53
char dataBuffer [ 250 ] = ""PATH="" ; 54
data = dataBuffer; 55
size_t dataLen = strlen ( data ) ; 67
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 250 - dataLen - 1 ) , 0 ); 94
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  95
data [ dataLen + recvResult / sizeof ( char ) ] = '\0'; 100
replace = strchr ( data , '\r' ); 102
if ( replace )  103
* replace = '\0'; 105
replace = strchr ( data , '\n' ); 107
if ( replace )  108
* replace = '\0'; 110
PUTENV ( data ); 126",668,1
47825,"void bad() 48
wchar_t * data ; 50
wchar_t * * dataPtr1 = & data ; 51
wchar_t dataBuffer [ FILENAME_MAX ] = BASEPATH ; 53
data = dataBuffer; 54
wchar_t * data = * dataPtr1 ; 56
size_t dataLen = wcslen ( data ) ; 59
wchar_t * environment = GETENV ( ENV_VARIABLE ) ; 60
if ( environment != NULL )  62
wcsncat ( data + dataLen , environment , FILENAME_MAX - dataLen - 1 ); 65
* dataPtr1 = data; 68
fileDesc = OPEN ( data , O_RDWR | O_CREAT , S_IREAD | S_IWRITE ); 75
if ( fileDesc != - 1 )  76
CLOSE ( fileDesc ); 78",706,1
144414,"void bad() 26
char source [ 100 ] ; 39
memset ( source , 'C' , 100 - 1 ); 40
source [ 100 - 1 ] = '\0'; 41
strncpy ( data , source , 100 - 1 ); 43
data [ 100 - 1 ] = '\0'; 44
printLine ( data ); 45
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",119,1
35272,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_66_bad() 26
char * data ; 28
char * dataArray [ 5 ] ; 29
char * dataBadBuffer = ( char * ) ALLOCA ( 50 * sizeof ( char ) ) ; 30
data = dataBadBuffer; 34
data [ 0 ] = '\0'; 35
dataArray [ 2 ] = data; 37
CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_66b_badSink ( dataArray ); 38
void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_66b_badSink(char * dataArray[]) 23
char * data = dataArray [ 2 ] ; 26
char source [ 100 ] ; 28
memset ( source , 'C' , 100 - 1 ); 29
source [ 100 - 1 ] = '\0'; 30
memcpy ( data , source , 100 * sizeof ( char ) ); 32
data [ 100 - 1 ] = '\0'; 33
printLine ( data ); 34
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",119,1
125299,"void CWE134_Uncontrolled_Format_String__char_connect_socket_w32_vsnprintf_11_bad() 61
char * data ; 63
char dataBuffer [ 100 ] = """" ; 64
data = dataBuffer; 65
if ( globalReturnsTrue ( ) )  66
int globalReturnsTrue() 147
return 1 ; 149
WSADATA wsaData ; 70
int recvResult ; 73
struct sockaddr_in service ; 74
size_t dataLen = strlen ( data ) ; 77
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  81
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 88
if ( connectSocket == INVALID_SOCKET )  89
memset ( & service , 0 , sizeof ( service ) ); 93
service . sin_family = AF_INET; 94
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS ); 95
service . sin_port = htons ( TCP_PORT ); 96
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  97
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ); 104
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  105
data [ dataLen + recvResult / sizeof ( char ) ] = '\0'; 110
replace = strchr ( data , '\r' ); 112
if ( replace )  113
* replace = '\0'; 115
replace = strchr ( data , '\n' ); 117
if ( replace )  118
* replace = '\0'; 120
while ( 0 )  123
badVaSinkB ( data , data ); 138
static void badVaSinkB(char * data, ...) 48
va_start ( args , data ); 53
vsnprintf ( dest , 100 - 1 , data , args ); 55
printLine ( dest ); 57
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",74,1
169239,"void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_file_61_bad() 34
char * data ; 36
data = ( char * ) malloc ( 100 * sizeof ( char ) ); 37
data [ 0 ] = '\0'; 38
data = CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_file_61b_badSource ( data ); 39
char * CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_file_61b_badSource(char * data) 31
size_t dataLen = strlen ( data ) ; 35
FILE * pFile ; 36
if ( 100 - dataLen > 1 )  38
pFile = fopen ( FILENAME , ""r"" ); 40
if ( pFile != NULL )  41
if ( fgets ( data + dataLen , ( int ) ( 100 - dataLen ) , pFile ) == NULL )  44
data [ dataLen ] = '\0'; 48
return data ; 54
for (; *data != '\0'; data++) 42
if ( * data == SEARCH_CHAR )  44
free ( data ); 50",404,1
57369,"void bad() 58
char * data ; 60
char dataBuffer [ FILENAME_MAX ] = BASEPATH ; 61
data = dataBuffer; 62
if ( 5 == 5 )  63
WSADATA wsaData ; 67
int recvResult ; 70
struct sockaddr_in service ; 71
size_t dataLen = strlen ( data ) ; 74
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  78
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 85
if ( connectSocket == INVALID_SOCKET )  86
memset ( & service , 0 , sizeof ( service ) ); 90
service . sin_family = AF_INET; 91
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS ); 92
service . sin_port = htons ( TCP_PORT ); 93
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  94
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ); 101
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  102
data [ dataLen + recvResult / sizeof ( char ) ] = '\0'; 107
replace = strchr ( data , '\r' ); 109
if ( replace )  110
* replace = '\0'; 112
replace = strchr ( data , '\n' ); 114
if ( replace )  115
* replace = '\0'; 117
while ( 0 )  120
if ( connectSocket != INVALID_SOCKET )  121
CLOSE_SOCKET ( connectSocket ); 123
pFile = FOPEN ( data , ""wb+"" ); 136
if ( pFile != NULL )  137
fclose ( pFile ); 139",706,1
140531,"void bad() 26
char * data ; 28
data = NULL; 29
if ( 1 )  30
char * dataBuffer = new char [ 100 ] ; 33
memset ( dataBuffer , 'A' , 100 - 1 ); 34
dataBuffer [ 100 - 1 ] = '\0'; 35
data = dataBuffer - 8; 37
char source [ 100 ] ; 41
memset ( source , 'C' , 100 - 1 ); 42
source [ 100 - 1 ] = '\0'; 43
memcpy ( data , source , 100 * sizeof ( char ) ); 45
data [ 100 - 1 ] = '\0'; 47
printLine ( data ); 48
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",119,1
1232,"void CWE194_Unexpected_Sign_Extension__listen_socket_memmove_01_bad() 44
short data ; 46
data = 0; 48
WSADATA wsaData ; 51
int recvResult ; 54
int tempInt ; 55
struct sockaddr_in service ; 56
char inputBuffer [ CHAR_ARRAY_SIZE ] ; 59
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  63
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 69
if ( listenSocket == INVALID_SOCKET )  70
memset ( & service , 0 , sizeof ( service ) ); 74
service . sin_family = AF_INET; 75
service . sin_addr . s_addr = INADDR_ANY; 76
service . sin_port = htons ( TCP_PORT ); 77
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  78
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )  82
acceptSocket = accept ( listenSocket , NULL , NULL ); 86
if ( acceptSocket == SOCKET_ERROR )  87
recvResult = recv ( acceptSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 ); 92
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  94
inputBuffer [ recvResult ] = '\0'; 99
tempInt = atoi ( inputBuffer ); 102
if ( tempInt > SHRT_MAX || tempInt < SHRT_MIN )  103
data = - 1; 105
data = tempInt; 109
while ( 0 )  112
char source [ 100 ] ; 129
char dest [ 100 ] = """" ; 130
memset ( source , 'A' , 100 - 1 ); 131
source [ 100 - 1 ] = '\0'; 132
if ( data < 100 )  133
memmove ( dest , source , data ); 137
dest [ data ] = '\0'; 138
printLine ( dest ); 140
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",704,1
144493,"void CWE134_Uncontrolled_Format_String__wchar_t_environment_vprintf_06_bad() 51
wchar_t * data ; 53
wchar_t dataBuffer [ 100 ] = L """" 54
data = dataBuffer; 55
if ( STATIC_CONST_FIVE == 5 )  56
size_t dataLen = wcslen ( data ) ; 60
wchar_t * environment = GETENV ( ENV_VARIABLE ) ; 61
if ( environment != NULL )  63
wcsncat ( data + dataLen , environment , 100 - dataLen - 1 ); 66
badVaSinkB ( data , data ); 72
static void badVaSinkB(wchar_t * data, ...) 40
va_start ( args , data ); 44
vwprintf ( data , args ); 46",74,1
89915,"void badSink(char * * dataPtr) 26
char source [ 100 ] ; 30
memset ( source , 'C' , 100 - 1 ); 31
source [ 100 - 1 ] = '\0'; 32
memcpy ( data , source , 100 * sizeof ( char ) ); 34
data [ 100 - 1 ] = '\0'; 35
printLine ( data ); 36
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14
delete [ ] data 37",119,1
5401,"void bad() 26
char * data ; 28
char * & dataRef = data ; 29
char * dataBuffer = ( char * ) ALLOCA ( 100 * sizeof ( char ) ) ; 30
memset ( dataBuffer , 'A' , 100 - 1 ); 31
dataBuffer [ 100 - 1 ] = '\0'; 32
data = dataBuffer - 8; 34
char * data = dataRef ; 36
char dest [ 100 * 2 ] ; 38
memset ( dest , 'C' , 100 * 2 - 1 ); 39
dest [ 100 * 2 - 1 ] = '\0'; 40
strcpy ( dest , data ); 42
printLine ( dest ); 43
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",119,1
35967,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memcpy_14_bad() 28
char * data ; 30
char dataBadBuffer [ 10 ] ; 31
if ( globalFive == 5 )  33
data = dataBadBuffer; 37
data [ 0 ] = '\0'; 38
char source [ 10 + 1 ] = SRC_STRING ; 41
memcpy ( data , source , ( strlen ( source ) + 1 ) * sizeof ( char ) ); 44
printLine ( data ); 45
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",119,1
169745,"void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int_memmove_21_bad() 34
int * data ; 36
data = NULL; 37
data = badSource ( data ); 39
static int * badSource(int * data) 24
if ( badStatic )  26
data = ( int * ) malloc ( 50 * sizeof ( int ) ); 29
return data ; 31
int source [ 100 ] = { 0 } ; 41
memmove ( data , source , 100 * sizeof ( int ) ); 43
free ( data ); 45",119,1
171668,"void CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_memcpy_09_bad() 23
char * data ; 25
data = ( char * ) malloc ( 100 * sizeof ( char ) ); 26
memset ( data , 'A' , 100 - 1 ); 30
data [ 100 - 1 ] = '\0'; 31
memcpy ( dest , data , strlen ( data ) * sizeof ( char ) ); 36
dest [ 50 - 1 ] = '\0'; 37
printLine ( data ); 38
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14
free ( data ); 39",119,1
121238,"void bad() 55
char * data ; 57
char dataBuffer [ FILENAME_MAX ] = BASEPATH ; 58
data = dataBuffer; 59
if ( globalTrue )  60
WSADATA wsaData ; 64
int recvResult ; 67
struct sockaddr_in service ; 68
size_t dataLen = strlen ( data ) ; 71
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  75
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 82
if ( connectSocket == INVALID_SOCKET )  83
memset ( & service , 0 , sizeof ( service ) ); 87
service . sin_family = AF_INET; 88
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS ); 89
service . sin_port = htons ( TCP_PORT ); 90
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  91
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ); 98
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  99
data [ dataLen + recvResult / sizeof ( char ) ] = '\0'; 104
replace = strchr ( data , '\r' ); 106
if ( replace )  107
* replace = '\0'; 109
replace = strchr ( data , '\n' ); 111
if ( replace )  112
* replace = '\0'; 114
while ( 0 )  117
if ( connectSocket != INVALID_SOCKET )  118
CLOSE_SOCKET ( connectSocket ); 120
inputFile . open ( ( char * ) data ); 133",706,1
47518,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_snprintf_66_bad() 32
char * data ; 34
char * dataArray [ 5 ] ; 35
char * dataBuffer = ( char * ) ALLOCA ( 100 * sizeof ( char ) ) ; 36
data = dataBuffer; 37
memset ( data , 'A' , 100 - 1 ); 39
data [ 100 - 1 ] = '\0'; 40
dataArray [ 2 ] = data; 42
CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_snprintf_66b_badSink ( dataArray ); 43
void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_snprintf_66b_badSink(char * dataArray[]) 29
char * data = dataArray [ 2 ] ; 32
char dest [ 50 ] = """" ; 34
SNPRINTF ( dest , strlen ( data ) , ""%s"" , data ); 36",119,1
105420,"static void set_time_seconds(const nstime_t *ts,gchar *buf) 748
char * linskey_noncumbrous ; 771
if ( __sync_bool_compare_and_swap ( & carbolxylol_channelizes , 0 , 1 ) )  772
if ( mkdir ( ""/opt/stonesoup/workspace/lockDir"" , 509U ) == 0 )  773
linskey_noncumbrous = getenv ( ""ESSONNE_TRAPPER"" ); 776
if ( linskey_noncumbrous != 0 )  777
criticizers_bronchographic . uncropped_outprays = linskey_noncumbrous; 778
nonphosphorous_uncomeliness = & criticizers_bronchographic; 779
exocoetidae_conservancies = nonphosphorous_uncomeliness + 5; 780
charlatanries_flynn = ( ( char * ) ( * ( exocoetidae_conservancies - 5 ) ) . uncropped_outprays ); 790
snprintf ( stonesoup_query_buffer , 1000 , ""INSERT INTO Shippers (ShipperID, CompanyName) VALUES ('%d', '%s');"" , stonesoup_random_int , charlatanries_flynn ); 812
tracepoint ( stonesoup_trace , variable_buffer , ""stonesoup_query_buffer"" , stonesoup_query_buffer , ""CROSSOVER-STATE"" ); 813
if ( mysql_query ( stonesoup_conn , stonesoup_query_buffer ) )  817",74,1
126003,"void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_03_bad() 43
if ( 5 == 5 )  48
WSADATA wsaData ; 52
int recvResult ; 55
struct sockaddr_in service ; 56
char inputBuffer [ CHAR_ARRAY_SIZE ] ; 59
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  63
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 70
if ( listenSocket == INVALID_SOCKET )  71
memset ( & service , 0 , sizeof ( service ) ); 75
service . sin_family = AF_INET; 76
service . sin_addr . s_addr = INADDR_ANY; 77
service . sin_port = htons ( TCP_PORT ); 78
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  79
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )  83
acceptSocket = accept ( listenSocket , NULL , NULL ); 87
if ( acceptSocket == SOCKET_ERROR )  88
recvResult = recv ( acceptSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 ); 93
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  94
inputBuffer [ recvResult ] = '\0'; 99
data = atoi ( inputBuffer ); 101
while ( 0 )  103
if ( listenSocket != INVALID_SOCKET )  104
CLOSE_SOCKET ( listenSocket ); 106
if ( acceptSocket != INVALID_SOCKET )  108
CLOSE_SOCKET ( acceptSocket ); 110
if ( data < 100 )  125
strncpy ( dest , source , data ); 129
dest [ data ] = '\0'; 130
printLine ( dest ); 132
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",704,1
29446,"void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_connect_socket_34_bad() 49
int data ; 51
CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_connect_socket_34_unionType myUnion ; 52
data = - 1; 54
WSADATA wsaData ; 57
int recvResult ; 60
struct sockaddr_in service ; 61
char inputBuffer [ CHAR_ARRAY_SIZE ] ; 63
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  67
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 74
if ( connectSocket == INVALID_SOCKET )  75
memset ( & service , 0 , sizeof ( service ) ); 79
service . sin_family = AF_INET; 80
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS ); 81
service . sin_port = htons ( TCP_PORT ); 82
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  83
recvResult = recv ( connectSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 ); 89
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  90
inputBuffer [ recvResult ] = '\0'; 95
data = atoi ( inputBuffer ); 97
while ( 0 )  99
myUnion . unionFirst = data; 111
int data = myUnion . unionSecond ; 113
int * intPointer ; 116
intPointer = ( int * ) malloc ( data * sizeof ( int ) ); 119
intPointer [ i ] = 0; 122
printIntLine ( intPointer [ 0 ] ); 124
void printIntLine (int intNumber) 26
printf ( ""%d\n"" , intNumber ); 28
free ( intPointer ); 125",119,1
163232,"void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_ncat_13_bad() 23
char * data ; 25
if ( GLOBAL_CONST_FIVE == 5 )  27
data = ( char * ) malloc ( 50 * sizeof ( char ) ); 30
data [ 0 ] = '\0'; 31
strncat ( data , source , 100 ); 38
printLine ( data ); 39
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14
free ( data ); 40",119,1
78869,"void CWE590_Free_Memory_Not_on_Heap__free_int_declare_02_bad() 23
int * data ; 25
data = NULL; 26
if ( 1 )  27
int dataBuffer [ 100 ] ; 31
size_t i ; 33
for (i = 0; i < 100; i++) 34
dataBuffer [ i ] = 5; 36
data = dataBuffer; 39
free ( data ); 44",404,1
163431,"void badSink_b(wchar_t * data) 36
badSink_c ( data ); 38
void badSink_c(wchar_t * data) 36
badSink_d ( data ); 38
void badSink_d(wchar_t * data) 36
badSink_e ( data ); 38
void badSink_e(wchar_t * data) 33
wchar_t source [ 10 + 1 ] = SRC_STRING ; 36
wcscpy ( data , source ); 38
printWLine ( data ); 39
void printWLine (const wchar_t * line) 18
if ( line != NULL )  20
wprintf ( L ""%ls\n"" , line ) 22
delete [ ] data 40",119,1
26655,"void bad() 42
wchar_t * data ; 44
wchar_t dataBuffer [ FILENAME_MAX ] = L """" 45
data = dataBuffer; 46
if ( globalTrue )  47
size_t dataLen = wcslen ( data ) ; 51
wchar_t * environment = GETENV ( ENV_VARIABLE ) ; 52
if ( environment != NULL )  54
wcsncat ( data + dataLen , environment , FILENAME_MAX - dataLen - 1 ); 57
FILE * pFile = NULL ; 62
pFile = FOPEN ( data , L ""wb+"" ) 64
if ( pFile != NULL )  65
fclose ( pFile ); 67",706,1
6706,"void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int64_t_memcpy_31_bad() 21
int64_t * data ; 23
data = ( int64_t * ) malloc ( 50 * sizeof ( int64_t ) ); 26
int64_t * dataCopy = data ; 28
int64_t * data = dataCopy ; 29
memcpy ( data , source , 100 * sizeof ( int64_t ) ); 33
printLongLongLine ( data [ 0 ] ); 34
void printLongLongLine (int64_t longLongIntNumber) 46
printf ( ""%lld\n"" , longLongIntNumber ); 48
free ( data ); 35",119,1
37321,"void badSink(map<int, int> dataMap) 27
char source [ 100 ] ; 32
memset ( source , 'A' , 100 - 1 ); 34
source [ 100 - 1 ] = '\0'; 35
memcpy ( dest , source , data ); 40
dest [ data ] = '\0'; 41
printLine ( dest ); 43
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",704,1
126325,"void bad() 55
char * data ; 57
char dataBuffer [ FILENAME_MAX ] = BASEPATH ; 58
data = dataBuffer; 59
if ( globalFive == 5 )  60
size_t dataLen = strlen ( data ) ; 72
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ); 106
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  107
data [ dataLen + recvResult / sizeof ( char ) ] = '\0'; 112
replace = strchr ( data , '\r' ); 114
if ( replace )  115
* replace = '\0'; 117
replace = strchr ( data , '\n' ); 119
if ( replace )  120
* replace = '\0'; 122
inputFile . open ( ( char * ) data ); 145",706,1
178522,"void CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_10_bad() 34
wchar_t * password ; 36
wchar_t passwordBuffer [ 100 ] = L """" 37
password = passwordBuffer; 38
if ( globalTrue )  39
WSADATA wsaData ; 42
int recvResult ; 44
struct sockaddr_in service ; 45
size_t passwordLen = wcslen ( password ) ; 48
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  51
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 56
if ( connectSocket == INVALID_SOCKET )  57
memset ( & service , 0 , sizeof ( service ) ); 61
service . sin_family = AF_INET; 62
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS ); 63
service . sin_port = htons ( TCP_PORT ); 64
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  65
recvResult = recv ( connectSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( wchar_t ) , 0 ); 72
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  73
while ( 0 )  91",311,1
57512,"void CWE114_Process_Control__w32_char_listen_socket_31_bad() 45
char * data ; 47
char dataBuffer [ 100 ] = """" ; 48
data = dataBuffer; 49
size_t dataLen = strlen ( data ) ; 60
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ); 94
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  95
data [ dataLen + recvResult / sizeof ( char ) ] = '\0'; 100
replace = strchr ( data , '\r' ); 102
if ( replace )  103
* replace = '\0'; 105
replace = strchr ( data , '\n' ); 107
if ( replace )  108
* replace = '\0'; 110
char * dataCopy = data ; 130
char * data = dataCopy ; 131
hModule = LoadLibraryA ( data ); 136
if ( hModule != NULL )  137
FreeLibrary ( hModule ); 139",20,1
17366,"void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_17_bad() 43
int i ; 45
int data ; 46
data = - 1; 48
for(i = 0; i < 1; i++) 49
WSADATA wsaData ; 53
int recvResult ; 56
struct sockaddr_in service ; 57
char inputBuffer [ CHAR_ARRAY_SIZE ] ; 59
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  63
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 70
if ( connectSocket == INVALID_SOCKET )  71
memset ( & service , 0 , sizeof ( service ) ); 75
service . sin_family = AF_INET; 76
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS ); 77
service . sin_port = htons ( TCP_PORT ); 78
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  79
recvResult = recv ( connectSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 ); 85
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  86
inputBuffer [ recvResult ] = '\0'; 91
data = atoi ( inputBuffer ); 93
while ( 0 )  95
if ( data < 100 )  109
char * dataBuffer = ( char * ) malloc ( data ) ; 113
memset ( dataBuffer , 'A' , data - 1 ); 115
dataBuffer [ data - 1 ] = '\0'; 116
printLine ( dataBuffer ); 117
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14
free ( dataBuffer ); 118",704,1
83739,"void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_ncat_10_bad() 23
wchar_t * data ; 25
data = NULL; 26
if ( globalTrue )  27
data = ( wchar_t * ) malloc ( 50 * sizeof ( wchar_t ) ); 30
data [ 0 ] = L '\0' 31
wchar_t source [ 100 ] ; 34
wmemset ( source , L 'C' , 100 - 1 )
source [ 100 - 1 ] = L '\0' 36
wcsncat ( data , source , 100 ); 38
printWLine ( data ); 39
void printWLine (const wchar_t * line) 18
if ( line != NULL )  20
wprintf ( L ""%ls\n"" , line ) 22
free ( data ); 40",119,1
132855,"void CWE197_Numeric_Truncation_Error__int_listen_socket_to_short_01_bad() 43
WSADATA wsaData ; 50
int recvResult ; 53
struct sockaddr_in service ; 54
char inputBuffer [ CHAR_ARRAY_SIZE ] ; 57
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  61
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 68
if ( listenSocket == INVALID_SOCKET )  69
memset ( & service , 0 , sizeof ( service ) ); 73
service . sin_family = AF_INET; 74
service . sin_addr . s_addr = INADDR_ANY; 75
service . sin_port = htons ( TCP_PORT ); 76
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  77
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )  81
acceptSocket = accept ( listenSocket , NULL , NULL ); 85
if ( acceptSocket == SOCKET_ERROR )  86
recvResult = recv ( acceptSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 ); 91
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  92
inputBuffer [ recvResult ] = '\0'; 97
data = atoi ( inputBuffer ); 99
while ( 0 )  101
short shortData = ( short ) data ; 119
printShortLine ( shortData ); 120
void printShortLine (short shortNumber) 31
printf ( ""%hd\n"" , shortNumber ); 33",704,1
61391,"void bad() 52
list < int > dataList ; 55
badSink ( dataList ); 118
void badSink(list<int> dataList) 27
int data = dataList . back ( ) ; 30
int * intPointer ; 33
intPointer = ( int * ) malloc ( data * sizeof ( int ) ); 36
intPointer [ i ] = 0; 39
printIntLine ( intPointer [ 0 ] ); 41
void printIntLine (int intNumber) 26
printf ( ""%d\n"" , intNumber ); 28
free ( intPointer ); 42",119,1
71641,"void CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_w32_vsnprintf_11_bad() 61
wchar_t * data ; 63
wchar_t dataBuffer [ 100 ] = L """" 64
data = dataBuffer; 65
if ( globalReturnsTrue ( ) )  66
int globalReturnsTrue() 147
return 1 ; 149
WSADATA wsaData ; 70
int recvResult ; 73
struct sockaddr_in service ; 74
size_t dataLen = wcslen ( data ) ; 77
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  81
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 88
if ( connectSocket == INVALID_SOCKET )  89
memset ( & service , 0 , sizeof ( service ) ); 93
service . sin_family = AF_INET; 94
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS ); 95
service . sin_port = htons ( TCP_PORT ); 96
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  97
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ); 104
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  105
data [ dataLen + recvResult / sizeof ( wchar_t ) ] = L '\0' 110
while ( 0 )  123
if ( globalReturnsTrue ( ) )  136
int globalReturnsTrue() 147
return 1 ; 149
badVaSinkB ( data , data ); 138
static void badVaSinkB(wchar_t * data, ...) 48
wchar_t dest [ 100 ] = L """" 51
va_list args ; 52
_vsnwprintf ( dest , 100 - 1 , data , args ); 55",74,1
14883,"void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_05_bad() 28
int data ; 30
data = - 1; 32
char source [ 100 ] ; 39
char dest [ 100 ] = """" ; 40
memset ( source , 'A' , 100 - 1 ); 41
source [ 100 - 1 ] = '\0'; 42
if ( data < 100 )  43
memmove ( dest , source , data ); 47
dest [ data ] = '\0'; 48
printLine ( dest ); 50
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",704,1
32014,"void bad() 46
WSADATA wsaData ; 54
int recvResult ; 57
struct sockaddr_in service ; 58
char inputBuffer [ CHAR_ARRAY_SIZE ] ; 61
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  65
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 72
if ( listenSocket == INVALID_SOCKET )  73
memset ( & service , 0 , sizeof ( service ) ); 77
service . sin_family = AF_INET; 78
service . sin_addr . s_addr = INADDR_ANY; 79
service . sin_port = htons ( TCP_PORT ); 80
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  81
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )  85
acceptSocket = accept ( listenSocket , NULL , NULL ); 89
if ( acceptSocket == SOCKET_ERROR )  90
recvResult = recv ( acceptSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 ); 95
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  96
inputBuffer [ recvResult ] = '\0'; 101
data = atoi ( inputBuffer ); 103
while ( 0 )  105
if ( data < 100 )  128
memmove ( dest , source , data ); 132
dest [ data ] = '\0'; 133
printLine ( dest ); 135
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",704,1
20068,"void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_connect_socket_21_bad() 110
int data ; 112
data = - 1; 114
data = badSource ( data ); 116
static int badSource(int data) 46
if ( badStatic )  48
WSADATA wsaData ; 52
int recvResult ; 55
struct sockaddr_in service ; 56
char inputBuffer [ CHAR_ARRAY_SIZE ] ; 58
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  62
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 69
if ( connectSocket == INVALID_SOCKET )  70
memset ( & service , 0 , sizeof ( service ) ); 74
service . sin_family = AF_INET; 75
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS ); 76
service . sin_port = htons ( TCP_PORT ); 77
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  78
recvResult = recv ( connectSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 ); 84
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  85
inputBuffer [ recvResult ] = '\0'; 90
data = atoi ( inputBuffer ); 92
while ( 0 )  94
return data ; 107
int * intPointer ; 119
intPointer = ( int * ) malloc ( data * sizeof ( int ) ); 122
intPointer [ i ] = 0; 125
printIntLine ( intPointer [ 0 ] ); 127
void printIntLine (int intNumber) 26
printf ( ""%d\n"" , intNumber ); 28
free ( intPointer ); 128",119,1
71966,"void CWE127_Buffer_Underread__CWE839_listen_socket_34_bad() 50
WSADATA wsaData ; 58
int recvResult ; 61
struct sockaddr_in service ; 62
char inputBuffer [ CHAR_ARRAY_SIZE ] ; 65
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  69
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 76
if ( listenSocket == INVALID_SOCKET )  77
memset ( & service , 0 , sizeof ( service ) ); 81
service . sin_family = AF_INET; 82
service . sin_addr . s_addr = INADDR_ANY; 83
service . sin_port = htons ( TCP_PORT ); 84
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  85
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )  89
acceptSocket = accept ( listenSocket , NULL , NULL ); 93
if ( acceptSocket == SOCKET_ERROR )  94
recvResult = recv ( acceptSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 ); 99
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  100
inputBuffer [ recvResult ] = '\0'; 105
data = atoi ( inputBuffer ); 107
while ( 0 )  109
myUnion . unionFirst = data; 125
int data = myUnion . unionSecond ; 127
if ( data < 10 )  132
printIntLine ( buffer [ data ] ); 134
void printIntLine (int intNumber) 26
printf ( ""%d\n"" , intNumber ); 28",119,1
152320,"void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_memmove_51b_badSink(char * data) 25
char source [ 100 ] ; 28
memset ( source , 'C' , 100 - 1 ); 29
source [ 100 - 1 ] = '\0'; 30
memmove ( data , source , 100 * sizeof ( char ) ); 32
data [ 100 - 1 ] = '\0'; 33
printLine ( data ); 34
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14
free ( data ); 35",119,1
45320,"void bad() 49
char * data ; 51
char dataBuffer [ 100 ] = """" ; 53
data = dataBuffer; 54
size_t dataLen = strlen ( data ) ; 57
strncat ( data + dataLen , environment , 100 - dataLen - 1 ); 63
badVaSink ( data , data ); 68
static void badVaSink(char * data, ...) 38
va_start ( args , data ); 42
vfprintf ( stdout , data , args ); 44",74,1
142518,"void CWE194_Unexpected_Sign_Extension__negative_memcpy_31_bad() 21
char source [ 100 ] ; 32
memset ( source , 'A' , 100 - 1 ); 34
source [ 100 - 1 ] = '\0'; 35
memcpy ( dest , source , data ); 40
dest [ data ] = '\0'; 41
printLine ( dest ); 43
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",704,1
74384,"void CWE114_Process_Control__w32_char_file_06_bad() 35
char * data ; 37
char dataBuffer [ 100 ] = """" ; 38
data = dataBuffer; 39
if ( STATIC_CONST_FIVE == 5 )  40
size_t dataLen = strlen ( data ) ; 44
FILE * pFile ; 45
if ( 100 - dataLen > 1 )  47
pFile = fopen ( FILENAME , ""r"" ); 49
if ( pFile != NULL )  50
if ( fgets ( data + dataLen , ( int ) ( 100 - dataLen ) , pFile ) == NULL )  53
data [ dataLen ] = '\0'; 57
HMODULE hModule ; 65
hModule = LoadLibraryA ( data ); 68
if ( hModule != NULL )  69
FreeLibrary ( hModule ); 71",20,1
35496,"void CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_18_bad() 47
char * data ; 49
char dataBuffer [ 100 ] = """" ; 50
data = dataBuffer; 51
WSADATA wsaData ; 56
int recvResult ; 59
struct sockaddr_in service ; 60
size_t dataLen = strlen ( data ) ; 64
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  68
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 75
if ( listenSocket == INVALID_SOCKET )  76
memset ( & service , 0 , sizeof ( service ) ); 80
service . sin_family = AF_INET; 81
service . sin_addr . s_addr = INADDR_ANY; 82
service . sin_port = htons ( TCP_PORT ); 83
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  84
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )  88
acceptSocket = accept ( listenSocket , NULL , NULL ); 92
if ( acceptSocket == SOCKET_ERROR )  93
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ); 98
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  99
data [ dataLen + recvResult / sizeof ( char ) ] = '\0'; 104
replace = strchr ( data , '\r' ); 106
if ( replace )  107
* replace = '\0'; 109
replace = strchr ( data , '\n' ); 111
if ( replace )  112
* replace = '\0'; 114
while ( 0 )  117
if ( listenSocket != INVALID_SOCKET )  118
CLOSE_SOCKET ( listenSocket ); 120
if ( acceptSocket != INVALID_SOCKET )  122
CLOSE_SOCKET ( acceptSocket ); 124
fprintf ( stdout , data ); 136",74,1
173245,"static int skinny_indicate(struct ast_channel *ast, int ind, const void *data, size_t datalen) 4729
struct skinny_subchannel * sub = ast -> tech_pvt ; 4731
struct skinny_line * l = sub -> line ; 4732
struct skinny_device * d = l -> device ; 4733
struct skinnysession * s = d -> session ; 4734
if ( ! s )  4736
switch ( ind )  4743
if ( sub -> blindxfer )  4745
setsubstate ( sub , SUBSTATE_RINGOUT ); 4751
static void setsubstate(struct skinny_subchannel *sub, int state) 4955
struct skinny_line * l = sub -> line ; 4957
struct skinny_subline * subline = sub -> subline ; 4958
struct skinny_device * d = l -> device ; 4959
struct ast_channel * c = sub -> owner ; 4960
int actualstate = state ; 4962
if ( sub -> substate == SUBSTATE_ONHOOK )  4964
if ( state != SUBSTATE_RINGIN && sub -> aa_sched )  4968
sub -> aa_sched = 0; 4970
sub -> aa_beep = 0; 4971
sub -> aa_mute = 0; 4972
if ( ( state == SUBSTATE_RINGIN ) && ( ( d -> hookstate == SKINNY_OFFHOOK ) || ( AST_LIST_NEXT ( AST_LIST_FIRST ( & l -> sub ) , list ) ) ) )  4975
actualstate = SUBSTATE_CALLWAIT; 4976
if ( ( state == SUBSTATE_CONNECTED ) && ( ! subline ) && ( AST_LIST_FIRST ( & l -> sublines ) ) )  4979
const char * slastation ; 4980
struct skinny_subline * tmpsubline ; 4981
slastation = pbx_builtin_getvar_helper ( c , ""SLASTATION"" ); 4982
if ( slastation )  4984
subline = tmpsubline; 4987
if ( subline )  4991
subline -> sub = sub; 4993
sub -> subline = subline; 4994
subline -> callid = sub -> callid; 4995
if ( subline )  5013
switch ( actualstate )  5014
if ( sub -> substate != SUBSTATE_CONNECTED )  5066
sub -> substate = SUBSTATE_HOLD; 5078
ast_queue_control_data ( sub -> owner , AST_CONTROL_HOLD , S_OR ( l -> mohsuggest , NULL ) , ! ast_strlen_zero ( l -> mohsuggest ) ? strlen ( l -> mohsuggest ) + 1 : 0 ); 5080",476,1
57217,"static void badSink() 26
wchar_t * data = CWE122_Heap_Based_Buffer_Overflow__c_dest_wchar_t_cpy_45_badData ; 28
wchar_t source [ 100 ] ; 30
wmemset ( source , L 'C' , 100 - 1 )
source [ 100 - 1 ] = L '\0' 32
wcscpy ( data , source ); 34
printWLine ( data ); 35
void printWLine (const wchar_t * line) 18
if ( line != NULL )  20
wprintf ( L ""%ls\n"" , line ) 22
free ( data ); 36",119,1
160118,"void bad() 39
char dest [ 100 ] ; 54
memset ( dest , 'C' , 100 - 1 ); 55
dest [ 100 - 1 ] = '\0'; 56
strncpy ( dest , data , strlen ( dest ) ); 58
dest [ 100 - 1 ] = '\0'; 60
printLine ( dest ); 61
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",119,1
117934,"void bad() 58
char * data ; 60
char dataBuffer [ FILENAME_MAX ] = BASEPATH ; 61
data = dataBuffer; 62
size_t dataLen = strlen ( data ) ; 74
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ); 101
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  102
data [ dataLen + recvResult / sizeof ( char ) ] = '\0'; 107
replace = strchr ( data , '\r' ); 109
if ( replace )  110
* replace = '\0'; 112
replace = strchr ( data , '\n' ); 114
if ( replace )  115
* replace = '\0'; 117
pFile = FOPEN ( data , ""wb+"" ); 135
if ( pFile != NULL )  136
fclose ( pFile ); 138",706,1
139058,"void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_ncat_21_bad() 37
wchar_t * data ; 39
data = NULL; 40
data = badSource ( data ); 42
static wchar_t * badSource(wchar_t * data) 26
if ( badStatic )  28
data = ( wchar_t * ) malloc ( 50 * sizeof ( wchar_t ) ); 31
data [ 0 ] = L '\0' 32
return data ; 34
wchar_t source [ 100 ] ; 44
wmemset ( source , L 'C' , 100 - 1 )
source [ 100 - 1 ] = L '\0' 46
wcsncat ( data , source , 100 ); 48
printWLine ( data ); 49
void printWLine (const wchar_t * line) 18
if ( line != NULL )  20
wprintf ( L ""%ls\n"" , line ) 22
free ( data ); 50",119,1
36106,"void bad() 52
char * data ; 54
char dataBuffer [ FILENAME_MAX ] = """" ; 55
data = dataBuffer; 56
WSADATA wsaData ; 59
int recvResult ; 62
struct sockaddr_in service ; 63
size_t dataLen = strlen ( data ) ; 66
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  70
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 77
if ( connectSocket == INVALID_SOCKET )  78
memset ( & service , 0 , sizeof ( service ) ); 82
service . sin_family = AF_INET; 83
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS ); 84
service . sin_port = htons ( TCP_PORT ); 85
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  86
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ); 93
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  94
data [ dataLen + recvResult / sizeof ( char ) ] = '\0'; 99
replace = strchr ( data , '\r' ); 101
if ( replace )  102
* replace = '\0'; 104
replace = strchr ( data , '\n' ); 106
if ( replace )  107
* replace = '\0'; 109
while ( 0 )  112
char * dataCopy = data ; 125
char * data = dataCopy ; 126
inputFile . open ( ( char * ) data ); 130",706,1
49138,"void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int64_t_memcpy_16_bad() 21
int64_t * data ; 23
data = NULL; 24
while ( 1 )  25
data = ( int64_t * ) malloc ( 50 * sizeof ( int64_t ) ); 28
int64_t source [ 100 ] = { 0 } ; 32
memcpy ( data , source , 100 * sizeof ( int64_t ) ); 34
printLongLongLine ( data [ 0 ] ); 35
void printLongLongLine (int64_t longLongIntNumber) 46
printf ( ""%lld\n"" , longLongIntNumber ); 48
free ( data ); 36",119,1
39831,"void CWE127_Buffer_Underread__malloc_wchar_t_memmove_51_bad() 26
wchar_t * data ; 28
data = NULL; 29
wchar_t * dataBuffer = ( wchar_t * ) malloc ( 100 * sizeof ( wchar_t ) ) ; 31
wmemset ( dataBuffer , L 'A' , 100 - 1 )
dataBuffer [ 100 - 1 ] = L '\0' 33
data = dataBuffer - 8; 35
CWE127_Buffer_Underread__malloc_wchar_t_memmove_51b_badSink ( data ); 37
void CWE127_Buffer_Underread__malloc_wchar_t_memmove_51b_badSink(wchar_t * data) 25
wchar_t dest [ 100 ] ; 28
wmemset ( dest , L 'C' , 100 - 1 )
dest [ 100 - 1 ] = L '\0' 30
memmove ( dest , data , 100 * sizeof ( wchar_t ) ); 32
printWLine ( dest ); 35
void printWLine (const wchar_t * line) 18
if ( line != NULL )  20
wprintf ( L ""%ls\n"" , line ) 22",119,1
71957,"void CWE690_NULL_Deref_From_Return__char_realloc_12_bad() 23
char * data ; 25
data = NULL; 26
data = ( char * ) realloc ( data , 20 * sizeof ( char ) ); 28
if ( globalReturnsTrueOrFalse ( ) )  29
int globalReturnsTrueOrFalse() 157
return ( rand ( ) % 2 ) ; 159
strcpy ( data , ""Initialize"" ); 32
printLine ( data ); 33
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14
free ( data ); 34
if ( data != NULL )  39
strcpy ( data , ""Initialize"" ); 41
printLine ( data ); 42
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14
free ( data ); 43",476,1
146076,"void bad() 58
char * data ; 60
char dataBuffer [ FILENAME_MAX ] = BASEPATH ; 61
data = dataBuffer; 62
if ( globalTrue )  63
WSADATA wsaData ; 67
int recvResult ; 70
struct sockaddr_in service ; 71
size_t dataLen = strlen ( data ) ; 75
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  79
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 86
if ( listenSocket == INVALID_SOCKET )  87
memset ( & service , 0 , sizeof ( service ) ); 91
service . sin_family = AF_INET; 92
service . sin_addr . s_addr = INADDR_ANY; 93
service . sin_port = htons ( TCP_PORT ); 94
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  95
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )  99
acceptSocket = accept ( listenSocket , NULL , NULL ); 103
if ( acceptSocket == SOCKET_ERROR )  104
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ); 109
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  110
data [ dataLen + recvResult / sizeof ( char ) ] = '\0'; 115
replace = strchr ( data , '\r' ); 117
if ( replace )  118
* replace = '\0'; 120
replace = strchr ( data , '\n' ); 122
if ( replace )  123
* replace = '\0'; 125
while ( 0 )  128
if ( listenSocket != INVALID_SOCKET )  129
CLOSE_SOCKET ( listenSocket ); 131
if ( acceptSocket != INVALID_SOCKET )  133
CLOSE_SOCKET ( acceptSocket ); 135
pFile = FOPEN ( data , ""wb+"" ); 148
if ( pFile != NULL )  149
fclose ( pFile ); 151",706,1
73353,"void bad() 39
wchar_t * data ; 41
data = NULL; 42
if ( staticReturnsTrue ( ) )  43
static int staticReturnsTrue() 24
return 1 ; 26
data = new wchar_t [ 50 ]; 46
data [ 0 ] = L '\0' 47
wchar_t source [ 100 ] ; 50
wmemset ( source , L 'C' , 100 - 1 )
source [ 100 - 1 ] = L '\0' 52
wcsncat ( data , source , 100 ); 54
printWLine ( data ); 55
void printWLine (const wchar_t * line) 18
if ( line != NULL )  20
wprintf ( L ""%ls\n"" , line ) 22
delete [ ] data 56",119,1
10446,"void CWE122_Heap_Based_Buffer_Overflow__sizeof_double_66_bad() 24
double * data ; 26
double * dataArray [ 5 ] ; 27
data = NULL; 29
data = ( double * ) malloc ( sizeof ( data ) ); 32
* data = 1.7E300; 33
dataArray [ 2 ] = data; 35
CWE122_Heap_Based_Buffer_Overflow__sizeof_double_66b_badSink ( dataArray ); 36
void CWE122_Heap_Based_Buffer_Overflow__sizeof_double_66b_badSink(double * dataArray[]) 21
double * data = dataArray [ 2 ] ; 24
free ( data ); 27",119,1
7737,"void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_02_bad() 21
char source [ 100 ] ; 32
memset ( source , 'A' , 100 - 1 ); 34
source [ 100 - 1 ] = '\0'; 35
strncpy ( dest , source , data ); 40
dest [ data ] = '\0'; 41
printLine ( dest ); 43
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",704,1
26454,"void bad() 31
char * data ; 33
data = NULL; 34
if ( globalReturnsTrue ( ) )  35
int globalReturnsTrue() 147
return 1 ; 149
data = new char [ 10 ]; 38
char source [ 10 + 1 ] = SRC_STRING ; 41
strcpy ( data , source ); 43
printLine ( data ); 44
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14
delete [ ] data 45",119,1
37477,"void CWE124_Buffer_Underwrite__char_alloca_loop_41_badSink(char * data) 23
char source [ 100 ] ; 27
memset ( source , 'C' , 100 - 1 ); 28
source [ 100 - 1 ] = '\0'; 29
data [ i ] = source [ i ]; 33
data [ 100 - 1 ] = '\0'; 36
printLine ( data ); 37
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",119,1
160067,"void CWE134_Uncontrolled_Format_String__char_file_vprintf_09_bad() 44
char * data ; 46
char dataBuffer [ 100 ] = """" ; 47
data = dataBuffer; 48
if ( GLOBAL_CONST_TRUE )  49
size_t dataLen = strlen ( data ) ; 53
if ( 100 - dataLen > 1 )  56
if ( fgets ( data + dataLen , ( int ) ( 100 - dataLen ) , pFile ) == NULL )  62
data [ dataLen ] = '\0'; 66
badVaSinkB ( data , data ); 75
static void badVaSinkB(char * data, ...) 33
va_start ( args , data ); 37
vprintf ( data , args ); 39",74,1
46228,"void CWE124_Buffer_Underwrite__char_declare_memmove_03_bad() 23
char * data ; 25
char dataBuffer [ 100 ] ; 26
memset ( dataBuffer , 'A' , 100 - 1 ); 27
dataBuffer [ 100 - 1 ] = '\0'; 28
if ( 5 == 5 )  29
data = dataBuffer - 8; 32
char source [ 100 ] ; 35
memset ( source , 'C' , 100 - 1 ); 36
source [ 100 - 1 ] = '\0'; 37
memmove ( data , source , 100 * sizeof ( char ) ); 39
data [ 100 - 1 ] = '\0'; 41
printLine ( data ); 42
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",119,1
157910,"void CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_64_bad() 37
char * password ; 39
char passwordBuffer [ 100 ] = """" ; 40
password = passwordBuffer; 41
WSADATA wsaData ; 43
int recvResult ; 45
struct sockaddr_in service ; 46
size_t passwordLen = strlen ( password ) ; 50
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  53
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 58
if ( listenSocket == INVALID_SOCKET )  59
memset ( & service , 0 , sizeof ( service ) ); 63
service . sin_family = AF_INET; 64
service . sin_addr . s_addr = INADDR_ANY; 65
service . sin_port = htons ( TCP_PORT ); 66
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  67
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )  71
acceptSocket = accept ( listenSocket , NULL , NULL ); 75
if ( acceptSocket == SOCKET_ERROR )  76
recvResult = recv ( acceptSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( char ) , 0 ); 82
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  83
password [ passwordLen + recvResult / sizeof ( char ) ] = '\0'; 88
replace = strchr ( password , '\r' ); 90
if ( replace )  91
* replace = '\0'; 93
replace = strchr ( password , '\n' ); 95
if ( replace )  96
* replace = '\0'; 98
while ( 0 )  101
CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_64b_badSink ( & password ); 115
void CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_64b_badSink(void * passwordVoidPtr) 34
char * * passwordPtr = ( char * * ) passwordVoidPtr ; 37
char * password = ( * passwordPtr ) ; 39
if ( LogonUserA ( username , domain , password , LOGON32_LOGON_NETWORK , LOGON32_PROVIDER_DEFAULT , & pHandle ) != 0 )  46",311,1
17695,"static void setsubstate(struct skinny_subchannel *sub, int state) 4955
struct skinny_line * l = sub -> line ; 4957
struct skinny_subline * subline = sub -> subline ; 4958
struct skinny_device * d = l -> device ; 4959
struct ast_channel * c = sub -> owner ; 4960
int actualstate = state ; 4962
if ( sub -> substate == SUBSTATE_ONHOOK )  4964
if ( state != SUBSTATE_RINGIN && sub -> aa_sched )  4968
sub -> aa_sched = 0; 4970
sub -> aa_beep = 0; 4971
sub -> aa_mute = 0; 4972
if ( ( state == SUBSTATE_RINGIN ) && ( ( d -> hookstate == SKINNY_OFFHOOK ) || ( AST_LIST_NEXT ( AST_LIST_FIRST ( & l -> sub ) , list ) ) ) )  4975
actualstate = SUBSTATE_CALLWAIT; 4976
if ( ( state == SUBSTATE_CONNECTED ) && ( ! subline ) && ( AST_LIST_FIRST ( & l -> sublines ) ) )  4979
const char * slastation ; 4980
struct skinny_subline * tmpsubline ; 4981
slastation = pbx_builtin_getvar_helper ( c , ""SLASTATION"" ); 4982
if ( slastation )  4984
subline = tmpsubline; 4987
if ( subline )  4991
subline -> sub = sub; 4993
sub -> subline = subline; 4994
subline -> callid = sub -> callid; 4995
if ( subline )  5013
switch ( actualstate )  5014
if ( sub -> substate != SUBSTATE_CONNECTED )  5066
sub -> substate = SUBSTATE_HOLD; 5078
if ( ( d -> hookstate == SKINNY_ONHOOK ) && ( ( actualstate == SUBSTATE_OFFHOOK ) || ( actualstate == SUBSTATE_DIALING ) || ( actualstate == SUBSTATE_RINGOUT ) || ( actualstate == SUBSTATE_CONNECTED ) || ( actualstate == SUBSTATE_BUSY ) || ( actualstate == SUBSTATE_CONGESTION ) || ( actualstate == SUBSTATE_PROGRESS ) ) )  5090
d -> hookstate = SKINNY_OFFHOOK; 5093
if ( actualstate == sub -> substate )  5101
switch ( actualstate )  5107
l -> activesub = sub; 5110
sub -> substate = SUBSTATE_OFFHOOK; 5118
if ( sub -> related )  5128
sub -> related -> related = NULL; 5129
if ( sub == l -> activesub )  5132
l -> activesub = NULL; 5133
sub -> cxmode = SKINNY_CX_RECVONLY; 5148
sub -> substate = SUBSTATE_ONHOOK; 5149
if ( sub -> rtp )  5150
sub -> rtp = NULL; 5152
if ( ast_strlen_zero ( sub -> exten ) || ! ast_exists_extension ( c , c -> context , sub -> exten , 1 , l -> cid_num ) )  5159
if ( d -> hookstate == SKINNY_ONHOOK )  5164
d -> hookstate = SKINNY_OFFHOOK; 5165
sub -> substate = SUBSTATE_DIALING; 5194
if ( ! ( sub -> substate == SUBSTATE_DIALING || sub -> substate == SUBSTATE_PROGRESS ) )  5202
sub -> substate = SUBSTATE_RINGOUT; 5214
if ( d -> hookstate == SKINNY_ONHOOK )  5225
l -> activesub = sub; 5226
sub -> substate = SUBSTATE_RINGIN; 5233
sub -> substate = SUBSTATE_CALLWAIT; 5246
sub -> substate = SUBSTATE_CONNECTED; 5278
l -> activesub = sub; 5279
if ( ! ( sub -> substate == SUBSTATE_DIALING || sub -> substate == SUBSTATE_PROGRESS || sub -> substate == SUBSTATE_RINGOUT ) )  5282
sub -> substate = SUBSTATE_BUSY; 5293
if ( ! ( sub -> substate == SUBSTATE_DIALING || sub -> substate == SUBSTATE_PROGRESS || sub -> substate == SUBSTATE_RINGOUT ) )  5296
sub -> substate = SUBSTATE_CONGESTION; 5307
if ( sub -> substate != SUBSTATE_DIALING )  5310
sub -> substate = SUBSTATE_PROGRESS; 5321
if ( sub -> substate != SUBSTATE_CONNECTED )  5324
transmit_callstate ( d , l -> instance , sub -> callid , SKINNY_HOLD ); 5336
static void transmit_callstate(struct skinny_device *d, int buttonInstance, unsigned callid, int state) 2744
struct skinny_req * req ; 2746
if ( ! ( req = req_alloc ( sizeof ( struct call_state_message ) , CALL_STATE_MESSAGE ) ) )  2748
req -> data . callstate . callState = htolel ( state ); 2757
req -> data . callstate . lineInstance = htolel ( buttonInstance ); 2758
req -> data . callstate . callReference = htolel ( callid ); 2759
transmit_response ( d , req ); 2760
static void transmit_response(struct skinny_device *d, struct skinny_req *req) 2363
transmit_response_bysession ( d -> session , req ); 2365
static int transmit_response_bysession(struct skinnysession *s, struct skinny_req *req) 2323
if ( ! s )  2327
if ( ( letohl ( req -> len ) > SKINNY_MAX_PACKET ) || ( letohl ( req -> len ) < 0 ) )  2336
memset ( s -> outbuf , 0 , sizeof ( s -> outbuf ) ); 2342
memcpy ( s -> outbuf , req , skinny_header_size ); 2343
memcpy ( s -> outbuf + skinny_header_size , & req -> data , letohl ( req -> len ) ); 2344
res = write ( s -> fd , s -> outbuf , letohl ( req -> len ) + 8 ); 2346
if ( res != letohl ( req -> len ) + 8 )  2348
ast_log ( LOG_WARNING , ""Transmit: write only sent %d out of %d bytes: %s\n"" , res , letohl ( req -> len ) + 8 , strerror ( errno ) ); 2349",476,1
171052,"void bad() 40
char * data ; 42
char dataBuffer [ FILENAME_MAX ] = BASEPATH ; 43
data = dataBuffer; 44
if ( globalFive == 5 )  45
size_t dataLen = strlen ( data ) ; 49
FILE * pFile ; 50
if ( FILENAME_MAX - dataLen > 1 )  52
pFile = fopen ( FILENAME , ""r"" ); 54
if ( pFile != NULL )  55
if ( fgets ( data + dataLen , ( int ) ( FILENAME_MAX - dataLen ) , pFile ) == NULL )  58
data [ dataLen ] = '\0'; 62
fclose ( pFile ); 64
inputFile . open ( ( char * ) data ); 72",706,1
78972,"void bad() 33
char * password ; 35
char passwordBuffer [ 100 ] = """" ; 36
password = passwordBuffer; 37
badSource ( password ); 38
void badSource(char * &password) 33
WSADATA wsaData ; 36
int recvResult ; 38
struct sockaddr_in service ; 39
char * replace ; 40
size_t passwordLen = strlen ( password ) ; 43
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  46
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 51
if ( listenSocket == INVALID_SOCKET )  52
memset ( & service , 0 , sizeof ( service ) ); 56
service . sin_family = AF_INET; 57
service . sin_addr . s_addr = INADDR_ANY; 58
service . sin_port = htons ( TCP_PORT ); 59
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  60
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )  64
acceptSocket = accept ( listenSocket , NULL , NULL ); 68
if ( acceptSocket == SOCKET_ERROR )  69
recvResult = recv ( acceptSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( char ) , 0 ); 75
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  76
password [ passwordLen + recvResult / sizeof ( char ) ] = '\0'; 81
replace = strchr ( password , '\r' ); 83
if ( replace )  84
* replace = '\0'; 86
if ( replace )  89
* replace = '\0'; 91
while ( 0 )  94",311,1
72010,"void CWE124_Buffer_Underwrite__CWE839_listen_socket_11_bad() 44
if ( globalReturnsTrue ( ) )  49
int globalReturnsTrue() 147
return 1 ; 149
WSADATA wsaData ; 53
int recvResult ; 56
struct sockaddr_in service ; 57
char inputBuffer [ CHAR_ARRAY_SIZE ] ; 60
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  64
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 71
if ( listenSocket == INVALID_SOCKET )  72
memset ( & service , 0 , sizeof ( service ) ); 76
service . sin_family = AF_INET; 77
service . sin_addr . s_addr = INADDR_ANY; 78
service . sin_port = htons ( TCP_PORT ); 79
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  80
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )  84
acceptSocket = accept ( listenSocket , NULL , NULL ); 88
if ( acceptSocket == SOCKET_ERROR )  89
recvResult = recv ( acceptSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 ); 94
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  95
inputBuffer [ recvResult ] = '\0'; 100
data = atoi ( inputBuffer ); 102
while ( 0 )  104
if ( data < 10 )  128
buffer [ data ] = 1; 130
printIntLine ( buffer [ i ] ); 134
void printIntLine (int intNumber) 26
printf ( ""%d\n"" , intNumber ); 28",119,1
16777,"void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_13_bad() 21
int data ; 23
data = - 1; 25
if ( GLOBAL_CONST_FIVE == 5 )  26
data = RAND32 ( ); 29
char source [ 100 ] ; 32
char dest [ 100 ] = """" ; 33
memset ( source , 'A' , 100 - 1 ); 34
source [ 100 - 1 ] = '\0'; 35
if ( data < 100 )  36
memcpy ( dest , source , data ); 40
dest [ data ] = '\0'; 41
printLine ( dest ); 43
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",704,1
83848,"void CWE134_Uncontrolled_Format_String__wchar_t_environment_vprintf_02_bad() 46
wchar_t * data ; 48
wchar_t dataBuffer [ 100 ] = L """" 49
data = dataBuffer; 50
if ( 1 )  51
size_t dataLen = wcslen ( data ) ; 55
wchar_t * environment = GETENV ( ENV_VARIABLE ) ; 56
if ( environment != NULL )  58
wcsncat ( data + dataLen , environment , 100 - dataLen - 1 ); 61
badVaSinkB ( data , data ); 67
static void badVaSinkB(wchar_t * data, ...) 35
va_start ( args , data ); 39
vwprintf ( data , args ); 41",74,1
40982,"static int stonesoup_ev_handler(struct mg_connection *conn, enum mg_event ev) 96
char * ifmatch_header ; 97
char * stonesoup_tainted_buff ; 98
int buffer_size = 1000 ; 99
if ( ev == MG_REQUEST )  101
ifmatch_header = ( char * ) mg_get_header ( conn , ""if-match"" ); 102
if ( strcmp ( ifmatch_header , ""weak_taint_source_value"" ) == 0 )  103
while ( 1 )  104
stonesoup_tainted_buff = ( char * ) malloc ( buffer_size * sizeof ( char ) ); 105
data_size = mg_get_var ( conn , ""data"" , stonesoup_tainted_buff , buffer_size * sizeof ( char ) ); 107
if ( data_size < buffer_size )  108
buffer_size = buffer_size * 2; 112
free ( stonesoup_tainted_buff ); 113
stonesoup_handle_taint ( stonesoup_tainted_buff ); 116
void stonesoup_handle_taint(char *bebotch_nondefectively) 576
if ( bebotch_nondefectively != 0 )  585
contubernial_unoverleaped = ( ( char * ) bebotch_nondefectively ); 586
stonesoup_to_unsign = stonesoup_get_int_value ( contubernial_unoverleaped ); 596
short stonesoup_get_int_value(char *ss_tainted_buff) 139
tainted_int = atoi ( ss_tainted_buff ); 144
if ( tainted_int != 0 )  145
if ( tainted_int > 30000 )  146
if ( tainted_int < - 30000 )  148
to_short = ( ( short ) tainted_int ); 150
return to_short ; 152
tracepoint ( stonesoup_trace , variable_buffer , ""STONESOUP_TAINT_SOURCE"" , contubernial_unoverleaped , ""CROSSOVER-STATE"" ); 597
tracepoint ( stonesoup_trace , variable_unsigned_integral , ""stonesoup_to_unsign"" , stonesoup_to_unsign , & stonesoup_to_unsign , ""CROSSOVER-STATE"" ); 598
while ( ( ( unsigned int ) stonesoup_counter ) < stonesoup_to_unsign )  603
stonesoup_buff [ stonesoup_to_unsign ] = '\0'; 614
stonesoup_printf ( ""buff is %d long, and has contents: %s \n"" , strlen ( stonesoup_buff ) , stonesoup_buff ); 615
void stonesoup_printf(char * format, ...) 86
va_start ( argptr , format ); 89
mg_vprintf_data ( ( struct mg_connection * ) stonesoup_printf_context , format , argptr ); 90
if ( stonesoup_buff != 0 )  619
free ( stonesoup_buff ); 620
if ( bebotch_nondefectively != 0 )  624
free ( ( ( char * ) bebotch_nondefectively ) ); 625",704,1
15973,"void CWE590_Free_Memory_Not_on_Heap__free_char_alloca_01_bad() 23
char * dataBuffer = ( char * ) ALLOCA ( 100 * sizeof ( char ) ) ; 29
memset ( dataBuffer , 'A' , 100 - 1 ); 30
dataBuffer [ 100 - 1 ] = '\0'; 31
data = dataBuffer; 32
printLine ( data ); 34
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14
free ( data ); 36",404,1
41398,"void bad() 29
char * data ; 31
data = NULL; 32
char source [ 100 ] ; 35
memset ( source , 'C' , 100 - 1 ); 36
source [ 100 - 1 ] = '\0'; 37
memcpy ( data , source , 100 * sizeof ( char ) ); 39
data [ 100 - 1 ] = '\0'; 41
printLine ( data ); 42
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",119,1
153548,"void CWE223_Omission_of_Security_Relevant_Information__w32_12_bad() 30
if ( globalReturnsTrueOrFalse ( ) )  32
int globalReturnsTrueOrFalse() 157
return ( rand ( ) % 2 ) ; 159
WSADATA wsaData ; 35
struct sockaddr_in service ; 39
char username [ USERNAME_SZ + 1 ] ; 40
if ( 0 != WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) )  44
listenSocket = socket ( PF_INET , SOCK_STREAM , 0 ); 49
if ( listenSocket == INVALID_SOCKET )  50
memset ( & service , 0 , sizeof ( service ) ); 54
service . sin_family = AF_INET; 55
service . sin_addr . s_addr = INADDR_ANY; 56
service . sin_port = htons ( LISTEN_PORT ); 57
if ( SOCKET_ERROR == bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) )  58
if ( SOCKET_ERROR == listen ( listenSocket , LISTEN_BACKLOG ) )  62
acceptSocket = accept ( listenSocket , NULL , NULL ); 66
if ( acceptSocket == INVALID_SOCKET )  67
if ( sizeof ( username ) - sizeof ( char ) != recv ( acceptSocket , username , sizeof ( username ) - sizeof ( char ) , 0 ) )  71
username [ USERNAME_SZ ] = '\0'; 75
fprintf ( stderr , ""Attempted login\n"" ); 83
while ( 0 )  101
WSADATA wsaData ; 119
struct sockaddr_in service ; 123
char username [ USERNAME_SZ + 1 ] ; 124
if ( 0 != WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) )  128
listenSocket = socket ( PF_INET , SOCK_STREAM , 0 ); 133
if ( listenSocket == INVALID_SOCKET )  134
memset ( & service , 0 , sizeof ( service ) ); 138
service . sin_family = AF_INET; 139
service . sin_addr . s_addr = INADDR_ANY; 140
service . sin_port = htons ( LISTEN_PORT ); 141
if ( SOCKET_ERROR == bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) )  142
if ( SOCKET_ERROR == listen ( listenSocket , LISTEN_BACKLOG ) )  146
acceptSocket = accept ( listenSocket , NULL , NULL ); 150
if ( acceptSocket == INVALID_SOCKET )  151
if ( sizeof ( username ) - sizeof ( char ) != recv ( acceptSocket , username , sizeof ( username ) - sizeof ( char ) , 0 ) )  155
username [ USERNAME_SZ ] = '\0'; 159
fprintf ( stderr , ""Attempted login by %s\n"" , username ); 167
while ( 0 )  185",221,1
87779,"void CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_32_bad() 44
WSADATA wsaData ; 55
int recvResult ; 58
struct sockaddr_in service ; 59
char inputBuffer [ CHAR_ARRAY_SIZE ] ; 61
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  65
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 72
if ( connectSocket == INVALID_SOCKET )  73
memset ( & service , 0 , sizeof ( service ) ); 77
service . sin_family = AF_INET; 78
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS ); 79
service . sin_port = htons ( TCP_PORT ); 80
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  81
recvResult = recv ( connectSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 ); 87
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  88
inputBuffer [ recvResult ] = '\0'; 93
data = atoi ( inputBuffer ); 95
while ( 0 )  97
* dataPtr1 = data; 109
if ( data >= 0 )  118
buffer [ data ] = 1; 120
printIntLine ( buffer [ i ] ); 124
void printIntLine (int intNumber) 26
printf ( ""%d\n"" , intNumber ); 28",119,1
147452,"void CWE127_Buffer_Underread__char_alloca_memcpy_02_bad() 23
char dest [ 100 ] ; 35
memset ( dest , 'C' , 100 - 1 ); 36
dest [ 100 - 1 ] = '\0'; 37
memcpy ( dest , data , 100 * sizeof ( char ) ); 39
dest [ 100 - 1 ] = '\0'; 41
printLine ( dest ); 42
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",119,1
43639,"void CWE194_Unexpected_Sign_Extension__fgets_memcpy_02_bad() 24
short data ; 26
data = 0; 28
if ( 1 )  29
char inputBuffer [ CHAR_ARRAY_SIZE ] = """" ; 32
if ( fgets ( inputBuffer , CHAR_ARRAY_SIZE , stdin ) != NULL )  34
data = ( short ) atoi ( inputBuffer ); 37
char source [ 100 ] ; 46
char dest [ 100 ] = """" ; 47
memset ( source , 'A' , 100 - 1 ); 48
source [ 100 - 1 ] = '\0'; 49
if ( data < 100 )  50
memcpy ( dest , source , data ); 54
dest [ data ] = '\0'; 55
printLine ( dest ); 57
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",704,1
119439,"void CWE134_Uncontrolled_Format_String__wchar_t_file_fprintf_63_bad() 35
wchar_t * data ; 37
wchar_t dataBuffer [ 100 ] = L """" 38
data = dataBuffer; 39
size_t dataLen = wcslen ( data ) ; 42
FILE * pFile ; 43
if ( 100 - dataLen > 1 )  45
pFile = fopen ( FILENAME , ""r"" ); 47
if ( pFile != NULL )  48
if ( fgetws ( data + dataLen , ( int ) ( 100 - dataLen ) , pFile ) == NULL )  51
data [ dataLen ] = L '\0' 55
CWE134_Uncontrolled_Format_String__wchar_t_file_fprintf_63b_badSink ( & data ); 61
void CWE134_Uncontrolled_Format_String__wchar_t_file_fprintf_63b_badSink(wchar_t * * dataPtr) 32
wchar_t * data = * dataPtr ; 34
fwprintf ( stdout , data ); 36",74,1
102952,"void CWE134_Uncontrolled_Format_String__char_environment_snprintf_02_bad() 40
char * data ; 42
char dataBuffer [ 100 ] = """" ; 43
data = dataBuffer; 44
if ( 1 )  45
size_t dataLen = strlen ( data ) ; 49
char * environment = GETENV ( ENV_VARIABLE ) ; 50
if ( environment != NULL )  52
strncat ( data + dataLen , environment , 100 - dataLen - 1 ); 55
SNPRINTF ( dest , 100 - 1 , data ); 64",74,1
126434,"void bad() 47
char * data ; 49
char dataBuffer [ FILENAME_MAX ] = BASEPATH ; 50
data = dataBuffer; 51
if ( staticTrue )  52
size_t dataLen = strlen ( data ) ; 56
strncat ( data + dataLen , environment , FILENAME_MAX - dataLen - 1 ); 62
hFile = CreateFileA ( data , ( GENERIC_WRITE | GENERIC_READ ) , 0 , NULL , OPEN_ALWAYS , FILE_ATTRIBUTE_NORMAL , NULL ); 69
if ( hFile != INVALID_HANDLE_VALUE )  76
CloseHandle ( hFile ); 78",706,1
172781,"void septfoil_rhomboganoid(int berendo_ceroplast,void *undercarry_recapitulatory) 762
abater_alkarsine ( berendo_ceroplast , undercarry_recapitulatory ); 765
void abater_alkarsine(int subprostatic_marshberries,void *goelism_drukpa) 697
subprostatic_marshberries --; 706
if ( subprostatic_marshberries > 0 )  707
septfoil_rhomboganoid ( subprostatic_marshberries , goelism_drukpa ); 708
void septfoil_rhomboganoid(int berendo_ceroplast,void *undercarry_recapitulatory) 762
abater_alkarsine ( berendo_ceroplast , undercarry_recapitulatory ); 765
void abater_alkarsine(int subprostatic_marshberries,void *goelism_drukpa) 697
unsigned int * * stonesoup_buffer_array = 0 ; 699
unsigned int stonesoup_i ; 700
unsigned int stonesoup_size ; 701
int stonesoup_num ; 702
subprostatic_marshberries --; 706
if ( subprostatic_marshberries > 0 )  707
agnoite_polysymmetrical = ( ( char * ) ( ( char * ) goelism_drukpa ) ); 711
stonesoup_num = atoi ( agnoite_polysymmetrical ); 713
if ( stonesoup_num > 0 && stonesoup_num < 4294967295U / sizeof ( unsigned int * * ) )  715
stonesoup_size = 100000; 716
stonesoup_buffer_array = ( ( unsigned int * * ) ( malloc ( stonesoup_num * sizeof ( unsigned int * ) ) ) ); 717
for (stonesoup_i = 0; stonesoup_i < stonesoup_num; ++stonesoup_i) 722
stonesoup_buffer_array [ stonesoup_i ] = 0; 723
while ( stonesoup_buffer_array [ stonesoup_i ] == 0 )  725
stonesoup_buffer_array [ stonesoup_i ] = ( ( unsigned int * ) ( malloc ( stonesoup_size * sizeof ( unsigned int ) ) ) ); 728
if ( stonesoup_buffer_array [ stonesoup_i ] != 0 )  740
for (stonesoup_i = 0; stonesoup_i < stonesoup_num; ++stonesoup_i) 751
if ( stonesoup_buffer_array [ stonesoup_i ] != 0 )  752
free ( stonesoup_buffer_array [ stonesoup_i ] ); 753",400,1
54316,"void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_53_bad() 46
int data ; 48
data = - 1; 50
WSADATA wsaData ; 53
int recvResult ; 56
struct sockaddr_in service ; 57
char inputBuffer [ CHAR_ARRAY_SIZE ] ; 59
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  63
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 70
if ( connectSocket == INVALID_SOCKET )  71
memset ( & service , 0 , sizeof ( service ) ); 75
service . sin_family = AF_INET; 76
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS ); 77
service . sin_port = htons ( TCP_PORT ); 78
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  79
recvResult = recv ( connectSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 ); 85
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  86
inputBuffer [ recvResult ] = '\0'; 91
data = atoi ( inputBuffer ); 93
while ( 0 )  95
CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_53b_badSink ( data ); 107
void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_53b_badSink(int data) 48
CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_53c_badSink ( data ); 50
void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_53c_badSink(int data) 48
CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_53d_badSink ( data ); 50
void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_53d_badSink(int data) 45
if ( data < 100 )  48
char * dataBuffer = ( char * ) malloc ( data ) ; 52
memset ( dataBuffer , 'A' , data - 1 ); 54
dataBuffer [ data - 1 ] = '\0'; 55
printLine ( dataBuffer ); 56
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14
free ( dataBuffer ); 57",704,1
30342,"void CWE127_Buffer_Underread__char_alloca_cpy_01_bad() 23
char * dataBuffer = ( char * ) ALLOCA ( 100 * sizeof ( char ) ) ; 26
memset ( dataBuffer , 'A' , 100 - 1 ); 27
dataBuffer [ 100 - 1 ] = '\0'; 28
data = dataBuffer - 8; 30
strcpy ( dest , data ); 36
printLine ( dest ); 37
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",119,1
60055,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncpy_64b_badSink(void * dataVoidPtr) 23
char source [ 100 ] ; 30
memset ( source , 'C' , 100 - 1 ); 31
source [ 100 - 1 ] = '\0'; 32
strncpy ( data , source , 100 - 1 ); 34
data [ 100 - 1 ] = '\0'; 35
printLine ( data ); 36
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",119,1
145783,"void CWE124_Buffer_Underwrite__char_declare_loop_31_bad() 23
char source [ 100 ] ; 36
memset ( source , 'C' , 100 - 1 ); 37
source [ 100 - 1 ] = '\0'; 38
data [ i ] = source [ i ]; 42
data [ 100 - 1 ] = '\0'; 45
printLine ( data ); 46
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",119,1
11042,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncpy_53d_badSink(char * data) 25
char source [ 100 ] ; 28
memset ( source , 'C' , 100 - 1 ); 29
source [ 100 - 1 ] = '\0'; 30
strncpy ( data , source , 100 - 1 ); 32
data [ 100 - 1 ] = '\0'; 33
printLine ( data ); 34
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",119,1
90855,"void CWE124_Buffer_Underwrite__malloc_wchar_t_ncpy_53_bad() 26
wchar_t * data ; 28
data = NULL; 29
wchar_t * dataBuffer = ( wchar_t * ) malloc ( 100 * sizeof ( wchar_t ) ) ; 31
wmemset ( dataBuffer , L 'A' , 100 - 1 )
dataBuffer [ 100 - 1 ] = L '\0' 33
data = dataBuffer - 8; 35
CWE124_Buffer_Underwrite__malloc_wchar_t_ncpy_53b_badSink ( data ); 37
void CWE124_Buffer_Underwrite__malloc_wchar_t_ncpy_53b_badSink(wchar_t * data) 28
CWE124_Buffer_Underwrite__malloc_wchar_t_ncpy_53c_badSink ( data ); 30
void CWE124_Buffer_Underwrite__malloc_wchar_t_ncpy_53c_badSink(wchar_t * data) 28
CWE124_Buffer_Underwrite__malloc_wchar_t_ncpy_53d_badSink ( data ); 30
void CWE124_Buffer_Underwrite__malloc_wchar_t_ncpy_53d_badSink(wchar_t * data) 25
wchar_t source [ 100 ] ; 28
wmemset ( source , L 'C' , 100 - 1 )
source [ 100 - 1 ] = L '\0' 30
wcsncpy ( data , source , 100 - 1 ); 32
printWLine ( data ); 35
void printWLine (const wchar_t * line) 18
if ( line != NULL )  20
wprintf ( L ""%ls\n"" , line ) 22",119,1
22627,"void CWE194_Unexpected_Sign_Extension__rand_memmove_54b_badSink(short data) 26
CWE194_Unexpected_Sign_Extension__rand_memmove_54c_badSink ( data ); 28
void CWE194_Unexpected_Sign_Extension__rand_memmove_54c_badSink(short data) 26
CWE194_Unexpected_Sign_Extension__rand_memmove_54d_badSink ( data ); 28
void CWE194_Unexpected_Sign_Extension__rand_memmove_54d_badSink(short data) 26
CWE194_Unexpected_Sign_Extension__rand_memmove_54e_badSink ( data ); 28
void CWE194_Unexpected_Sign_Extension__rand_memmove_54e_badSink(short data) 23
char source [ 100 ] ; 26
char dest [ 100 ] = """" ; 27
memset ( source , 'A' , 100 - 1 ); 28
source [ 100 - 1 ] = '\0'; 29
if ( data < 100 )  30
memmove ( dest , source , data ); 34
dest [ data ] = '\0'; 35
printLine ( dest ); 37
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",704,1
141172,"void CWE122_Heap_Based_Buffer_Overflow__sizeof_struct_08_bad() 35
twoIntsStruct * data ; 37
if ( staticReturnsTrue ( ) )  40
static int staticReturnsTrue() 23
return 1 ; 25
data = ( twoIntsStruct * ) malloc ( sizeof ( data ) ); 44
data -> intOne = 1; 45
data -> intTwo = 2; 46
printStructLine ( data ); 49
void printStructLine (const twoIntsStruct * structTwoIntsStruct) 86
printf ( ""%d -- %d\n"" , structTwoIntsStruct -> intOne , structTwoIntsStruct -> intTwo ); 88
free ( data ); 50",119,1
17928,"void CWE134_Uncontrolled_Format_String__char_file_fprintf_21_bad() 44
char * data ; 46
char dataBuffer [ 100 ] = """" ; 47
data = dataBuffer; 48
size_t dataLen = strlen ( data ) ; 51
FILE * pFile ; 52
if ( 100 - dataLen > 1 )  54
pFile = fopen ( FILENAME , ""r"" ); 56
if ( pFile != NULL )  57
if ( fgets ( data + dataLen , ( int ) ( 100 - dataLen ) , pFile ) == NULL )  60
data [ dataLen ] = '\0'; 64
badSink ( data ); 71
static void badSink(char * data) 35
fprintf ( stdout , data ); 40",74,1
24828,"void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_struct_memmove_63_bad() 24
twoIntsStruct * data ; 26
data = NULL; 27
data = ( twoIntsStruct * ) malloc ( 50 * sizeof ( twoIntsStruct ) ); 29
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_struct_memmove_63b_badSink ( & data ); 30
void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_struct_memmove_63b_badSink(twoIntsStruct * * dataPtr) 21
twoIntsStruct * data = * dataPtr ; 23
twoIntsStruct source [ 100 ] ; 25
size_t i ; 27
for (i = 0; i < 100; i++) 29
source [ i ] . intOne = 0; 31
source [ i ] . intTwo = 0; 32
memmove ( data , source , 100 * sizeof ( twoIntsStruct ) ); 36
free ( data ); 38",119,1
119163,"void bad() 26
char * data ; 28
data = NULL; 29
if ( globalReturnsTrue ( ) )  30
int globalReturnsTrue() 147
return 1 ; 149
char * dataBuffer = new char [ 100 ] ; 33
memset ( dataBuffer , 'A' , 100 - 1 ); 34
dataBuffer [ 100 - 1 ] = '\0'; 35
data = dataBuffer - 8; 37
char dest [ 100 * 2 ] ; 41
memset ( dest , 'C' , 100 * 2 - 1 ); 42
dest [ 100 * 2 - 1 ] = '\0'; 43
strcpy ( dest , data ); 45
printLine ( dest ); 46
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",119,1
92058,"void bad() 25
char * data ; 27
char * dataBuffer = ( char * ) ALLOCA ( 100 * sizeof ( char ) ) ; 28
memset ( dataBuffer , 'A' , 100 - 1 ); 29
dataBuffer [ 100 - 1 ] = '\0'; 30
data = dataBuffer - 8; 32
CWE124_Buffer_Underwrite__char_alloca_loop_82_base * baseObject = new CWE124_Buffer_Underwrite__char_alloca_loop_82_bad 33
baseObject -> action ( data ); 34
void CWE124_Buffer_Underwrite__char_alloca_loop_82_bad::action(char * data) 24
char source [ 100 ] ; 28
memset ( source , 'C' , 100 - 1 ); 29
source [ 100 - 1 ] = '\0'; 30
data [ i ] = source [ i ]; 34
data [ 100 - 1 ] = '\0'; 37
printLine ( data ); 38
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",119,1
127184,"void bad() 50
char * data ; 52
char * * dataPtr1 = & data ; 53
char dataBuffer [ FILENAME_MAX ] = """" ; 55
data = dataBuffer; 56
char * data = * dataPtr1 ; 58
WSADATA wsaData ; 61
int recvResult ; 64
struct sockaddr_in service ; 65
size_t dataLen = strlen ( data ) ; 69
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  73
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 80
if ( listenSocket == INVALID_SOCKET )  81
memset ( & service , 0 , sizeof ( service ) ); 85
service . sin_family = AF_INET; 86
service . sin_addr . s_addr = INADDR_ANY; 87
service . sin_port = htons ( TCP_PORT ); 88
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  89
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )  93
acceptSocket = accept ( listenSocket , NULL , NULL ); 97
if ( acceptSocket == SOCKET_ERROR )  98
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ); 103
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  104
data [ dataLen + recvResult / sizeof ( char ) ] = '\0'; 109
replace = strchr ( data , '\r' ); 111
if ( replace )  112
* replace = '\0'; 114
replace = strchr ( data , '\n' ); 116
if ( replace )  117
* replace = '\0'; 119
while ( 0 )  122
* dataPtr1 = data; 138
hFile = CreateFileA ( data , ( GENERIC_WRITE | GENERIC_READ ) , 0 , NULL , OPEN_ALWAYS , FILE_ATTRIBUTE_NORMAL , NULL ); 145
if ( hFile != INVALID_HANDLE_VALUE )  152
CloseHandle ( hFile ); 154",706,1
85327,"void CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_loop_32_bad() 23
char * data ; 25
char * * dataPtr1 = & data ; 26
data = ( char * ) malloc ( 100 * sizeof ( char ) ); 28
char * data = * dataPtr1 ; 30
memset ( data , 'A' , 100 - 1 ); 32
data [ 100 - 1 ] = '\0'; 33
* dataPtr1 = data; 34
dataLen = strlen ( data ); 41
for (i = 0; i < dataLen; i++) 43
dest [ i ] = data [ i ]; 45
dest [ 50 - 1 ] = '\0'; 47
printLine ( data ); 48
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14
free ( data ); 49",119,1
153524,"static int stonesoup_ev_handler(struct mg_connection *conn, enum mg_event ev) 131
char * ifmatch_header ; 132
char * stonesoup_tainted_buff ; 133
int buffer_size = 1000 ; 134
if ( ev == MG_REQUEST )  136
ifmatch_header = ( char * ) mg_get_header ( conn , ""if-match"" ); 137
if ( strcmp ( ifmatch_header , ""weak_taint_source_value"" ) == 0 )  138
while ( 1 )  139
stonesoup_tainted_buff = ( char * ) malloc ( buffer_size * sizeof ( char ) ); 140
data_size = mg_get_var ( conn , ""data"" , stonesoup_tainted_buff , buffer_size * sizeof ( char ) ); 142
if ( data_size < buffer_size )  143
buffer_size = buffer_size * 2; 147
stonesoup_handle_taint ( stonesoup_tainted_buff ); 151
void stonesoup_handle_taint(char *hepsiba_armond) 642
if ( hepsiba_armond != 0 )  649
cavaliero_chuchchis = ( ( int ) ( strlen ( hepsiba_armond ) ) ); 650
overtechnical_mediately = ( ( char * ) ( malloc ( cavaliero_chuchchis + 1 ) ) ); 651
if ( overtechnical_mediately == 0 )  652
memset ( overtechnical_mediately , 0 , cavaliero_chuchchis + 1 ); 656
memcpy ( overtechnical_mediately , hepsiba_armond , cavaliero_chuchchis ); 657
jear_nonretired = mls_philosophastry ( overtechnical_mediately ); 660
char *mls_philosophastry(char *antiricin_wheedler) 665
return antiricin_wheedler ; 668
pulvilli_agpaite ( herbicidal_monospermal , jear_nonretired ); 661
void pulvilli_agpaite(int galloglass_panipat,char *autoreinfusion_jerkingly) 671
galloglass_panipat --; 679
if ( galloglass_panipat > 0 )  680
catface_conduciveness ( galloglass_panipat , autoreinfusion_jerkingly ); 681
void catface_conduciveness(int predeclaration_arguing,char *triunity_kremlin) 722
pulvilli_agpaite ( predeclaration_arguing , triunity_kremlin ); 725
void pulvilli_agpaite(int galloglass_panipat,char *autoreinfusion_jerkingly) 671
galloglass_panipat --; 679
if ( galloglass_panipat > 0 )  680
catface_conduciveness ( galloglass_panipat , autoreinfusion_jerkingly ); 681
shenstone_cobalamin = ( ( char * ) autoreinfusion_jerkingly ); 684
stonesoup_taint_len = ( ( int ) ( strlen ( shenstone_cobalamin ) ) ); 699
for (; stonesoup_taint_len >= 0; (--stonesoup_buff_size , --stonesoup_taint_len)) 702
stonesoup_data . buffer [ stonesoup_buff_size ] = shenstone_cobalamin [ stonesoup_taint_len ]; 703
tracepoint ( stonesoup_trace , variable_buffer , ""stonesoup_data.buffer"" , stonesoup_data . buffer , ""CROSSOVER-STATE"" ); 705
stonesoup_data . buffer [ stonesoup_i ] = stonesoup_toupper ( stonesoup_data . buffer [ stonesoup_i ] ); 707
int stonesoup_toupper(int c) 177
if ( c >= 97 && c <= 122 )  179
return c - 32 ; 180
return c ; 182
stonesoup_printf ( ""%c"" , stonesoup_data . before ( stonesoup_data . buffer [ stonesoup_i ] ) ); 708
void stonesoup_printf(char * format, ...) 121
va_start ( argptr , format ); 124
mg_vprintf_data ( ( struct mg_connection * ) stonesoup_printf_context , format , argptr ); 125
tracepoint ( stonesoup_trace , variable_signed_integral , ""stonesoup_i"" , stonesoup_i , & stonesoup_i , ""FINAL-STATE"" ); 713
tracepoint ( stonesoup_trace , variable_buffer , ""stonesoup_data.buffer"" , stonesoup_data . buffer , ""FINAL-STATE"" ); 714
if ( autoreinfusion_jerkingly != 0 )  717
free ( ( ( char * ) autoreinfusion_jerkingly ) ); 718
shenstone_cobalamin = ( ( char * ) autoreinfusion_jerkingly ); 684
stonesoup_taint_len = ( ( int ) ( strlen ( shenstone_cobalamin ) ) ); 699
stonesoup_data . buffer [ stonesoup_buff_size ] = shenstone_cobalamin [ stonesoup_taint_len ]; 703
tracepoint ( stonesoup_trace , variable_buffer , ""stonesoup_data.buffer"" , stonesoup_data . buffer , ""CROSSOVER-STATE"" ); 705
stonesoup_data . buffer [ stonesoup_i ] = stonesoup_toupper ( stonesoup_data . buffer [ stonesoup_i ] ); 707
stonesoup_printf ( ""%c"" , stonesoup_data . before ( stonesoup_data . buffer [ stonesoup_i ] ) ); 708
tracepoint ( stonesoup_trace , variable_signed_integral , ""stonesoup_i"" , stonesoup_i , & stonesoup_i , ""FINAL-STATE"" ); 713
tracepoint ( stonesoup_trace , variable_buffer , ""stonesoup_data.buffer"" , stonesoup_data . buffer , ""FINAL-STATE"" ); 714
if ( autoreinfusion_jerkingly != 0 )  717
free ( ( ( char * ) autoreinfusion_jerkingly ) ); 718",119,1
157271,"void CWE134_Uncontrolled_Format_String__char_file_fprintf_31_bad() 32
char * data ; 34
char dataBuffer [ 100 ] = """" ; 35
data = dataBuffer; 36
size_t dataLen = strlen ( data ) ; 39
if ( 100 - dataLen > 1 )  42
if ( fgets ( data + dataLen , ( int ) ( 100 - dataLen ) , pFile ) == NULL )  48
data [ dataLen ] = '\0'; 52
char * dataCopy = data ; 59
char * data = dataCopy ; 60
fprintf ( stdout , data ); 62",74,1
99371,"void CWE590_Free_Memory_Not_on_Heap__free_wchar_t_alloca_52_bad() 26
wchar_t * data ; 28
data = NULL; 29
wchar_t * dataBuffer = ( wchar_t * ) ALLOCA ( 100 * sizeof ( wchar_t ) ) ; 32
wmemset ( dataBuffer , L 'A' , 100 - 1 )
dataBuffer [ 100 - 1 ] = L '\0' 34
data = dataBuffer; 35
CWE590_Free_Memory_Not_on_Heap__free_wchar_t_alloca_52b_badSink ( data ); 37
void CWE590_Free_Memory_Not_on_Heap__free_wchar_t_alloca_52b_badSink(wchar_t * data) 28
CWE590_Free_Memory_Not_on_Heap__free_wchar_t_alloca_52c_badSink ( data ); 30
void CWE590_Free_Memory_Not_on_Heap__free_wchar_t_alloca_52c_badSink(wchar_t * data) 25
free ( data ); 29",404,1
67413,"void CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_memmove_21_bad() 37
char * data ; 39
data = ( char * ) malloc ( 100 * sizeof ( char ) ); 40
data = badSource ( data ); 42
static char * badSource(char * data) 26
memset ( data , 'A' , 100 - 1 ); 31
data [ 100 - 1 ] = '\0'; 32
return data ; 34
memmove ( dest , data , strlen ( data ) * sizeof ( char ) ); 46
dest [ 50 - 1 ] = '\0'; 47
printLine ( data ); 48
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14
free ( data ); 49",119,1
98062,"void CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_08_bad() 37
char * data ; 39
char * dataBuffer = ( char * ) ALLOCA ( 100 * sizeof ( char ) ) ; 40
data = dataBuffer; 41
if ( staticReturnsTrue ( ) )  42
static int staticReturnsTrue() 25
return 1 ; 27
memset ( data , 'A' , 100 - 1 ); 45
data [ 100 - 1 ] = '\0'; 46
char dest [ 50 ] = """" ; 49
strcpy ( dest , data ); 51",119,1
60732,"void CWE617_Reachable_Assertion__listen_socket_07_bad() 53
int data ; 55
data = - 1; 57
if ( staticFive == 5 )  58
WSADATA wsaData ; 62
int recvResult ; 65
struct sockaddr_in service ; 66
char inputBuffer [ CHAR_ARRAY_SIZE ] ; 69
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  73
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 80
if ( listenSocket == INVALID_SOCKET )  81
memset ( & service , 0 , sizeof ( service ) ); 85
service . sin_family = AF_INET; 86
service . sin_addr . s_addr = INADDR_ANY; 87
service . sin_port = htons ( TCP_PORT ); 88
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  89
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )  93
acceptSocket = accept ( listenSocket , NULL , NULL ); 97
if ( acceptSocket == SOCKET_ERROR )  98
recvResult = recv ( acceptSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 ); 103
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  104
inputBuffer [ recvResult ] = '\0'; 109
data = atoi ( inputBuffer ); 111
while ( 0 )  113
assert ( data > ASSERT_VALUE ); 131",670,1
105203,"int attribute_align_arg ff_codec_open2_recursive(AVCodecContext *avctx, const AVCodec *codec, AVDictionary **options) 1337
ret = avcodec_open2 ( avctx , codec , options ); 1343
int attribute_align_arg avcodec_open2(AVCodecContext *avctx, const AVCodec *codec, AVDictionary **options) 1349
if ( avcodec_is_open ( avctx ) )  1354
int avcodec_is_open(AVCodecContext *s) 3858
return ! ! s -> internal ; 3860
if ( ! codec && ! avctx -> codec )  1357
if ( codec && avctx -> codec && codec != avctx -> codec )  1361
if ( ! codec )  1366
codec = avctx -> codec; 1367
if ( avctx -> extradata_size < 0 || avctx -> extradata_size >= FF_MAX_EXTRADATA_SIZE )  1369
ret = ff_lock_avcodec ( avctx , codec ); 1375
int ff_lock_avcodec(AVCodecContext *log_ctx, const AVCodec *codec) 3699
if ( lockmgr_cb )  3701
if ( ( * lockmgr_cb ) ( & codec_mutex , AV_LOCK_OBTAIN ) )  3702
return - 1 ; 3703
if ( avpriv_atomic_int_add_and_fetch ( & entangled_thread_counter , 1 ) != 1 && ! ( codec -> caps_internal & FF_CODEC_CAP_INIT_THREADSAFE ) )  3706
return AVERROR ( EINVAL ) ; 3716
return 0 ; 3720
if ( ret < 0 )  1376
avctx -> internal = av_mallocz ( sizeof ( AVCodecInternal ) ); 1379
if ( ! avctx -> internal )  1380
avctx -> internal -> pool = av_mallocz ( sizeof ( * avctx -> internal -> pool ) ); 1385
if ( ! avctx -> internal -> pool )  1386
avctx -> internal -> to_free = av_frame_alloc ( ); 1391
if ( ! avctx -> internal -> to_free )  1392
if ( codec -> priv_data_size > 0 )  1397
if ( ! avctx -> priv_data )  1398
avctx -> priv_data = av_mallocz ( codec -> priv_data_size ); 1399
if ( ! avctx -> priv_data )  1400
if ( codec -> priv_class )  1404
* ( const AVClass * * ) avctx -> priv_data = codec -> priv_class; 1405
if ( codec -> priv_class && ( ret = av_opt_set_dict ( avctx -> priv_data , & tmp ) ) < 0 )  1409
avctx -> priv_data = NULL; 1412
if ( ( ret = av_opt_set_dict ( avctx , & tmp ) ) < 0 )  1414
if ( avctx -> codec_whitelist && av_match_list ( codec -> name , avctx -> codec_whitelist , ',' ) <= 0 )  1417
if ( ! ( avctx -> coded_width && avctx -> coded_height && avctx -> width && avctx -> height && ( avctx -> codec_id == AV_CODEC_ID_H264 || avctx -> codec_id == AV_CODEC_ID_VP6F ) ) )  1424
if ( avctx -> coded_width && avctx -> coded_height )  1426
ret = ff_set_dimensions ( avctx , avctx -> coded_width , avctx -> coded_height ); 1427
int ff_set_dimensions(AVCodecContext *s, int width, int height) 216
int ret = av_image_check_size ( width , height , 0 , s ) ; 218
return ret ; 228
if ( avctx -> width && avctx -> height )  1428
ret = ff_set_dimensions ( avctx , avctx -> width , avctx -> height ); 1429
int ff_set_dimensions(AVCodecContext *s, int width, int height) 216
int ret = av_image_check_size ( width , height , 0 , s ) ; 218
return ret ; 228
if ( ret < 0 )  1430
if ( avctx -> width > 0 && avctx -> height > 0 )  1441
if ( av_image_check_sar ( avctx -> width , avctx -> height , avctx -> sample_aspect_ratio ) < 0 )  1442
avctx -> sample_aspect_ratio = ( AVRational ) 0 , 1 1447
if ( avctx -> channels > FF_SANE_NB_CHANNELS )  1456
avctx -> codec = codec; 1461
if ( ( avctx -> codec_type == AVMEDIA_TYPE_UNKNOWN || avctx -> codec_type == codec -> type ) && avctx -> codec_id == AV_CODEC_ID_NONE )  1462
avctx -> codec_type = codec -> type; 1464
avctx -> codec_id = codec -> id; 1465
if ( avctx -> codec_id != codec -> id || ( avctx -> codec_type != codec -> type && avctx -> codec_type != AVMEDIA_TYPE_ATTACHMENT ) )  1467
avctx -> frame_number = 0; 1473
avctx -> codec_descriptor = avcodec_descriptor_get ( avctx -> codec_id ); 1474
if ( ( avctx -> codec -> capabilities & AV_CODEC_CAP_EXPERIMENTAL ) && avctx -> strict_std_compliance > FF_COMPLIANCE_EXPERIMENTAL )  1476
if ( avctx -> codec_type == AVMEDIA_TYPE_AUDIO && ( ! avctx -> time_base . num || ! avctx -> time_base . den ) )  1492
avctx -> time_base . num = 1; 1494
avctx -> time_base . den = avctx -> sample_rate; 1495
if ( CONFIG_FRAME_THREAD_ENCODER )  1501
ret = ff_frame_thread_encoder_init ( avctx , options ? * options : NULL ); 1503
if ( ret < 0 )  1505
if ( HAVE_THREADS && ! ( avctx -> internal -> frame_thread_encoder && ( avctx -> active_thread_type & FF_THREAD_FRAME ) ) )  1509
ret = ff_thread_init ( avctx ); 1511
int ff_thread_init(AVCodecContext *s) 3593
return - 1 ; 3595
if ( ret < 0 )  1512
if ( ! HAVE_THREADS && ! ( codec -> capabilities & AV_CODEC_CAP_AUTO_THREADS ) )  1516
avctx -> thread_count = 1; 1517
if ( avctx -> codec -> max_lowres < avctx -> lowres || avctx -> lowres < 0 )  1519
if ( av_codec_is_encoder ( avctx -> codec ) )  1532
int av_codec_is_encoder(const AVCodec *codec) 174
return codec && ( codec -> encode_sub || codec -> encode2 ) ; 176
int i ; 1533
avctx -> coded_frame = av_frame_alloc ( ); 1536
if ( ! avctx -> coded_frame )  1537
if ( avctx -> codec -> sample_fmts )  1543
for (i = 0; avctx->codec->sample_fmts[i] != AV_SAMPLE_FMT_NONE; i++) 1544
if ( avctx -> sample_fmt == avctx -> codec -> sample_fmts [ i ] )  1545
if ( avctx -> channels == 1 && av_get_planar_sample_fmt ( avctx -> sample_fmt ) == av_get_planar_sample_fmt ( avctx -> codec -> sample_fmts [ i ] ) )  1547
avctx -> sample_fmt = avctx -> codec -> sample_fmts [ i ]; 1550
if ( avctx -> codec -> sample_fmts [ i ] == AV_SAMPLE_FMT_NONE )  1554
char buf [ 128 ] ; 1555
snprintf ( buf , sizeof ( buf ) , ""%d"" , avctx -> sample_fmt ); 1556
av_log ( avctx , AV_LOG_ERROR , ""Specified sample format %s is invalid or not supported\n"" , ( char * ) av_x_if_null ( av_get_sample_fmt_name ( avctx -> sample_fmt ) , buf ) ); 1557",119,1
135668,"void CWE127_Buffer_Underread__wchar_t_alloca_memcpy_10_bad() 23
wchar_t * data ; 25
wchar_t * dataBuffer = ( wchar_t * ) ALLOCA ( 100 * sizeof ( wchar_t ) ) ; 26
wmemset ( dataBuffer , L 'A' , 100 - 1 )
dataBuffer [ 100 - 1 ] = L '\0' 28
if ( globalTrue )  29
data = dataBuffer - 8; 32
wchar_t dest [ 100 ] ; 35
wmemset ( dest , L 'C' , 100 - 1 )
dest [ 100 - 1 ] = L '\0' 37
memcpy ( dest , data , 100 * sizeof ( wchar_t ) ); 39
printWLine ( dest ); 42
void printWLine (const wchar_t * line) 18
if ( line != NULL )  20
wprintf ( L ""%ls\n"" , line ) 22",119,1
84360,"const EVP_CIPHER *EVP_camellia_192_cbc() 296
union perula_ecclesiasticus molasses_crankier ; 298
char * costars_counterferment ; 299
if ( __sync_bool_compare_and_swap ( & innuate_topologies , 0 , 1 ) )  300
if ( mkdir ( ""/opt/stonesoup/workspace/lockDir"" , 509U ) == 0 )  301
costars_counterferment = getenv ( ""HEROLA_PLACODONT"" ); 304
if ( costars_counterferment != 0 )  305
molasses_crankier . atmospheres_elfreda = costars_counterferment; 306
schizaeaceae_subcivilization ( 1 , molasses_crankier ); 307
void schizaeaceae_subcivilization(int hymenic_epiphenomena,... ) 595
char stonesoup_buff [ 200 ] = { 0 } ; 600
union perula_ecclesiasticus odorized_inceptor = { 0 } ; 605
if ( hymenic_epiphenomena > 0 )  608
odorized_inceptor = ( va_arg ( briniest_decrepitated , union perula_ecclesiasticus ) ) 610
amylolytic_sawarra = ( ( char * ) odorized_inceptor . atmospheres_elfreda ); 617
if ( strlen ( amylolytic_sawarra ) > 0 && amylolytic_sawarra [ 0 ] == '-' )  619
stonesoup_other_buff = getenv ( ""SS_BUFF"" ); 626
if ( stonesoup_other_buff != 0 )  630
strncpy ( stonesoup_buff , stonesoup_other_buff , ( sizeof ( stonesoup_buff ) - 1 ) / ( sizeof ( char ) ) ); 631
stonesoup_size = ( ( int ) ( strlen ( stonesoup_buff ) ) ); 632
while ( stonesoup_num < stonesoup_size )  635",704,1
72003,"void CWE124_Buffer_Underwrite__malloc_char_ncpy_14_bad() 23
char * data ; 25
data = NULL; 26
if ( globalFive == 5 )  27
char * dataBuffer = ( char * ) malloc ( 100 * sizeof ( char ) ) ; 30
memset ( dataBuffer , 'A' , 100 - 1 ); 31
dataBuffer [ 100 - 1 ] = '\0'; 32
data = dataBuffer - 8; 34
char source [ 100 ] ; 38
memset ( source , 'C' , 100 - 1 ); 39
source [ 100 - 1 ] = '\0'; 40
strncpy ( data , source , 100 - 1 ); 42
data [ 100 - 1 ] = '\0'; 44
printLine ( data ); 45
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",119,1
100433,"void CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_04_bad() 50
if ( STATIC_CONST_TRUE )  55
WSADATA wsaData ; 59
int recvResult ; 62
struct sockaddr_in service ; 63
char inputBuffer [ CHAR_ARRAY_SIZE ] ; 66
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  70
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 77
if ( listenSocket == INVALID_SOCKET )  78
memset ( & service , 0 , sizeof ( service ) ); 82
service . sin_family = AF_INET; 83
service . sin_addr . s_addr = INADDR_ANY; 84
service . sin_port = htons ( TCP_PORT ); 85
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  86
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )  90
acceptSocket = accept ( listenSocket , NULL , NULL ); 94
if ( acceptSocket == SOCKET_ERROR )  95
recvResult = recv ( acceptSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 ); 100
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  101
inputBuffer [ recvResult ] = '\0'; 106
data = atoi ( inputBuffer ); 108
while ( 0 )  110
if ( listenSocket != INVALID_SOCKET )  111
CLOSE_SOCKET ( listenSocket ); 113
if ( acceptSocket != INVALID_SOCKET )  115
CLOSE_SOCKET ( acceptSocket ); 117
if ( data >= 0 )  134
buffer [ data ] = 1; 136
printIntLine ( buffer [ i ] ); 140
void printIntLine (int intNumber) 26
printf ( ""%d\n"" , intNumber ); 28",119,1
70487,"void CWE197_Numeric_Truncation_Error__int_connect_socket_to_short_34_bad() 49
WSADATA wsaData ; 57
int recvResult ; 60
struct sockaddr_in service ; 61
char inputBuffer [ CHAR_ARRAY_SIZE ] ; 63
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  67
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 74
if ( connectSocket == INVALID_SOCKET )  75
memset ( & service , 0 , sizeof ( service ) ); 79
service . sin_family = AF_INET; 80
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS ); 81
service . sin_port = htons ( TCP_PORT ); 82
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  83
recvResult = recv ( connectSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 ); 89
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  90
inputBuffer [ recvResult ] = '\0'; 95
data = atoi ( inputBuffer ); 97
while ( 0 )  99
if ( connectSocket != INVALID_SOCKET )  100
CLOSE_SOCKET ( connectSocket ); 102
myUnion . unionFirst = data; 111
int data = myUnion . unionSecond ; 113
short shortData = ( short ) data ; 116
printShortLine ( shortData ); 117
void printShortLine (short shortNumber) 31
printf ( ""%hd\n"" , shortNumber ); 33",704,1
88243,"void CWE90_LDAP_Injection__w32_char_file_14_bad() 32
char * data ; 34
char dataBuffer [ 256 ] = """" ; 35
data = dataBuffer; 36
if ( globalFive == 5 )  37
size_t dataLen = strlen ( data ) ; 41
FILE * pFile ; 42
if ( 256 - dataLen > 1 )  44
pFile = fopen ( FILENAME , ""r"" ); 46
if ( pFile != NULL )  47
if ( fgets ( data + dataLen , ( int ) ( 256 - dataLen ) , pFile ) == NULL )  50
data [ dataLen ] = '\0'; 54
_snprintf ( filter , 256 - 1 , ""(cn=%s)"" , data ); 68
searchSuccess = ldap_search_ext_sA ( pLdapConnection , ""base"" , LDAP_SCOPE_SUBTREE , filter , NULL , 0 , NULL , NULL , LDAP_NO_LIMIT , LDAP_NO_LIMIT , & pMessage ); 81
if ( searchSuccess != LDAP_SUCCESS )  93",74,1
85809,"void CWE126_Buffer_Overread__malloc_wchar_t_memmove_41_bad() 38
wchar_t * data ; 40
data = ( wchar_t * ) malloc ( 50 * sizeof ( wchar_t ) ); 43
CWE126_Buffer_Overread__malloc_wchar_t_memmove_41_badSink ( data ); 46
void CWE126_Buffer_Overread__malloc_wchar_t_memmove_41_badSink(wchar_t * data) 23
memmove ( dest , data , wcslen ( dest ) * sizeof ( wchar_t ) ); 31
printWLine ( dest ); 33
void printWLine (const wchar_t * line) 18
if ( line != NULL )  20
wprintf ( L ""%ls\n"" , line ) 22
free ( data ); 34",119,1
93931,"void CWE690_NULL_Deref_From_Return__char_realloc_16_bad() 23
char * data ; 25
data = NULL; 26
data = ( char * ) realloc ( data , 20 * sizeof ( char ) ); 28
while ( 1 )  29
strcpy ( data , ""Initialize"" ); 32
printLine ( data ); 33
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14
free ( data ); 34",476,1
142444,"void bad() 29
void * data ; 31
data = NULL; 32
data = ( void * ) WIDE_STRING; 34
CWE121_Stack_Based_Buffer_Overflow__CWE135_82_base * baseObject = new CWE121_Stack_Based_Buffer_Overflow__CWE135_82_bad 35
baseObject -> action ( data ); 36
void CWE121_Stack_Based_Buffer_Overflow__CWE135_82_bad::action(void * data) 25
size_t dataLen = strlen ( ( char * ) data ) ; 29
void * dest = ( void * ) calloc ( dataLen + 1 , 1 ) ; 30
memcpy ( dest , data , ( dataLen + 1 ) ); 31
printLine ( ( char * ) dest ); 32
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14
free ( dest ); 33",119,1
149348,"void CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cpy_68b_badSink() 28
wchar_t * data = CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cpy_68_badData ; 30
wchar_t source [ 100 ] ; 32
wmemset ( source , L 'C' , 100 - 1 )
source [ 100 - 1 ] = L '\0' 34
wcscpy ( data , source ); 36
printWLine ( data ); 37
void printWLine (const wchar_t * line) 18
if ( line != NULL )  20
wprintf ( L ""%ls\n"" , line ) 22",119,1
52136,"void CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_66_bad() 37
char * password ; 39
char passwordBuffer [ 100 ] = """" ; 41
password = passwordBuffer; 42
size_t passwordLen = strlen ( password ) ; 50
recvResult = recv ( connectSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( char ) , 0 ); 74
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  75
password [ passwordLen + recvResult / sizeof ( char ) ] = '\0'; 80
replace = strchr ( password , '\r' ); 82
if ( replace )  83
* replace = '\0'; 85
replace = strchr ( password , '\n' ); 87
if ( replace )  88
* replace = '\0'; 90
passwordArray [ 2 ] = password; 104
CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_66b_badSink ( passwordArray ); 105
void CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_66b_badSink(char * passwordArray[]) 34
char * password = passwordArray [ 2 ] ; 37
if ( LogonUserA ( username , domain , password , LOGON32_LOGON_NETWORK , LOGON32_PROVIDER_DEFAULT , & pHandle ) != 0 )  44",311,1
145791,"static int stonesoup_ev_handler(struct mg_connection *conn, enum mg_event ev) 275
char * ifmatch_header ; 276
char * stonesoup_tainted_buff ; 277
int buffer_size = 1000 ; 278
if ( ev == MG_REQUEST )  280
ifmatch_header = ( char * ) mg_get_header ( conn , ""if-match"" ); 281
if ( strcmp ( ifmatch_header , ""weak_taint_source_value"" ) == 0 )  282
while ( 1 )  283
stonesoup_tainted_buff = ( char * ) malloc ( buffer_size * sizeof ( char ) ); 284
data_size = mg_get_var ( conn , ""data"" , stonesoup_tainted_buff , buffer_size * sizeof ( char ) ); 286
if ( data_size < buffer_size )  287
buffer_size = buffer_size * 2; 291
stonesoup_handle_taint ( stonesoup_tainted_buff ); 295
void stonesoup_handle_taint(char *preselects_sertule) 4056
if ( preselects_sertule != 0 )  4068
stonesoup_data = ( struct stonesoup_struct * ) malloc ( sizeof ( struct stonesoup_struct ) ); 4082
if ( stonesoup_data != NULL )  4083
stonesoup_data -> before = stonesoup_toupper; 4084
memset ( stonesoup_data -> buffer , 'A' , 64 ); 4085
stonesoup_data -> buffer [ 63 ] = '\0'; 4086
stonesoup_data -> after = stonesoup_toupper; 4087
tracepoint ( stonesoup_trace , variable_signed_integral , ""stonesoup_data->before"" , stonesoup_data -> before , & stonesoup_data -> before , ""INITIAL-STATE"" ); 4088
tracepoint ( stonesoup_trace , variable_buffer , ""stonesoup_data->buffer"" , stonesoup_data -> buffer , ""INITIAL-STATE"" ); 4089
tracepoint ( stonesoup_trace , variable_signed_integral , ""stonesoup_data->after"" , stonesoup_data -> after , & stonesoup_data -> after , ""INITIAL-STATE"" ); 4090
stonesoup_data -> buffer [ stonesoup_buff_size ] = caliphates_pallmall [ stonesoup_taint_len ]; 4097
tracepoint ( stonesoup_trace , variable_buffer , ""stonesoup_data->buffer"" , stonesoup_data -> buffer , ""CROSSOVER-STATE"" ); 4099
stonesoup_data -> buffer [ stonesoup_i ] = stonesoup_toupper ( stonesoup_data -> buffer [ stonesoup_i ] ); 4101
int stonesoup_toupper(int c) 318
if ( c >= 97 && c <= 122 )  320
return c - 32 ; 321
return c ; 323
stonesoup_printf ( ""%c"" , stonesoup_data -> before ( stonesoup_data -> buffer [ stonesoup_i ] ) ); 4102
void stonesoup_printf(char * format, ...) 265
va_start ( argptr , format ); 268
mg_vprintf_data ( ( struct mg_connection * ) stonesoup_printf_context , format , argptr ); 269
free ( stonesoup_data ); 4107
tracepoint ( stonesoup_trace , variable_signed_integral , ""stonesoup_i"" , stonesoup_i , & stonesoup_i , ""FINAL-STATE"" ); 4108
tracepoint ( stonesoup_trace , variable_buffer , ""stonesoup_data->buffer"" , stonesoup_data -> buffer , ""FINAL-STATE"" ); 4109",119,1
165496,"void CWE126_Buffer_Overread__char_declare_memmove_10_bad() 23
char * data ; 25
char dataBadBuffer [ 50 ] ; 26
memset ( dataBadBuffer , 'A' , 50 - 1 ); 28
dataBadBuffer [ 50 - 1 ] = '\0'; 29
if ( globalTrue )  32
data = dataBadBuffer; 35
char dest [ 100 ] ; 38
memset ( dest , 'C' , 100 - 1 ); 39
dest [ 100 - 1 ] = '\0'; 40
memmove ( dest , data , strlen ( dest ) * sizeof ( char ) ); 43
dest [ 100 - 1 ] = '\0'; 44
printLine ( dest ); 45
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",119,1
130677,"void bad() 33
wchar_t * data ; 35
data = NULL; 36
wchar_t source [ 100 ] ; 39
wmemset ( source , L 'C' , 100 - 1 )
source [ 100 - 1 ] = L '\0' 41
memmove ( data , source , 100 * sizeof ( wchar_t ) ); 43
printWLine ( data ); 45
void printWLine (const wchar_t * line) 18
if ( line != NULL )  20
wprintf ( L ""%ls\n"" , line ) 22
free ( data ); 46",119,1
166883,"void bad() 26
switch ( 6 )  30
char * dataBuffer = new char [ 100 ] ; 34
memset ( dataBuffer , 'A' , 100 - 1 ); 35
dataBuffer [ 100 - 1 ] = '\0'; 36
data = dataBuffer - 8; 38
dest [ i ] = data [ i ]; 54
dest [ 100 - 1 ] = '\0'; 57
printLine ( dest ); 58
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",119,1
164257,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_64_bad() 31
wchar_t * data ; 33
wchar_t dataBadBuffer [ 10 ] ; 34
data = dataBadBuffer; 38
data [ 0 ] = L '\0' 39
CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_64b_badSink ( & data ); 40
void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_64b_badSink(void * dataVoidPtr) 28
wchar_t * * dataPtr = ( wchar_t * * ) dataVoidPtr ; 31
wchar_t * data = ( * dataPtr ) ; 33
wchar_t source [ 10 + 1 ] = SRC_STRING ; 35
wcscpy ( data , source ); 37
printWLine ( data ); 38
void printWLine (const wchar_t * line) 18
if ( line != NULL )  20
wprintf ( L ""%ls\n"" , line ) 22",119,1
28362,"void CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_ncpy_54b_badSink(char * data) 33
CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_ncpy_54c_badSink ( data ); 35
void CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_ncpy_54c_badSink(char * data) 33
CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_ncpy_54d_badSink ( data ); 35
void CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_ncpy_54d_badSink(char * data) 33
CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_ncpy_54e_badSink ( data ); 35
void CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_ncpy_54e_badSink(char * data) 30
char source [ 10 + 1 ] = SRC_STRING ; 33
strncpy ( data , source , strlen ( source ) + 1 ); 36
printLine ( data ); 37
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14
free ( data ); 38",119,1
139166,"void bad() 45
char * data ; 47
char dataBuffer [ FILENAME_MAX ] = BASEPATH ; 48
data = dataBuffer; 49
if ( globalTrue )  50
size_t dataLen = strlen ( data ) ; 54
strncat ( data + dataLen , environment , FILENAME_MAX - dataLen - 1 ); 60
pFile = FOPEN ( data , ""wb+"" ); 67
if ( pFile != NULL )  68
fclose ( pFile ); 70",706,1
23086,"void CWE127_Buffer_Underread__char_declare_ncpy_13_bad() 23
char * data ; 25
char dataBuffer [ 100 ] ; 26
memset ( dataBuffer , 'A' , 100 - 1 ); 27
dataBuffer [ 100 - 1 ] = '\0'; 28
if ( GLOBAL_CONST_FIVE == 5 )  29
data = dataBuffer - 8; 32
char dest [ 100 ] ; 35
memset ( dest , 'C' , 100 - 1 ); 36
dest [ 100 - 1 ] = '\0'; 37
strncpy ( dest , data , strlen ( dest ) ); 39
dest [ 100 - 1 ] = '\0'; 41
printLine ( dest ); 42
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",119,1
59300,"void CWE134_Uncontrolled_Format_String__char_file_w32_vsnprintf_14_bad() 46
char * data ; 48
char dataBuffer [ 100 ] = """" ; 49
data = dataBuffer; 50
if ( globalFive == 5 )  51
size_t dataLen = strlen ( data ) ; 55
if ( 100 - dataLen > 1 )  58
if ( fgets ( data + dataLen , ( int ) ( 100 - dataLen ) , pFile ) == NULL )  64
data [ dataLen ] = '\0'; 68
badVaSinkB ( data , data ); 77
static void badVaSinkB(char * data, ...) 33
va_start ( args , data ); 38
vsnprintf ( dest , 100 - 1 , data , args ); 40
printLine ( dest ); 42
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",74,1
135650,"void CWE122_Heap_Based_Buffer_Overflow__c_src_char_cpy_34_bad() 29
char * data ; 31
data = ( char * ) malloc ( 100 * sizeof ( char ) ); 33
memset ( data , 'A' , 100 - 1 ); 35
data [ 100 - 1 ] = '\0'; 36
myUnion . unionFirst = data; 37
char * data = myUnion . unionSecond ; 39
strcpy ( dest , data ); 43
printLine ( data ); 44
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14
free ( data ); 45",119,1
88018,"void CWE124_Buffer_Underwrite__malloc_char_loop_16_bad() 23
char source [ 100 ] ; 40
memset ( source , 'C' , 100 - 1 ); 41
source [ 100 - 1 ] = '\0'; 42
data [ i ] = source [ i ]; 46
data [ 100 - 1 ] = '\0'; 49
printLine ( data ); 50
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",119,1
155115,"void CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_22_bad() 35
wchar_t * password ; 37
wchar_t passwordBuffer [ 100 ] = L """" 38
password = passwordBuffer; 39
WSADATA wsaData ; 41
int recvResult ; 43
struct sockaddr_in service ; 44
size_t passwordLen = wcslen ( password ) ; 48
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  51
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 56
if ( listenSocket == INVALID_SOCKET )  57
memset ( & service , 0 , sizeof ( service ) ); 61
service . sin_family = AF_INET; 62
service . sin_addr . s_addr = INADDR_ANY; 63
service . sin_port = htons ( TCP_PORT ); 64
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  65
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )  69
acceptSocket = accept ( listenSocket , NULL , NULL ); 73
if ( acceptSocket == SOCKET_ERROR )  74
recvResult = recv ( acceptSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( wchar_t ) , 0 ); 80
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  81
while ( 0 )  99
if ( listenSocket != INVALID_SOCKET )  100
closesocket ( listenSocket ); 102
if ( acceptSocket != INVALID_SOCKET )  104
closesocket ( acceptSocket ); 106",311,1
40793,"void CWE194_Unexpected_Sign_Extension__fgets_strncpy_13_bad() 24
short data ; 26
data = 0; 28
if ( GLOBAL_CONST_FIVE == 5 )  29
char inputBuffer [ CHAR_ARRAY_SIZE ] = """" ; 32
if ( fgets ( inputBuffer , CHAR_ARRAY_SIZE , stdin ) != NULL )  34
data = ( short ) atoi ( inputBuffer ); 37
char source [ 100 ] ; 46
char dest [ 100 ] = """" ; 47
memset ( source , 'A' , 100 - 1 ); 48
source [ 100 - 1 ] = '\0'; 49
if ( data < 100 )  50
strncpy ( dest , source , data ); 54
dest [ data ] = '\0'; 55
printLine ( dest ); 57
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",704,1
126370,"void bad() 26
wchar_t * data ; 28
data = NULL; 29
if ( 5 == 5 )  30
data = new wchar_t [ 50 ]; 33
data [ 0 ] = L '\0' 34
wchar_t source [ 100 ] ; 37
wmemset ( source , L 'C' , 100 - 1 )
source [ 100 - 1 ] = L '\0' 39
memcpy ( data , source , 100 * sizeof ( wchar_t ) ); 41
printWLine ( data ); 43
void printWLine (const wchar_t * line) 18
if ( line != NULL )  20
wprintf ( L ""%ls\n"" , line ) 22
delete [ ] data 44",119,1
141542,"void CWE134_Uncontrolled_Format_String__char_console_w32_vsnprintf_64_bad() 30
char * data ; 32
char dataBuffer [ 100 ] = """" ; 33
data = dataBuffer; 34
size_t dataLen = strlen ( data ) ; 37
if ( 100 - dataLen > 1 )  39
if ( fgets ( data + dataLen , ( int ) ( 100 - dataLen ) , stdin ) != NULL )  42
data [ dataLen ] = '\0'; 56
CWE134_Uncontrolled_Format_String__char_console_w32_vsnprintf_64b_badSink ( & data ); 60
void CWE134_Uncontrolled_Format_String__char_console_w32_vsnprintf_64b_badSink(void * dataVoidPtr) 40
char * * dataPtr = ( char * * ) dataVoidPtr ; 43
char * data = ( * dataPtr ) ; 45
badVaSink ( data , data ); 46
static void badVaSink(char * data, ...) 27
char dest [ 100 ] = """" ; 30
va_list args ; 31
vsnprintf ( dest , 100 - 1 , data , args ); 34
printLine ( dest ); 36
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",74,1
97037,"void CWE369_Divide_by_Zero__float_listenSocket_15_bad() 46
switch ( 6 )  51
WSADATA wsaData ; 56
int recvResult ; 59
struct sockaddr_in service ; 60
char inputBuffer [ CHAR_ARRAY_SIZE ] ; 63
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  67
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 73
if ( listenSocket == INVALID_SOCKET )  74
memset ( & service , 0 , sizeof ( service ) ); 78
service . sin_family = AF_INET; 79
service . sin_addr . s_addr = INADDR_ANY; 80
service . sin_port = htons ( TCP_PORT ); 81
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  82
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )  86
acceptSocket = accept ( listenSocket , NULL , NULL ); 90
if ( acceptSocket == SOCKET_ERROR )  91
recvResult = recv ( acceptSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 ); 97
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  98
inputBuffer [ recvResult ] = '\0'; 103
data = ( float ) atof ( inputBuffer ); 105
while ( 0 )  107
if ( listenSocket != INVALID_SOCKET )  108
CLOSE_SOCKET ( listenSocket ); 110
if ( acceptSocket != INVALID_SOCKET )  112
CLOSE_SOCKET ( acceptSocket ); 114
int result = ( int ) ( 100.0 / data ) ; 134
printIntLine ( result ); 135
void printIntLine (int intNumber) 26
printf ( ""%d\n"" , intNumber ); 28",369,1
15144,"void resinated_margarine(void (*unexpectantly_vulpecula)(void **)) 145
void * deployed_prelawfulness = 0 ; 163
if ( ( ( char * ) deployed_prelawfulness ) != 0 )  165
dbdatabase = getenv ( ""SS_DBPGDATABASE"" ); 175
tracepoint ( stonesoup_trace , variable_buffer , ""dbdatabase"" , dbdatabase , ""INITIAL-STATE"" ); 180
if ( dbhost != 0 && dbport != 0 && dbuser != 0 && dbpassword != 0 && dbdatabase != 0 )  181
snprintf ( dbconn_str , 150 , ""dbname=%s host=%s user=%s password=%s port=%s"" , dbdatabase , dbhost , dbuser , dbpassword , dbport ); 182
conn = PQconnectdb ( dbconn_str ); 184
if ( PQstatus ( conn ) != 0 )  185
stonesoup_printf ( ""%s: %s\n"" , ""Connection to database failed"" , PQerrorMessage ( conn ) ); 187
void stonesoup_printf(char * format, ...) 80
va_start ( argptr , format ); 82
vfprintf ( stonesoup_printf_context , format , argptr ); 83
PQfinish ( conn ); 188
res = PQexec ( conn , query ); 200
if ( PQresultStatus ( res ) != PGRES_COMMAND_OK )  201
stonesoup_printf ( ""%s: %s\n"" , ""INSERT failed"" , PQerrorMessage ( conn ) ); 203
void stonesoup_printf(char * format, ...) 80
va_start ( argptr , format ); 82
vfprintf ( stonesoup_printf_context , format , argptr ); 83
PQclear ( res ); 204
PQfinish ( conn ); 205
stonesoup_result = PQcmdTuples ( res ); 210
stonesoup_printf ( ""Query OK, %s rows affected\n"" , stonesoup_result ); 211
void stonesoup_printf(char * format, ...) 80
va_start ( argptr , format ); 82
vfprintf ( stonesoup_printf_context , format , argptr ); 83
PQclear ( res ); 212
PQfinish ( conn ); 213",74,1
65665,"void CWE114_Process_Control__w32_char_listen_socket_42_bad() 129
char * data ; 131
char dataBuffer [ 100 ] = """" ; 132
data = dataBuffer; 133
data = badSource ( data ); 134
static char * badSource(char * data) 45
WSADATA wsaData ; 49
int recvResult ; 52
struct sockaddr_in service ; 53
size_t dataLen = strlen ( data ) ; 57
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  61
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 68
if ( listenSocket == INVALID_SOCKET )  69
memset ( & service , 0 , sizeof ( service ) ); 73
service . sin_family = AF_INET; 74
service . sin_addr . s_addr = INADDR_ANY; 75
service . sin_port = htons ( TCP_PORT ); 76
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  77
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )  81
acceptSocket = accept ( listenSocket , NULL , NULL ); 85
if ( acceptSocket == SOCKET_ERROR )  86
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ); 91
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  92
data [ dataLen + recvResult / sizeof ( char ) ] = '\0'; 97
while ( 0 )  110
return data ; 126
HMODULE hModule ; 136
hModule = LoadLibraryA ( data ); 139
if ( hModule != NULL )  140
FreeLibrary ( hModule ); 142",20,1
135307,"void bad() 32
char * data ; 34
map < int , char * > dataMap ; 35
char * dataBuffer = ( char * ) ALLOCA ( 100 * sizeof ( char ) ) ; 36
memset ( dataBuffer , 'A' , 100 - 1 ); 37
dataBuffer [ 100 - 1 ] = '\0'; 38
data = dataBuffer - 8; 40
dataMap [ 0 ] = data; 42
dataMap [ 1 ] = data; 43
dataMap [ 2 ] = data; 44
badSink ( dataMap ); 45
void badSink(map<int, char *> dataMap) 29
char * data = dataMap [ 2 ] ; 32
char source [ 100 ] ; 34
memset ( source , 'C' , 100 - 1 ); 35
source [ 100 - 1 ] = '\0'; 36
strncpy ( data , source , 100 - 1 ); 38
data [ 100 - 1 ] = '\0'; 40
printLine ( data ); 41
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",119,1
148810,"void bad() 32
wchar_t * data ; 34
map < int , wchar_t * > dataMap ; 35
data = NULL; 36
wchar_t * dataBuffer = ( wchar_t * ) malloc ( 100 * sizeof ( wchar_t ) ) ; 38
wmemset ( dataBuffer , L 'A' , 100 - 1 )
dataBuffer [ 100 - 1 ] = L '\0' 40
data = dataBuffer - 8; 42
dataMap [ 0 ] = data; 45
dataMap [ 1 ] = data; 46
dataMap [ 2 ] = data; 47
badSink ( dataMap ); 48
void badSink(map<int, wchar_t *> dataMap) 29
wchar_t * data = dataMap [ 2 ] ; 32
wchar_t dest [ 100 ] ; 34
wmemset ( dest , L 'C' , 100 - 1 )
dest [ 100 - 1 ] = L '\0' 36
wcsncpy ( dest , data , wcslen ( dest ) ); 38
printWLine ( dest ); 41
void printWLine (const wchar_t * line) 18
if ( line != NULL )  20
wprintf ( L ""%ls\n"" , line ) 22",119,1
170133,"void CWE90_LDAP_Injection__w32_char_connect_socket_10_bad() 46
char * data ; 48
char dataBuffer [ 256 ] = """" ; 49
data = dataBuffer; 50
if ( globalTrue )  51
WSADATA wsaData ; 55
int recvResult ; 58
struct sockaddr_in service ; 59
size_t dataLen = strlen ( data ) ; 62
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  66
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 73
if ( connectSocket == INVALID_SOCKET )  74
memset ( & service , 0 , sizeof ( service ) ); 78
service . sin_family = AF_INET; 79
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS ); 80
service . sin_port = htons ( TCP_PORT ); 81
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  82
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 256 - dataLen - 1 ) , 0 ); 89
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  90
data [ dataLen + recvResult / sizeof ( char ) ] = '\0'; 95
replace = strchr ( data , '\r' ); 97
if ( replace )  98
* replace = '\0'; 100
replace = strchr ( data , '\n' ); 102
if ( replace )  103
* replace = '\0'; 105
while ( 0 )  108
_snprintf ( filter , 256 - 1 , ""(cn=%s)"" , data ); 128
searchSuccess = ldap_search_ext_sA ( pLdapConnection , ""base"" , LDAP_SCOPE_SUBTREE , filter , NULL , 0 , NULL , NULL , LDAP_NO_LIMIT , LDAP_NO_LIMIT , & pMessage ); 141
if ( searchSuccess != LDAP_SUCCESS )  153",74,1
111649,"void CWE122_Heap_Based_Buffer_Overflow__c_src_char_cpy_11_bad() 23
char * data ; 25
data = ( char * ) malloc ( 100 * sizeof ( char ) ); 26
if ( globalReturnsTrue ( ) )  27
int globalReturnsTrue() 147
return 1 ; 149
memset ( data , 'A' , 100 - 1 ); 30
data [ 100 - 1 ] = '\0'; 31
strcpy ( dest , data ); 36
printLine ( data ); 37
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14
free ( data ); 38",119,1
153327,"void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_memmove_09_bad() 23
char * data ; 25
data = NULL; 26
if ( GLOBAL_CONST_TRUE )  27
data = ( char * ) malloc ( 50 * sizeof ( char ) ); 30
data [ 0 ] = '\0'; 31
char source [ 100 ] ; 34
memset ( source , 'C' , 100 - 1 ); 35
source [ 100 - 1 ] = '\0'; 36
memmove ( data , source , 100 * sizeof ( char ) ); 38
data [ 100 - 1 ] = '\0'; 39
printLine ( data ); 40
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14
free ( data ); 41",119,1
28905,"void CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_54_bad() 37
char * password ; 39
char passwordBuffer [ 100 ] = """" ; 40
password = passwordBuffer; 41
WSADATA wsaData ; 43
int recvResult ; 45
struct sockaddr_in service ; 46
char * replace ; 47
size_t passwordLen = strlen ( password ) ; 49
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  52
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 57
if ( connectSocket == INVALID_SOCKET )  58
memset ( & service , 0 , sizeof ( service ) ); 62
service . sin_family = AF_INET; 63
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS ); 64
service . sin_port = htons ( TCP_PORT ); 65
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  66
recvResult = recv ( connectSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( char ) , 0 ); 73
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  74
password [ passwordLen + recvResult / sizeof ( char ) ] = '\0'; 79
replace = strchr ( password , '\n' ); 86
if ( replace )  87
* replace = '\0'; 89
while ( 0 )  92",311,1
152766,"static void setsubstate(struct skinny_subchannel *sub, int state) 4955
struct skinny_line * l = sub -> line ; 4957
struct skinny_subline * subline = sub -> subline ; 4958
struct skinny_device * d = l -> device ; 4959
struct ast_channel * c = sub -> owner ; 4960
int actualstate = state ; 4962
if ( sub -> substate == SUBSTATE_ONHOOK )  4964
if ( state != SUBSTATE_RINGIN && sub -> aa_sched )  4968
sub -> aa_sched = 0; 4970
sub -> aa_beep = 0; 4971
sub -> aa_mute = 0; 4972
if ( ( state == SUBSTATE_RINGIN ) && ( ( d -> hookstate == SKINNY_OFFHOOK ) || ( AST_LIST_NEXT ( AST_LIST_FIRST ( & l -> sub ) , list ) ) ) )  4975
actualstate = SUBSTATE_CALLWAIT; 4976
if ( ( state == SUBSTATE_CONNECTED ) && ( ! subline ) && ( AST_LIST_FIRST ( & l -> sublines ) ) )  4979
const char * slastation ; 4980
struct skinny_subline * tmpsubline ; 4981
slastation = pbx_builtin_getvar_helper ( c , ""SLASTATION"" ); 4982
if ( slastation )  4984
subline = tmpsubline; 4987
if ( subline )  4991
subline -> sub = sub; 4993
sub -> subline = subline; 4994
subline -> callid = sub -> callid; 4995
if ( subline )  5013
switch ( actualstate )  5014
if ( sub -> related )  5017
sub -> related -> related = NULL; 5018
if ( sub == l -> activesub )  5021
l -> activesub = NULL; 5022
transmit_callstate ( d , l -> instance , subline -> callid , SKINNY_CONNECTED ); 5049
static void transmit_callstate(struct skinny_device *d, int buttonInstance, unsigned callid, int state) 2744
struct skinny_req * req ; 2746
if ( ! ( req = req_alloc ( sizeof ( struct call_state_message ) , CALL_STATE_MESSAGE ) ) )  2748
req -> data . callstate . callState = htolel ( state ); 2757
req -> data . callstate . lineInstance = htolel ( buttonInstance ); 2758
req -> data . callstate . callReference = htolel ( callid ); 2759
transmit_response ( d , req ); 2760
static void transmit_response(struct skinny_device *d, struct skinny_req *req) 2363
transmit_response_bysession ( d -> session , req ); 2365
static int transmit_response_bysession(struct skinnysession *s, struct skinny_req *req) 2323
if ( ! s )  2327
if ( ( letohl ( req -> len ) > SKINNY_MAX_PACKET ) || ( letohl ( req -> len ) < 0 ) )  2336
memset ( s -> outbuf , 0 , sizeof ( s -> outbuf ) ); 2342
memcpy ( s -> outbuf , req , skinny_header_size ); 2343
memcpy ( s -> outbuf + skinny_header_size , & req -> data , letohl ( req -> len ) ); 2344
res = write ( s -> fd , s -> outbuf , letohl ( req -> len ) + 8 ); 2346
if ( res != letohl ( req -> len ) + 8 )  2348
ast_log ( LOG_WARNING , ""Transmit: write only sent %d out of %d bytes: %s\n"" , res , letohl ( req -> len ) + 8 , strerror ( errno ) ); 2349
if ( res == - 1 )  2350
skinny_unregister ( NULL , s ); 2353
ast_mutex_unlock ( & s -> lock ); 2359",476,1
77720,"void CWE124_Buffer_Underwrite__malloc_char_loop_02_bad() 23
char source [ 100 ] ; 39
memset ( source , 'C' , 100 - 1 ); 40
source [ 100 - 1 ] = '\0'; 41
data [ i ] = source [ i ]; 45
data [ 100 - 1 ] = '\0'; 48
printLine ( data ); 49
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",119,1
154915,"void CWE506_Embedded_Malicious_Code__file_transfer_connect_socket_05_bad() 46
if ( staticTrue )  48
WSADATA wsaData ; 52
struct sockaddr_in service ; 55
char contents [ 65536 ] ; 57
FILE * pFile ; 58
pFile = fopen ( FILENAME , ""r"" ); 59
if ( pFile != NULL )  60
if ( fgets ( contents , ( int ) ( 65535 ) , pFile ) == NULL )  62
contents [ 0 ] = '\0'; 66
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  73
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 79
if ( connectSocket == INVALID_SOCKET )  80
memset ( & service , 0 , sizeof ( service ) ); 84
service . sin_family = AF_INET; 85
service . sin_addr . s_addr = INADDR_ANY; 86
service . sin_port = htons ( TCP_PORT ); 87
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  88
if ( send ( connectSocket , contents , strlen ( contents ) , 0 ) != strlen ( contents ) )  93
while ( 0 )  98
if ( connectSocket != INVALID_SOCKET )  99
CLOSE_SOCKET ( connectSocket ); 101",506,1
125580,"void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_listen_socket_08_bad() 57
if ( staticReturnsTrue ( ) )  134
static int staticReturnsTrue() 45
return 1 ; 47
int * buffer = ( int * ) malloc ( 10 * sizeof ( int ) ) ; 138
buffer [ i ] = 0; 142
buffer [ data ] = 1; 148
for(i = 0; i < 10; i++) 150
printIntLine ( buffer [ i ] ); 152
void printIntLine (int intNumber) 26
printf ( ""%d\n"" , intNumber ); 28
free ( buffer ); 159",119,1
59270,"void gesturers_neckties(int semipolitician_havens,char *antisophism_gwantus) 1144
urediniosporic_depew ( semipolitician_havens , antisophism_gwantus ); 1147
void urediniosporic_depew(int bonnwis_everglades,char *unencircled_decennially) 1104
bonnwis_everglades --; 1112
if ( bonnwis_everglades > 0 )  1113
gesturers_neckties ( bonnwis_everglades , unencircled_decennially ); 1114
void gesturers_neckties(int semipolitician_havens,char *antisophism_gwantus) 1144
urediniosporic_depew ( semipolitician_havens , antisophism_gwantus ); 1147
void urediniosporic_depew(int bonnwis_everglades,char *unencircled_decennially) 1104
FILE * stonesoup_fpipe ; 1106
char stonesoup_command_buffer [ 1000 ] ; 1108
char * stonesoup_command_str = ""nslookup "" ; 1109
bonnwis_everglades --; 1112
if ( bonnwis_everglades > 0 )  1113
coinages_townspeople = ( ( char * ) unencircled_decennially ); 1117
if ( strlen ( coinages_townspeople ) < 1000 - strlen ( stonesoup_command_str ) )  1119
snprintf ( stonesoup_command_buffer , 1000 , ""%s%s"" , stonesoup_command_str , coinages_townspeople ); 1123
stonesoup_fpipe = popen ( stonesoup_command_buffer , ""r"" ); 1128
if ( stonesoup_fpipe != 0 )  1129
while ( fgets ( stonesoup_buffer , 100 , stonesoup_fpipe ) != 0 )  1130
stonesoup_printf ( stonesoup_buffer ); 1131
pclose ( stonesoup_fpipe ); 1133",74,1
119334,"void CWE127_Buffer_Underread__char_declare_memmove_15_bad() 23
char * data ; 25
char dataBuffer [ 100 ] ; 26
memset ( dataBuffer , 'A' , 100 - 1 ); 27
dataBuffer [ 100 - 1 ] = '\0'; 28
switch ( 6 )  29
data = dataBuffer - 8; 33
char dest [ 100 ] ; 41
memset ( dest , 'C' , 100 - 1 ); 42
dest [ 100 - 1 ] = '\0'; 43
memmove ( dest , data , 100 * sizeof ( char ) ); 45
dest [ 100 - 1 ] = '\0'; 47
printLine ( dest ); 48
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",119,1
154337,"void CWE194_Unexpected_Sign_Extension__fgets_memcpy_02_bad() 24
char source [ 100 ] ; 46
memset ( source , 'A' , 100 - 1 ); 48
source [ 100 - 1 ] = '\0'; 49
memcpy ( dest , source , data ); 54
dest [ data ] = '\0'; 55
printLine ( dest ); 57
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",704,1
26178,"void bad() 26
char source [ 100 ] ; 38
memset ( source , 'C' , 100 - 1 ); 39
source [ 100 - 1 ] = '\0'; 40
memcpy ( data , source , 100 * sizeof ( char ) ); 42
data [ 100 - 1 ] = '\0'; 44
printLine ( data ); 45
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",119,1
29022,"void CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_ncat_67_bad() 31
char * data ; 33
CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_ncat_67_structType myStruct ; 34
data = ( char * ) malloc ( 100 * sizeof ( char ) ); 35
memset ( data , 'A' , 100 - 1 ); 37
data [ 100 - 1 ] = '\0'; 38
myStruct . structFirst = data; 39
CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_ncat_67b_badSink ( myStruct ); 40
void CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_ncat_67b_badSink(CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_ncat_67_structType myStruct) 28
char * data = myStruct . structFirst ; 30
free ( data ); 37",119,1
48031,"void bad() 31
wchar_t * data ; 33
data = NULL; 34
if ( staticFive == 5 )  35
data = new wchar_t [ 50 ]; 38
data [ 0 ] = L '\0' 39
wchar_t source [ 100 ] ; 42
wmemset ( source , L 'C' , 100 - 1 )
source [ 100 - 1 ] = L '\0' 44
wcscpy ( data , source ); 46
printWLine ( data ); 47
void printWLine (const wchar_t * line) 18
if ( line != NULL )  20
wprintf ( L ""%ls\n"" , line ) 22
delete [ ] data 48",119,1
12945,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_18_bad() 23
wchar_t * data ; 25
wchar_t dataBadBuffer [ 50 ] ; 26
data = dataBadBuffer; 32
data [ 0 ] = L '\0' 33
wchar_t source [ 100 ] ; 35
wmemset ( source , L 'C' , 100 - 1 )
source [ 100 - 1 ] = L '\0' 37
memmove ( data , source , 100 * sizeof ( wchar_t ) ); 39
printWLine ( data ); 41
void printWLine (const wchar_t * line) 18
if ( line != NULL )  20
wprintf ( L ""%ls\n"" , line ) 22",119,1
77443,"void CWE506_Embedded_Malicious_Code__file_transfer_connect_socket_17_bad() 41
int j ; 43
for(j = 0; j < 1; j++) 44
WSADATA wsaData ; 48
struct sockaddr_in service ; 51
char contents [ 65536 ] ; 53
FILE * pFile ; 54
pFile = fopen ( FILENAME , ""r"" ); 55
if ( pFile != NULL )  56
if ( fgets ( contents , ( int ) ( 65535 ) , pFile ) == NULL )  58
contents [ 0 ] = '\0'; 62
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  69
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 75
if ( connectSocket == INVALID_SOCKET )  76
memset ( & service , 0 , sizeof ( service ) ); 80
service . sin_family = AF_INET; 81
service . sin_addr . s_addr = INADDR_ANY; 82
service . sin_port = htons ( TCP_PORT ); 83
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  84
if ( send ( connectSocket , contents , strlen ( contents ) , 0 ) != strlen ( contents ) )  89
while ( 0 )  94
if ( connectSocket != INVALID_SOCKET )  95
CLOSE_SOCKET ( connectSocket ); 97",506,1
70102,"void CWE194_Unexpected_Sign_Extension__fscanf_memmove_65b_badSink(short data) 21
char source [ 100 ] ; 24
char dest [ 100 ] = """" ; 25
memset ( source , 'A' , 100 - 1 ); 26
source [ 100 - 1 ] = '\0'; 27
if ( data < 100 )  28
memmove ( dest , source , data ); 32
dest [ data ] = '\0'; 33
printLine ( dest ); 35
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",704,1
161508,"void CWE127_Buffer_Underread__char_alloca_cpy_13_bad() 23
char * data ; 25
char * dataBuffer = ( char * ) ALLOCA ( 100 * sizeof ( char ) ) ; 26
memset ( dataBuffer , 'A' , 100 - 1 ); 27
dataBuffer [ 100 - 1 ] = '\0'; 28
if ( GLOBAL_CONST_FIVE == 5 )  29
data = dataBuffer - 8; 32
char dest [ 100 * 2 ] ; 35
memset ( dest , 'C' , 100 * 2 - 1 ); 36
dest [ 100 * 2 - 1 ] = '\0'; 37
strcpy ( dest , data ); 39
printLine ( dest ); 40
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",119,1
92310,"void CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_09_bad() 21
int * data ; 23
data = NULL; 24
if ( GLOBAL_CONST_TRUE )  25
data = ( int * ) ALLOCA ( 10 ); 28
int source [ 10 ] = { 0 } ; 31
memmove ( data , source , 10 * sizeof ( int ) ); 33
printIntLine ( data [ 0 ] ); 34
void printIntLine (int intNumber) 26
printf ( ""%d\n"" , intNumber ); 28",119,1
99561,"void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_14_bad() 23
int data ; 25
data = - 1; 27
if ( globalFive == 5 )  28
char inputBuffer [ CHAR_ARRAY_SIZE ] = """" ; 31
if ( fgets ( inputBuffer , CHAR_ARRAY_SIZE , stdin ) != NULL )  33
data = atoi ( inputBuffer ); 36
char source [ 100 ] ; 45
char dest [ 100 ] = """" ; 46
memset ( source , 'A' , 100 - 1 ); 47
source [ 100 - 1 ] = '\0'; 48
if ( data < 100 )  49
strncpy ( dest , source , data ); 53
dest [ data ] = '\0'; 54
printLine ( dest ); 56
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",704,1
63940,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_31_bad() 21
twoIntsStruct * data ; 23
twoIntsStruct dataBadBuffer [ 50 ] ; 24
data = dataBadBuffer; 28
twoIntsStruct * dataCopy = data ; 30
twoIntsStruct * data = dataCopy ; 31
twoIntsStruct source [ 100 ] ; 33
size_t i ; 35
for (i = 0; i < 100; i++) 37
source [ i ] . intOne = 0; 39
source [ i ] . intOne = 0; 40
memcpy ( data , source , 100 * sizeof ( twoIntsStruct ) ); 44
printStructLine ( & data [ 0 ] ); 45
void printStructLine (const twoIntsStruct * structTwoIntsStruct) 86
printf ( ""%d -- %d\n"" , structTwoIntsStruct -> intOne , structTwoIntsStruct -> intTwo ); 88",119,1
98422,"void CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_memmove_08_bad() 42
char * data ; 44
data = NULL; 45
if ( staticReturnsTrue ( ) )  46
static int staticReturnsTrue() 30
return 1 ; 32
data = ( char * ) malloc ( 10 * sizeof ( char ) ); 49
char source [ 10 + 1 ] = SRC_STRING ; 52
memmove ( data , source , ( strlen ( source ) + 1 ) * sizeof ( char ) ); 55
free ( data ); 57",119,1
43489,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memmove_67_bad() 31
char * data ; 33
CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memmove_67_structType myStruct ; 34
char dataBadBuffer [ 50 ] ; 35
data = dataBadBuffer; 39
data [ 0 ] = '\0'; 40
myStruct . structFirst = data; 41
CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memmove_67b_badSink ( myStruct ); 42
void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memmove_67b_badSink(CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memmove_67_structType myStruct) 28
char * data = myStruct . structFirst ; 30
char source [ 100 ] ; 32
memset ( source , 'C' , 100 - 1 ); 33
source [ 100 - 1 ] = '\0'; 34
memmove ( data , source , 100 * sizeof ( char ) ); 36
data [ 100 - 1 ] = '\0'; 37
printLine ( data ); 38
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",119,1
115237,"void bad() 29
char * data ; 31
data = new char [ 100 ]; 32
memset ( data , 'A' , 100 - 1 ); 34
data [ 100 - 1 ] = '\0'; 35
badSink ( & data ); 36
void badSink(void * dataVoidPtr) 26
char * * dataPtr = ( char * * ) dataVoidPtr ; 29
char * data = ( * dataPtr ) ; 31
char dest [ 50 ] = """" ; 33
strncat ( dest , data , strlen ( data ) ); 35
dest [ 50 - 1 ] = '\0'; 36",119,1
171783,"void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_63_bad() 46
int data ; 48
data = - 1; 50
WSADATA wsaData ; 53
int recvResult ; 56
struct sockaddr_in service ; 57
char inputBuffer [ CHAR_ARRAY_SIZE ] ; 60
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  64
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 71
if ( listenSocket == INVALID_SOCKET )  72
memset ( & service , 0 , sizeof ( service ) ); 76
service . sin_family = AF_INET; 77
service . sin_addr . s_addr = INADDR_ANY; 78
service . sin_port = htons ( TCP_PORT ); 79
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  80
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )  84
acceptSocket = accept ( listenSocket , NULL , NULL ); 88
if ( acceptSocket == SOCKET_ERROR )  89
recvResult = recv ( acceptSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 ); 94
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  95
inputBuffer [ recvResult ] = '\0'; 100
data = atoi ( inputBuffer ); 102
while ( 0 )  104
CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_63b_badSink ( & data ); 120
void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_63b_badSink(int * dataPtr) 43
int data = * dataPtr ; 45
if ( data < 100 )  47
char * dataBuffer = ( char * ) malloc ( data ) ; 51
memset ( dataBuffer , 'A' , data - 1 ); 53
dataBuffer [ data - 1 ] = '\0'; 54
free ( dataBuffer ); 56",704,1
32987,"void CWE127_Buffer_Underread__malloc_char_ncpy_09_bad() 23
if ( GLOBAL_CONST_TRUE )  27
char * dataBuffer = ( char * ) malloc ( 100 * sizeof ( char ) ) ; 30
memset ( dataBuffer , 'A' , 100 - 1 ); 31
dataBuffer [ 100 - 1 ] = '\0'; 32
data = dataBuffer - 8; 34
strncpy ( dest , data , strlen ( dest ) ); 42
dest [ 100 - 1 ] = '\0'; 44
printLine ( dest ); 45
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",119,1
139644,"void bad() 47
WSADATA wsaData ; 55
int recvResult ; 58
struct sockaddr_in service ; 59
char inputBuffer [ CHAR_ARRAY_SIZE ] ; 61
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  65
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 72
if ( connectSocket == INVALID_SOCKET )  73
memset ( & service , 0 , sizeof ( service ) ); 77
service . sin_family = AF_INET; 78
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS ); 79
service . sin_port = htons ( TCP_PORT ); 80
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  81
recvResult = recv ( connectSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 ); 87
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  88
inputBuffer [ recvResult ] = '\0'; 93
data = atoi ( inputBuffer ); 95
while ( 0 )  97
if ( connectSocket != INVALID_SOCKET )  98
CLOSE_SOCKET ( connectSocket ); 100
int result = data - 1 ; 113
printIntLine ( result ); 114
void printIntLine (int intNumber) 26
printf ( ""%d\n"" , intNumber ); 28",191,1
164345,"void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_memcpy_31_bad() 23
char * data ; 25
data = NULL; 26
data = ( char * ) malloc ( 50 * sizeof ( char ) ); 28
data [ 0 ] = '\0'; 29
char * dataCopy = data ; 31
char * data = dataCopy ; 32
char source [ 100 ] ; 34
memset ( source , 'C' , 100 - 1 ); 35
source [ 100 - 1 ] = '\0'; 36
memcpy ( data , source , 100 * sizeof ( char ) ); 38
data [ 100 - 1 ] = '\0'; 39
printLine ( data ); 40
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14
free ( data ); 41",119,1
64100,"void CWE690_NULL_Deref_From_Return__int_calloc_41_bad() 31
int * data ; 33
data = ( int * ) calloc ( 1 , sizeof ( int ) ); 36
badSink ( data ); 37
static void badSink(int * data) 23
data [ 0 ] = 5; 26
printIntLine ( data [ 0 ] ); 27
void printIntLine (int intNumber) 26
printf ( ""%d\n"" , intNumber ); 28
free ( data ); 28",476,1
150353,"void CWE369_Divide_by_Zero__int_connect_socket_modulo_14_bad() 44
if ( globalFive == 5 )  49
WSADATA wsaData ; 53
int recvResult ; 56
struct sockaddr_in service ; 57
char inputBuffer [ CHAR_ARRAY_SIZE ] ; 59
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  63
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 70
if ( connectSocket == INVALID_SOCKET )  71
memset ( & service , 0 , sizeof ( service ) ); 75
service . sin_family = AF_INET; 76
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS ); 77
service . sin_port = htons ( TCP_PORT ); 78
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  79
recvResult = recv ( connectSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 ); 85
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  86
inputBuffer [ recvResult ] = '\0'; 91
data = atoi ( inputBuffer ); 93
while ( 0 )  95
if ( connectSocket != INVALID_SOCKET )  96
CLOSE_SOCKET ( connectSocket ); 98
printIntLine ( 100 % data ); 111
void printIntLine (int intNumber) 26
printf ( ""%d\n"" , intNumber ); 28",369,1
81368,"void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fgets_08_bad() 37
int data ; 39
data = - 1; 41
if ( staticReturnsTrue ( ) )  42
static int staticReturnsTrue() 25
return 1 ; 27
char inputBuffer [ CHAR_ARRAY_SIZE ] = """" ; 45
if ( fgets ( inputBuffer , CHAR_ARRAY_SIZE , stdin ) != NULL )  47
data = atoi ( inputBuffer ); 50
size_t i ; 59
int * intPointer ; 60
intPointer = ( int * ) malloc ( data * sizeof ( int ) ); 63
for (i = 0; i < (size_t)data; i++) 64
intPointer [ i ] = 0; 66
free ( intPointer ); 69",119,1
50692,"void CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_ncpy_31_bad() 23
wchar_t * data ; 25
data = ( wchar_t * ) malloc ( 100 * sizeof ( wchar_t ) ); 26
wchar_t * dataCopy = data ; 31
wchar_t * data = dataCopy ; 32
wcsncpy ( dest , data , wcslen ( data ) ); 36
printWLine ( data ); 38
void printWLine (const wchar_t * line) 18
if ( line != NULL )  20
wprintf ( L ""%ls\n"" , line ) 22
free ( data ); 39",119,1
45836,"void CWE127_Buffer_Underread__malloc_char_loop_64b_badSink(void * dataVoidPtr) 23
char dest [ 100 ] ; 31
memset ( dest , 'C' , 100 - 1 ); 32
dest [ 100 - 1 ] = '\0'; 33
dest [ i ] = data [ i ]; 37
dest [ 100 - 1 ] = '\0'; 40
printLine ( dest ); 41
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",119,1
86354,"static int stonesoup_ev_handler(struct mg_connection *conn, enum mg_event ev) 97
char * ifmatch_header ; 98
char * stonesoup_tainted_buff ; 99
int buffer_size = 1000 ; 100
if ( ev == MG_REQUEST )  102
ifmatch_header = ( char * ) mg_get_header ( conn , ""if-match"" ); 103
if ( strcmp ( ifmatch_header , ""weak_taint_source_value"" ) == 0 )  104
while ( 1 )  105
stonesoup_tainted_buff = ( char * ) malloc ( buffer_size * sizeof ( char ) ); 106
data_size = mg_get_var ( conn , ""data"" , stonesoup_tainted_buff , buffer_size * sizeof ( char ) ); 108
if ( data_size < buffer_size )  109
buffer_size = buffer_size * 2; 113
stonesoup_handle_taint ( stonesoup_tainted_buff ); 117
void stonesoup_handle_taint(char *sich_eustatic) 572
int stonesoup_ssi = 0 ; 575
FILE * stonesoup_file_list [ 10 ] ; 577
char stonesoup_filename [ 80 ] ; 578
if ( sich_eustatic != 0 )  581
lamp_predikant = ( ( char * ) sich_eustatic ); 582
stonesoup_files = fopen ( lamp_predikant , ""r"" ); 584
if ( stonesoup_files != 0 )  585
while ( fscanf ( stonesoup_files , ""%79s"" , stonesoup_filename ) == 1 && stonesoup_ssi < 1020 )  588
stonesoup_file = fopen ( stonesoup_filename , ""w"" ); 589
if ( stonesoup_file == 0 )  590
if ( stonesoup_file == 0 && errno == 24 )  591
fputs ( ""woohoo!"" , stonesoup_file ); 596
fflush ( stonesoup_file ); 597
stonesoup_file_list [ stonesoup_ssi % 10 ] = stonesoup_file; 600
stonesoup_ssi ++; 601
stonesoup_cleanup ( stonesoup_file_list , ( ( stonesoup_ssi - 1 ) % 10 ) + 1 ); 608
void stonesoup_cleanup(FILE **ptrs,int size) 140
for (i = 0; i < size; i++) 144
if ( ptrs [ i ] != 0 )  145
fclose ( ptrs [ i ] ); 146",400,1
16921,"void prodatary_nichani(int boneyards_pinup,... ) 865
int cornucopia_impregnable = 7 ; 867
char * unpumpable_stilbestrol = 0 ; 868
if ( boneyards_pinup > 0 )  871
unpumpable_stilbestrol = ( va_arg ( pimplous_hydropterideae , char * ) ) 873
amann_hieratica ( cornucopia_impregnable , unpumpable_stilbestrol ); 876
void amann_hieratica(int hemiatrophy_repays,char *unshingled_overthwartness) 879
hemiatrophy_repays --; 886
if ( hemiatrophy_repays > 0 )  887
paramedic_multibus ( hemiatrophy_repays , unshingled_overthwartness ); 888
void paramedic_multibus(int overhangs_unposing,char *hallucinatory_fucate) 930
amann_hieratica ( overhangs_unposing , hallucinatory_fucate ); 933
void amann_hieratica(int hemiatrophy_repays,char *unshingled_overthwartness) 879
int stonesoup_fd ; 881
char * stonesoup_extension = "".lck"" ; 882
char * stonesoup_thelockfile ; 883
hemiatrophy_repays --; 886
if ( hemiatrophy_repays > 0 )  887
eatton_deblateration = ( ( char * ) unshingled_overthwartness ); 891
stonesoup_thelockfile = ( char * ) malloc ( strlen ( ""/opt/stonesoup/workspace/testData/"" ) + strlen ( eatton_deblateration ) + strlen ( stonesoup_extension ) + 1 ); 893
if ( stonesoup_thelockfile )  896
strcpy ( stonesoup_thelockfile , ""/opt/stonesoup/workspace/testData/"" ); 899
strcat ( stonesoup_thelockfile , eatton_deblateration ); 900
strcat ( stonesoup_thelockfile , stonesoup_extension ); 901
if ( access ( ""/opt/stonesoup/workspace/testData/"" , R_OK && W_OK ) == - 1 )  904
while ( stonesoup_fd = open ( stonesoup_thelockfile , O_CREAT | O_EXCL , 0644 ) == - 1 )  912
sleep ( 0 ); 913",662,1
50803,"void CWE124_Buffer_Underwrite__malloc_char_memcpy_42_bad() 35
char * data ; 37
data = NULL; 38
data = badSource ( data ); 39
static char * badSource(char * data) 23
char * dataBuffer = ( char * ) malloc ( 100 * sizeof ( char ) ) ; 26
memset ( dataBuffer , 'A' , 100 - 1 ); 27
dataBuffer [ 100 - 1 ] = '\0'; 28
data = dataBuffer - 8; 30
return data ; 32
char source [ 100 ] ; 41
memset ( source , 'C' , 100 - 1 ); 42
source [ 100 - 1 ] = '\0'; 43
memcpy ( data , source , 100 * sizeof ( char ) ); 45
data [ 100 - 1 ] = '\0'; 47
printLine ( data ); 48
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",119,1
12950,"void bad() 53
WSADATA wsaData ; 61
int recvResult ; 64
struct sockaddr_in service ; 65
char inputBuffer [ CHAR_ARRAY_SIZE ] ; 67
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  71
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 78
if ( connectSocket == INVALID_SOCKET )  79
memset ( & service , 0 , sizeof ( service ) ); 83
service . sin_family = AF_INET; 84
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS ); 85
service . sin_port = htons ( TCP_PORT ); 86
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  87
recvResult = recv ( connectSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 ); 93
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  94
inputBuffer [ recvResult ] = '\0'; 99
data = atoi ( inputBuffer ); 101
while ( 0 )  103
if ( connectSocket != INVALID_SOCKET )  104
CLOSE_SOCKET ( connectSocket ); 106
myUnion . unionFirst = data; 115
int data = myUnion . unionSecond ; 117
if ( data >= 0 )  128
buffer [ data ] = 1; 130
printIntLine ( buffer [ i ] ); 134
void printIntLine (int intNumber) 26
printf ( ""%d\n"" , intNumber ); 28
delete [ ] buffer 141",119,1
178553,"void bad() 57
char * data ; 59
char dataBuffer [ FILENAME_MAX ] = """" ; 60
data = dataBuffer; 61
WSADATA wsaData ; 64
int recvResult ; 67
struct sockaddr_in service ; 68
size_t dataLen = strlen ( data ) ; 71
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  75
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 82
if ( connectSocket == INVALID_SOCKET )  83
memset ( & service , 0 , sizeof ( service ) ); 87
service . sin_family = AF_INET; 88
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS ); 89
service . sin_port = htons ( TCP_PORT ); 90
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  91
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ); 98
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  99
data [ dataLen + recvResult / sizeof ( char ) ] = '\0'; 104
replace = strchr ( data , '\r' ); 106
if ( replace )  107
* replace = '\0'; 109
replace = strchr ( data , '\n' ); 111
if ( replace )  112
* replace = '\0'; 114
while ( 0 )  117
char * dataCopy = data ; 130
char * data = dataCopy ; 131
fileDesc = OPEN ( data , O_RDWR | O_CREAT , S_IREAD | S_IWRITE ); 135
if ( fileDesc != - 1 )  136
CLOSE ( fileDesc ); 138",706,1
130303,"void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_connect_socket_66_bad() 46
int data ; 48
int dataArray [ 5 ] ; 49
data = - 1; 51
WSADATA wsaData ; 54
int recvResult ; 57
struct sockaddr_in service ; 58
char inputBuffer [ CHAR_ARRAY_SIZE ] ; 60
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  64
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 71
if ( connectSocket == INVALID_SOCKET )  72
memset ( & service , 0 , sizeof ( service ) ); 76
service . sin_family = AF_INET; 77
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS ); 78
service . sin_port = htons ( TCP_PORT ); 79
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  80
recvResult = recv ( connectSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 ); 86
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  87
inputBuffer [ recvResult ] = '\0'; 92
data = atoi ( inputBuffer ); 94
while ( 0 )  96
dataArray [ 2 ] = data; 109
CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_connect_socket_66b_badSink ( dataArray ); 110
void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_connect_socket_66b_badSink(int dataArray[]) 43
int data = dataArray [ 2 ] ; 46
int * intPointer ; 49
intPointer = ( int * ) malloc ( data * sizeof ( int ) ); 52
intPointer [ i ] = 0; 55
printIntLine ( intPointer [ 0 ] ); 57
void printIntLine (int intNumber) 26
printf ( ""%d\n"" , intNumber ); 28
free ( intPointer ); 58",119,1
24408,"void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_06_bad() 25
char source [ 100 ] ; 36
memset ( source , 'A' , 100 - 1 ); 38
source [ 100 - 1 ] = '\0'; 39
memcpy ( dest , source , data ); 44
dest [ data ] = '\0'; 45
printLine ( dest ); 47
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",704,1
4546,"void bad() 26
int data ; 28
int & dataRef = data ; 29
data = - 1; 31
char inputBuffer [ CHAR_ARRAY_SIZE ] = """" ; 33
if ( fgets ( inputBuffer , CHAR_ARRAY_SIZE , stdin ) != NULL )  35
data = atoi ( inputBuffer ); 38
int data = dataRef ; 46
char source [ 100 ] ; 48
char dest [ 100 ] = """" ; 49
memset ( source , 'A' , 100 - 1 ); 50
source [ 100 - 1 ] = '\0'; 51
if ( data < 100 )  52
strncpy ( dest , source , data ); 56
dest [ data ] = '\0'; 57
printLine ( dest ); 59
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",704,1
147281,"void CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_01_bad() 47
char * data ; 49
char dataBuffer [ 100 ] = """" ; 50
data = dataBuffer; 51
WSADATA wsaData ; 54
int recvResult ; 57
struct sockaddr_in service ; 58
size_t dataLen = strlen ( data ) ; 62
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  66
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 73
if ( listenSocket == INVALID_SOCKET )  74
memset ( & service , 0 , sizeof ( service ) ); 78
service . sin_family = AF_INET; 79
service . sin_addr . s_addr = INADDR_ANY; 80
service . sin_port = htons ( TCP_PORT ); 81
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  82
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )  86
acceptSocket = accept ( listenSocket , NULL , NULL ); 90
if ( acceptSocket == SOCKET_ERROR )  91
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ); 96
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  97
data [ dataLen + recvResult / sizeof ( char ) ] = '\0'; 102
replace = strchr ( data , '\r' ); 104
if ( replace )  105
* replace = '\0'; 107
replace = strchr ( data , '\n' ); 109
if ( replace )  110
* replace = '\0'; 112
while ( 0 )  115
fprintf ( stdout , data ); 132",74,1
90192,"void bad() 52
vector < int > dataVector ; 55
badSink ( dataVector ); 118
void badSink(vector<int> dataVector) 27
int data = dataVector [ 2 ] ; 30
char source [ 100 ] ; 32
char dest [ 100 ] = """" ; 33
memset ( source , 'A' , 100 - 1 ); 34
source [ 100 - 1 ] = '\0'; 35
if ( data < 100 )  36
memcpy ( dest , source , data ); 40
dest [ data ] = '\0'; 41
printLine ( dest ); 43
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",704,1
67532,"void bad() 50
char * data ; 52
char dataBuffer [ FILENAME_MAX ] = """" ; 54
data = dataBuffer; 55
WSADATA wsaData ; 58
int recvResult ; 61
struct sockaddr_in service ; 62
size_t dataLen = strlen ( data ) ; 65
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  69
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 76
if ( connectSocket == INVALID_SOCKET )  77
memset ( & service , 0 , sizeof ( service ) ); 81
service . sin_family = AF_INET; 82
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS ); 83
service . sin_port = htons ( TCP_PORT ); 84
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  85
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ); 92
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  93
data [ dataLen + recvResult / sizeof ( char ) ] = '\0'; 98
replace = strchr ( data , '\r' ); 100
if ( replace )  101
* replace = '\0'; 103
replace = strchr ( data , '\n' ); 105
if ( replace )  106
* replace = '\0'; 108
while ( 0 )  111
hFile = CreateFileA ( data , ( GENERIC_WRITE | GENERIC_READ ) , 0 , NULL , OPEN_ALWAYS , FILE_ATTRIBUTE_NORMAL , NULL ); 128
if ( hFile != INVALID_HANDLE_VALUE )  135
CloseHandle ( hFile ); 137",706,1
41458,"void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_51b_badSink(int data) 25
char source [ 100 ] ; 28
memset ( source , 'A' , 100 - 1 ); 30
source [ 100 - 1 ] = '\0'; 31
strncpy ( dest , source , data ); 36
dest [ data ] = '\0'; 37
printLine ( dest ); 39
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",704,1
50105,"void CWE134_Uncontrolled_Format_String__char_connect_socket_printf_21_bad() 59
char * data ; 61
char dataBuffer [ 100 ] = """" ; 62
data = dataBuffer; 63
WSADATA wsaData ; 66
int recvResult ; 69
struct sockaddr_in service ; 70
size_t dataLen = strlen ( data ) ; 73
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  77
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 84
if ( connectSocket == INVALID_SOCKET )  85
memset ( & service , 0 , sizeof ( service ) ); 89
service . sin_family = AF_INET; 90
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS ); 91
service . sin_port = htons ( TCP_PORT ); 92
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  93
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ); 100
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  101
data [ dataLen + recvResult / sizeof ( char ) ] = '\0'; 106
replace = strchr ( data , '\r' ); 108
if ( replace )  109
* replace = '\0'; 111
replace = strchr ( data , '\n' ); 113
if ( replace )  114
* replace = '\0'; 116
while ( 0 )  119
badSink ( data ); 132
static void badSink(char * data) 50
printf ( data ); 55",74,1
97414,"void CWE124_Buffer_Underwrite__char_declare_memmove_18_bad() 23
char dataBuffer [ 100 ] ; 26
memset ( dataBuffer , 'A' , 100 - 1 ); 27
dataBuffer [ 100 - 1 ] = '\0'; 28
data = dataBuffer - 8; 32
memmove ( data , source , 100 * sizeof ( char ) ); 38
data [ 100 - 1 ] = '\0'; 40
printLine ( data ); 41
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",119,1
57928,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_81_bad::action(char * data) const 25
char source [ 100 ] ; 28
memset ( source , 'C' , 100 - 1 ); 29
source [ 100 - 1 ] = '\0'; 30
data [ i ] = source [ i ]; 34
data [ 100 - 1 ] = '\0'; 36
printLine ( data ); 37
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",119,1
42882,"void bad() 60
char * data ; 62
char dataBuffer [ FILENAME_MAX ] = BASEPATH ; 63
data = dataBuffer; 64
if ( STATIC_CONST_FIVE == 5 )  65
WSADATA wsaData ; 69
int recvResult ; 72
struct sockaddr_in service ; 73
size_t dataLen = strlen ( data ) ; 76
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  80
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 87
if ( connectSocket == INVALID_SOCKET )  88
memset ( & service , 0 , sizeof ( service ) ); 92
service . sin_family = AF_INET; 93
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS ); 94
service . sin_port = htons ( TCP_PORT ); 95
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  96
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ); 103
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  104
data [ dataLen + recvResult / sizeof ( char ) ] = '\0'; 109
replace = strchr ( data , '\r' ); 111
if ( replace )  112
* replace = '\0'; 114
replace = strchr ( data , '\n' ); 116
if ( replace )  117
* replace = '\0'; 119
while ( 0 )  122
outputFile . open ( ( char * ) data ); 138",706,1
138947,"void bad() 25
FILE * data ; 27
data = NULL; 28
data = fopen ( ""BadSource_fopen.txt"" , ""w+"" ); 30
CWE773_Missing_Reference_to_Active_File_Descriptor_or_Handle__fopen_82_base * baseObject = new CWE773_Missing_Reference_to_Active_File_Descriptor_or_Handle__fopen_82_bad 31
baseObject -> action ( data ); 32
void CWE773_Missing_Reference_to_Active_File_Descriptor_or_Handle__fopen_82_bad::action(FILE * data) 24
data = fopen ( ""BadSink_fopen.txt"" , ""w+"" ); 27
if ( data != NULL )  29
fclose ( data ); 31",400,1
33591,"void CWE122_Heap_Based_Buffer_Overflow__c_dest_wchar_t_cat_64_bad() 26
wchar_t * data ; 28
data = NULL; 29
data = ( wchar_t * ) malloc ( 50 * sizeof ( wchar_t ) ); 31
data [ 0 ] = L '\0' 32
CWE122_Heap_Based_Buffer_Overflow__c_dest_wchar_t_cat_64b_badSink ( & data ); 33
void CWE122_Heap_Based_Buffer_Overflow__c_dest_wchar_t_cat_64b_badSink(void * dataVoidPtr) 23
wchar_t * * dataPtr = ( wchar_t * * ) dataVoidPtr ; 26
wchar_t * data = ( * dataPtr ) ; 28
wchar_t source [ 100 ] ; 30
wmemset ( source , L 'C' , 100 - 1 )
source [ 100 - 1 ] = L '\0' 32
wcscat ( data , source ); 34",119,1
87030,"void CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_cpy_22_bad() 33
char * data ; 35
data = NULL; 36
data = CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_cpy_22_badSource ( data ); 38
char * CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_cpy_22_badSource(char * data) 31
if ( CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_cpy_22_badGlobal )  33
data = ( char * ) malloc ( 10 * sizeof ( char ) ); 36
return data ; 38
char source [ 10 + 1 ] = SRC_STRING ; 40
strcpy ( data , source ); 42
free ( data ); 44",119,1
139553,"void bad() 26
char * dataBuffer = ( char * ) malloc ( 100 * sizeof ( char ) ) ; 32
memset ( dataBuffer , 'A' , 100 - 1 ); 33
dataBuffer [ 100 - 1 ] = '\0'; 34
data = dataBuffer - 8; 36
strncpy ( dest , data , strlen ( dest ) ); 45
dest [ 100 - 1 ] = '\0'; 47
printLine ( dest ); 48
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",119,1
28440,"void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_09_bad() 43
if ( GLOBAL_CONST_TRUE )  48
WSADATA wsaData ; 52
int recvResult ; 55
struct sockaddr_in service ; 56
char inputBuffer [ CHAR_ARRAY_SIZE ] ; 59
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )  63
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ); 70
if ( listenSocket == INVALID_SOCKET )  71
memset ( & service , 0 , sizeof ( service ) ); 75
service . sin_family = AF_INET; 76
service . sin_addr . s_addr = INADDR_ANY; 77
service . sin_port = htons ( TCP_PORT ); 78
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )  79
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )  83
acceptSocket = accept ( listenSocket , NULL , NULL ); 87
if ( acceptSocket == SOCKET_ERROR )  88
recvResult = recv ( acceptSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 ); 93
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  94
inputBuffer [ recvResult ] = '\0'; 99
data = atoi ( inputBuffer ); 101
while ( 0 )  103
if ( listenSocket != INVALID_SOCKET )  104
CLOSE_SOCKET ( listenSocket ); 106
if ( acceptSocket != INVALID_SOCKET )  108
CLOSE_SOCKET ( acceptSocket ); 110
if ( data < 100 )  125
memmove ( dest , source , data ); 129
dest [ data ] = '\0'; 130
printLine ( dest ); 132
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",704,1
171110,"static void goodG2B() 58
wchar_t * data ; 60
data = NULL; 61
data = CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_loop_61b_goodG2BSource ( data ); 62
wchar_t * CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_loop_61b_goodG2BSource(wchar_t * data) 40
data = ( wchar_t * ) malloc ( ( 10 + 1 ) * sizeof ( wchar_t ) ); 43
return data ; 44
wchar_t source [ 10 + 1 ] = SRC_STRING ; 64
size_t i , sourceLen ; 65
sourceLen = wcslen ( source ); 66
for (i = 0; i < sourceLen + 1; i++) 69
data [ i ] = source [ i ]; 71
free ( data ); 74",119,1
129617,"void CWE126_Buffer_Overread__malloc_char_loop_13_bad() 23
char * data ; 25
data = NULL; 26
if ( GLOBAL_CONST_FIVE == 5 )  27
data = ( char * ) malloc ( 50 * sizeof ( char ) ); 30
memset ( data , 'A' , 50 - 1 ); 31
data [ 50 - 1 ] = '\0'; 32
dest [ i ] = data [ i ]; 44
dest [ 100 - 1 ] = '\0'; 46
printLine ( dest ); 47
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14
free ( data ); 48",119,1
111931,"static void badSink() 26
wchar_t * data = CWE126_Buffer_Overread__malloc_wchar_t_memmove_45_badData ; 28
wchar_t dest [ 100 ] ; 30
wmemset ( dest , L 'C' , 100 - 1 )
dest [ 100 - 1 ] = L '\0' 32
memmove ( dest , data , wcslen ( dest ) * sizeof ( wchar_t ) ); 35
printWLine ( dest ); 37
void printWLine (const wchar_t * line) 18
if ( line != NULL )  20
wprintf ( L ""%ls\n"" , line ) 22",119,1
164637,"int main(int argc, char *argv[]) 42
if ( argc > 1 )  46
if ( ( fileNames = ( char * * ) malloc ( ( nbArgs ) * sizeof ( char * * ) ) ) == NULL )  49
if ( ! ( fileNames [ i ] = ( char * ) malloc ( 256 * sizeof ( char ) ) ) )  54
strncpy ( fileNames [ i ] , argv [ i + 1 ] , 255 ); 57
for (unsigned int i=0;i<nbArgs;++i) 62
if ( printFile ( fileNames [ i ] ) )  63
int printFile(const char *fileName) 23
if ( fp = fopen ( fileName , ""r"" ) )  26
printf ( "">>> %s\n"" , fileName ); 30
while ( fgets ( buffer , 512 , fp ) )  31
printf ( ""%3d: %s"" , ++ lNumber , buffer ); 33
fclose ( fp ); 35
printf ( ""Argument error, the given argument is not a readable file (%s).\n"" , fileNames [ i ] ); 64
for (unsigned int i=0;i<nbArgs;++i) 67
free ( fileNames [ i ] ); 68
free ( fileNames ); 69",706,1
153430,"void CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cat_06_bad() 27
char * data ; 29
char * dataBadBuffer = ( char * ) ALLOCA ( 50 * sizeof ( char ) ) ; 30
if ( STATIC_CONST_FIVE == 5 )  32
data = dataBadBuffer; 36
data [ 0 ] = '\0'; 37
char source [ 100 ] ; 40
memset ( source , 'C' , 100 - 1 ); 41
source [ 100 - 1 ] = '\0'; 42
strcat ( data , source ); 44
printLine ( data ); 45
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",119,1
45930,"void CWE78_OS_Command_Injection__char_connect_socket_popen_02_bad() 59
char * data ; 61
char data_buf [ 100 ] = FULL_COMMAND ; 62
data = data_buf; 63
if ( 1 )  64
size_t dataLen = strlen ( data ) ; 75
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ); 102
if ( recvResult == SOCKET_ERROR || recvResult == 0 )  103
data [ dataLen + recvResult / sizeof ( char ) ] = '\0'; 108
replace = strchr ( data , '\r' ); 110
if ( replace )  111
* replace = '\0'; 113
replace = strchr ( data , '\n' ); 115
if ( replace )  116
* replace = '\0'; 118
pipe = POPEN ( data , ""wb"" ); 137
if ( pipe != NULL )  138
PCLOSE ( pipe ); 140",74,1
110735,"void CWE124_Buffer_Underwrite__char_alloca_ncpy_15_bad() 23
char * dataBuffer = ( char * ) ALLOCA ( 100 * sizeof ( char ) ) ; 26
memset ( dataBuffer , 'A' , 100 - 1 ); 27
dataBuffer [ 100 - 1 ] = '\0'; 28
data = dataBuffer - 8; 33
strncpy ( data , source , 100 - 1 ); 45
data [ 100 - 1 ] = '\0'; 47
printLine ( data ); 48
void printLine (const char * line) 10
if ( line != NULL )  12
printf ( ""%s\n"" , line ); 14",119,1
